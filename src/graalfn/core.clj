(ns graalfn.core
    (:refer-clojure :only [*ns* + - / <= = and assoc bit-and bit-not bit-or bit-shift-left bit-shift-right byte cond condp cons defmacro defn doseq first import inc int int-array keys let letfn make-array neg? next not ns-imports ns-unmap nth or quot reduce rem repeat rest second seq sequential? short some? symbol? unsigned-bit-shift-right vary-meta vec vector?])
)

(defmacro § [& _])
(defmacro ß [& _])

(defmacro class-ns  [_ & s] (cons 'do s))
(defmacro final-ns  [_ & s] (cons 'do s))
(defmacro value-ns  [_ & s] (cons 'do s))

(doseq [% (keys (ns-imports *ns*))] (ns-unmap *ns* %))

(import
    [java.lang ArithmeticException Boolean Byte Character Class ClassLoader Double Error IllegalArgumentException IllegalStateException IncompatibleClassChangeError IndexOutOfBoundsException Integer Iterable Long Math Module NoClassDefFoundError NoSuchFieldError NoSuchMethodError Object Short String StringBuilder System Throwable UnsupportedClassVersionError]
)

(defmacro throw! [^String s] `(throw (Error. ~s)))

(defmacro def-      [x & s] `(def      ~(vary-meta x assoc :private true) ~@s))
(defmacro defn-     [x & s] `(defn     ~(vary-meta x assoc :private true) ~@s))
(defmacro defmacro- [x & s] `(defmacro ~(vary-meta x assoc :private true) ~@s))

(letfn [(=> [s] (if (= '=> (first s)) (next s) (cons nil s)))]
    (defmacro     when       [? & s] (let [[e & s] (=> s)]               `(if     ~? (do ~@s) ~e)))
    (defmacro     when-not   [? & s] (let [[e & s] (=> s)]               `(if-not ~? (do ~@s) ~e)))
    (defmacro let-when     [v ? & s] (let [[e & s] (=> s)] `(let ~(vec v) (if     ~? (do ~@s) ~e))))
    (defmacro let-when-not [v ? & s] (let [[e & s] (=> s)] `(let ~(vec v) (if-not ~? (do ~@s) ~e))))
)

(letfn [(v' [v] (cond (vector? v) v (symbol? v) [v v] :else [`_# v]))
        (r' [r] (cond (vector? r) `((recur ~@r)) (some? r) `((recur ~r))))
        (=> [s] (if (= '=> (first s)) (next s) (cons nil s)))
        (l' [v ? r s] (let [r (r' r) [e & s] (=> s)] `(loop ~(v' v) (if ~? (do ~@s ~@r) ~e))))]
    (defmacro loop-when [v ? & s] (l' v ? nil s))
    (defmacro loop-when-recur [v ? r & s] (l' v ? r s))
)

(letfn [(r' [r] (cond (vector? r) `(recur ~@r) (some? r) `(recur ~r)))
        (=> [s] (if (= '=> (first s)) (second s)))]
    (defmacro recur-if [? r & s] `(if ~? ~(r' r) ~(=> s)))
)

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & s] `(let [f# ~f x# ~x] (or (f# x# ~y) (any f# x# ~@s))))
)

(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & s] (=? x (cons y s)))
)

(defmacro aswap [a i f & s] `(let [a# ~a i# ~i] (aset a# i# (~f (aget a# i#) ~@s))))

(def % rem)

(def & bit-and)
(def | bit-or)

(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defn abs [a] (if (neg? a) (- a) a))

(import
    [java.io ByteArrayInputStream ByteArrayOutputStream DataInputStream DataOutputStream IOException InputStream]
    [java.lang.annotation Annotation Inherited]
    [java.lang.invoke ConstantCallSite MethodHandle MethodHandles MethodType MutableCallSite VolatileCallSite]
    [java.lang.ref #_Reference]
    [java.lang.reflect AnnotatedElement Array Constructor Field Method Modifier Type]
    [java.nio ByteBuffer ByteOrder]
    [java.nio.charset Charset]
    [java.util
        AbstractList ArrayDeque ArrayList Arrays BitSet Collection Collections Comparator ConcurrentModificationException
        Deque EnumMap EnumSet HashMap Iterator LinkedList List ListIterator Map Map$Entry NoSuchElementException
        PriorityQueue Queue Set SortedSet TreeSet
    ]
    [java.util.concurrent.atomic AtomicInteger AtomicLong AtomicReference]
    [java.util.function BiConsumer BiFunction Consumer Function IntUnaryOperator Predicate ToDoubleFunction]
    [java.util.stream Stream Stream$Builder]

    [jdk.vm.ci.amd64 AMD64 AMD64$CPUFeature AMD64Kind]
    [jdk.vm.ci.code
        Architecture BytecodeFrame BytecodePosition CallingConvention CodeCacheProvider CodeUtil
        CompiledCode InstalledCode MemoryBarriers Register Register$RegisterCategory RegisterArray RegisterAttributes
        RegisterConfig RegisterSaveLayout RegisterValue StackSlot TargetDescription ValueKindFactory
    ]
    [jdk.vm.ci.code.site ConstantReference DataPatch DataSectionReference Mark #_Reference Site]
    [jdk.vm.ci.hotspot
        HotSpotCallingConventionType HotSpotCodeCacheProvider HotSpotCompiledCode
        HotSpotCompressedNullConstant HotSpotConstant HotSpotConstantReflectionProvider HotSpotInstalledCode
        HotSpotJVMCIRuntime HotSpotMemoryAccessProvider HotSpotMetaAccessProvider HotSpotMetaspaceConstant
        HotSpotObjectConstant HotSpotResolvedJavaField HotSpotResolvedJavaMethod HotSpotResolvedJavaType
        HotSpotResolvedObjectType HotSpotVMConfigAccess
    ]
    [jdk.vm.ci.meta
        AllocatableValue Constant ConstantPool ConstantReflectionProvider DeoptimizationAction DeoptimizationReason
        InvokeTarget JavaConstant JavaField JavaKind JavaMethod JavaType MemoryAccessProvider MetaAccessProvider
        MethodHandleAccessProvider MethodHandleAccessProvider$IntrinsicMethod PlatformKind PrimitiveConstant
        RawConstant ResolvedJavaField ResolvedJavaMethod ResolvedJavaType SerializableConstant Signature
        TriState VMConstant Value ValueKind
    ]
    [jdk.vm.ci.runtime JVMCIBackend JVMCICompiler]

    [org.graalvm.collections EconomicMap EconomicSet Equivalence MapCursor Pair UnmodifiableEconomicMap UnmodifiableMapCursor]
    [org.graalvm.word ComparableWord LocationIdentity Pointer SignedWord UnsignedWord WordBase WordFactory]
    [org.graalvm.word.impl WordBoxFactory WordFactoryOperation]

    [sun.misc Unsafe]
)

(value-ns HotSpot
    (def #_"HotSpotJVMCIRuntime" JVMCI'runtime (HotSpotJVMCIRuntime/runtime))
    (def #_"JVMCIBackend"        JVMCI'backend (#_"HotSpotJVMCIRuntime" .getHostJVMCIBackend JVMCI'runtime))

    (def #_"CodeCacheProvider"          HotSpot'codeCache          (#_"JVMCIBackend"        .getCodeCache          JVMCI'backend))
    (def #_"RegisterConfig"             HotSpot'registerConfig     (#_"CodeCacheProvider"   .getRegisterConfig     HotSpot'codeCache))
    (def #_"TargetDescription"          HotSpot'target             (#_"CodeCacheProvider"   .getTarget             HotSpot'codeCache))
    (def #_"ConstantReflectionProvider" HotSpot'constantReflection (#_"JVMCIBackend"        .getConstantReflection JVMCI'backend))
    (def #_"MetaAccessProvider"         HotSpot'metaAccess         (#_"JVMCIBackend"        .getMetaAccess         JVMCI'backend))

    (def #_"HotSpotVMConfigAccess" HotSpot'config (HotSpotVMConfigAccess. (#_"HotSpotJVMCIRuntime" .getConfigStore JVMCI'runtime)))

    (def #_"boolean" HotSpot'useFastLocking          (.getFlag HotSpot'config, "JVMCIUseFastLocking",    Boolean))
    (def #_"boolean" HotSpot'foldStableValues        (.getFlag HotSpot'config, "FoldStableValues",       Boolean))
    (def #_"boolean" HotSpot'useTLAB                 (.getFlag HotSpot'config, "UseTLAB",                Boolean))
    (def #_"boolean" HotSpot'useBiasedLocking        (.getFlag HotSpot'config, "UseBiasedLocking",       Boolean))
    (def #_"boolean" HotSpot'threadLocalHandshakes   (.getFlag HotSpot'config, "ThreadLocalHandshakes",  Boolean))
    (def #_"boolean" HotSpot'useG1GC                 (.getFlag HotSpot'config, "UseG1GC",                Boolean))
    (def #_"boolean" HotSpot'useDeferredInitBarriers (.getFlag HotSpot'config, "ReduceInitialCardMarks", Boolean))

    (def #_"int" HotSpot'allocatePrefetchStyle         (.getFlag HotSpot'config, "AllocatePrefetchStyle",         Integer))
    (def #_"int" HotSpot'allocatePrefetchInstr         (.getFlag HotSpot'config, "AllocatePrefetchInstr",         Integer))
    (def #_"int" HotSpot'allocatePrefetchLines         (.getFlag HotSpot'config, "AllocatePrefetchLines",         Integer))
    (def #_"int" HotSpot'allocateInstancePrefetchLines (.getFlag HotSpot'config, "AllocateInstancePrefetchLines", Integer))
    (def #_"int" HotSpot'allocatePrefetchStepSize      (.getFlag HotSpot'config, "AllocatePrefetchStepSize",      Integer))
    (def #_"int" HotSpot'allocatePrefetchDistance      (.getFlag HotSpot'config, "AllocatePrefetchDistance",      Integer))
    (def #_"int" HotSpot'codeEntryAlignment            (.getFlag HotSpot'config, "CodeEntryAlignment",            Integer))
    (def #_"int" HotSpot'objectAlignment               (.getFlag HotSpot'config, "ObjectAlignmentInBytes",        Integer))
    (def #_"int" HotSpot'heapWordSize                  (.getConstant HotSpot'config, "HeapWordSize",              Integer))

    ;; Compressed Oops related values.
    (def #_"boolean" HotSpot'useCompressedOops          (.getFlag HotSpot'config, "UseCompressedOops",          Boolean))
    (def #_"boolean" HotSpot'useCompressedClassPointers (.getFlag HotSpot'config, "UseCompressedClassPointers", Boolean))

    (def #_"long" HotSpot'narrowOopBase   (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_narrow_oop_base",   Long, "address"))
    (def #_"long" HotSpot'narrowKlassBase (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_narrow_klass_base", Long, "address"))

    (def #_"int" HotSpot'narrowOopShift   (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_narrow_oop_shift",   Integer, "int"))
    (def #_"int" HotSpot'narrowKlassShift (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_narrow_klass_shift", Integer, "int"))
    (def #_"int" HotSpot'narrowKlassSize  (.getFieldValue HotSpot'config, "CompilerToVM::Data::sizeof_narrowKlass",          Integer, "int"))
    (def #_"int" HotSpot'arrayOopDescSize (.getFieldValue HotSpot'config, "CompilerToVM::Data::sizeof_arrayOopDesc",         Integer, "int"))
    (def #_"int" HotSpot'vmPageSize       (.getFieldValue HotSpot'config, "CompilerToVM::Data::vm_page_size",                Integer, "int"))

    (§ def #_"CompressEncoding" HotSpot'oopEncoding   (CompressEncoding'new-2 HotSpot'narrowOopBase, HotSpot'narrowOopShift))
    (§ def #_"CompressEncoding" HotSpot'klassEncoding (CompressEncoding'new-2 HotSpot'narrowKlassBase, HotSpot'narrowKlassShift))

    (def #_"boolean" HotSpot'useStackBanging (.getFlag HotSpot'config, "UseStackBanging", Boolean))
    (def #_"int" HotSpot'stackShadowPages    (.getFlag HotSpot'config, "StackShadowPages", Integer))
    (def #_"int" HotSpot'stackBias           (.getConstant HotSpot'config, "STACK_BIAS", Integer))

    (def #_"int" HotSpot'markOffset (.getFieldOffset HotSpot'config, "oopDesc::_mark",            Integer, "markOop"))
    (def #_"int" HotSpot'hubOffset  (.getFieldOffset HotSpot'config, "oopDesc::_metadata._klass", Integer, "Klass*"))

    (def #_"int" HotSpot'prototypeMarkWordOffset   (.getFieldOffset HotSpot'config, "Klass::_prototype_header",      Integer, "markOop"))
    (def #_"int" HotSpot'superCheckOffsetOffset    (.getFieldOffset HotSpot'config, "Klass::_super_check_offset",    Integer, "juint"))
    (def #_"int" HotSpot'secondarySuperCacheOffset (.getFieldOffset HotSpot'config, "Klass::_secondary_super_cache", Integer, "Klass*"))
    (def #_"int" HotSpot'secondarySupersOffset     (.getFieldOffset HotSpot'config, "Klass::_secondary_supers",      Integer, "Array<Klass*>*"))
    (def #_"int" HotSpot'classMirrorOffset         (.getFieldOffset HotSpot'config, "Klass::_java_mirror",           Integer, "OopHandle"))
    (def #_"int" HotSpot'klassLayoutHelperOffset   (.getFieldOffset HotSpot'config, "Klass::_layout_helper",         Integer, "jint"))

    (def #_"int" HotSpot'klassLayoutHelperNeutralValue    (.getConstant HotSpot'config, "Klass::_lh_neutral_value",           Integer))
    (def #_"int" HotSpot'layoutHelperLog2ElementSizeShift (.getConstant HotSpot'config, "Klass::_lh_log2_element_size_shift", Integer))
    (def #_"int" HotSpot'layoutHelperLog2ElementSizeMask  (.getConstant HotSpot'config, "Klass::_lh_log2_element_size_mask",  Integer))
    (def #_"int" HotSpot'layoutHelperElementTypeShift     (.getConstant HotSpot'config, "Klass::_lh_element_type_shift",      Integer))
    (def #_"int" HotSpot'layoutHelperElementTypeMask      (.getConstant HotSpot'config, "Klass::_lh_element_type_mask",       Integer))
    (def #_"int" HotSpot'layoutHelperHeaderSizeShift      (.getConstant HotSpot'config, "Klass::_lh_header_size_shift",       Integer))
    (def #_"int" HotSpot'layoutHelperHeaderSizeMask       (.getConstant HotSpot'config, "Klass::_lh_header_size_mask",        Integer))

    (def #_"int" HotSpot'instanceKlassInitStateOffset       (.getFieldOffset HotSpot'config, "InstanceKlass::_init_state", Integer, "u1"))
    (def #_"int" HotSpot'instanceKlassStateFullyInitialized (.getConstant HotSpot'config, "InstanceKlass::fully_initialized", Integer))

    ;;;
     ; The offset of the array length word in an array object's header.
     ;;
    (def #_"int" HotSpot'arrayLengthOffset (if HotSpot'useCompressedClassPointers (+ HotSpot'hubOffset HotSpot'narrowKlassSize) HotSpot'arrayOopDescSize))

    (def #_"int" HotSpot'metaspaceArrayBaseOffset   (.getFieldOffset HotSpot'config, "Array<Klass*>::_data[0]",       Integer, "Klass*"))
    (def #_"int" HotSpot'metaspaceArrayLengthOffset (.getFieldOffset HotSpot'config, "Array<Klass*>::_length",        Integer, "int"))
    (def #_"int" HotSpot'arrayClassElementOffset    (.getFieldOffset HotSpot'config, "ObjArrayKlass::_element_klass", Integer, "Klass*"))

    (def #_"int" HotSpot'threadTlabOffset       (.getFieldOffset HotSpot'config, "Thread::_tlab",          Integer, "ThreadLocalAllocBuffer"))
    (def #_"int" HotSpot'javaThreadAnchorOffset (.getFieldOffset HotSpot'config, "JavaThread::_anchor",    Integer, "JavaFrameAnchor"))
    (def #_"int" HotSpot'objectResultOffset     (.getFieldOffset HotSpot'config, "JavaThread::_vm_result", Integer, "oop"))

    ;;;
     ; This field is used to pass exception objects into and out of the runtime system during exception handling for compiled code.
     ;;
    (def #_"int" HotSpot'pendingExceptionOffset         (.getFieldOffset HotSpot'config, "ThreadShadow::_pending_exception",        Integer, "oop"))
    (def #_"int" HotSpot'pendingDeoptimizationOffset    (.getFieldOffset HotSpot'config, "JavaThread::_pending_deoptimization",     Integer, "int"))
    (def #_"int" HotSpot'pendingFailedSpeculationOffset (.getFieldOffset HotSpot'config, "JavaThread::_pending_failed_speculation", Integer, "oop"))

    (def #_"int" HotSpot'threadLastJavaSpOffset (+ HotSpot'javaThreadAnchorOffset (.getFieldOffset HotSpot'config, "JavaFrameAnchor::_last_Java_sp", Integer, "intptr_t*")))
    (def #_"int" HotSpot'threadLastJavaPcOffset (+ HotSpot'javaThreadAnchorOffset (.getFieldOffset HotSpot'config, "JavaFrameAnchor::_last_Java_pc", Integer, "address")))
    (def #_"int" HotSpot'threadLastJavaFpOffset (+ HotSpot'javaThreadAnchorOffset (.getFieldOffset HotSpot'config, "JavaFrameAnchor::_last_Java_fp", Integer, "intptr_t*")))

    (def #_"int" HotSpot'frameInterpreterFrameSenderSpOffset (.getConstant HotSpot'config, "frame::interpreter_frame_sender_sp_offset", Integer))
    (def #_"int" HotSpot'frameInterpreterFrameLastSpOffset   (.getConstant HotSpot'config, "frame::interpreter_frame_last_sp_offset",   Integer))

    (def #_"long" HotSpot'markOopDescHashShift       (.getConstant HotSpot'config, "markOopDesc::hash_shift",         Long))
    (def #_"long" HotSpot'markOopDescHashMask        (.getConstant HotSpot'config, "markOopDesc::hash_mask",          Long))
    (def #_"long" HotSpot'markOopDescHashMaskInPlace (.getConstant HotSpot'config, "markOopDesc::hash_mask_in_place", Long))

    ;;;
     ; Mask for a biasable, locked or unlocked mark word.
     ;
     ; +----------------------------------+-+-+
     ; |                                 1|1|1|
     ; +----------------------------------+-+-+
     ;;

    ;;;
     ; Pattern for a biasable, unlocked mark word.
     ;
     ; +----------------------------------+-+-+
     ; |                                 1|0|1|
     ; +----------------------------------+-+-+
     ;;

    (def #_"int" HotSpot'biasedLockMaskInPlace (.getConstant HotSpot'config, "markOopDesc::biased_lock_mask_in_place", Integer))
    (def #_"int" HotSpot'biasedLockPattern     (.getConstant HotSpot'config, "markOopDesc::biased_lock_pattern",       Integer))
    (def #_"int" HotSpot'ageMaskInPlace        (.getConstant HotSpot'config, "markOopDesc::age_mask_in_place",         Integer))
    (def #_"int" HotSpot'epochMaskInPlace      (.getConstant HotSpot'config, "markOopDesc::epoch_mask_in_place",       Integer))
    (def #_"int" HotSpot'unlockedMask          (.getConstant HotSpot'config, "markOopDesc::unlocked_value",            Integer))
    (def #_"int" HotSpot'monitorMask           (.getConstant HotSpot'config, "markOopDesc::monitor_value",             Integer, -1))

    ;; this field has no type in vmStructs.cpp
    (def #_"int" HotSpot'objectMonitorOwnerOffset      (.getFieldOffset HotSpot'config, "ObjectMonitor::_owner",      Integer, nil,             -1))
    (def #_"int" HotSpot'objectMonitorRecursionsOffset (.getFieldOffset HotSpot'config, "ObjectMonitor::_recursions", Integer, "intptr_t",      -1))
    (def #_"int" HotSpot'objectMonitorCxqOffset        (.getFieldOffset HotSpot'config, "ObjectMonitor::_cxq",        Integer, "ObjectWaiter*", -1))
    (def #_"int" HotSpot'objectMonitorEntryListOffset  (.getFieldOffset HotSpot'config, "ObjectMonitor::_EntryList",  Integer, "ObjectWaiter*", -1))

    (def #_"int" HotSpot'markWordNoHashInPlace (.getConstant HotSpot'config, "markOopDesc::no_hash_in_place", Integer))
    (def #_"int" HotSpot'markWordNoLockInPlace (.getConstant HotSpot'config, "markOopDesc::no_lock_in_place", Integer))

    (def #_"long" HotSpot'arrayPrototypeMarkWord (| HotSpot'markWordNoHashInPlace HotSpot'markWordNoLockInPlace))
    (def #_"long" HotSpot'tlabIntArrayMarkWord   (| (& HotSpot'arrayPrototypeMarkWord (bit-not HotSpot'markOopDescHashMaskInPlace)) (<< (& 0x2 HotSpot'markOopDescHashMask) HotSpot'markOopDescHashShift)))

    (def #_"int" HotSpot'methodCompiledEntryOffset (.getFieldOffset HotSpot'config, "Method::_from_compiled_entry", Integer, "address"))

    ;;;
     ; Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
     ; are allowed to look like (respectively) the high or low bits of a real oop.
     ;;
    (def #_"long" HotSpot'nonOopBits (.getFieldValue HotSpot'config, "CompilerToVM::Data::Universe_non_oop_bits", Long, "void*"))

    (def #_"int" HotSpot'logOfHeapRegionGrainBytes (.getFieldValue HotSpot'config, "HeapRegion::LogOfHRGrainBytes", Integer, "int"))

    (def #_"long" HotSpot'cardTableAddress (.getFieldValue HotSpot'config, "CompilerToVM::Data::cardtable_start_address", Long, "jbyte*"))
    (def #_"int" HotSpot'cardTableShift (.getFieldValue HotSpot'config, "CompilerToVM::Data::cardtable_shift", Integer, "int"))

    (def #_"long" HotSpot'safepointPollingAddress (.getFieldValue HotSpot'config, "os::_polling_page", Long, "address"))

    ;; G1 Collector Related Values.
    (def #_"byte" HotSpot'dirtyCardValue   (.getConstant HotSpot'config, "CardTableModRefBS::dirty_card",         Byte))
    (def #_"byte" HotSpot'g1YoungCardValue (.getConstant HotSpot'config, "G1SATBCardTableModRefBS::g1_young_gen", Byte))

    (def #_"int" HotSpot'javaThreadDirtyCardQueueOffset (.getFieldOffset HotSpot'config, "JavaThread::_dirty_card_queue", Integer, "DirtyCardQueue"))
    (def #_"int" HotSpot'javaThreadSatbMarkQueueOffset  (.getFieldOffset HotSpot'config, "JavaThread::_satb_mark_queue",  Integer))

    (def #_"int" HotSpot'g1CardQueueIndexOffset   (+ HotSpot'javaThreadDirtyCardQueueOffset (.getConstant HotSpot'config, "dirtyCardQueueIndexOffset",  Integer)))
    (def #_"int" HotSpot'g1CardQueueBufferOffset  (+ HotSpot'javaThreadDirtyCardQueueOffset (.getConstant HotSpot'config, "dirtyCardQueueBufferOffset", Integer)))
    (def #_"int" HotSpot'g1SATBQueueMarkingOffset (+ HotSpot'javaThreadSatbMarkQueueOffset  (.getConstant HotSpot'config, "satbMarkQueueActiveOffset",  Integer)))
    (def #_"int" HotSpot'g1SATBQueueIndexOffset   (+ HotSpot'javaThreadSatbMarkQueueOffset  (.getConstant HotSpot'config, "satbMarkQueueIndexOffset",   Integer)))
    (def #_"int" HotSpot'g1SATBQueueBufferOffset  (+ HotSpot'javaThreadSatbMarkQueueOffset  (.getConstant HotSpot'config, "satbMarkQueueBufferOffset",  Integer)))

    (def #_"int" HotSpot'klassOffset      (.getFieldValue HotSpot'config, "java_lang_Class::_klass_offset",       Integer, "int"))
    (def #_"int" HotSpot'arrayKlassOffset (.getFieldValue HotSpot'config, "java_lang_Class::_array_klass_offset", Integer, "int"))

    (def #_"int" HotSpot'lockDisplacedMarkOffset (.getFieldOffset HotSpot'config, "BasicLock::_displaced_header", Integer, "markOop"))

    (def #_"int" HotSpot'threadPollingPageOffset    (.getFieldOffset HotSpot'config, "Thread::_polling_page",    Integer, "address"))
    (def #_"int" HotSpot'threadAllocatedBytesOffset (.getFieldOffset HotSpot'config, "Thread::_allocated_bytes", Integer, "jlong"))

    (def #_"int" HotSpot'tlabRefillWasteIncrement (.getFlag HotSpot'config, "TLABWasteIncrement", Integer))

    (def #_"int" HotSpot'tlabSlowAllocationsOffset  (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_slow_allocations",   Integer, "unsigned")))
    (def #_"int" HotSpot'tlabFastRefillWasteOffset  (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_fast_refill_waste",  Integer, "unsigned")))
    (def #_"int" HotSpot'tlabNumberOfRefillsOffset  (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_number_of_refills",  Integer, "unsigned")))
    (def #_"int" HotSpot'tlabRefillWasteLimitOffset (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_refill_waste_limit", Integer, "size_t")))

    (def #_"int" HotSpot'threadTlabSizeOffset  (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_desired_size", Integer, "size_t")))
    (def #_"int" HotSpot'threadTlabStartOffset (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_start",        Integer, "HeapWord*")))
    (def #_"int" HotSpot'threadTlabEndOffset   (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_end",          Integer, "HeapWord*")))
    (def #_"int" HotSpot'threadTlabTopOffset   (+ HotSpot'threadTlabOffset (.getFieldOffset HotSpot'config, "ThreadLocalAllocBuffer::_top",          Integer, "HeapWord*")))

    (def #_"int" HotSpot'tlabAlignmentReserve (.getFieldValue HotSpot'config, "CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve", Integer, "size_t"))

    (def #_"boolean" HotSpot'tlabStats (.getFlag HotSpot'config, "TLABStats", Boolean))

    (def #_"boolean" HotSpot'inlineContiguousAllocationSupported (.getFieldValue HotSpot'config, "CompilerToVM::Data::_supports_inline_contig_alloc", Boolean))

    (def #_"long" HotSpot'heapEndAddress   (.getFieldValue HotSpot'config, "CompilerToVM::Data::_heap_end_addr",                         Long, "HeapWord**"))
    (def #_"long" HotSpot'heapTopAddress   (.getFieldValue HotSpot'config, "CompilerToVM::Data::_heap_top_addr",                         Long, "HeapWord* volatile*"))
    (def #_"long" HotSpot'handleDeoptStub  (.getFieldValue HotSpot'config, "CompilerToVM::Data::SharedRuntime_deopt_blob_unpack",        Long, "address"))
    (def #_"long" HotSpot'uncommonTrapStub (.getFieldValue HotSpot'config, "CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap", Long, "address"))

    (def #_"long" HotSpot'codeCacheLowBound  (.getFieldValue HotSpot'config, "CodeCache::_low_bound",  Long, "address"))
    (def #_"long" HotSpot'codeCacheHighBound (.getFieldValue HotSpot'config, "CodeCache::_high_bound", Long, "address"))

    (def #_"long" HotSpot'newInstanceAddress        (.getAddress HotSpot'config, "JVMCIRuntime::new_instance"))
    (def #_"long" HotSpot'newArrayAddress           (.getAddress HotSpot'config, "JVMCIRuntime::new_array"))
    (def #_"long" HotSpot'dynamicNewArrayAddress    (.getAddress HotSpot'config, "JVMCIRuntime::dynamic_new_array"))
    (def #_"long" HotSpot'dynamicNewInstanceAddress (.getAddress HotSpot'config, "JVMCIRuntime::dynamic_new_instance"))
    (def #_"long" HotSpot'monitorenterAddress       (.getAddress HotSpot'config, "JVMCIRuntime::monitorenter"))
    (def #_"long" HotSpot'monitorexitAddress        (.getAddress HotSpot'config, "JVMCIRuntime::monitorexit"))
    (def #_"long" HotSpot'writeBarrierPreAddress    (.getAddress HotSpot'config, "JVMCIRuntime::write_barrier_pre"))
    (def #_"long" HotSpot'writeBarrierPostAddress   (.getAddress HotSpot'config, "JVMCIRuntime::write_barrier_post"))

    (def #_"int" HotSpot'verifiedEntryMark                       (.getConstant HotSpot'config, "CodeInstaller::VERIFIED_ENTRY",                         Integer))
    (def #_"int" HotSpot'deoptHandlerEntryMark                   (.getConstant HotSpot'config, "CodeInstaller::DEOPT_HANDLER_ENTRY",                    Integer))
    (def #_"int" HotSpot'invokeinterfaceMark                     (.getConstant HotSpot'config, "CodeInstaller::INVOKEINTERFACE",                        Integer))
    (def #_"int" HotSpot'invokevirtualMark                       (.getConstant HotSpot'config, "CodeInstaller::INVOKEVIRTUAL",                          Integer))
    (def #_"int" HotSpot'invokestaticMark                        (.getConstant HotSpot'config, "CodeInstaller::INVOKESTATIC",                           Integer))
    (def #_"int" HotSpot'invokespecialMark                       (.getConstant HotSpot'config, "CodeInstaller::INVOKESPECIAL",                          Integer))
    (def #_"int" HotSpot'inlineInvokeMark                        (.getConstant HotSpot'config, "CodeInstaller::INLINE_INVOKE",                          Integer))
    (def #_"int" HotSpot'pollNearMark                            (.getConstant HotSpot'config, "CodeInstaller::POLL_NEAR",                              Integer))
    (def #_"int" HotSpot'pollReturnNearMark                      (.getConstant HotSpot'config, "CodeInstaller::POLL_RETURN_NEAR",                       Integer))
    (def #_"int" HotSpot'pollFarMark                             (.getConstant HotSpot'config, "CodeInstaller::POLL_FAR",                               Integer))
    (def #_"int" HotSpot'pollReturnFarMark                       (.getConstant HotSpot'config, "CodeInstaller::POLL_RETURN_FAR",                        Integer))
    (def #_"int" HotSpot'cardTableAddressMark                    (.getConstant HotSpot'config, "CodeInstaller::CARD_TABLE_ADDRESS",                     Integer))
    (def #_"int" HotSpot'heapTopAddressMark                      (.getConstant HotSpot'config, "CodeInstaller::HEAP_TOP_ADDRESS",                       Integer))
    (def #_"int" HotSpot'heapEndAddressMark                      (.getConstant HotSpot'config, "CodeInstaller::HEAP_END_ADDRESS",                       Integer))
    (def #_"int" HotSpot'narrowKlassBaseAddressMark              (.getConstant HotSpot'config, "CodeInstaller::NARROW_KLASS_BASE_ADDRESS",              Integer))
    (def #_"int" HotSpot'logOfHeapRegionGrainBytesMark           (.getConstant HotSpot'config, "CodeInstaller::LOG_OF_HEAP_REGION_GRAIN_BYTES",         Integer))
    (def #_"int" HotSpot'inlineContiguousAllocationSupportedMark (.getConstant HotSpot'config, "CodeInstaller::INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED", Integer))

    (defn- #_"?" peep [#_"Class" class #_"String" field] (let [#_"Field" f (.getDeclaredField class, field)] (.setAccessible f, true) (.get f, class)))

    (def #_"Unsafe" HotSpot'unsafe (peep Unsafe "theUnsafe"))

    (def #_"int" Unsafe'ARRAY_BOOLEAN_BASE_OFFSET (peep Unsafe "ARRAY_BOOLEAN_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_BYTE_BASE_OFFSET    (peep Unsafe "ARRAY_BYTE_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_SHORT_BASE_OFFSET   (peep Unsafe "ARRAY_SHORT_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_CHAR_BASE_OFFSET    (peep Unsafe "ARRAY_CHAR_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_INT_BASE_OFFSET     (peep Unsafe "ARRAY_INT_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_LONG_BASE_OFFSET    (peep Unsafe "ARRAY_LONG_BASE_OFFSET"))
    (def #_"int" Unsafe'ARRAY_OBJECT_BASE_OFFSET  (peep Unsafe "ARRAY_OBJECT_BASE_OFFSET"))

    (def #_"int" Unsafe'ARRAY_BOOLEAN_INDEX_SCALE (peep Unsafe "ARRAY_BOOLEAN_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_BYTE_INDEX_SCALE    (peep Unsafe "ARRAY_BYTE_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_SHORT_INDEX_SCALE   (peep Unsafe "ARRAY_SHORT_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_CHAR_INDEX_SCALE    (peep Unsafe "ARRAY_CHAR_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_INT_INDEX_SCALE     (peep Unsafe "ARRAY_INT_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_LONG_INDEX_SCALE    (peep Unsafe "ARRAY_LONG_INDEX_SCALE"))
    (def #_"int" Unsafe'ARRAY_OBJECT_INDEX_SCALE  (peep Unsafe "ARRAY_OBJECT_INDEX_SCALE"))

    (defn #_"int" HotSpot'arrayBaseOffset-1 [#_"JavaKind" kind]
        (condp = kind
            JavaKind/Boolean Unsafe'ARRAY_BOOLEAN_BASE_OFFSET
            JavaKind/Byte    Unsafe'ARRAY_BYTE_BASE_OFFSET
            JavaKind/Short   Unsafe'ARRAY_SHORT_BASE_OFFSET
            JavaKind/Char    Unsafe'ARRAY_CHAR_BASE_OFFSET
            JavaKind/Int     Unsafe'ARRAY_INT_BASE_OFFSET
            JavaKind/Long    Unsafe'ARRAY_LONG_BASE_OFFSET
            JavaKind/Object  Unsafe'ARRAY_OBJECT_BASE_OFFSET
        )
    )

    (defn #_"int" HotSpot'arrayIndexScale-1 [#_"JavaKind" kind]
        (condp = kind
            JavaKind/Boolean Unsafe'ARRAY_BOOLEAN_INDEX_SCALE
            JavaKind/Byte    Unsafe'ARRAY_BYTE_INDEX_SCALE
            JavaKind/Short   Unsafe'ARRAY_SHORT_INDEX_SCALE
            JavaKind/Char    Unsafe'ARRAY_CHAR_INDEX_SCALE
            JavaKind/Int     Unsafe'ARRAY_INT_INDEX_SCALE
            JavaKind/Long    Unsafe'ARRAY_LONG_INDEX_SCALE
            JavaKind/Object  Unsafe'ARRAY_OBJECT_INDEX_SCALE
        )
    )

    ;;;
     ; Special registers reserved by HotSpot for frequently used values.
     ;;
    (§ def #_"Register" HotSpot'threadRegister       AMD64/r15)
    (§ def #_"Register" HotSpot'heapBaseRegister     AMD64/r12)
    (§ def #_"Register" HotSpot'stackPointerRegister AMD64/rsp)

    (§ def #_"ValueKindFactory<LIRKind>" HotSpot'valueKindFactory
        (§ reify #_"ValueKindFactory<LIRKind>" (ValueKindFactory.)
            (§ override! #_"LIRKind" #_"ValueKindFactory" .getValueKind [#_"ValueKindFactory<LIRKind>" this, #_"JavaKind" javaKind]
                (LIRKind'fromJavaKind-2 (.arch HotSpot'target), javaKind)
            )
        )
    )

    (§ def #_"BytecodeProvider" HotSpot'defaultBytecodeProvider (ClassfileBytecodeProvider'new-0))

    (§ def #_"ForeignCalls" HotSpot'foreignCalls (ForeignCalls'new-0))
    (§ def #_"Replacements" HotSpot'replacements (Replacements'new-0))
    (§ def #_"Plugins"      HotSpot'plugins      (Plugins'create-0))

    (§ def #_"PhaseSuite<HighTierContext>" HotSpot'graphBuilderSuite (Suites'createGraphBuilderSuite-0))
)

;;;
 ; A snippet is a Graal graph expressed as a Java source method. Snippets are used for lowering
 ; nodes that have runtime dependent semantics (e.g. the CHECKCAST bytecode).
 ;
 ; @target ElementType.METHOD
 ;;
(§ annotation Snippet
)

;;;
 ; Denotes a snippet parameter representing 0 or more arguments that will be bound during
 ; snippet template instantiation. During snippet template creation, its value must be an array
 ; whose length specifies the number of arguments (the contents of the array are ignored) bound
 ; to the parameter during instantiation.
 ;
 ; @anno Snippet.VarargsParameter
 ; @target ElementType.PARAMETER
 ;;
(§ annotation VarargsParameter
)

;;;
 ; Denotes a snippet parameter that will bound to a constant value during snippet template instantiation.
 ;
 ; @anno Snippet.ConstantParameter
 ; @target ElementType.PARAMETER
 ;;
(§ annotation ConstantParameter
)

;;;
 ; Denotes a snippet parameter that will bound to a non-nil value during snippet template instantiation.
 ;
 ; @anno Snippet.NonNullParameter
 ; @target ElementType.PARAMETER
 ;;
(§ annotation NonNullParameter
)

;;;
 ; Abstract base class that represents a platform specific address.
 ;;
(class-ns AbstractAddress
    (§ defn #_"AbstractAddress" AbstractAddress'new-0 []
        (Object.)
    )
)

;;;
 ; Represents an address in target machine memory, specified via some combination of a base
 ; register, an index register, a displacement and a scale. Note that the base and index registers
 ; may be a variable that will get a register assigned later by the register allocator.
 ;;
(final-ns AMD64Address (§ extends AbstractAddress)
    ;;;
     ; Base register that defines the start of the address computation.
     ; If not present, is denoted by Register#None.
     ;;
    (§ final #_"Register" :base nil)
    ;;;
     ; Index register, the value of which (possibly scaled by #getScale) is added to #getBase.
     ; If not present, is denoted by Register#None.
     ;;
    (§ final #_"Register" :index nil)
    ;;;
     ; Scaling factor for indexing, dependent on target operand size.
     ;;
    (§ final #_"Scale" :scale nil)
    ;;;
     ; Optional additive displacement.
     ;;
    (§ final #_"int" :displacement 0)
    ;;;
     ; The start of the instruction, i.e. the value that is used as the key for looking up placeholder
     ; patching information. Only used for {@link Assembler#getPlaceholder placeholder addresses}.
     ;;
    (§ final #_"int" :instructionStartPosition 0)

    ;;;
     ; Creates an AMD64Address with given base register, no scaling and no displacement.
     ;
     ; @param base the base register
     ;;
    (§ defn #_"AMD64Address" AMD64Address'new-1 [#_"Register" base]
        (AMD64Address'new-4 base, Register/None, Scale'Times1, 0)
    )

    ;;;
     ; Creates an AMD64Address with given base register, no scaling and a given displacement.
     ;
     ; @param base the base register
     ; @param displacement the displacement
     ;;
    (§ defn #_"AMD64Address" AMD64Address'new-2 [#_"Register" base, #_"int" displacement]
        (AMD64Address'new-4 base, Register/None, Scale'Times1, displacement)
    )

    ;;;
     ; Creates an AMD64Address with given base and index registers, scaling and 0 displacement.
     ;
     ; @param base the base register
     ; @param index the index register
     ; @param scale the scaling factor
     ;;
    #_unused
    (§ defn #_"AMD64Address" AMD64Address'new-3 [#_"Register" base, #_"Register" index, #_"Scale" scale]
        (AMD64Address'new-5 base, index, scale, 0, -1)
    )

    ;;;
     ; Creates an AMD64Address with given base and index registers, scaling and
     ; displacement. This is the most general constructor.
     ;
     ; @param base the base register
     ; @param index the index register
     ; @param scale the scaling factor
     ; @param displacement the displacement
     ;;
    (§ defn #_"AMD64Address" AMD64Address'new-4 [#_"Register" base, #_"Register" index, #_"Scale" scale, #_"int" displacement]
        (AMD64Address'new-5 base, index, scale, displacement, -1)
    )

    (§ defn #_"AMD64Address" AMD64Address'new-5 [#_"Register" base, #_"Register" index, #_"Scale" scale, #_"int" displacement, #_"int" instructionStartPosition]
        (let [
            #_"AMD64Address" this (AbstractAddress'new-0)
            this (assoc this :base base)
            this (assoc this :index index)
            this (assoc this :scale scale)
            this (assoc this :displacement displacement)
            this (assoc this :instructionStartPosition instructionStartPosition)
        ]
            this
        )
    )
)

;;;
 ; A scaling factor used in the SIB addressing mode.
 ;
 ; @anno AMD64Address.Scale
 ;;
(final-ns Scale
    ;;;
     ; The value (or multiplier) of this scale.
     ;;
    (§ final #_"int" :value 0)
    ;;;
     ; The shift (value log 2) of this scale.
     ;;
    (§ final #_"int" :shift 0)

    (§ defn- #_"Scale" Scale'new-2 [#_"int" value, #_"int" shift]
        (let [
            #_"Scale" this (Object.)
            this (assoc this :value value)
            this (assoc this :shift shift)
        ]
            this
        )
    )

    (§ def Scale'Times1 (Scale'new-2 1, 0))
    (§ def Scale'Times2 (Scale'new-2 2, 1))
    (§ def Scale'Times4 (Scale'new-2 4, 2))
    (§ def Scale'Times8 (Scale'new-2 8, 3))

    (§ defn #_"Scale" Scale'fromInt-1   [#_"int" scale] (case scale 1 Scale'Times1 2 Scale'Times2 4 Scale'Times4 8 Scale'Times8 nil))
    (§ defn #_"Scale" Scale'fromShift-1 [#_"int" shift] (case shift 0 Scale'Times1 1 Scale'Times2 2 Scale'Times4 3 Scale'Times8 nil))
)

(final-ns Assembler
    (def- #_"boolean" Assembler'UseNormalNop false)
    (def- #_"boolean" Assembler'UseAddressNop true)
    (def- #_"boolean" Assembler'UseIncDec true)

    (def- #_"int" Assembler'MinEncodingNeedsRex 8)

    ;;;
     ; The LIR for which code is being generated.
     ;;
    (§ final #_"LIR" :lir nil)

    (§ final #_"FrameMap" :frameMap nil)
    ;;;
     ; The object that emits code for managing a method's frame.
     ;;
    (§ final #_"FrameContext" :frameContext nil)

    (§ final #_"CompilationResult" :compilationResult nil)

    ;;;
     ; The index of the block currently being emitted.
     ;;
    (§ mutable #_"int" :currentBlockIndex 0)

    (§ final #_"EconomicMap<Constant, Data>" :dataCache (EconomicMap/create Equivalence/DEFAULT))

    (§ final #_"CodeBuffer" :codeBuffer (CodeBuffer'new-1 (#_"Architecture" .getByteOrder (.arch HotSpot'target))))

    (§ defn #_"Assembler" Assembler'new-1 [#_"LIRGenerationResult" res]
        (let [
            #_"Assembler" this (Object.)
            this (assoc this :lir (:lir res))
            this (assoc this :frameMap (:frameMap res))
            ;; Omit the frame if the method:
            ;; - has no spill slots or other slots allocated during register allocation
            ;; - has no callee-saved registers
            ;; - has no incoming arguments passed on the stack
            ;; - has no deoptimization points
            ;; - makes no foreign calls (which require an aligned stack)
            #_"boolean" omit-frame?
                (and GraalOptions'canOmitFrame
                    (not (FrameMap''frameNeedsAllocating-1 (:frameMap res)))
                    (not (:hasArgInCallerFrame (:lir res)))
                    (not (:hasForeignCall res))
                )
            this (assoc this :frameContext (FrameContext'new-2 (some? (:stub res)), omit-frame?))
            this (assoc this :compilationResult (CompilationResult'new-1 (FrameMap''totalFrameSize-1 (:frameMap res))))
        ]
            this
        )
    )

    ;;;
     ; Returns the current position of the underlying code buffer.
     ;
     ; @return current position in code buffer
     ;;
    (§ method! #_"int" Assembler''position-1 [#_"Assembler" this]
        (CodeBuffer''position-1 (:codeBuffer this))
    )

    (§ method! #_"void" Assembler''emitByte-2 [#_"Assembler" this, #_"int" x]
        (§ ass! (:codeBuffer this) (CodeBuffer''emitByte-2 (:codeBuffer this), x))
        nil
    )

    (§ method! #_"void" Assembler''emitShort-2 [#_"Assembler" this, #_"int" x]
        (§ ass! (:codeBuffer this) (CodeBuffer''emitShort-2 (:codeBuffer this), x))
        nil
    )

    (§ method! #_"void" Assembler''emitInt-2 [#_"Assembler" this, #_"int" x]
        (§ ass! (:codeBuffer this) (CodeBuffer''emitInt-2 (:codeBuffer this), x))
        nil
    )

    (§ method! #_"void" Assembler''emitLong-2 [#_"Assembler" this, #_"long" x]
        (§ ass! (:codeBuffer this) (CodeBuffer''emitLong-2 (:codeBuffer this), x))
        nil
    )

    (§ method! #_"void" Assembler''emitByte-3 [#_"Assembler" this, #_"int" b, #_"int" pos]
        (§ ass! (:codeBuffer this) (CodeBuffer''emitByte-3 (:codeBuffer this), b, pos))
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''emitShort-3 [#_"Assembler" this, #_"int" b, #_"int" pos]
        (§ ass! (:codeBuffer this) (CodeBuffer''emitShort-3 (:codeBuffer this), b, pos))
        nil
    )

    (§ method! #_"void" Assembler''emitInt-3 [#_"Assembler" this, #_"int" b, #_"int" pos]
        (§ ass! (:codeBuffer this) (CodeBuffer''emitInt-3 (:codeBuffer this), b, pos))
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''emitLong-3 [#_"Assembler" this, #_"long" b, #_"int" pos]
        (§ ass! (:codeBuffer this) (CodeBuffer''emitLong-3 (:codeBuffer this), b, pos))
        nil
    )

    (§ method! #_"int" Assembler''getByte-2 [#_"Assembler" this, #_"int" pos]
        (CodeBuffer''getByte-2 (:codeBuffer this), pos)
    )

    (§ method! #_"int" Assembler''getShort-2 [#_"Assembler" this, #_"int" pos]
        (CodeBuffer''getShort-2 (:codeBuffer this), pos)
    )

    #_unused
    (§ method! #_"int" Assembler''getInt-2 [#_"Assembler" this, #_"int" pos]
        (CodeBuffer''getInt-2 (:codeBuffer this), pos)
    )

    ;;;
     ; Closes this assembler. No extra data can be written to this assembler after this call.
     ;
     ; @param trim? if true, then a copy of the underlying byte array up to (but not including) {@code position()} is returned
     ; @return the data in this buffer or a trimmed copy if {@code trim?} is true
     ;;
    (§ method! #_"byte[]" Assembler''close-2 [#_"Assembler" this, #_"boolean" trim?]
        (CodeBuffer''close-2 (:codeBuffer this), trim?)
    )

    (§ method! #_"void" Assembler''bind-2 [#_"Assembler" this, #_"Label" l]
        (§ ass! l (Label''bind-2 l, (Assembler''position-1 this)))
        (Label''patchInstructions-2 l, this)
        nil
    )

    (§ defn- #_"int" Assembler'encode-1 [#_"Register" r]
        (& (.encoding r) 0x7)
    )

    ;;;
     ; Get RXB bits for register-register instruction. In that encoding, ModRM.rm contains a
     ; register index. The R bit extends the ModRM.reg field and the B bit extends the ModRM.rm
     ; field. The X bit must be 0.
     ;;
    (§ defn #_"int" Assembler'getRXB-2 [#_"Register" reg, #_"Register" rm]
        (| (>> (if (nil? reg) 0 (& (.encoding reg) 0x08)) 1) (>> (if (nil? rm) 0 (& (.encoding rm) 0x08)) 3))
    )

    ;;;
     ; Get RXB bits for register-memory instruction. The R bit extends the ModRM.reg field.
     ; There are two cases for the memory operand:
     ; ModRM.rm contains the base register: In that case, B extends the ModRM.rm field and X = 0.
     ;
     ; There is an SIB byte: In that case, X extends SIB.index and B extends SIB.base.
     ;;
    (§ defn #_"int" Assembler'getRXB-2 [#_"Register" reg, #_"AMD64Address" rm]
        (let [
            #_"int" rxb (>> (if (nil? reg) 0 (& (.encoding reg) 0x08)) 1)
        ]
            (when-not (= (:index rm) Register/None)
                (§ ass rxb (| rxb (>> (& (.encoding (:index rm)) 0x08) 2)))
            )
            (when-not (= (:base rm) Register/None)
                (§ ass rxb (| rxb (>> (& (.encoding (:base rm)) 0x08) 3)))
            )
            rxb
        )
    )

    ;;;
     ; Emit the ModR/M byte for one register operand and an opcode extension in the R field.
     ;
     ; Format: [ 11 reg r/m ]
     ;;
    (§ method! #_"void" Assembler''emitModRM-3 [#_"Assembler" this, #_"int" reg, #_"Register" rm]
        (Assembler''emitByte-2 this, (| 0xc0 (<< reg 3) (& (.encoding rm) 0x07)))
        nil
    )

    ;;;
     ; Emit the ModR/M byte for two register operands.
     ;
     ; Format: [ 11 reg r/m ]
     ;;
    (§ method! #_"void" Assembler''emitModRM-3 [#_"Assembler" this, #_"Register" reg, #_"Register" rm]
        (Assembler''emitModRM-3 this, (& (.encoding reg) 0x07), rm)
        nil
    )

    (§ method! #_"void" Assembler''emitOperandHelper-4 [#_"Assembler" this, #_"Register" reg, #_"AMD64Address" addr, #_"int" additionalInstructionSize]
        (Assembler''emitOperandHelper-5 this, (Assembler'encode-1 reg), addr, false, additionalInstructionSize)
        nil
    )

    ;;;
     ; Emits the ModR/M byte and optionally the SIB byte for one register and one memory operand.
     ;
     ; @param force4Byte use 4 byte encoding for displacements that would normally fit in a byte
     ;;
    (§ method! #_"void" Assembler''emitOperandHelper-5 [#_"Assembler" this, #_"Register" reg, #_"AMD64Address" addr, #_"boolean" force4Byte, #_"int" additionalInstructionSize]
        (Assembler''emitOperandHelper-5 this, (Assembler'encode-1 reg), addr, force4Byte, additionalInstructionSize)
        nil
    )

    (§ method! #_"void" Assembler''emitOperandHelper-4 [#_"Assembler" this, #_"int" reg, #_"AMD64Address" addr, #_"int" additionalInstructionSize]
        (Assembler''emitOperandHelper-5 this, reg, addr, false, additionalInstructionSize)
        nil
    )

    ;;;
     ; Emits the ModR/M byte and optionally the SIB byte for one memory operand and an opcode
     ; extension in the R field.
     ;
     ; @param force4Byte use 4 byte encoding for displacements that would normally fit in a byte
     ; @param additionalInstructionSize the number of bytes that will be emitted after the operand,
     ;            so that the start position of the next instruction can be computed even though
     ;            this instruction has not been completely emitted yet.
     ;;
    (§ method! #_"void" Assembler''emitOperandHelper-5 [#_"Assembler" this, #_"int" reg, #_"AMD64Address" addr, #_"boolean" force4Byte, #_"int" additionalInstructionSize]
        (let [
            #_"int" regenc (<< reg 3)
            #_"Register" base (:base addr)
            #_"Register" index (:index addr)
            #_"Scale" scale (:scale addr)
            #_"int" disp (:displacement addr)
        ]
            (cond
                (= base AMD64/rip) ;; also matches addresses returned by getPlaceholder()
                    (do
                        ;; [00 000 101] disp32
                        (Assembler''emitByte-2 this, (| 0x05 regenc))
                        (Assembler''emitInt-2 this, disp)
                    )
                (#_"Register" .isValid base)
                    (let [
                        #_"int" baseenc (if (#_"Register" .isValid base) (Assembler'encode-1 base) 0)
                    ]
                        (cond
                            (#_"Register" .isValid index)
                            (let [
                                #_"int" indexenc (<< (Assembler'encode-1 index) 3)
                            ]
                                ;; [base + indexscale + disp]
                                (cond
                                    (and (zero? disp) (not (= base AMD64/rbp)) (not (= base AMD64/r13)))
                                    (do
                                        ;; [base + indexscale]
                                        ;; [00 reg 100][ss index base]
                                        (Assembler''emitByte-2 this, (| 0x04 regenc))
                                        (Assembler''emitByte-2 this, (| (<< (:shift scale) 6) indexenc baseenc))
                                    )
                                    (and (NumUtil'isByte-1 disp) (not force4Byte))
                                    (do
                                        ;; [base + indexscale + imm8]
                                        ;; [01 reg 100][ss index base] imm8
                                        (Assembler''emitByte-2 this, (| 0x44 regenc))
                                        (Assembler''emitByte-2 this, (| (<< (:shift scale) 6) indexenc baseenc))
                                        (Assembler''emitByte-2 this, (& disp 0xff))
                                    )
                                    :else
                                    (do
                                        ;; [base + indexscale + disp32]
                                        ;; [10 reg 100][ss index base] disp32
                                        (Assembler''emitByte-2 this, (| 0x84 regenc))
                                        (Assembler''emitByte-2 this, (| (<< (:shift scale) 6) indexenc baseenc))
                                        (Assembler''emitInt-2 this, disp)
                                    )
                                )
                            )
                            (or (= base AMD64/rsp) (= base AMD64/r12))
                                ;; [rsp + disp]
                                (cond
                                    (zero? disp)
                                    (do
                                        ;; [rsp]
                                        ;; [00 reg 100][00 100 100]
                                        (Assembler''emitByte-2 this, (| 0x04 regenc))
                                        (Assembler''emitByte-2 this, 0x24)
                                    )
                                    (and (NumUtil'isByte-1 disp) (not force4Byte))
                                    (do
                                        ;; [rsp + imm8]
                                        ;; [01 reg 100][00 100 100] disp8
                                        (Assembler''emitByte-2 this, (| 0x44 regenc))
                                        (Assembler''emitByte-2 this, 0x24)
                                        (Assembler''emitByte-2 this, (& disp 0xff))
                                    )
                                    :else
                                    (do
                                        ;; [rsp + imm32]
                                        ;; [10 reg 100][00 100 100] disp32
                                        (Assembler''emitByte-2 this, (| 0x84 regenc))
                                        (Assembler''emitByte-2 this, 0x24)
                                        (Assembler''emitInt-2 this, disp)
                                    )
                                )
                            :else
                                ;; [base + disp]
                                (cond
                                    (and (zero? disp) (not (= base AMD64/rbp)) (not (= base AMD64/r13)))
                                    (do
                                        ;; [base]
                                        ;; [00 reg base]
                                        (Assembler''emitByte-2 this, (| 0x00 regenc baseenc))
                                    )
                                    (and (NumUtil'isByte-1 disp) (not force4Byte))
                                    (do
                                        ;; [base + disp8]
                                        ;; [01 reg base] disp8
                                        (Assembler''emitByte-2 this, (| 0x40 regenc baseenc))
                                        (Assembler''emitByte-2 this, (& disp 0xff))
                                    )
                                    :else
                                    (do
                                        ;; [base + disp32]
                                        ;; [10 reg base] disp32
                                        (Assembler''emitByte-2 this, (| 0x80 regenc baseenc))
                                        (Assembler''emitInt-2 this, disp)
                                    )
                                )
                        )
                    )
                :else
                    (if (#_"Register" .isValid index)
                        (let [
                            #_"int" indexenc (<< (Assembler'encode-1 index) 3)
                        ]
                            ;; [indexscale + disp]
                            ;; [00 reg 100][ss index 101] disp32
                            (Assembler''emitByte-2 this, (| 0x04 regenc))
                            (Assembler''emitByte-2 this, (| (<< (:shift scale) 6) indexenc 0x05))
                            (Assembler''emitInt-2 this, disp)
                        )
                        (do
                            ;; [disp] ABSOLUTE
                            ;; [00 reg 100][00 100 101] disp32
                            (Assembler''emitByte-2 this, (| 0x04 regenc))
                            (Assembler''emitByte-2 this, 0x25)
                            (Assembler''emitInt-2 this, disp)
                        )
                    )
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''addl-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'ADD, OperandSize'DWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''addl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'ADD, OperandSize'DWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''addl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'ADD), this, OperandSize'DWORD, dst, src)
        nil
    )

    (§ method- #_"void" Assembler''addrNop4-1 [#_"Assembler" this]
        ;; 4 bytes: NOP DWORD PTR [EAX+0]
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x1f)
        (Assembler''emitByte-2 this, 0x40) ;; emitRm(cbuf, 0x1, EAXEnc, EAXEnc);
        (Assembler''emitByte-2 this, 0) ;; 8-bits offset (1 byte)
        nil
    )

    (§ method- #_"void" Assembler''addrNop5-1 [#_"Assembler" this]
        ;; 5 bytes: NOP DWORD PTR [EAX+EAX*0+0] 8-bits offset
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x1f)
        (Assembler''emitByte-2 this, 0x44) ;; emitRm(cbuf, 0x1, EAXEnc, 0x4);
        (Assembler''emitByte-2 this, 0x00) ;; emitRm(cbuf, 0x0, EAXEnc, EAXEnc);
        (Assembler''emitByte-2 this, 0) ;; 8-bits offset (1 byte)
        nil
    )

    (§ method- #_"void" Assembler''addrNop7-1 [#_"Assembler" this]
        ;; 7 bytes: NOP DWORD PTR [EAX+0] 32-bits offset
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x1f)
        (Assembler''emitByte-2 this, 0x80) ;; emitRm(cbuf, 0x2, EAXEnc, EAXEnc);
        (Assembler''emitInt-2 this, 0) ;; 32-bits offset (4 bytes)
        nil
    )

    (§ method- #_"void" Assembler''addrNop8-1 [#_"Assembler" this]
        ;; 8 bytes: NOP DWORD PTR [EAX+EAX*0+0] 32-bits offset
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x1f)
        (Assembler''emitByte-2 this, 0x84) ;; emitRm(cbuf, 0x2, EAXEnc, 0x4);
        (Assembler''emitByte-2 this, 0x00) ;; emitRm(cbuf, 0x0, EAXEnc, EAXEnc);
        (Assembler''emitInt-2 this, 0) ;; 32-bits offset (4 bytes)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''andl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'AND, OperandSize'DWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''andl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'AND), this, OperandSize'DWORD, dst, src)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''bsfq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (#_"Register" .encoding dst), (#_"Register" .encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbc)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''bsrl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3 this, (#_"Register" .encoding dst), (#_"Register" .encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbd)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''bswapl-2 [#_"Assembler" this, #_"Register" reg]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding reg))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0xc8 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''cdql-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0x99)
        nil
    )

    (§ method! #_"void" Assembler''cmovl-4 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0x40 (:value cc)))
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''cmovl-4 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, (| 0x40 (:value cc)))
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''cmpl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'CMP, OperandSize'DWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''cmpl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'CMP), this, OperandSize'DWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''cmpl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'CMP), this, OperandSize'DWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''cmpl-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'CMP, OperandSize'DWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    ;; The 32-bit cmpxchg compares the value at adr with the contents of X86.rax,
    ;; and stores reg into adr if so; otherwise, the value at adr is loaded into X86.rax.
    ;; The ZF is set if the compared values were equal, and cleared otherwise.
    (§ method! #_"void" Assembler''cmpxchgl-3 [#_"Assembler" this, #_"Register" reg, #_"AMD64Address" adr] ;; cmpxchg
        (Assembler''prefix-3 this, adr, reg)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xb1)
        (Assembler''emitOperandHelper-4 this, reg, adr, 0)
        nil
    )

    (§ method! #_"void" Assembler''decl-2 [#_"Assembler" this, #_"AMD64Address" dst]
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xff)
        (Assembler''emitOperandHelper-4 this, 1, dst, 0)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''hlt-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0xf4)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''imull-4 [#_"Assembler" this, #_"Register" dst, #_"Register" src, #_"int" value]
        (if (NumUtil'isByte-1 value)
            (AMD64RMIOp''emit-6 AMD64RMIOp'IMUL_SX, this, OperandSize'DWORD, dst, src, value)
            (AMD64RMIOp''emit-6 AMD64RMIOp'IMUL, this, OperandSize'DWORD, dst, src, value)
        )
        nil
    )

    (§ method! #_"void" Assembler''incl-2 [#_"Assembler" this, #_"AMD64Address" dst]
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xff)
        (Assembler''emitOperandHelper-4 this, 0, dst, 0)
        nil
    )

    (§ method! #_"void" Assembler''jcc-4 [#_"Assembler" this, #_"ConditionFlag" cc, #_"int" jumpTarget, #_"boolean" forceDisp32]
        (let [
            #_"int" shortSize 2
            #_"int" longSize 6
            #_"long" disp (- jumpTarget (Assembler''position-1 this))
        ]
            (if (and (not forceDisp32) (NumUtil'isByte-1 (- disp shortSize)))
                (do
                    ;; 0111 tttn #8-bit disp
                    (Assembler''emitByte-2 this, (| 0x70 (:value cc)))
                    (Assembler''emitByte-2 this, (int (& (- disp shortSize) 0xff)))
                )
                (do
                    ;; 0000 1111 1000 tttn #32-bit disp
                    (Assembler''emitByte-2 this, 0x0f)
                    (Assembler''emitByte-2 this, (| 0x80 (:value cc)))
                    (Assembler''emitInt-2 this, (int (- disp longSize)))
                )
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''jcc-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Label" l]
        (if (Label''isBound-1 l)
            (Assembler''jcc-4 this, cc, (:position l), false)
            (do
                ;; note: could eliminate cond. jumps to this jump if condition is the same however, seems to be rather unlikely case
                ;; note: use jccb() if label to be bound is very close to get an 8-bit displacement
                (§ ass! l (Label''addPatchAt-2 l, (Assembler''position-1 this)))
                (Assembler''emitByte-2 this, 0x0f)
                (Assembler''emitByte-2 this, (| 0x80 (:value cc)))
                (Assembler''emitInt-2 this, 0)
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''jccb-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Label" l]
        (if (Label''isBound-1 l)
            (let [
                #_"int" shortSize 2
                #_"int" entry (:position l)
                #_"long" disp (- entry (Assembler''position-1 this))
            ]
                ;; 0111 tttn #8-bit disp
                (Assembler''emitByte-2 this, (| 0x70 (:value cc)))
                (Assembler''emitByte-2 this, (int (& (- disp shortSize) 0xff)))
            )
            (do
                (§ ass! l (Label''addPatchAt-2 l, (Assembler''position-1 this)))
                (Assembler''emitByte-2 this, (| 0x70 (:value cc)))
                (Assembler''emitByte-2 this, 0)
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''jmp-3 [#_"Assembler" this, #_"int" jumpTarget, #_"boolean" forceDisp32]
        (let [
            #_"int" shortSize 2
            #_"int" longSize 5
            #_"long" disp (- jumpTarget (Assembler''position-1 this))
        ]
            (if (and (not forceDisp32) (NumUtil'isByte-1 (- disp shortSize)))
                (do
                    (Assembler''emitByte-2 this, 0xeb)
                    (Assembler''emitByte-2 this, (int (& (- disp shortSize) 0xff)))
                )
                (do
                    (Assembler''emitByte-2 this, 0xe9)
                    (Assembler''emitInt-2 this, (int (- disp longSize)))
                )
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''jmp-2 [#_"Assembler" this, #_"Label" l]
        (if (Label''isBound-1 l)
            (Assembler''jmp-3 this, (:position l), false)
            (do
                ;; By default, forward jumps are always 32-bit displacements, since we can't yet know where the label will be bound.
                ;; If you're sure that the forward jump will not run beyond 256 bytes, use jmpb to force an 8-bit displacement.
                (§ ass! l (Label''addPatchAt-2 l, (Assembler''position-1 this)))
                (Assembler''emitByte-2 this, 0xe9)
                (Assembler''emitInt-2 this, 0)
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''jmp-2 [#_"Assembler" this, #_"Register" entry]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding entry))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xe0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''jmp-2 [#_"Assembler" this, #_"AMD64Address" adr]
        (Assembler''prefix-2 this, adr)
        (Assembler''emitByte-2 this, 0xff)
        (Assembler''emitOperandHelper-4 this, AMD64/rsp, adr, 0)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''jmpb-2 [#_"Assembler" this, #_"Label" l]
        (if (Label''isBound-1 l)
            (let [
                #_"int" shortSize 2
                #_"int" entry (:position l)
                #_"long" offs (- entry (Assembler''position-1 this))
            ]
                (Assembler''emitByte-2 this, 0xeb)
                (Assembler''emitByte-2 this, (int (& (- offs shortSize) 0xff)))
            )
            (do
                (§ ass! l (Label''addPatchAt-2 l, (Assembler''position-1 this)))
                (Assembler''emitByte-2 this, 0xeb)
                (Assembler''emitByte-2 this, 0)
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''lead-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8d)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''leaq-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8d)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''leave-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0xc9)
        nil
    )

    (§ method! #_"void" Assembler''lock-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0xf0)
        nil
    )

    (§ method! #_"void" Assembler''movb-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm8]
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xc6)
        (Assembler''emitOperandHelper-4 this, 0, dst, 1)
        (Assembler''emitByte-2 this, imm8)
        nil
    )

    (§ method! #_"void" Assembler''movb-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefix-4 this, dst, src, true)
        (Assembler''emitByte-2 this, 0x88)
        (Assembler''emitOperandHelper-4 this, src, dst, 0)
        nil
    )

    (§ method! #_"void" Assembler''movl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, (| 0xb8 encode))
            (Assembler''emitInt-2 this, imm32)
        )
        nil
    )

    (§ method! #_"void" Assembler''movl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x8b)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''movl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8b)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    ;;;
     ; @param wide use 4 byte encoding for displacements that would normally fit in a byte
     ;;
    #_unused
    (§ method! #_"void" Assembler''movl-4 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src, #_"boolean" wide]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8b)
        (Assembler''emitOperandHelper-5 this, dst, src, wide, 0)
        nil
    )

    (§ method! #_"void" Assembler''movl-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xc7)
        (Assembler''emitOperandHelper-4 this, 0, dst, 4)
        (Assembler''emitInt-2 this, imm32)
        nil
    )

    (§ method! #_"void" Assembler''movl-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefix-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x89)
        (Assembler''emitOperandHelper-4 this, src, dst, 0)
        nil
    )

    (§ method! #_"void" Assembler''movq-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''movq-4 this, dst, src, false)
        nil
    )

    (§ method! #_"void" Assembler''movq-4 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src, #_"boolean" wide]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x8b)
        (Assembler''emitOperandHelper-5 this, dst, src, wide, 0)
        nil
    )

    (§ method! #_"void" Assembler''movq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x8b)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''movq-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefixq-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x89)
        (Assembler''emitOperandHelper-4 this, src, dst, 0)
        nil
    )

    (§ method! #_"void" Assembler''movsbl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xbe)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''movsbl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-5 this, (.encoding dst), false, (.encoding src), true)
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbe)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''movsbq-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xbe)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''movsbq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbe)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''movswl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xbf)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''movw-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm16]
        (Assembler''emitByte-2 this, 0x66) ;; switch to 16-bit mode
        (Assembler''prefix-2 this, dst)
        (Assembler''emitByte-2 this, 0xc7)
        (Assembler''emitOperandHelper-4 this, 0, dst, 2)
        (Assembler''emitShort-2 this, imm16)
        nil
    )

    (§ method! #_"void" Assembler''movw-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''emitByte-2 this, 0x66)
        (Assembler''prefix-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x89)
        (Assembler''emitOperandHelper-4 this, src, dst, 0)
        nil
    )

    (§ method! #_"void" Assembler''movzbl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xb6)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''movzbl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 AMD64RMOp'MOVZXB, this, OperandSize'DWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''movzbq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 AMD64RMOp'MOVZXB, this, OperandSize'QWORD, dst, src)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''movzwl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xb7)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''negl-2 [#_"Assembler" this, #_"Register" dst]
        (AMD64MOp''emit-4 AMD64MOp'NEG, this, OperandSize'DWORD, dst)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''notl-2 [#_"Assembler" this, #_"Register" dst]
        (AMD64MOp''emit-4 AMD64MOp'NOT, this, OperandSize'DWORD, dst)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''notq-2 [#_"Assembler" this, #_"Register" dst]
        (AMD64MOp''emit-4 AMD64MOp'NOT, this, OperandSize'QWORD, dst)
        nil
    )

    ;;;
     ; Emits a NOP instruction to advance the current PC.
     ;;
    (§ method! #_"void" Assembler''ensureUniquePC-1 [#_"Assembler" this]
        (Assembler''nop-1 this)
        nil
    )

    (§ method! #_"void" Assembler''nop-1 [#_"Assembler" this]
        (Assembler''nop-2 this, 1)
        nil
    )

    (§ method! #_"void" Assembler''nop-2 [#_"Assembler" this, #_"int" n]
        (cond
            Assembler'UseNormalNop
            (do
                ;; The fancy nops aren't currently recognized by debuggers making it a pain to disassemble code while debugging.
                ;; If assert are on clearly speed is not an issue so simply use the single byte traditional nop to do alignment.
                (dotimes [_ n]
                    (Assembler''emitByte-2 this, 0x90)
                )
            )

            Assembler'UseAddressNop
            (do
                ;; Using multi-bytes nops "0x0f 0x1f [Address]" for AMD.
                ;;
                ;;  1: 0x90
                ;;  2: 0x66 0x90
                ;;  3: 0x66 0x66 0x90 (don't use "0x0f 0x1f 0x00" - need patching safe padding)
                ;;  4: 0x0f 0x1f 0x40 0x00
                ;;  5: 0x0f 0x1f 0x44 0x00 0x00
                ;;  6: 0x66 0x0f 0x1f 0x44 0x00 0x00
                ;;  7: 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00
                ;;  8: 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;;  9: 0x66 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;; 10: 0x66 0x66 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;; 11: 0x66 0x66 0x66 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;;
                ;; The rest coding is AMD specific - use consecutive Address nops.
                ;;
                ;; 12: 0x66 0x0f 0x1f 0x44 0x00 0x00 0x66 0x0f 0x1f 0x44 0x00 0x00
                ;; 13: 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00 0x66 0x0f 0x1f 0x44 0x00 0x00
                ;; 14: 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00
                ;; 15: 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00 0x0f 0x1f 0x80 0x00 0x00 0x00 0x00
                ;; 16: 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00 0x0f 0x1f 0x84 0x00 0x00 0x00 0x00 0x00
                ;;
                ;; Size prefixes (0x66) are added for larger sizes.
                (§ ass n
                    (loop-when-recur n (<= 22 n) (- n 11) => n
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop8-1 this)
                    )
                )
                ;; Generate first nop for size between 21-12.
                (§ ass n
                    (case n
                        21
                        (do
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''addrNop8-1 this)
                            (- n 11)
                        )
                        (20 19)
                        (do
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''addrNop8-1 this)
                            (- n 10)
                        )
                        (18 17)
                        (do
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''addrNop8-1 this)
                            (- n 9)
                        )
                        (16 15)
                        (do
                            (Assembler''addrNop8-1 this)
                            (- n 8)
                        )
                        (14 13)
                        (do
                            (Assembler''addrNop7-1 this)
                            (- n 7)
                        )
                        12
                        (do
                            (Assembler''emitByte-2 this, 0x66)
                            (Assembler''addrNop5-1 this)
                            (- n 6)
                        )
                        n
                    )
                )

                ;; Generate second nop for size between 11-1.
                (case n
                    11
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop8-1 this)
                        nil
                    )
                    10
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop8-1 this)
                        nil
                    )
                    9
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop8-1 this)
                        nil
                    )
                    8
                    (do
                        (Assembler''addrNop8-1 this)
                        nil
                    )
                    7
                    (do
                        (Assembler''addrNop7-1 this)
                        nil
                    )
                    6
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''addrNop5-1 this)
                        nil
                    )
                    5
                    (do
                        (Assembler''addrNop5-1 this)
                        nil
                    )
                    4
                    (do
                        (Assembler''addrNop4-1 this)
                        nil
                    )
                    3
                    (do
                        ;; Don't use "0x0f 0x1f 0x00" - need patching safe padding.
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    2
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    1
                    (do
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    nil
                )
            )

            :else
            (do
                ;; Using nops with size prefixes "0x66 0x90".
                ;; From AMD Optimization Guide:
                ;;  1: 0x90
                ;;  2: 0x66 0x90
                ;;  3: 0x66 0x66 0x90
                ;;  4: 0x66 0x66 0x66 0x90
                ;;  5: 0x66 0x66 0x90 0x66 0x90
                ;;  6: 0x66 0x66 0x90 0x66 0x66 0x90
                ;;  7: 0x66 0x66 0x66 0x90 0x66 0x66 0x90
                ;;  8: 0x66 0x66 0x66 0x90 0x66 0x66 0x66 0x90
                ;;  9: 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
                ;; 10: 0x66 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
                (§ ass n
                    (loop-when-recur n (< 12 n) (- n 4) => n
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                    )
                )
                ;; 1 - 12 nops
                (when (< 8 n)
                    (when (< 9 n)
                        (Assembler''emitByte-2 this, 0x66)
                        (§ ass n (dec n))
                    )
                    (Assembler''emitByte-2 this, 0x66)
                    (Assembler''emitByte-2 this, 0x66)
                    (Assembler''emitByte-2 this, 0x90)
                    (§ ass n (- n 3))
                )
                ;; 1 - 8 nops
                (when (< 4 n)
                    (when (< 6 n)
                        (Assembler''emitByte-2 this, 0x66)
                        (§ ass n (dec n))
                    )
                    (Assembler''emitByte-2 this, 0x66)
                    (Assembler''emitByte-2 this, 0x66)
                    (Assembler''emitByte-2 this, 0x90)
                    (§ ass n (- n 3))
                )
                (case n
                    4
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    3
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    2
                    (do
                        (Assembler''emitByte-2 this, 0x66)
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    1
                    (do
                        (Assembler''emitByte-2 this, 0x90)
                        nil
                    )
                    nil
                )
            )
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''orl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'OR), this, OperandSize'DWORD, dst, src)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''orl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'OR, OperandSize'DWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''pop-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, (| 0x58 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''push-2 [#_"Assembler" this, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding src))
        ]
            (Assembler''emitByte-2 this, (| 0x50 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''ret-2 [#_"Assembler" this, #_"int" imm16]
        (if (zero? imm16)
            (Assembler''emitByte-2 this, 0xc3)
            (do
                (Assembler''emitByte-2 this, 0xc2)
                (Assembler''emitShort-2 this, imm16)
            )
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''sarl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (if (= imm8 1)
                (do
                    (Assembler''emitByte-2 this, 0xd1)
                    (Assembler''emitByte-2 this, (| 0xf8 encode))
                )
                (do
                    (Assembler''emitByte-2 this, 0xc1)
                    (Assembler''emitByte-2 this, (| 0xf8 encode))
                    (Assembler''emitByte-2 this, imm8)
                )
            )
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''shll-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (if (= imm8 1)
                (do
                    (Assembler''emitByte-2 this, 0xd1)
                    (Assembler''emitByte-2 this, (| 0xe0 encode))
                )
                (do
                    (Assembler''emitByte-2 this, 0xc1)
                    (Assembler''emitByte-2 this, (| 0xe0 encode))
                    (Assembler''emitByte-2 this, imm8)
                )
            )
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''shll-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xd3)
            (Assembler''emitByte-2 this, (| 0xe0 encode))
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''shrl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xc1)
            (Assembler''emitByte-2 this, (| 0xe8 encode))
            (Assembler''emitByte-2 this, imm8)
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''shrl-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xd3)
            (Assembler''emitByte-2 this, (| 0xe8 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''subl-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'DWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''subl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'DWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'DWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''subl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'SUB), this, OperandSize'DWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''testl-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        ;; not using emitArith because test
        ;; doesn't support sign-extension of
        ;; 8bit operands
        (let [
            #_"int" encode (.encoding dst)
        ]
            (if (zero? encode)
                (Assembler''emitByte-2 this, 0xa9)
                (do
                    (§ ass encode (Assembler''prefixAndEncode-2 this, encode))
                    (Assembler''emitByte-2 this, 0xf7)
                    (Assembler''emitByte-2 this, (| 0xc0 encode))
                )
            )
            (Assembler''emitInt-2 this, imm32)
        )
        nil
    )

    (§ method! #_"void" Assembler''testl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x85)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''testl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x85)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''xorl-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'XOR), this, OperandSize'DWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''decl-2 [#_"Assembler" this, #_"Register" dst]
        ;; Use two-byte form (one-byte form is a REX prefix in 64-bit mode).
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xc8 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''incl-2 [#_"Assembler" this, #_"Register" dst]
        ;; Use two-byte form (one-byte from is a REX prefix in 64-bit mode).
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method- #_"int" Assembler''prefixAndEncode-2 [#_"Assembler" this, #_"int" regEnc]
        (Assembler''prefixAndEncode-3 this, regEnc, false)
    )

    (§ method- #_"int" Assembler''prefixAndEncode-3 [#_"Assembler" this, #_"int" regEnc, #_"boolean" byte-inst?]
        (if (< regEnc 8)
            (do
                (when (and byte-inst? (<= 4 regEnc))
                    (Assembler''emitByte-2 this, Prefix'REX)
                )
                regEnc
            )
            (do
                (Assembler''emitByte-2 this, Prefix'REXB)
                (- regEnc 8)
            )
        )
    )

    (§ method- #_"int" Assembler''prefixqAndEncode-2 [#_"Assembler" this, #_"int" regEnc]
        (if (< regEnc 8)
            (do
                (Assembler''emitByte-2 this, Prefix'REXW)
                regEnc
            )
            (do
                (Assembler''emitByte-2 this, Prefix'REXWB)
                (- regEnc 8)
            )
        )
    )

    (§ method- #_"int" Assembler''prefixAndEncode-3 [#_"Assembler" this, #_"int" dstEnc, #_"int" srcEnc]
        (Assembler''prefixAndEncode-5 this, dstEnc, false, srcEnc, false)
    )

    (§ method- #_"int" Assembler''prefixAndEncode-5 [#_"Assembler" this, #_"int" dstEncoding, #_"boolean" dstIsByte, #_"int" srcEncoding, #_"boolean" srcIsByte]
        (let [
            #_"int" src srcEncoding
            #_"int" dst dstEncoding
            [src dst]
                (if (< dst 8)
                    (if (< src 8)
                        (do
                            (when (or (and srcIsByte (<= 4 src)) (and dstIsByte (<= 4 dst)))
                                (Assembler''emitByte-2 this, Prefix'REX)
                            )
                            [src dst]
                        )
                        (do
                            (Assembler''emitByte-2 this, Prefix'REXB)
                            [(- src 8) dst]
                        )
                    )
                    (if (< src 8)
                        (do (Assembler''emitByte-2 this, Prefix'REXR)  [   src    (- dst 8)])
                        (do (Assembler''emitByte-2 this, Prefix'REXRB) [(- src 8) (- dst 8)])
                    )
                )
        ]
            (| (<< dst 3) src)
        )
    )

    ;;;
     ; Creates prefix and the encoding of the lower 6 bits of the ModRM-Byte. It emits an operand
     ; prefix. If the given operands exceed 3 bits, the 4th bit is encoded in the prefix.
     ;
     ; @param regEncoding the encoding of the register part of the ModRM-Byte
     ; @param rmEncoding the encoding of the r/m part of the ModRM-Byte
     ; @return the lower 6 bits of the ModRM-Byte that should be emitted
     ;;
    (§ method- #_"int" Assembler''prefixqAndEncode-3 [#_"Assembler" this, #_"int" regEncoding, #_"int" rmEncoding]
        (let [
            #_"int" rm rmEncoding
            #_"int" reg regEncoding
            [rm reg]
                (if (< reg 8)
                    (if (< rm 8)
                        (do (Assembler''emitByte-2 this, Prefix'REXW)   [   rm    reg])
                        (do (Assembler''emitByte-2 this, Prefix'REXWB)  [(- rm 8) reg])
                    )
                    (if (< rm 8)
                        (do (Assembler''emitByte-2 this, Prefix'REXWR)  [   rm    (- reg 8)])
                        (do (Assembler''emitByte-2 this, Prefix'REXWRB) [(- rm 8) (- reg 8)])
                    )
                )
        ]
            (| (<< reg 3) rm)
        )
    )

    (§ defn- #_"boolean" Assembler'needsRex-1 [#_"Register" reg]
        (<= Assembler'MinEncodingNeedsRex (.encoding reg))
    )

    (§ method- #_"void" Assembler''prefix-2 [#_"Assembler" this, #_"AMD64Address" adr]
        (if (Assembler'needsRex-1 (:base adr))
            (if (Assembler'needsRex-1 (:index adr))
                (Assembler''emitByte-2 this, Prefix'REXXB)
                (Assembler''emitByte-2 this, Prefix'REXB)
            )
            (when (Assembler'needsRex-1 (:index adr))
                (Assembler''emitByte-2 this, Prefix'REXX)
            )
        )
        nil
    )

    (§ method- #_"void" Assembler''prefixq-2 [#_"Assembler" this, #_"AMD64Address" adr]
        (if (Assembler'needsRex-1 (:base adr))
            (if (Assembler'needsRex-1 (:index adr))
                (Assembler''emitByte-2 this, Prefix'REXWXB)
                (Assembler''emitByte-2 this, Prefix'REXWB)
            )
            (if (Assembler'needsRex-1 (:index adr))
                (Assembler''emitByte-2 this, Prefix'REXWX)
                (Assembler''emitByte-2 this, Prefix'REXW)
            )
        )
        nil
    )

    (§ method- #_"void" Assembler''prefix-3 [#_"Assembler" this, #_"AMD64Address" adr, #_"Register" reg]
        (Assembler''prefix-4 this, adr, reg, false)
        nil
    )

    (§ method- #_"void" Assembler''prefix-4 [#_"Assembler" this, #_"AMD64Address" adr, #_"Register" reg, #_"boolean" byte-inst?]
        (if (< (.encoding reg) 8)
            (if (Assembler'needsRex-1 (:base adr))
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXXB)
                    (Assembler''emitByte-2 this, Prefix'REXB)
                )
                (cond
                    (Assembler'needsRex-1 (:index adr))
                        (Assembler''emitByte-2 this, Prefix'REXX)
                    (and byte-inst? (<= 4 (.encoding reg)))
                        (Assembler''emitByte-2 this, Prefix'REX)
                )
            )
            (if (Assembler'needsRex-1 (:base adr))
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXRXB)
                    (Assembler''emitByte-2 this, Prefix'REXRB)
                )
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXRX)
                    (Assembler''emitByte-2 this, Prefix'REXR)
                )
            )
        )
        nil
    )

    (§ method- #_"void" Assembler''prefixq-3 [#_"Assembler" this, #_"AMD64Address" adr, #_"Register" src]
        (if (< (.encoding src) 8)
            (if (Assembler'needsRex-1 (:base adr))
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXWXB)
                    (Assembler''emitByte-2 this, Prefix'REXWB)
                )
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXWX)
                    (Assembler''emitByte-2 this, Prefix'REXW)
                )
            )
            (if (Assembler'needsRex-1 (:base adr))
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXWRXB)
                    (Assembler''emitByte-2 this, Prefix'REXWRB)
                )
                (if (Assembler'needsRex-1 (:index adr))
                    (Assembler''emitByte-2 this, Prefix'REXWRX)
                    (Assembler''emitByte-2 this, Prefix'REXWR)
                )
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''addq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'ADD, OperandSize'QWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''addq-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'ADD, OperandSize'QWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''addq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'ADD), this, OperandSize'QWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''addq-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (AMD64MROp''emit-5 (:mrOp BinaryArithmetic'ADD), this, OperandSize'QWORD, dst, src)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''andq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'AND, OperandSize'QWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''bsrq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (#_"Register" .encoding dst), (#_"Register" .encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xbd)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''bswapq-2 [#_"Assembler" this, #_"Register" reg]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding reg))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0xc8 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''cdqq-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, Prefix'REXW)
        (Assembler''emitByte-2 this, 0x99)
        nil
    )

    (§ method! #_"void" Assembler''cmovq-4 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0x40 (:value cc)))
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''setb-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-3 this, (.encoding dst), true)
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, (| 0x90 (:value cc)))
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''cmovq-4 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, (| 0x40 (:value cc)))
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''cmpq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'CMP, OperandSize'QWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''cmpq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'CMP), this, OperandSize'QWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''cmpq-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'CMP), this, OperandSize'QWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''cmpxchgq-3 [#_"Assembler" this, #_"Register" reg, #_"AMD64Address" adr]
        (Assembler''prefixq-3 this, adr, reg)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xb1)
        (Assembler''emitOperandHelper-4 this, reg, adr, 0)
        nil
    )

    (§ method! #_"void" Assembler''decq-2 [#_"Assembler" this, #_"Register" dst]
        ;; Use two-byte form (one-byte from is a REX prefix in 64-bit mode).
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xc8 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''decq-2 [#_"Assembler" this, #_"AMD64Address" dst]
        (AMD64MOp''emit-4 AMD64MOp'DEC, this, OperandSize'QWORD, dst)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''imulq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xaf)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''incq-2 [#_"Assembler" this, #_"Register" dst]
        ;; Don't use it directly. Use the macro incrementq() instead.
        ;; Use two-byte form (one-byte from is a REX prefix in 64-bit mode).
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''incq-2 [#_"Assembler" this, #_"AMD64Address" dst]
        (AMD64MOp''emit-4 AMD64MOp'INC, this, OperandSize'QWORD, dst)
        nil
    )

    (§ method! #_"void" Assembler''movq-3 [#_"Assembler" this, #_"Register" dst, #_"long" imm64]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, (| 0xb8 encode))
            (Assembler''emitLong-2 this, imm64)
        )
        nil
    )

    (§ method! #_"void" Assembler''movslq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xc7)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
            (Assembler''emitInt-2 this, imm32)
        )
        nil
    )

    (§ method! #_"void" Assembler''movslq-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (Assembler''prefixq-2 this, dst)
        (Assembler''emitByte-2 this, 0xc7)
        (Assembler''emitOperandHelper-4 this, 0, dst, 4)
        (Assembler''emitInt-2 this, imm32)
        nil
    )

    (§ method! #_"void" Assembler''movslq-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x63)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''movslq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x63)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''negq-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xf7)
            (Assembler''emitByte-2 this, (| 0xd8 encode))
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''orq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'OR), this, OperandSize'QWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''shlq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (if (= imm8 1)
                (do
                    (Assembler''emitByte-2 this, 0xd1)
                    (Assembler''emitByte-2 this, (| 0xe0 encode))
                )
                (do
                    (Assembler''emitByte-2 this, 0xc1)
                    (Assembler''emitByte-2 this, (| 0xe0 encode))
                    (Assembler''emitByte-2 this, imm8)
                )
            )
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''shlq-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xd3)
            (Assembler''emitByte-2 this, (| 0xe0 encode))
        )
        nil
    )

    (§ method! #_"void" Assembler''shrq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (if (= imm8 1)
                (do
                    (Assembler''emitByte-2 this, 0xd1)
                    (Assembler''emitByte-2 this, (| 0xe8 encode))
                )
                (do
                    (Assembler''emitByte-2 this, 0xc1)
                    (Assembler''emitByte-2 this, (| 0xe8 encode))
                    (Assembler''emitByte-2 this, imm8)
                )
            )
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''shrq-2 [#_"Assembler" this, #_"Register" dst]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding dst))
        ]
            (Assembler''emitByte-2 this, 0xd3)
            (Assembler''emitByte-2 this, (| 0xe8 encode))
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''sbbq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'SBB), this, OperandSize'QWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''subq-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'QWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''subq-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" imm32]
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'QWORD, (NumUtil'isByte-1 imm32)), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''subqWide-3 [#_"Assembler" this, #_"Register" dst, #_"int" imm32]
        ;; don't use the sign-extending version, forcing a 32-bit immediate
        (AMD64MIOp''emit-5 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'SUB, OperandSize'QWORD, false), this, OperandSize'QWORD, dst, imm32)
        nil
    )

    (§ method! #_"void" Assembler''subq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (AMD64RMOp''emit-5 (:rmOp BinaryArithmetic'SUB), this, OperandSize'QWORD, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''testq-3 [#_"Assembler" this, #_"Register" dst, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-3 this, (.encoding dst), (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x85)
            (Assembler''emitByte-2 this, (| 0xc0 encode))
        )
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''btrq-3 [#_"Assembler" this, #_"Register" src, #_"int" imm8]
        (let [
            #_"int" encode (Assembler''prefixqAndEncode-2 this, (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0x0f)
            (Assembler''emitByte-2 this, 0xba)
            (Assembler''emitByte-2 this, (| 0xf0 encode))
            (Assembler''emitByte-2 this, imm8)
        )
        nil
    )

    (§ method! #_"void" Assembler''xaddl-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefix-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xc1)
        (Assembler''emitOperandHelper-4 this, src, dst, 0)
        nil
    )

    (§ method! #_"void" Assembler''xaddq-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''prefixq-3 this, dst, src)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xc1)
        (Assembler''emitOperandHelper-4 this, src, dst, 0)
        nil
    )

    (§ method! #_"void" Assembler''xchgl-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefix-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x87)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''xchgq-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''prefixq-3 this, src, dst)
        (Assembler''emitByte-2 this, 0x87)
        (Assembler''emitOperandHelper-4 this, dst, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''membar-2 [#_"Assembler" this, #_"int" barriers]
        (when (.isMP HotSpot'target)
            ;; We only have to handle StoreLoad.
            (when-not (zero? (& barriers MemoryBarriers/STORE_LOAD))
                ;; All usable chips support "locked" instructions which suffice as barriers,
                ;; and are much faster than the alternative of using cpuid instruction.
                ;; We use here a locked add [rsp],0. This is conveniently otherwise a no-op except
                ;; for blowing flags. Any change to this code may need to revisit other places
                ;; in the code where this idiom is used, in particular the orderAccess code.
                (Assembler''lock-1 this)
                (Assembler''addl-3 this, (AMD64Address'new-2 AMD64/rsp, 0), 0) ;; Assert the lock# signal here.
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''patchJumpTarget-3 [#_"Assembler" this, #_"int" branch, #_"int" jumpTarget]
        (let [
            #_"int" op (Assembler''getByte-2 this, branch)
        ]
            (cond
                (= op 0x00)
                    (let [
                        #_"int" offsetToJumpTableBase (Assembler''getShort-2 this, (inc branch))
                        #_"int" jumpTableBase (- branch offsetToJumpTableBase)
                        #_"int" imm32 (- jumpTarget jumpTableBase)
                    ]
                        (Assembler''emitInt-3 this, imm32, branch)
                    )
                (or (= op 0xeb) (= (& op 0xf0) 0x70))
                    ;; short offset operators (jmp and jcc)
                    (let [
                        #_"int" imm8 (- jumpTarget (+ branch 2))
                    ]
                        ;; Since a wrongly patched short branch can potentially lead to working but really bad
                        ;; behaving code we should always fail with an exception instead of having an assert.
                        (when-not (NumUtil'isByte-1 imm8)
                            (throw! (str "branch displacement out of range: " imm8))
                        )
                        (Assembler''emitByte-3 this, imm8, (inc branch))
                    )
                :else
                    (let [
                        #_"int" off (if (= op 0x0f) 2 1)
                        #_"int" imm32 (- jumpTarget (+ branch 4 off))
                    ]
                        (Assembler''emitInt-3 this, imm32, (+ branch off))
                    )
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''nullCheck-2 [#_"Assembler" this, #_"AMD64Address" address]
        (Assembler''testl-3 this, AMD64/rax, address)
        nil
    )

    (§ method! #_"void" Assembler''align-2 [#_"Assembler" this, #_"int" modulus]
        (when-not (zero? (% (Assembler''position-1 this) modulus))
            (Assembler''nop-2 this, (- modulus (% (Assembler''position-1 this) modulus)))
        )
        nil
    )

    ;;;
     ; Emits a direct call instruction. Note that the actual call target is not specified, because
     ; all calls need patching anyway. Therefore, 0 is emitted as the call target, and the user is
     ; responsible to add the call address to the appropriate patching tables.
     ;;
    (§ method! #_"void" Assembler''call-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0xe8)
        (Assembler''emitInt-2 this, 0)
        nil
    )

    (§ method! #_"void" Assembler''call-2 [#_"Assembler" this, #_"Register" src]
        (let [
            #_"int" encode (Assembler''prefixAndEncode-2 this, (.encoding src))
        ]
            (Assembler''emitByte-2 this, 0xff)
            (Assembler''emitByte-2 this, (| 0xd0 encode))
        )
        nil
    )

    ;;;
     ; Returns a target specific placeholder address that can be used for code patching.
     ;
     ; @param pos The start of the instruction, i.e. the value that is used as the key
     ;            for looking up placeholder patching information.
     ;;
    (§ defn #_"AMD64Address" Assembler'createPlaceholder-1 [#_"int" pos]
        (AMD64Address'new-5 AMD64/rip, Register/None, Scale'Times1, 0, pos)
    )

    (§ method- #_"void" Assembler''prefetchPrefix-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefix-2 this, src)
        (Assembler''emitByte-2 this, 0x0f)
        nil
    )

    (§ method! #_"void" Assembler''prefetchnta-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefetchPrefix-2 this, src)
        (Assembler''emitByte-2 this, 0x18)
        (Assembler''emitOperandHelper-4 this, 0, src, 0)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''prefetchr-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefetchPrefix-2 this, src)
        (Assembler''emitByte-2 this, 0x0d)
        (Assembler''emitOperandHelper-4 this, 0, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''prefetcht0-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefetchPrefix-2 this, src)
        (Assembler''emitByte-2 this, 0x18)
        (Assembler''emitOperandHelper-4 this, 1, src, 0)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''prefetcht1-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefetchPrefix-2 this, src)
        (Assembler''emitByte-2 this, 0x18)
        (Assembler''emitOperandHelper-4 this, 2, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''prefetcht2-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefix-2 this, src)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x18)
        (Assembler''emitOperandHelper-4 this, 3, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''prefetchw-2 [#_"Assembler" this, #_"AMD64Address" src]
        (Assembler''prefix-2 this, src)
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x0d)
        (Assembler''emitOperandHelper-4 this, 1, src, 0)
        nil
    )

    (§ method! #_"void" Assembler''rdtsc-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x31)
        nil
    )

    ;;;
     ; Emits an instruction which is considered to be illegal. This is used if we deliberately want
     ; to crash the program (debugging etc.).
     ;;
    #_unused
    (§ method! #_"void" Assembler''illegal-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0x0b)
        nil
    )

    (§ method! #_"void" Assembler''lfence-1 [#_"Assembler" this]
        (Assembler''emitByte-2 this, 0x0f)
        (Assembler''emitByte-2 this, 0xae)
        (Assembler''emitByte-2 this, 0xe8)
        nil
    )

    ;; masm

    (§ method! #_"void" Assembler''decrementq-3 [#_"Assembler" this, #_"Register" reg, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''subq-3 this, reg, value)
            (neg? value)                          (Assembler''incrementq-3 this, reg, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''decq-2 this, reg)
            :else                                 (Assembler''subq-3 this, reg, value)
        )
        nil
    )

    (§ method! #_"void" Assembler''decrementq-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''subq-3 this, dst, value)
            (neg? value)                          (Assembler''incrementq-3 this, dst, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''decq-2 this, dst)
            :else                                 (Assembler''subq-3 this, dst, value)
        )
        nil
    )

    (§ method! #_"void" Assembler''incrementq-3 [#_"Assembler" this, #_"Register" reg, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''addq-3 this, reg, value)
            (neg? value)                          (Assembler''decrementq-3 this, reg, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''incq-2 this, reg)
            :else                                 (Assembler''addq-3 this, reg, value)
        )
        nil
    )

    (§ method! #_"void" Assembler''incrementq-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''addq-3 this, dst, value)
            (neg? value)                          (Assembler''decrementq-3 this, dst, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''incq-2 this, dst)
            :else                                 (Assembler''addq-3 this, dst, value)
        )
        nil
    )

    (§ method! #_"void" Assembler''movptr-3 [#_"Assembler" this, #_"Register" dst, #_"AMD64Address" src]
        (Assembler''movq-3 this, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''movptr-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"Register" src]
        (Assembler''movq-3 this, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''movptr-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" src]
        (Assembler''movslq-3 this, dst, src)
        nil
    )

    (§ method! #_"void" Assembler''cmpptr-3 [#_"Assembler" this, #_"Register" src1, #_"Register" src2]
        (Assembler''cmpq-3 this, src1, src2)
        nil
    )

    (§ method! #_"void" Assembler''cmpptr-3 [#_"Assembler" this, #_"Register" src1, #_"AMD64Address" src2]
        (Assembler''cmpq-3 this, src1, src2)
        nil
    )

    #_unused
    (§ method! #_"void" Assembler''decrementl-2 [#_"Assembler" this, #_"Register" reg]
        (Assembler''decrementl-3 this, reg, 1)
        nil
    )

    (§ method! #_"void" Assembler''decrementl-3 [#_"Assembler" this, #_"Register" reg, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''subl-3 this, reg, value)
            (neg? value)                          (Assembler''incrementl-3 this, reg, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''decl-2 this, reg)
            :else                                 (Assembler''subl-3 this, reg, value)
        )
        nil
    )

    (§ method! #_"void" Assembler''decrementl-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''subl-3 this, dst, value)
            (neg? value)                          (Assembler''incrementl-3 this, dst, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''decl-2 this, dst)
            :else                                 (Assembler''subl-3 this, dst, value)
        )
        nil
    )

    (§ method! #_"void" Assembler''incrementl-3 [#_"Assembler" this, #_"Register" reg, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''addl-3 this, reg, value)
            (neg? value)                          (Assembler''decrementl-3 this, reg, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''incl-2 this, reg)
            :else                                 (Assembler''addl-3 this, reg, value)
        )
        nil
    )

    (§ method! #_"void" Assembler''incrementl-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"int" value]
        (cond
            (= value Integer/MIN_VALUE)           (Assembler''addl-3 this, dst, value)
            (neg? value)                          (Assembler''decrementl-3 this, dst, (- value))
            (zero? value)                         nil
            (and (= value 1) Assembler'UseIncDec) (Assembler''incl-2 this, dst)
            :else                                 (Assembler''addl-3 this, dst, value)
        )
        nil
    )

    ;;;
     ; Non-atomic write of a 64-bit constant to memory.
     ; Do not use if the address might be a volatile field!
     ;;
    (§ method! #_"void" Assembler''movlong-3 [#_"Assembler" this, #_"AMD64Address" dst, #_"long" src]
        (if (NumUtil'isInt-1 src)
            (AMD64MIOp''emit-5 AMD64MIOp'MOV, this, OperandSize'QWORD, dst, (int src))
            (let [
                #_"AMD64Address" high (AMD64Address'new-4 (:base dst), (:index dst), (:scale dst), (+ (:displacement dst) 4))
            ]
                (Assembler''movl-3 this, dst, (int (& src 0xffffffff)))
                (Assembler''movl-3 this, high, (int (>> src 32)))
            )
        )
        nil
    )

    (§ method! #_"void" Assembler''setl-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst]
        (Assembler''setb-3 this, cc, dst)
        (Assembler''movzbl-3 this, dst, dst)
        nil
    )

    (§ method! #_"void" Assembler''setq-3 [#_"Assembler" this, #_"ConditionFlag" cc, #_"Register" dst]
        (Assembler''setb-3 this, cc, dst)
        (Assembler''movzbq-3 this, dst, dst)
        nil
    )

    ;; crb

    (§ method! #_"Mark" Assembler''recordMark-2 [#_"Assembler" this, #_"Object" id]
        (CompilationResult''recordMark-3 (:compilationResult this), (Assembler''position-1 this), id)
    )

    (§ method! #_"void" Assembler''recordInlineDataInCode-2 [#_"Assembler" this, #_"Constant" data]
        (when (instance? VMConstant data)
            (CompilationResult''recordDataPatch-3 (:compilationResult this), (Assembler''position-1 this), (ConstantReference. data))
        )
        nil
    )

    (§ method! #_"AbstractAddress" Assembler''recordDataSectionReference-2 [#_"Assembler" this, #_"Data" data]
        (let [
            #_"DataSectionReference" reference (DataSection''insertData-2 (:dataSection (:compilationResult this)), data)
            #_"int" pos (Assembler''position-1 this)
        ]
            (CompilationResult''recordDataPatch-3 (:compilationResult this), pos, reference)
            (Assembler'createPlaceholder-1 pos)
        )
    )

    (§ method! #_"AbstractAddress" Assembler''recordDataReferenceInCode-2 [#_"Assembler" this, #_"DataPointerConstant" constant]
        (Assembler''recordDataReferenceInCode-3 this, constant, (:alignment constant))
    )

    (§ method- #_"Data" Assembler''createDataItem-2 [#_"Assembler" this, #_"Constant" constant]
        (or (get (:dataCache this) constant)
            (let [
                #_"Data" data (DataBuilder'createDataItem-1 constant)
            ]
                (#_"EconomicMap" .put (:dataCache this), constant, data)
                data
            )
        )
    )

    (§ method! #_"AbstractAddress" Assembler''recordDataReferenceInCode-3 [#_"Assembler" this, #_"Constant" constant, #_"int" alignment]
        (let [
            #_"Data" data (Assembler''createDataItem-2 this, constant)
        ]
            (§ ass! data (Data''updateAlignment-2 data, alignment))
            (Assembler''recordDataSectionReference-2 this, data)
        )
    )

    (§ method! #_"AbstractAddress" Assembler''recordDataReferenceInCode-3 [#_"Assembler" this, #_"Data" data, #_"int" alignment]
        (§ ass! data (Data''updateAlignment-2 data, alignment))
        (Assembler''recordDataSectionReference-2 this, data)
    )

    (§ method! #_"AbstractAddress" Assembler''recordDataReferenceInCode-3 [#_"Assembler" this, #_"byte[]" data, #_"int" alignment]
        (Assembler''recordDataSectionReference-2 this, (RawData'new-2 data, alignment))
    )

    ;;;
     ; Returns the integer value of any constant that can be represented by a 32-bit integer value,
     ; including long constants that fit into the 32-bit range.
     ;;
    #_unused
    (§ method! #_"int" Assembler''asIntConst-2 [#_"Assembler" this, #_"Value" value]
        (let [
            #_"long" c (#_"JavaConstant" .asLong (:constant value))
        ]
            (when (NumUtil'isInt-1 c) => (throw! "should not reach here")
                (int c)
            )
        )
    )

    ;;;
     ; Returns the long value of any constant that can be represented by a 64-bit long value.
     ;;
    #_unused
    (§ method! #_"long" Assembler''asLongConst-2 [#_"Assembler" this, #_"Value" value]
        (#_"JavaConstant" .asLong (:constant value))
    )

    ;;;
     ; Returns the address of a long constant that is embedded as a data reference into the code.
     ;;
    (§ method! #_"AbstractAddress" Assembler''asLongConstRef-2 [#_"Assembler" this, #_"JavaConstant" value]
        (Assembler''recordDataReferenceInCode-3 this, value, 8)
    )

    ;;;
     ; Returns the address of an object constant that is embedded as a data reference into the code.
     ;;
    #_unused
    (§ method! #_"AbstractAddress" Assembler''asObjectConstRef-2 [#_"Assembler" this, #_"JavaConstant" value]
        (Assembler''recordDataReferenceInCode-3 this, value, 8)
    )

    (§ method! #_"AbstractAddress" Assembler''asAddress-2 [#_"Assembler" this, #_"Value" value]
        (AMD64Address'new-2 (#_"RegisterConfig" .getFrameRegister HotSpot'registerConfig), (FrameMap''offsetForStackSlot-2 (:frameMap this), value))
    )

    ;;;
     ; Determines if a given edge from the block currently being emitted goes to its lexical successor.
     ;;
    (§ method! #_"boolean" Assembler''isSuccessorEdge-2 [#_"Assembler" this, #_"LabelRef" edge]
        (= (LIR'getNextBlock-2 (:codeEmittingOrder (:lir this)), (:currentBlockIndex this)) (LabelRef''getTargetBlock-1 edge))
    )

    ;;;
     ; Emits code for {@code lir} in its {@linkplain LIR#codeEmittingOrder() code emitting order}.
     ;;
    (§ method! #_"Assembler" Assembler''assemble-1 [#_"Assembler" this]
        (Assembler''align-2 this, HotSpot'codeEntryAlignment)
        (Assembler''recordMark-2 this, HotSpot'verifiedEntryMark)

        (FrameContext''enter-2 (:frameContext this), this)
        (let [
            this
                (loop-when [this this #_"ISeq" s (seq (:codeEmittingOrder (:lir this)))] (some? s) => this
                    (let [
                        #_"Block" block (first s)
                    ]
                        (when (some? block)
                            (doseq [#_"LIRInstruction" op (LIR''getLIRforBlock-2 (:lir this), block)]
                                (LIRInstruction''emitCode-2 op, this)
                            )
                        )
                        (recur (update this :currentBlockIndex inc) (next s))
                    )
                )
        ]
            (when-not (:isStub (:frameContext this))
                (Assembler''recordMark-2 this, HotSpot'deoptHandlerEntryMark)
                (AMD64Call'directCall-4 this, (ForeignCalls''lookupForeignCall-2 HotSpot'foreignCalls, ForeignCallDescriptor'DEOPTIMIZATION_HANDLER), nil, false)
            )
            this
        )
    )

    (§ method! #_"CompilationResult" Assembler''finish-1 [#_"Assembler" this]
        (§ ass! (:compilationResult this) (CompilationResult''setTargetCode-3 (:compilationResult this), (Assembler''close-2 this, false), (Assembler''position-1 this)))
        (CompilationResult''close-1 (:compilationResult this))
    )
)

;;;
 ; The x86 condition codes used for conditional jumps/moves.
 ;
 ; @anno Assembler.ConditionFlag
 ;;
(final-ns ConditionFlag
    (§ final #_"int" :value 0)
    (§ final #_"String" :operator nil)

    (§ defn- #_"ConditionFlag" ConditionFlag'new-2 [#_"int" value, #_"String" operator]
        (let [
            #_"ConditionFlag" this (Object.)
            this (assoc this :value value)
            this (assoc this :operator operator)
        ]
            this
        )
    )

    (§ def #_"ConditionFlag" ConditionFlag'Zero         (ConditionFlag'new-2 0x4, "|zero|"))
    (§ def #_"ConditionFlag" ConditionFlag'NotZero      (ConditionFlag'new-2 0x5, "|nzero|"))
    (§ def #_"ConditionFlag" ConditionFlag'Equal        (ConditionFlag'new-2 0x4, "="))
    (§ def #_"ConditionFlag" ConditionFlag'NotEqual     (ConditionFlag'new-2 0x5, "!="))
    (§ def #_"ConditionFlag" ConditionFlag'Less         (ConditionFlag'new-2 0xc, "<"))
    (§ def #_"ConditionFlag" ConditionFlag'LessEqual    (ConditionFlag'new-2 0xe, "<="))
    (§ def #_"ConditionFlag" ConditionFlag'Greater      (ConditionFlag'new-2 0xf, ">"))
    (§ def #_"ConditionFlag" ConditionFlag'GreaterEqual (ConditionFlag'new-2 0xd, ">="))
    (§ def #_"ConditionFlag" ConditionFlag'Below        (ConditionFlag'new-2 0x2, "|<|"))
    (§ def #_"ConditionFlag" ConditionFlag'BelowEqual   (ConditionFlag'new-2 0x6, "|<=|"))
    (§ def #_"ConditionFlag" ConditionFlag'Above        (ConditionFlag'new-2 0x7, "|>|"))
    (§ def #_"ConditionFlag" ConditionFlag'AboveEqual   (ConditionFlag'new-2 0x3, "|>=|"))
    (§ def #_"ConditionFlag" ConditionFlag'Overflow     (ConditionFlag'new-2 0x0, "|of|"))
    (§ def #_"ConditionFlag" ConditionFlag'NoOverflow   (ConditionFlag'new-2 0x1, "|nof|"))
    (§ def #_"ConditionFlag" ConditionFlag'CarrySet     (ConditionFlag'new-2 0x2, "|carry|"))
    (§ def #_"ConditionFlag" ConditionFlag'CarryClear   (ConditionFlag'new-2 0x3, "|ncarry|"))
    (§ def #_"ConditionFlag" ConditionFlag'Negative     (ConditionFlag'new-2 0x8, "|neg|"))
    (§ def #_"ConditionFlag" ConditionFlag'Positive     (ConditionFlag'new-2 0x9, "|pos|"))
    (§ def #_"ConditionFlag" ConditionFlag'Parity       (ConditionFlag'new-2 0xa, "|par|"))
    (§ def #_"ConditionFlag" ConditionFlag'NoParity     (ConditionFlag'new-2 0xb, "|npar|"))

    (§ method! #_"ConditionFlag" ConditionFlag''negate-1 [#_"ConditionFlag" this]
        (condp = this
            ConditionFlag'Zero         ConditionFlag'NotZero
            ConditionFlag'NotZero      ConditionFlag'Zero
            ConditionFlag'Equal        ConditionFlag'NotEqual
            ConditionFlag'NotEqual     ConditionFlag'Equal
            ConditionFlag'Less         ConditionFlag'GreaterEqual
            ConditionFlag'LessEqual    ConditionFlag'Greater
            ConditionFlag'Greater      ConditionFlag'LessEqual
            ConditionFlag'GreaterEqual ConditionFlag'Less
            ConditionFlag'Below        ConditionFlag'AboveEqual
            ConditionFlag'BelowEqual   ConditionFlag'Above
            ConditionFlag'Above        ConditionFlag'BelowEqual
            ConditionFlag'AboveEqual   ConditionFlag'Below
            ConditionFlag'Overflow     ConditionFlag'NoOverflow
            ConditionFlag'NoOverflow   ConditionFlag'Overflow
            ConditionFlag'CarrySet     ConditionFlag'CarryClear
            ConditionFlag'CarryClear   ConditionFlag'CarrySet
            ConditionFlag'Negative     ConditionFlag'Positive
            ConditionFlag'Positive     ConditionFlag'Negative
            ConditionFlag'Parity       ConditionFlag'NoParity
            ConditionFlag'NoParity     ConditionFlag'Parity
        )
    )
)

;;;
 ; Constants for X86 prefix bytes.
 ;
 ; @anno Assembler.Prefix
 ;;
(value-ns Prefix
    (def #_"int" Prefix'REX        0x40)
    (def #_"int" Prefix'REXB       0x41)
    (def #_"int" Prefix'REXX       0x42)
    (def #_"int" Prefix'REXXB      0x43)
    (def #_"int" Prefix'REXR       0x44)
    (def #_"int" Prefix'REXRB      0x45)
    (def #_"int" Prefix'REXRX      0x46)
    (def #_"int" Prefix'REXRXB     0x47)
    (def #_"int" Prefix'REXW       0x48)
    (def #_"int" Prefix'REXWB      0x49)
    (def #_"int" Prefix'REXWX      0x4a)
    (def #_"int" Prefix'REXWXB     0x4b)
    (def #_"int" Prefix'REXWR      0x4c)
    (def #_"int" Prefix'REXWRB     0x4d)
    (def #_"int" Prefix'REXWRX     0x4e)
    (def #_"int" Prefix'REXWRXB    0x4f)
)

;;;
 ; The x86 operand sizes.
 ;
 ; @anno Assembler.OperandSize
 ;;
(final-ns OperandSize
    (§ enum
        (§ reify #_"OperandSize" (ß enum OperandSize'BYTE 1, AMD64Kind/BYTE)
            (§ override! #_"void" OperandSize''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm]
                (Assembler''emitByte-2 asm, imm)
                nil
            )

            #_unused
            (§ override! #_"int" OperandSize''immediateSize-1 [#_"OperandSize" this]
                1
            )
        )
    )

    (§ enum
        (§ reify #_"OperandSize" (ß enum OperandSize'WORD 2, AMD64Kind/WORD, 0x66)
            (§ override! #_"void" OperandSize''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm]
                (Assembler''emitShort-2 asm, imm)
                nil
            )

            #_unused
            (§ override! #_"int" OperandSize''immediateSize-1 [#_"OperandSize" this]
                2
            )
        )
    )

    (§ enum
        (§ reify #_"OperandSize" (ß enum OperandSize'DWORD 4, AMD64Kind/DWORD)
            (§ override! #_"void" OperandSize''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm]
                (Assembler''emitInt-2 asm, imm)
                nil
            )

            #_unused
            (§ override! #_"int" OperandSize''immediateSize-1 [#_"OperandSize" this]
                4
            )
        )
    )

    (§ enum
        (§ reify #_"OperandSize" (ß enum OperandSize'QWORD 8, AMD64Kind/QWORD)
            (§ override! #_"void" OperandSize''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm]
                (Assembler''emitInt-2 asm, imm)
                nil
            )

            #_unused
            (§ override! #_"int" OperandSize''immediateSize-1 [#_"OperandSize" this]
                4
            )
        )
    )

    (§ final #_"int" :sizePrefix 0)
    (§ final #_"int" :bytes 0)
    (§ final #_"AMD64Kind" :kind nil)

    #_unused
    (§ defn #_"OperandSize" OperandSize'new-2 [#_"int" bytes, #_"AMD64Kind" kind]
        (OperandSize'new-3 bytes, kind, 0)
    )

    (§ defn #_"OperandSize" OperandSize'new-3 [#_"int" bytes, #_"AMD64Kind" kind, #_"int" sizePrefix]
        (let [
            #_"OperandSize" this (Object.)
            this (assoc this :sizePrefix sizePrefix)
            this (assoc this :bytes bytes)
            this (assoc this :kind kind)
        ]
            this
        )
    )

    #_unused
    (§ defn #_"OperandSize" OperandSize'get-1 [#_"PlatformKind" kind]
        (loop-when [#_"ISeq" s (seq (OperandSize'values-0))] (some? s) => (throw! (str "unexpected kind: " kind))
            (let [
                #_"OperandSize" operandSize (first s)
            ]
                (if (= (:kind operandSize) kind)
                    operandSize
                    (recur (next s))
                )
            )
        )
    )

    ;;;
     ; Emit an immediate of this size. Note that immediate #QWORD operands are encoded
     ; as sign-extended 32-bit values.
     ;;
    (§ method! #_"void" OperandSize''emitImmediate-3 [#_"OperandSize" this, #_"Assembler" asm, #_"int" imm]
        (throw! "unsupported operation")
    )

    #_unused
    (§ method! #_"int" OperandSize''immediateSize-1 [#_"OperandSize" this]
        (throw! "unsupported operation")
    )
)

;;;
 ; Operand size and register type constraints.
 ;
 ; @anno Assembler.OpAssertion
 ;;
(final-ns OpAssertion
    (§ enum (OpAssertion'ByteAssertion AMD64/CPU, AMD64/CPU, OperandSize'BYTE))
    (§ enum (OpAssertion'ByteOrLargerAssertion AMD64/CPU, AMD64/CPU, OperandSize'BYTE, OperandSize'WORD, OperandSize'DWORD, OperandSize'QWORD))
    (§ enum (OpAssertion'WordOrLargerAssertion AMD64/CPU, AMD64/CPU, OperandSize'WORD, OperandSize'DWORD, OperandSize'QWORD))
    (§ enum (OpAssertion'DwordOrLargerAssertion AMD64/CPU, AMD64/CPU, OperandSize'DWORD, OperandSize'QWORD))
    (§ enum (OpAssertion'WordOrDwordAssertion AMD64/CPU, AMD64/CPU, OperandSize'WORD, OperandSize'QWORD))
    (§ enum (OpAssertion'QwordAssertion AMD64/CPU, AMD64/CPU, OperandSize'QWORD))

    (§ final #_"Register$RegisterCategory" :resultCategory nil)
    (§ final #_"Register$RegisterCategory" :inputCategory nil)
    (§ final #_"OperandSize[]" :allowedSizes nil)

    (§ defn #_"OpAssertion" OpAssertion'new-3* [#_"Register$RegisterCategory" resultCategory, #_"Register$RegisterCategory" inputCategory, #_"OperandSize..." allowedSizes]
        (let [
            #_"OpAssertion" this (Object.)
            this (assoc this :resultCategory resultCategory)
            this (assoc this :inputCategory inputCategory)
            this (assoc this :allowedSizes allowedSizes)
        ]
            this
        )
    )
)

;;;
 ; Base class for AMD64 opcodes.
 ;
 ; @anno Assembler.AMD64Op
 ;;
(class-ns AMD64Op
    (def #_"int" AMD64Op'P_0F 0x0f)
    (def #_"int" AMD64Op'P_0F38 0x380f)
    (def #_"int" AMD64Op'P_0F3A 0x3a0f)

    (§ final #_"String" :opcode nil)

    (§ final #_"int" :prefix1 0)
    (§ final #_"int" :prefix2 0)
    (§ final #_"int" :op 0)

    (§ final #_"boolean" :dstIsByte false)
    (§ final #_"boolean" :srcIsByte false)

    (§ final #_"OpAssertion" :assertion nil)
    (§ final #_"AMD64$CPUFeature" :feature nil)

    (§ defn #_"AMD64Op" AMD64Op'new-6 [#_"String" opcode, #_"int" prefix1, #_"int" prefix2, #_"int" op, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (AMD64Op'new-8 opcode, prefix1, prefix2, op, (= assertion OpAssertion'ByteAssertion), (= assertion OpAssertion'ByteAssertion), assertion, feature)
    )

    (§ defn #_"AMD64Op" AMD64Op'new-8 [#_"String" opcode, #_"int" prefix1, #_"int" prefix2, #_"int" op, #_"boolean" dstIsByte, #_"boolean" srcIsByte, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (let [
            #_"AMD64Op" this (Object.)
            this (assoc this :opcode opcode)
            this (assoc this :prefix1 prefix1)
            this (assoc this :prefix2 prefix2)
            this (assoc this :op op)
            this (assoc this :dstIsByte dstIsByte)
            this (assoc this :srcIsByte srcIsByte)
            this (assoc this :assertion assertion)
            this (assoc this :feature feature)
        ]
            this
        )
    )

    (§ method! #_"void" AMD64Op''emitOpcode-6 [#_"AMD64Op" this, #_"Assembler" asm, #_"OperandSize" size, #_"int" rxb, #_"int" dstEnc, #_"int" srcEnc]
        (when-not (zero? (:prefix1 this))
            (Assembler''emitByte-2 asm, (:prefix1 this))
        )
        (when-not (zero? (:sizePrefix size))
            (Assembler''emitByte-2 asm, (:sizePrefix size))
        )
        (let [
            #_"int" rexPrefix (| rxb (if (= size OperandSize'QWORD) 0x48 0x40))
        ]
            (when (or (not= rexPrefix 0x40) (and (:dstIsByte this) (<= 4 dstEnc)) (and (:srcIsByte this) (<= 4 srcEnc)))
                (Assembler''emitByte-2 asm, rexPrefix)
            )
            (cond
                (< 0xff (:prefix2 this)) (Assembler''emitShort-2 asm, (:prefix2 this))
                (< 0x00 (:prefix2 this)) (Assembler''emitByte-2 asm, (:prefix2 this))
            )
            (Assembler''emitByte-2 asm, (:op this))
        )
        nil
    )
)

;;;
 ; Base class for AMD64 opcodes with immediate operands.
 ;
 ; @anno Assembler.AMD64ImmOp
 ;;
(class-ns AMD64ImmOp (§ extends AMD64Op)
    (§ final #_"boolean" :immIsByte false)

    (§ defn #_"AMD64ImmOp" AMD64ImmOp'new-5 [#_"String" opcode, #_"boolean" immIsByte, #_"int" prefix, #_"int" op, #_"OpAssertion" assertion]
        (let [
            #_"AMD64ImmOp" this (AMD64Op'new-6 opcode, 0, prefix, op, assertion, nil)
            this (assoc this :immIsByte immIsByte)
        ]
            this
        )
    )

    (§ method! #_"void" AMD64ImmOp''emitImmediate-4 [#_"AMD64ImmOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"int" imm]
        (if (:immIsByte this)
            (Assembler''emitByte-2 asm, imm)
            (OperandSize''emitImmediate-3 size, asm, imm)
        )
        nil
    )

    (§ method! #_"int" AMD64ImmOp''immediateSize-2 [#_"AMD64ImmOp" this, #_"OperandSize" size]
        (if (:immIsByte this) 1 (:bytes size))
    )
)

;;;
 ; Opcode with operand order of either RM or MR for 2 address forms.
 ;
 ; @anno Assembler.AMD64RROp
 ;;
(class-ns AMD64RROp (§ extends AMD64Op)
    (§ defn #_"AMD64RROp" AMD64RROp'new-6 [#_"String" opcode, #_"int" prefix1, #_"int" prefix2, #_"int" op, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (AMD64Op'new-6 opcode, prefix1, prefix2, op, assertion, feature)
    )

    (§ defn #_"AMD64RROp" AMD64RROp'new-8 [#_"String" opcode, #_"int" prefix1, #_"int" prefix2, #_"int" op, #_"boolean" dstIsByte, #_"boolean" srcIsByte, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (AMD64Op'new-8 opcode, prefix1, prefix2, op, dstIsByte, srcIsByte, assertion, feature)
    )

    #_unused
    (§ abstract #_"void" AMD64RROp''emit-5 [#_"AMD64RROp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"Register" src])
)

;;;
 ; Opcode with operand order of either RM or MR for 3 address forms.
 ;
 ; @anno Assembler.AMD64RRROp
 ;;
(class-ns AMD64RRROp (§ extends AMD64Op)
    #_unused
    (§ defn #_"AMD64RRROp" AMD64RRROp'new-6 [#_"String" opcode, #_"int" prefix1, #_"int" prefix2, #_"int" op, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (AMD64Op'new-6 opcode, prefix1, prefix2, op, assertion, feature)
    )

    #_unused
    (§ defn #_"AMD64RRROp" AMD64RRROp'new-8 [#_"String" opcode, #_"int" prefix1, #_"int" prefix2, #_"int" op, #_"boolean" dstIsByte, #_"boolean" srcIsByte, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (AMD64Op'new-8 opcode, prefix1, prefix2, op, dstIsByte, srcIsByte, assertion, feature)
    )

    #_unused
    (§ abstract #_"void" AMD64RRROp''emit-6 [#_"AMD64RRROp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"Register" nds, #_"Register" src])
)

;;;
 ; Opcode with operand order of RM.
 ;
 ; @anno Assembler.AMD64RMOp
 ;;
(final-ns AMD64RMOp (§ extends AMD64RROp)
    (§ def #_"AMD64RMOp" AMD64RMOp'IMUL   (AMD64RMOp'new-4 "IMUL",         AMD64Op'P_0F, 0xaf, OpAssertion'ByteOrLargerAssertion))
    (§ def #_"AMD64RMOp" AMD64RMOp'BSF    (AMD64RMOp'new-3 "BSF",          AMD64Op'P_0F, 0xbc))
    (§ def #_"AMD64RMOp" AMD64RMOp'BSR    (AMD64RMOp'new-3 "BSR",          AMD64Op'P_0F, 0xbd))
    (§ def #_"AMD64RMOp" AMD64RMOp'POPCNT (AMD64RMOp'new-5 "POPCNT", 0xf3, AMD64Op'P_0F, 0xb8, CPUFeature'POPCNT))
    (§ def #_"AMD64RMOp" AMD64RMOp'TZCNT  (AMD64RMOp'new-5 "TZCNT",  0xf3, AMD64Op'P_0F, 0xbc, CPUFeature'BMI1))
    (§ def #_"AMD64RMOp" AMD64RMOp'LZCNT  (AMD64RMOp'new-5 "LZCNT",  0xf3, AMD64Op'P_0F, 0xbd, CPUFeature'LZCNT))
    (§ def #_"AMD64RMOp" AMD64RMOp'MOVZXB (AMD64RMOp'new-6 "MOVZXB",       AMD64Op'P_0F, 0xb6, false, true, OpAssertion'WordOrLargerAssertion))
    (§ def #_"AMD64RMOp" AMD64RMOp'MOVZX  (AMD64RMOp'new-4 "MOVZX",        AMD64Op'P_0F, 0xb7, OpAssertion'DwordOrLargerAssertion))
    (§ def #_"AMD64RMOp" AMD64RMOp'MOVSXB (AMD64RMOp'new-6 "MOVSXB",       AMD64Op'P_0F, 0xbe, false, true, OpAssertion'WordOrLargerAssertion))
    (§ def #_"AMD64RMOp" AMD64RMOp'MOVSX  (AMD64RMOp'new-4 "MOVSX",        AMD64Op'P_0F, 0xbf, OpAssertion'DwordOrLargerAssertion))
    (§ def #_"AMD64RMOp" AMD64RMOp'MOVSXD (AMD64RMOp'new-3 "MOVSXD",             0x63, OpAssertion'QwordAssertion))
    (§ def #_"AMD64RMOp" AMD64RMOp'MOVB   (AMD64RMOp'new-3 "MOVB",               0x8a, OpAssertion'ByteAssertion))
    (§ def #_"AMD64RMOp" AMD64RMOp'MOV    (AMD64RMOp'new-2 "MOV",                0x8b))

    ;; TEST is documented as MR operation, but it's symmetric, and using it as RM operation is more convenient.
    (§ def #_"AMD64RMOp" AMD64RMOp'TESTB  (AMD64RMOp'new-3 "TEST",               0x84, OpAssertion'ByteAssertion))
    (§ def #_"AMD64RMOp" AMD64RMOp'TEST   (AMD64RMOp'new-2 "TEST",               0x85))

    (§ defn #_"AMD64RMOp" AMD64RMOp'new-2 [#_"String" opcode, #_"int" op]
        (AMD64RMOp'new-3 opcode, 0, op)
    )

    (§ defn #_"AMD64RMOp" AMD64RMOp'new-3 [#_"String" opcode, #_"int" op, #_"OpAssertion" assertion]
        (AMD64RMOp'new-4 opcode, 0, op, assertion)
    )

    (§ defn #_"AMD64RMOp" AMD64RMOp'new-3 [#_"String" opcode, #_"int" prefix, #_"int" op]
        (AMD64RMOp'new-5 opcode, 0, prefix, op, nil)
    )

    (§ defn #_"AMD64RMOp" AMD64RMOp'new-4 [#_"String" opcode, #_"int" prefix, #_"int" op, #_"OpAssertion" assertion]
        (AMD64RMOp'new-6 opcode, 0, prefix, op, assertion, nil)
    )

    (§ defn #_"AMD64RMOp" AMD64RMOp'new-5 [#_"String" opcode, #_"int" prefix, #_"int" op, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (AMD64RMOp'new-6 opcode, 0, prefix, op, assertion, feature)
    )

    (§ defn #_"AMD64RMOp" AMD64RMOp'new-6 [#_"String" opcode, #_"int" prefix, #_"int" op, #_"boolean" dstIsByte, #_"boolean" srcIsByte, #_"OpAssertion" assertion]
        (AMD64RROp'new-8 opcode, 0, prefix, op, dstIsByte, srcIsByte, assertion, nil)
    )

    (§ defn #_"AMD64RMOp" AMD64RMOp'new-5 [#_"String" opcode, #_"int" prefix1, #_"int" prefix2, #_"int" op, #_"AMD64$CPUFeature" feature]
        (AMD64RMOp'new-6 opcode, prefix1, prefix2, op, OpAssertion'WordOrLargerAssertion, feature)
    )

    (§ defn #_"AMD64RMOp" AMD64RMOp'new-6 [#_"String" opcode, #_"int" prefix1, #_"int" prefix2, #_"int" op, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (AMD64RROp'new-6 opcode, prefix1, prefix2, op, assertion, feature)
    )

    (§ override! #_"void" AMD64RMOp''emit-5 [#_"AMD64RMOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"Register" src]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 dst, src), (.encoding dst), (.encoding src))
        (Assembler''emitModRM-3 asm, dst, src)
        nil
    )

    (§ method! #_"void" AMD64RMOp''emit-5 [#_"AMD64RMOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"AMD64Address" src]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 dst, src), (.encoding dst), 0)
        (Assembler''emitOperandHelper-4 asm, dst, src, 0)
        nil
    )
)

;;;
 ; Opcode with operand order of MR.
 ;
 ; @anno Assembler.AMD64MROp
 ;;
(final-ns AMD64MROp (§ extends AMD64RROp)
    (§ def #_"AMD64MROp" AMD64MROp'MOVB (AMD64MROp'new-3 "MOVB", 0x88, OpAssertion'ByteAssertion))
    (§ def #_"AMD64MROp" AMD64MROp'MOV  (AMD64MROp'new-2 "MOV",  0x89))

    (§ defn #_"AMD64MROp" AMD64MROp'new-2 [#_"String" opcode, #_"int" op]
        (AMD64MROp'new-3 opcode, 0, op)
    )

    (§ defn #_"AMD64MROp" AMD64MROp'new-3 [#_"String" opcode, #_"int" op, #_"OpAssertion" assertion]
        (AMD64MROp'new-4 opcode, 0, op, assertion)
    )

    (§ defn #_"AMD64MROp" AMD64MROp'new-3 [#_"String" opcode, #_"int" prefix, #_"int" op]
        (AMD64MROp'new-4 opcode, prefix, op, OpAssertion'WordOrLargerAssertion)
    )

    (§ defn #_"AMD64MROp" AMD64MROp'new-4 [#_"String" opcode, #_"int" prefix, #_"int" op, #_"OpAssertion" assertion]
        (AMD64MROp'new-5 opcode, prefix, op, assertion, nil)
    )

    (§ defn #_"AMD64MROp" AMD64MROp'new-5 [#_"String" opcode, #_"int" prefix, #_"int" op, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (AMD64MROp'new-6 opcode, 0, prefix, op, assertion, feature)
    )

    (§ defn #_"AMD64MROp" AMD64MROp'new-6 [#_"String" opcode, #_"int" prefix1, #_"int" prefix2, #_"int" op, #_"OpAssertion" assertion, #_"AMD64$CPUFeature" feature]
        (AMD64RROp'new-6 opcode, prefix1, prefix2, op, assertion, feature)
    )

    (§ override! #_"void" AMD64MROp''emit-5 [#_"AMD64MROp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"Register" src]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 src, dst), (.encoding src), (.encoding dst))
        (Assembler''emitModRM-3 asm, src, dst)
        nil
    )

    (§ method! #_"void" AMD64MROp''emit-5 [#_"AMD64MROp" this, #_"Assembler" asm, #_"OperandSize" size, #_"AMD64Address" dst, #_"Register" src]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 src, dst), (.encoding src), 0)
        (Assembler''emitOperandHelper-4 asm, src, dst, 0)
        nil
    )
)

;;;
 ; Opcodes with operand order of M.
 ;
 ; @anno Assembler.AMD64MOp
 ;;
(final-ns AMD64MOp (§ extends AMD64Op)
    (§ def #_"AMD64MOp" AMD64MOp'NOT  (AMD64MOp'new-3 "NOT",  0xf7, 2))
    (§ def #_"AMD64MOp" AMD64MOp'NEG  (AMD64MOp'new-3 "NEG",  0xf7, 3))
    (§ def #_"AMD64MOp" AMD64MOp'MUL  (AMD64MOp'new-3 "MUL",  0xf7, 4))
    (§ def #_"AMD64MOp" AMD64MOp'IMUL (AMD64MOp'new-3 "IMUL", 0xf7, 5))
    (§ def #_"AMD64MOp" AMD64MOp'DIV  (AMD64MOp'new-3 "DIV",  0xf7, 6))
    (§ def #_"AMD64MOp" AMD64MOp'IDIV (AMD64MOp'new-3 "IDIV", 0xf7, 7))
    (§ def #_"AMD64MOp" AMD64MOp'INC  (AMD64MOp'new-3 "INC",  0xff, 0))
    (§ def #_"AMD64MOp" AMD64MOp'DEC  (AMD64MOp'new-3 "DEC",  0xff, 1))
    (§ def #_"AMD64MOp" AMD64MOp'PUSH (AMD64MOp'new-3 "PUSH", 0xff, 6))
    (§ def #_"AMD64MOp" AMD64MOp'POP  (AMD64MOp'new-4 "POP",  0x8f, 0, OpAssertion'WordOrDwordAssertion))

    (§ final #_"int" :ext 0)

    (§ defn #_"AMD64MOp" AMD64MOp'new-3 [#_"String" opcode, #_"int" op, #_"int" ext]
        (AMD64MOp'new-4 opcode, 0, op, ext)
    )

    (§ defn #_"AMD64MOp" AMD64MOp'new-4 [#_"String" opcode, #_"int" prefix, #_"int" op, #_"int" ext]
        (AMD64MOp'new-5 opcode, prefix, op, ext, OpAssertion'WordOrLargerAssertion)
    )

    (§ defn #_"AMD64MOp" AMD64MOp'new-4 [#_"String" opcode, #_"int" op, #_"int" ext, #_"OpAssertion" assertion]
        (AMD64MOp'new-5 opcode, 0, op, ext, assertion)
    )

    (§ defn #_"AMD64MOp" AMD64MOp'new-5 [#_"String" opcode, #_"int" prefix, #_"int" op, #_"int" ext, #_"OpAssertion" assertion]
        (let [
            #_"AMD64MOp" this (AMD64Op'new-6 opcode, 0, prefix, op, assertion, nil)
            this (assoc this :ext ext)
        ]
            this
        )
    )

    (§ method! #_"void" AMD64MOp''emit-4 [#_"AMD64MOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 nil, dst), 0, (.encoding dst))
        (Assembler''emitModRM-3 asm, (:ext this), dst)
        nil
    )

    (§ method! #_"void" AMD64MOp''emit-4 [#_"AMD64MOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"AMD64Address" dst]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 nil, dst), 0, 0)
        (Assembler''emitOperandHelper-4 asm, (:ext this), dst, 0)
        nil
    )
)

;;;
 ; Opcodes with operand order of MI.
 ;
 ; @anno Assembler.AMD64MIOp
 ;;
(final-ns AMD64MIOp (§ extends AMD64ImmOp)
    (§ def #_"AMD64MIOp" AMD64MIOp'MOVB (AMD64MIOp'new-5 "MOVB", true,  0xc6, 0, OpAssertion'ByteAssertion))
    (§ def #_"AMD64MIOp" AMD64MIOp'MOV  (AMD64MIOp'new-4 "MOV",  false, 0xc7, 0))
    (§ def #_"AMD64MIOp" AMD64MIOp'TEST (AMD64MIOp'new-4 "TEST", false, 0xf7, 0))

    (§ final #_"int" :ext 0)

    (§ defn #_"AMD64MIOp" AMD64MIOp'new-4 [#_"String" opcode, #_"boolean" immIsByte, #_"int" op, #_"int" ext]
        (AMD64MIOp'new-5 opcode, immIsByte, op, ext, OpAssertion'WordOrLargerAssertion)
    )

    (§ defn #_"AMD64MIOp" AMD64MIOp'new-5 [#_"String" opcode, #_"boolean" immIsByte, #_"int" op, #_"int" ext, #_"OpAssertion" assertion]
        (AMD64MIOp'new-6 opcode, immIsByte, 0, op, ext, assertion)
    )

    (§ defn #_"AMD64MIOp" AMD64MIOp'new-6 [#_"String" opcode, #_"boolean" immIsByte, #_"int" prefix, #_"int" op, #_"int" ext, #_"OpAssertion" assertion]
        (let [
            #_"AMD64MIOp" this (AMD64ImmOp'new-5 opcode, immIsByte, prefix, op, assertion)
            this (assoc this :ext ext)
        ]
            this
        )
    )

    (§ method! #_"void" AMD64MIOp''emit-5 [#_"AMD64MIOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"int" imm]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 nil, dst), 0, (.encoding dst))
        (Assembler''emitModRM-3 asm, (:ext this), dst)
        (AMD64ImmOp''emitImmediate-4 this, asm, size, imm)
        nil
    )

    (§ method! #_"void" AMD64MIOp''emit-5 [#_"AMD64MIOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"AMD64Address" dst, #_"int" imm]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 nil, dst), 0, 0)
        (Assembler''emitOperandHelper-4 asm, (:ext this), dst, (AMD64ImmOp''immediateSize-2 this, size))
        (AMD64ImmOp''emitImmediate-4 this, asm, size, imm)
        nil
    )
)

;;;
 ; Opcodes with operand order of RMI.
 ;
 ; @anno Assembler.AMD64RMIOp
 ;;
(final-ns AMD64RMIOp (§ extends AMD64ImmOp)
    (§ def #_"AMD64RMIOp" AMD64RMIOp'IMUL    (AMD64RMIOp'new-3 "IMUL", false, 0x69))
    (§ def #_"AMD64RMIOp" AMD64RMIOp'IMUL_SX (AMD64RMIOp'new-3 "IMUL", true,  0x6b))

    (§ defn #_"AMD64RMIOp" AMD64RMIOp'new-3 [#_"String" opcode, #_"boolean" immIsByte, #_"int" op]
        (AMD64RMIOp'new-5 opcode, immIsByte, 0, op, OpAssertion'WordOrLargerAssertion)
    )

    (§ defn #_"AMD64RMIOp" AMD64RMIOp'new-5 [#_"String" opcode, #_"boolean" immIsByte, #_"int" prefix, #_"int" op, #_"OpAssertion" assertion]
        (AMD64ImmOp'new-5 opcode, immIsByte, prefix, op, assertion)
    )

    (§ method! #_"void" AMD64RMIOp''emit-6 [#_"AMD64RMIOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"Register" src, #_"int" imm]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 dst, src), (.encoding dst), (.encoding src))
        (Assembler''emitModRM-3 asm, dst, src)
        (AMD64ImmOp''emitImmediate-4 this, asm, size, imm)
        nil
    )

    (§ method! #_"void" AMD64RMIOp''emit-6 [#_"AMD64RMIOp" this, #_"Assembler" asm, #_"OperandSize" size, #_"Register" dst, #_"AMD64Address" src, #_"int" imm]
        (AMD64Op''emitOpcode-6 this, asm, size, (Assembler'getRXB-2 dst, src), (.encoding dst), 0)
        (Assembler''emitOperandHelper-4 asm, dst, src, (AMD64ImmOp''immediateSize-2 this, size))
        (AMD64ImmOp''emitImmediate-4 this, asm, size, imm)
        nil
    )
)

;;;
 ; Arithmetic operation with operand order of RM, MR or MI.
 ;
 ; @anno Assembler.BinaryArithmetic
 ;;
(final-ns BinaryArithmetic
    (§ final #_"AMD64MIOp" :byteImmOp nil)
    (§ final #_"AMD64MROp" :byteMrOp nil)
    (§ final #_"AMD64RMOp" :byteRmOp nil)

    (§ final #_"AMD64MIOp" :immOp nil)
    (§ final #_"AMD64MIOp" :immSxOp nil)
    (§ final #_"AMD64MROp" :mrOp nil)
    (§ final #_"AMD64RMOp" :rmOp nil)

    (§ defn- #_"BinaryArithmetic" BinaryArithmetic'new-2 [#_"String" opcode, #_"int" code]
        (let [
            #_"BinaryArithmetic" this (Object.)
            #_"int" baseOp (<< code 3)
            this (assoc this :byteImmOp (AMD64MIOp'new-6 opcode, true, 0, 0x80, code, OpAssertion'ByteAssertion))
            this (assoc this :byteMrOp (AMD64MROp'new-4 opcode, 0, baseOp, OpAssertion'ByteAssertion))
            this (assoc this :byteRmOp (AMD64RMOp'new-4 opcode, 0, (| baseOp 0x02), OpAssertion'ByteAssertion))
            this (assoc this :immOp (AMD64MIOp'new-6 opcode, false, 0, 0x81, code, OpAssertion'WordOrLargerAssertion))
            this (assoc this :immSxOp (AMD64MIOp'new-6 opcode, true, 0, 0x83, code, OpAssertion'WordOrLargerAssertion))
            this (assoc this :mrOp (AMD64MROp'new-4 opcode, 0, (| baseOp 0x01), OpAssertion'WordOrLargerAssertion))
            this (assoc this :rmOp (AMD64RMOp'new-4 opcode, 0, (| baseOp 0x03), OpAssertion'WordOrLargerAssertion))
        ]
            this
        )
    )

    (§ def #_"BinaryArithmetic" BinaryArithmetic'ADD (BinaryArithmetic'new-2 "ADD", 0))
    (§ def #_"BinaryArithmetic" BinaryArithmetic'OR  (BinaryArithmetic'new-2 "OR",  1))
    (§ def #_"BinaryArithmetic" BinaryArithmetic'ADC (BinaryArithmetic'new-2 "ADC", 2))
    (§ def #_"BinaryArithmetic" BinaryArithmetic'SBB (BinaryArithmetic'new-2 "SBB", 3))
    (§ def #_"BinaryArithmetic" BinaryArithmetic'AND (BinaryArithmetic'new-2 "AND", 4))
    (§ def #_"BinaryArithmetic" BinaryArithmetic'SUB (BinaryArithmetic'new-2 "SUB", 5))
    (§ def #_"BinaryArithmetic" BinaryArithmetic'XOR (BinaryArithmetic'new-2 "XOR", 6))
    (§ def #_"BinaryArithmetic" BinaryArithmetic'CMP (BinaryArithmetic'new-2 "CMP", 7))

    (§ method! #_"AMD64MIOp" BinaryArithmetic''getMIOpcode-3 [#_"BinaryArithmetic" this, #_"OperandSize" size, #_"boolean" sx]
        (cond
            (= size OperandSize'BYTE) (:byteImmOp this)
            sx                        (:immSxOp this)
            :else                     (:immOp this)
        )
    )

    #_unused
    (§ method! #_"AMD64MROp" BinaryArithmetic''getMROpcode-2 [#_"BinaryArithmetic" this, #_"OperandSize" size]
        (if (= size OperandSize'BYTE) (:byteMrOp this) (:mrOp this))
    )

    (§ method! #_"AMD64RMOp" BinaryArithmetic''getRMOpcode-2 [#_"BinaryArithmetic" this, #_"OperandSize" size]
        (if (= size OperandSize'BYTE) (:byteRmOp this) (:rmOp this))
    )
)

;;;
 ; Shift operation with operand order of M1, MC or MI.
 ;
 ; @anno Assembler.AMD64Shift
 ;;
(final-ns AMD64Shift
    (§ def #_"AMD64Shift" AMD64Shift'ROL (AMD64Shift'new-2 "ROL", 0))
    (§ def #_"AMD64Shift" AMD64Shift'ROR (AMD64Shift'new-2 "ROR", 1))
    (§ def #_"AMD64Shift" AMD64Shift'RCL (AMD64Shift'new-2 "RCL", 2))
    (§ def #_"AMD64Shift" AMD64Shift'RCR (AMD64Shift'new-2 "RCR", 3))
    (§ def #_"AMD64Shift" AMD64Shift'SHL (AMD64Shift'new-2 "SHL", 4))
    (§ def #_"AMD64Shift" AMD64Shift'SHR (AMD64Shift'new-2 "SHR", 5))
    (§ def #_"AMD64Shift" AMD64Shift'SAR (AMD64Shift'new-2 "SAR", 7))

    (§ final #_"AMD64MOp" :m1Op nil)
    (§ final #_"AMD64MOp" :mcOp nil)
    (§ final #_"AMD64MIOp" :miOp nil)

    (§ defn- #_"AMD64Shift" AMD64Shift'new-2 [#_"String" opcode, #_"int" code]
        (let [
            #_"AMD64Shift" this (Object.)
            this (assoc this :m1Op (AMD64MOp'new-5 opcode, 0, 0xd1, code, OpAssertion'WordOrLargerAssertion))
            this (assoc this :mcOp (AMD64MOp'new-5 opcode, 0, 0xd3, code, OpAssertion'WordOrLargerAssertion))
            this (assoc this :miOp (AMD64MIOp'new-6 opcode, true, 0, 0xc1, code, OpAssertion'WordOrLargerAssertion))
        ]
            this
        )
    )
)

;;;
 ; Code buffer management for the assembler.
 ;;
(final-ns CodeBuffer
    (def #_"int" CodeBuffer'InitialSize 232)

    (§ final #_"ByteBuffer" :data nil)

    (§ defn #_"CodeBuffer" CodeBuffer'new-1 [#_"ByteOrder" order]
        (let [
            #_"CodeBuffer" this (Object.)
            this (assoc this :data (ByteBuffer/allocate CodeBuffer'InitialSize))
        ]
            (#_"ByteBuffer" .order (:data this), order)
            this
        )
    )

    (§ method! #_"int" CodeBuffer''position-1 [#_"CodeBuffer" this]
        (#_"ByteBuffer" .position (:data this))
    )

    #_unused
    (§ method! #_"void" CodeBuffer''setPosition-2 [#_"CodeBuffer" this, #_"int" i]
        (#_"ByteBuffer" .position (:data this), i)
        nil
    )

    (§ method- #_"CodeBuffer" CodeBuffer''ensureSize-2 [#_"CodeBuffer" this, #_"int" n]
        (when (<= (#_"ByteBuffer" .limit (:data this)) n) => this
            (let [
                #_"ByteBuffer" data (ByteBuffer/wrap (Arrays/copyOf (#_"ByteBuffer" .array (:data this)), (* n 4)))
            ]
                (#_"ByteBuffer" .order data, (#_"ByteBuffer" .order (:data this)))
                (#_"ByteBuffer" .position data, (#_"ByteBuffer" .position (:data this)))
                (assoc this :data data)
            )
        )
    )

    #_unused
    (§ method! #_"CodeBuffer" CodeBuffer''emitBytes-4 [#_"CodeBuffer" this, #_"byte[]" a, #_"int" i, #_"int" n]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ (#_"ByteBuffer" .position (:data this)) n))
        ]
            (#_"ByteBuffer" .put (:data this), a, i, n)
            this
        )
    )

    (§ method! #_"CodeBuffer" CodeBuffer''emitByte-2 [#_"CodeBuffer" this, #_"int" b]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ (#_"ByteBuffer" .position (:data this)) 1))
        ]
            (#_"ByteBuffer" .put (:data this), (byte (& b 0xff)))
            this
        )
    )

    (§ method! #_"CodeBuffer" CodeBuffer''emitShort-2 [#_"CodeBuffer" this, #_"int" b]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ (#_"ByteBuffer" .position (:data this)) 2))
        ]
            (#_"ByteBuffer" .putShort (:data this), (short b))
            this
        )
    )

    (§ method! #_"CodeBuffer" CodeBuffer''emitInt-2 [#_"CodeBuffer" this, #_"int" b]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ (#_"ByteBuffer" .position (:data this)) 4))
        ]
            (#_"ByteBuffer" .putInt (:data this), b)
            this
        )
    )

    (§ method! #_"CodeBuffer" CodeBuffer''emitLong-2 [#_"CodeBuffer" this, #_"long" b]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ (#_"ByteBuffer" .position (:data this)) 8))
        ]
            (#_"ByteBuffer" .putLong (:data this), b)
            this
        )
    )

    #_unused
    (§ method! #_"CodeBuffer" CodeBuffer''emitBytes-3 [#_"CodeBuffer" this, #_"byte[]" a, #_"int" i]
        (let [
            #_"int" n (count a)
            this (CodeBuffer''ensureSize-2 this, (+ i n))
        ]
            ;; Write directly into the underlying array so as to not change the ByteBuffer's position.
            (System/arraycopy a, 0, (#_"ByteBuffer" .array (:data this)), i, n)
            this
        )
    )

    (§ method! #_"CodeBuffer" CodeBuffer''emitByte-3 [#_"CodeBuffer" this, #_"int" b, #_"int" i]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ i 1))
        ]
            (#_"ByteBuffer" .put (:data this), i, (byte (& b 0xff)))
            this
        )
    )

    (§ method! #_"CodeBuffer" CodeBuffer''emitShort-3 [#_"CodeBuffer" this, #_"int" b, #_"int" i]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ i 2))
        ]
            (#_"ByteBuffer" .putShort (:data this), i, (short b))
            this
        )
    )

    (§ method! #_"CodeBuffer" CodeBuffer''emitInt-3 [#_"CodeBuffer" this, #_"int" b, #_"int" i]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ i 4))
        ]
            (#_"ByteBuffer" .putInt (:data this), i, b)
            this
        )
    )

    (§ method! #_"CodeBuffer" CodeBuffer''emitLong-3 [#_"CodeBuffer" this, #_"long" b, #_"int" i]
        (let [
            this (CodeBuffer''ensureSize-2 this, (+ i 8))
        ]
            (#_"ByteBuffer" .putLong (:data this), i, b)
            this
        )
    )

    (§ method! #_"int" CodeBuffer''getByte-2 [#_"CodeBuffer" this, #_"int" i]
        (let [
            #_"int" b (#_"ByteBuffer" .get (:data this), i)
        ]
            (& b 0xff)
        )
    )

    (§ method! #_"int" CodeBuffer''getShort-2 [#_"CodeBuffer" this, #_"int" i]
        (let [
            #_"short" s (#_"ByteBuffer" .getShort (:data this), i)
        ]
            (& s 0xffff)
        )
    )

    (§ method! #_"int" CodeBuffer''getInt-2 [#_"CodeBuffer" this, #_"int" i]
        (#_"ByteBuffer" .getInt (:data this), i)
    )

    ;;;
     ; Closes this buffer. Any further operations on a closed buffer will result in a NullPointerException.
     ;
     ; @param trim? if true, then a copy of the underlying byte array up to (but not including) {@code position()} is returned
     ; @return the data in this buffer or a trimmed copy if {@code trim?} is true
     ;;
    (§ method! #_"byte[]" CodeBuffer''close-2 [#_"CodeBuffer" this, #_"boolean" trim?]
        (let [
            #_"byte[]" a (#_"ByteBuffer" .array (:data this))
            a
                (when trim? => a
                    ;; Make a copy even if a.length == data.position(),
                    ;; since the API for trim? states a copy is always made.
                    (Arrays/copyOf a, (#_"ByteBuffer" .position (:data this)))
                )
        ]
            (§ ass! this (assoc this :data nil))
            a
        )
    )
)

;;;
 ; This class represents a label within assembly code.
 ;;
(final-ns Label
    (§ mutable #_"int" :position -1)

    ;;;
     ; References to instructions that jump to this unresolved label. These instructions need to be
     ; patched when the label is bound using the #patchInstructions(Assembler) method.
     ;;
    (§ mutable #_"ArrayList<Integer>" :patchPositions nil)

    (§ defn #_"Label" Label'new-0 []
        (Object.)
    )

    ;;;
     ; Binds the label to the specified position.
     ;;
    (§ method! #_"Label" Label''bind-2 [#_"Label" this, #_"int" pos]
        (assoc this :position pos)
    )

    (§ method! #_"boolean" Label''isBound-1 [#_"Label" this]
        (<= 0 (:position this))
    )

    (§ method! #_"Label" Label''addPatchAt-2 [#_"Label" this, #_"int" pos]
        (let [
            this
                (when (nil? (:patchPositions this)) => this
                    (assoc this :patchPositions (ArrayList.))
                )
        ]
            (#_"ArrayList" .add (:patchPositions this), pos)
            this
        )
    )

    (§ method! #_"void" Label''patchInstructions-2 [#_"Label" this, #_"Assembler" asm]
        (when (some? (:patchPositions this))
            (let [
                #_"int" target (:position this)
            ]
                (dotimes [#_"int" i (count (:patchPositions this))]
                    (Assembler''patchJumpTarget-3 asm, (nth (:patchPositions this) i), target)
                )
            )
        )
        nil
    )
)

;;;
 ; Utilities for working around the absence of method annotations and parameter annotations on
 ; bridge methods where the bridged methods have method annotations or parameter annotations.
 ; Not all Java compilers copy method annotations and parameter annotations to bridge methods.
 ;;
(value-ns BridgeMethodUtils
    ;;;
     ; Gets the method bridged to by a {@linkplain ResolvedJavaMethod#isBridge() bridge} method. The
     ; value returned is the method called by {@code method} that has the same name as {@code bridge}.
     ;
     ; @param bridge a bridge method
     ; @return the method called by {@code bridge} whose name is the same as {@code bridge.getName()}
     ;;
    (§ defn- #_"ResolvedJavaMethod" BridgeMethodUtils'getBridgedMethod-1 [#_"ResolvedJavaMethod" bridge]
        (let [
            #_"Bytecode" code (ResolvedJavaMethodBytecode'new-1 bridge)
            #_"BytecodeStream" stream (BytecodeStream'new-1 (Bytecode''getCode-1 code))
        ]
            (loop-when [#_"boolean" miranda? false #_"int" opcode (BytecodeStream''currentBC-1 stream)] (not= opcode Bytecodes'END) => (throw! (str "Couldn't find method bridged by " (#_"ResolvedJavaMethod" .format bridge, "%R %H.\n(%P)")))
                (when (any = opcode Bytecodes'INVOKEVIRTUAL Bytecodes'INVOKESPECIAL Bytecodes'INVOKESTATIC Bytecodes'INVOKEINTERFACE)
                    (let [
                        #_"int" cpi (BytecodeStream''readCPI-1 stream)
                        #_"ConstantPool" cp (Bytecode''getConstantPool-1 code)
                    ]
                        (#_"ConstantPool" .loadReferencedType cp, cpi, opcode)
                        (let [
                            #_"ResolvedJavaMethod" method (#_"ConstantPool" .lookupMethod cp, cpi, opcode)
                        ]
                            (cond
                                (= (#_"ResolvedJavaMethod" .getName method) (#_"ResolvedJavaMethod" .getName bridge))
                                    (§ return method)
                                (and (= (#_"ResolvedJavaMethod" .getName method) "<init>") (= (#_"ResolvedJavaType" .getName (#_"ResolvedJavaMethod" .getDeclaringClass method)) "Ljava/lang/AbstractMethodError;"))
                                    ;; AbstractMethodError constructor called
                                    (§ ass miranda? true)
                            )
                        )
                    )
                )
                (§ ass! stream (BytecodeStream''next-1 stream))
                (recur miranda? (BytecodeStream''currentBC-1 stream))
            )
        )
    )

    ;;;
     ; A helper for ResolvedJavaMethod#getAnnotation(Class) that handles the absence of
     ; annotations on bridge methods where the bridged method has annotations.
     ;;
    (§ defn #_"<T extends Annotation> T" BridgeMethodUtils'getAnnotation-2 [#_"Class<T>" annotationClass, #_"ResolvedJavaMethod" method]
        (let [
            #_"T" a (#_"ResolvedJavaMethod" .getAnnotation method, annotationClass)
        ]
            (when (and (nil? a) (#_"ResolvedJavaMethod" .isBridge method))
                (let [
                    #_"ResolvedJavaMethod" bridged (BridgeMethodUtils'getBridgedMethod-1 method)
                ]
                    (when (some? bridged)
                        (§ ass a (#_"ResolvedJavaMethod" .getAnnotation bridged, annotationClass))
                    )
                )
            )
            a
        )
    )
)

;;;
 ; An interface for accessing the bytecode properties of a ResolvedJavaMethod that allows
 ; for different properties than those returned by ResolvedJavaMethod. Since the bytecode
 ; accessed directly from ResolvedJavaMethod may have been subject to bytecode
 ; instrumentation and VM rewriting, this indirection can be used to enable access to the original
 ; bytecode of a method (i.e. as defined in a class file).
 ;;
(§ interface Bytecode
    ;;;
     ; Gets the method this object supplies bytecode for.
     ;;
    (§ abstract #_"ResolvedJavaMethod" Bytecode''getMethod-1 [#_"Bytecode" this])

    (§ abstract #_"byte[]" Bytecode''getCode-1 [#_"Bytecode" this])

    (§ abstract #_"int" Bytecode''getCodeSize-1 [#_"Bytecode" this])

    (§ abstract #_"int" Bytecode''getMaxStackSize-1 [#_"Bytecode" this])

    (§ abstract #_"int" Bytecode''getMaxLocals-1 [#_"Bytecode" this])

    (§ abstract #_"ConstantPool" Bytecode''getConstantPool-1 [#_"Bytecode" this])
)

;;;
 ; A utility for processing Bytecodes#LOOKUPSWITCH bytecodes.
 ;;
(final-ns BytecodeLookupSwitch (§ extends BytecodeSwitch)
    (def- #_"int" BytecodeLookupSwitch'OFFSET_TO_NUMBER_PAIRS 4)
    (def- #_"int" BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_MATCH 8)
    (def- #_"int" BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_OFFSET 12)
    (def- #_"int" BytecodeLookupSwitch'PAIR_SIZE 8)

    ;;;
     ; Constructor for a BytecodeStream.
     ;
     ; @param stream the BytecodeStream containing the switch instruction
     ; @param bci the index in the stream of the switch instruction
     ;;
    (§ defn #_"BytecodeLookupSwitch" BytecodeLookupSwitch'new-2 [#_"BytecodeStream" stream, #_"int" bci]
        (BytecodeSwitch'new-2 stream, bci)
    )

    #_unused
    (§ override! #_"int" BytecodeLookupSwitch''offsetAt-2 [#_"BytecodeLookupSwitch" this, #_"int" i]
        (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_OFFSET (* BytecodeLookupSwitch'PAIR_SIZE i)))
    )

    #_unused
    (§ override! #_"int" BytecodeLookupSwitch''keyAt-2 [#_"BytecodeLookupSwitch" this, #_"int" i]
        (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_MATCH (* BytecodeLookupSwitch'PAIR_SIZE i)))
    )

    (§ override! #_"int" BytecodeLookupSwitch''numberOfCases-1 [#_"BytecodeLookupSwitch" this]
        (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeLookupSwitch'OFFSET_TO_NUMBER_PAIRS))
    )

    (§ override! #_"int" BytecodeLookupSwitch''size-1 [#_"BytecodeLookupSwitch" this]
        (- (+ (:alignedBci this) BytecodeLookupSwitch'OFFSET_TO_FIRST_PAIR_MATCH (* BytecodeLookupSwitch'PAIR_SIZE (BytecodeLookupSwitch''numberOfCases-1 this))) (:bci this))
    )
)

;;;
 ; Provides a Bytecode object for interposing on the bytecode of a
 ; ResolvedJavaMethod (i.e. potentially getting bytecode different than
 ; ResolvedJavaMethod#getCode()).
 ;;
(§ interface BytecodeProvider
    ;;;
     ; Gets a Bytecode object that supplies bytecode properties for {@code method}.
     ;;
    (§ abstract #_"Bytecode" BytecodeProvider''getBytecode-2 [#_"BytecodeProvider" this, #_"ResolvedJavaMethod" method])

    ;;;
     ; Determines if this provider supports the INVOKEDYNAMIC bytecode.
     ;;
    #_unused
    (§ abstract #_"boolean" BytecodeProvider''supportsInvokedynamic-1 [#_"BytecodeProvider" this])
)

;;;
 ; Definitions of the standard Java bytecodes defined by
 ; <a href= "http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">Java Virtual Machine Specification</a>.
 ;;
(value-ns Bytecodes
    (def #_"int" Bytecodes'NOP               0) ;; 0x00
    (def #_"int" Bytecodes'ACONST_NULL       1) ;; 0x01
    (def #_"int" Bytecodes'ICONST_M1         2) ;; 0x02
    (def #_"int" Bytecodes'ICONST_0          3) ;; 0x03
    (def #_"int" Bytecodes'ICONST_1          4) ;; 0x04
    (def #_"int" Bytecodes'ICONST_2          5) ;; 0x05
    (def #_"int" Bytecodes'ICONST_3          6) ;; 0x06
    (def #_"int" Bytecodes'ICONST_4          7) ;; 0x07
    (def #_"int" Bytecodes'ICONST_5          8) ;; 0x08
    (def #_"int" Bytecodes'LCONST_0          9) ;; 0x09
    (def #_"int" Bytecodes'LCONST_1         10) ;; 0x0a
    (def #_"int" Bytecodes'BIPUSH           16) ;; 0x10
    (def #_"int" Bytecodes'SIPUSH           17) ;; 0x11
    (def #_"int" Bytecodes'LDC              18) ;; 0x12
    (def #_"int" Bytecodes'LDC_W            19) ;; 0x13
    (def #_"int" Bytecodes'LDC2_W           20) ;; 0x14
    (def #_"int" Bytecodes'ILOAD            21) ;; 0x15
    (def #_"int" Bytecodes'LLOAD            22) ;; 0x16
    (def #_"int" Bytecodes'ALOAD            25) ;; 0x19
    (def #_"int" Bytecodes'ILOAD_0          26) ;; 0x1a
    (def #_"int" Bytecodes'ILOAD_1          27) ;; 0x1b
    (def #_"int" Bytecodes'ILOAD_2          28) ;; 0x1c
    (def #_"int" Bytecodes'ILOAD_3          29) ;; 0x1d
    (def #_"int" Bytecodes'LLOAD_0          30) ;; 0x1e
    (def #_"int" Bytecodes'LLOAD_1          31) ;; 0x1f
    (def #_"int" Bytecodes'LLOAD_2          32) ;; 0x20
    (def #_"int" Bytecodes'LLOAD_3          33) ;; 0x21
    (def #_"int" Bytecodes'ALOAD_0          42) ;; 0x2a
    (def #_"int" Bytecodes'ALOAD_1          43) ;; 0x2b
    (def #_"int" Bytecodes'ALOAD_2          44) ;; 0x2c
    (def #_"int" Bytecodes'ALOAD_3          45) ;; 0x2d
    (def #_"int" Bytecodes'IALOAD           46) ;; 0x2e
    (def #_"int" Bytecodes'LALOAD           47) ;; 0x2f
    (def #_"int" Bytecodes'AALOAD           50) ;; 0x32
    (def #_"int" Bytecodes'BALOAD           51) ;; 0x33
    (def #_"int" Bytecodes'CALOAD           52) ;; 0x34
    (def #_"int" Bytecodes'SALOAD           53) ;; 0x35
    (def #_"int" Bytecodes'ISTORE           54) ;; 0x36
    (def #_"int" Bytecodes'LSTORE           55) ;; 0x37
    (def #_"int" Bytecodes'ASTORE           58) ;; 0x3a
    (def #_"int" Bytecodes'ISTORE_0         59) ;; 0x3b
    (def #_"int" Bytecodes'ISTORE_1         60) ;; 0x3c
    (def #_"int" Bytecodes'ISTORE_2         61) ;; 0x3d
    (def #_"int" Bytecodes'ISTORE_3         62) ;; 0x3e
    (def #_"int" Bytecodes'LSTORE_0         63) ;; 0x3f
    (def #_"int" Bytecodes'LSTORE_1         64) ;; 0x40
    (def #_"int" Bytecodes'LSTORE_2         65) ;; 0x41
    (def #_"int" Bytecodes'LSTORE_3         66) ;; 0x42
    (def #_"int" Bytecodes'ASTORE_0         75) ;; 0x4b
    (def #_"int" Bytecodes'ASTORE_1         76) ;; 0x4c
    (def #_"int" Bytecodes'ASTORE_2         77) ;; 0x4d
    (def #_"int" Bytecodes'ASTORE_3         78) ;; 0x4e
    (def #_"int" Bytecodes'IASTORE          79) ;; 0x4f
    (def #_"int" Bytecodes'LASTORE          80) ;; 0x50
    (def #_"int" Bytecodes'AASTORE          83) ;; 0x53
    (def #_"int" Bytecodes'BASTORE          84) ;; 0x54
    (def #_"int" Bytecodes'CASTORE          85) ;; 0x55
    (def #_"int" Bytecodes'SASTORE          86) ;; 0x56
    (def #_"int" Bytecodes'POP              87) ;; 0x57
    (def #_"int" Bytecodes'POP2             88) ;; 0x58
    (def #_"int" Bytecodes'DUP              89) ;; 0x59
    (def #_"int" Bytecodes'DUP_X1           90) ;; 0x5a
    (def #_"int" Bytecodes'DUP_X2           91) ;; 0x5b
    (def #_"int" Bytecodes'DUP2             92) ;; 0x5c
    (def #_"int" Bytecodes'DUP2_X1          93) ;; 0x5d
    (def #_"int" Bytecodes'DUP2_X2          94) ;; 0x5e
    (def #_"int" Bytecodes'SWAP             95) ;; 0x5f
    (def #_"int" Bytecodes'IADD             96) ;; 0x60
    (def #_"int" Bytecodes'LADD             97) ;; 0x61
    (def #_"int" Bytecodes'ISUB            100) ;; 0x64
    (def #_"int" Bytecodes'LSUB            101) ;; 0x65
    (def #_"int" Bytecodes'IMUL            104) ;; 0x68
    (def #_"int" Bytecodes'LMUL            105) ;; 0x69
    (def #_"int" Bytecodes'IDIV            108) ;; 0x6c
    (def #_"int" Bytecodes'LDIV            109) ;; 0x6d
    (def #_"int" Bytecodes'IREM            112) ;; 0x70
    (def #_"int" Bytecodes'LREM            113) ;; 0x71
    (def #_"int" Bytecodes'INEG            116) ;; 0x74
    (def #_"int" Bytecodes'LNEG            117) ;; 0x75
    (def #_"int" Bytecodes'ISHL            120) ;; 0x78
    (def #_"int" Bytecodes'LSHL            121) ;; 0x79
    (def #_"int" Bytecodes'ISHR            122) ;; 0x7a
    (def #_"int" Bytecodes'LSHR            123) ;; 0x7b
    (def #_"int" Bytecodes'IUSHR           124) ;; 0x7c
    (def #_"int" Bytecodes'LUSHR           125) ;; 0x7d
    (def #_"int" Bytecodes'IAND            126) ;; 0x7e
    (def #_"int" Bytecodes'LAND            127) ;; 0x7f
    (def #_"int" Bytecodes'IOR             128) ;; 0x80
    (def #_"int" Bytecodes'LOR             129) ;; 0x81
    (def #_"int" Bytecodes'IXOR            130) ;; 0x82
    (def #_"int" Bytecodes'LXOR            131) ;; 0x83
    (def #_"int" Bytecodes'IINC            132) ;; 0x84
    (def #_"int" Bytecodes'I2L             133) ;; 0x85
    (def #_"int" Bytecodes'L2I             136) ;; 0x88
    (def #_"int" Bytecodes'I2B             145) ;; 0x91
    (def #_"int" Bytecodes'I2C             146) ;; 0x92
    (def #_"int" Bytecodes'I2S             147) ;; 0x93
    (def #_"int" Bytecodes'LCMP            148) ;; 0x94
    (def #_"int" Bytecodes'IFEQ            153) ;; 0x99
    (def #_"int" Bytecodes'IFNE            154) ;; 0x9a
    (def #_"int" Bytecodes'IFLT            155) ;; 0x9b
    (def #_"int" Bytecodes'IFGE            156) ;; 0x9c
    (def #_"int" Bytecodes'IFGT            157) ;; 0x9d
    (def #_"int" Bytecodes'IFLE            158) ;; 0x9e
    (def #_"int" Bytecodes'IF_ICMPEQ       159) ;; 0x9f
    (def #_"int" Bytecodes'IF_ICMPNE       160) ;; 0xa0
    (def #_"int" Bytecodes'IF_ICMPLT       161) ;; 0xa1
    (def #_"int" Bytecodes'IF_ICMPGE       162) ;; 0xa2
    (def #_"int" Bytecodes'IF_ICMPGT       163) ;; 0xa3
    (def #_"int" Bytecodes'IF_ICMPLE       164) ;; 0xa4
    (def #_"int" Bytecodes'IF_ACMPEQ       165) ;; 0xa5
    (def #_"int" Bytecodes'IF_ACMPNE       166) ;; 0xa6
    (def #_"int" Bytecodes'GOTO            167) ;; 0xa7
    (def #_"int" Bytecodes'JSR             168) ;; 0xa8
    (def #_"int" Bytecodes'RET             169) ;; 0xa9
    (def #_"int" Bytecodes'TABLESWITCH     170) ;; 0xaa
    (def #_"int" Bytecodes'LOOKUPSWITCH    171) ;; 0xab
    (def #_"int" Bytecodes'IRETURN         172) ;; 0xac
    (def #_"int" Bytecodes'LRETURN         173) ;; 0xad
    (def #_"int" Bytecodes'ARETURN         176) ;; 0xb0
    (def #_"int" Bytecodes'RETURN          177) ;; 0xb1
    (def #_"int" Bytecodes'GETSTATIC       178) ;; 0xb2
    (def #_"int" Bytecodes'PUTSTATIC       179) ;; 0xb3
    (def #_"int" Bytecodes'GETFIELD        180) ;; 0xb4
    (def #_"int" Bytecodes'PUTFIELD        181) ;; 0xb5
    (def #_"int" Bytecodes'INVOKEVIRTUAL   182) ;; 0xb6
    (def #_"int" Bytecodes'INVOKESPECIAL   183) ;; 0xb7
    (def #_"int" Bytecodes'INVOKESTATIC    184) ;; 0xb8
    (def #_"int" Bytecodes'INVOKEINTERFACE 185) ;; 0xb9
    (def #_"int" Bytecodes'INVOKEDYNAMIC   186) ;; 0xba
    (def #_"int" Bytecodes'NEW             187) ;; 0xbb
    (def #_"int" Bytecodes'NEWARRAY        188) ;; 0xbc
    (def #_"int" Bytecodes'ANEWARRAY       189) ;; 0xbd
    (def #_"int" Bytecodes'ARRAYLENGTH     190) ;; 0xbe
    (def #_"int" Bytecodes'CHECKCAST       192) ;; 0xc0
    (def #_"int" Bytecodes'INSTANCEOF      193) ;; 0xc1
    (def #_"int" Bytecodes'MONITORENTER    194) ;; 0xc2
    (def #_"int" Bytecodes'MONITOREXIT     195) ;; 0xc3
    (def #_"int" Bytecodes'WIDE            196) ;; 0xc4
    (def #_"int" Bytecodes'IFNULL          198) ;; 0xc6
    (def #_"int" Bytecodes'IFNONNULL       199) ;; 0xc7
    (def #_"int" Bytecodes'GOTO_W          200) ;; 0xc8
    (def #_"int" Bytecodes'JSR_W           201) ;; 0xc9

    (def #_"int" Bytecodes'ILLEGAL         255)
    (def #_"int" Bytecodes'END             256)

    ;;;
     ; The last opcode defined by the JVM specification.
     ;;
    (def #_"int" Bytecodes'LAST_JVM_OPCODE Bytecodes'JSR_W)

    ;;;
     ; An array that maps from a bytecode value to a String for the corresponding instruction mnemonic.
     ;;
    (def- #_"String[]" Bytecodes'nameArray (make-array String 256))

    ;;;
     ; An array that maps from a bytecode value to the set of BytecodeFlags for the corresponding instruction.
     ;;
    (def- #_"int[]" Bytecodes'flagsArray (int-array 256))

    ;;;
     ; An array that maps from a bytecode value to the length in bytes for the corresponding instruction.
     ;;
    (def- #_"int[]" Bytecodes'lengthArray (int-array 256))

    ;;;
     ; An array that maps from a bytecode value to the number of slots pushed on the stack by the
     ; corresponding instruction.
     ;;
    (def- #_"int[]" Bytecodes'stackEffectArray (int-array 256))

    ;;;
     ; Defines a bytecode by entering it into the arrays that record its name, length and flags.
     ;
     ; @param name instruction name (should be lower case)
     ; @param format encodes the length of the instruction
     ;;
    (§ defn- #_"void" Bytecodes'def-4 [#_"int" opcode, #_"String" name, #_"String" format, #_"int" stackEffect]
        (Bytecodes'def-5 opcode, name, format, stackEffect, 0)
        nil
    )

    ;;;
     ; Defines a bytecode by entering it into the arrays that record its name, length and flags.
     ;
     ; @param name instruction name (lower case)
     ; @param format encodes the length of the instruction
     ; @param flags the set of BytecodeFlags associated with the instruction
     ;;
    (§ defn- #_"void" Bytecodes'def-5 [#_"int" opcode, #_"String" name, #_"String" format, #_"int" stackEffect, #_"int" flags]
        (aset Bytecodes'nameArray opcode name)
        (aset Bytecodes'lengthArray opcode (count format))
        (aset Bytecodes'stackEffectArray opcode stackEffect)
        (aset Bytecodes'flagsArray opcode flags)
        nil
    )

    (§ init
        (Bytecodes'def-4 Bytecodes'NOP,             "nop",             "b",      0)
        (Bytecodes'def-4 Bytecodes'ACONST_NULL,     "aconst_null",     "b",      1)
        (Bytecodes'def-4 Bytecodes'ICONST_M1,       "iconst_m1",       "b",      1)
        (Bytecodes'def-4 Bytecodes'ICONST_0,        "iconst_0",        "b",      1)
        (Bytecodes'def-4 Bytecodes'ICONST_1,        "iconst_1",        "b",      1)
        (Bytecodes'def-4 Bytecodes'ICONST_2,        "iconst_2",        "b",      1)
        (Bytecodes'def-4 Bytecodes'ICONST_3,        "iconst_3",        "b",      1)
        (Bytecodes'def-4 Bytecodes'ICONST_4,        "iconst_4",        "b",      1)
        (Bytecodes'def-4 Bytecodes'ICONST_5,        "iconst_5",        "b",      1)
        (Bytecodes'def-4 Bytecodes'LCONST_0,        "lconst_0",        "b",      2)
        (Bytecodes'def-4 Bytecodes'LCONST_1,        "lconst_1",        "b",      2)
        (Bytecodes'def-4 Bytecodes'BIPUSH,          "bipush",          "bc",     1)
        (Bytecodes'def-4 Bytecodes'SIPUSH,          "sipush",          "bcc",    1)
        (Bytecodes'def-5 Bytecodes'LDC,             "ldc",             "bi",     1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'LDC_W,           "ldc_w",           "bii",    1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'LDC2_W,          "ldc2_w",          "bii",    2,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'ILOAD,           "iload",           "bi",     1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'LLOAD,           "lload",           "bi",     2,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'ALOAD,           "aload",           "bi",     1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'ILOAD_0,         "iload_0",         "b",      1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'ILOAD_1,         "iload_1",         "b",      1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'ILOAD_2,         "iload_2",         "b",      1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'ILOAD_3,         "iload_3",         "b",      1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'LLOAD_0,         "lload_0",         "b",      2,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'LLOAD_1,         "lload_1",         "b",      2,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'LLOAD_2,         "lload_2",         "b",      2,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'LLOAD_3,         "lload_3",         "b",      2,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'ALOAD_0,         "aload_0",         "b",      1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'ALOAD_1,         "aload_1",         "b",      1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'ALOAD_2,         "aload_2",         "b",      1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'ALOAD_3,         "aload_3",         "b",      1,    BytecodeFlags'LOAD)
        (Bytecodes'def-5 Bytecodes'IALOAD,          "iaload",          "b",     -1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'LALOAD,          "laload",          "b",      0,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'AALOAD,          "aaload",          "b",     -1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'BALOAD,          "baload",          "b",     -1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'CALOAD,          "caload",          "b",     -1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'SALOAD,          "saload",          "b",     -1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'ISTORE,          "istore",          "bi",    -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'LSTORE,          "lstore",          "bi",    -2,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'ASTORE,          "astore",          "bi",    -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'ISTORE_0,        "istore_0",        "b",     -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'ISTORE_1,        "istore_1",        "b",     -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'ISTORE_2,        "istore_2",        "b",     -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'ISTORE_3,        "istore_3",        "b",     -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'LSTORE_0,        "lstore_0",        "b",     -2,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'LSTORE_1,        "lstore_1",        "b",     -2,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'LSTORE_2,        "lstore_2",        "b",     -2,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'LSTORE_3,        "lstore_3",        "b",     -2,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'ASTORE_0,        "astore_0",        "b",     -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'ASTORE_1,        "astore_1",        "b",     -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'ASTORE_2,        "astore_2",        "b",     -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'ASTORE_3,        "astore_3",        "b",     -1,    BytecodeFlags'STORE)
        (Bytecodes'def-5 Bytecodes'IASTORE,         "iastore",         "b",     -3,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'LASTORE,         "lastore",         "b",     -4,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'AASTORE,         "aastore",         "b",     -3,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'BASTORE,         "bastore",         "b",     -3,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'CASTORE,         "castore",         "b",     -3,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'SASTORE,         "sastore",         "b",     -3,    BytecodeFlags'TRAP)
        (Bytecodes'def-4 Bytecodes'POP,             "pop",             "b",     -1)
        (Bytecodes'def-4 Bytecodes'POP2,            "pop2",            "b",     -2)
        (Bytecodes'def-4 Bytecodes'DUP,             "dup",             "b",      1)
        (Bytecodes'def-4 Bytecodes'DUP_X1,          "dup_x1",          "b",      1)
        (Bytecodes'def-4 Bytecodes'DUP_X2,          "dup_x2",          "b",      1)
        (Bytecodes'def-4 Bytecodes'DUP2,            "dup2",            "b",      2)
        (Bytecodes'def-4 Bytecodes'DUP2_X1,         "dup2_x1",         "b",      2)
        (Bytecodes'def-4 Bytecodes'DUP2_X2,         "dup2_x2",         "b",      2)
        (Bytecodes'def-4 Bytecodes'SWAP,            "swap",            "b",      0)
        (Bytecodes'def-5 Bytecodes'IADD,            "iadd",            "b",     -1, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-5 Bytecodes'LADD,            "ladd",            "b",     -2, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-4 Bytecodes'ISUB,            "isub",            "b",     -1)
        (Bytecodes'def-4 Bytecodes'LSUB,            "lsub",            "b",     -2)
        (Bytecodes'def-5 Bytecodes'IMUL,            "imul",            "b",     -1, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-5 Bytecodes'LMUL,            "lmul",            "b",     -2, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-5 Bytecodes'IDIV,            "idiv",            "b",     -1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'LDIV,            "ldiv",            "b",     -2,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'IREM,            "irem",            "b",     -1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'LREM,            "lrem",            "b",     -2,    BytecodeFlags'TRAP)
        (Bytecodes'def-4 Bytecodes'INEG,            "ineg",            "b",      0)
        (Bytecodes'def-4 Bytecodes'LNEG,            "lneg",            "b",      0)
        (Bytecodes'def-4 Bytecodes'ISHL,            "ishl",            "b",     -1)
        (Bytecodes'def-4 Bytecodes'LSHL,            "lshl",            "b",     -1)
        (Bytecodes'def-4 Bytecodes'ISHR,            "ishr",            "b",     -1)
        (Bytecodes'def-4 Bytecodes'LSHR,            "lshr",            "b",     -1)
        (Bytecodes'def-4 Bytecodes'IUSHR,           "iushr",           "b",     -1)
        (Bytecodes'def-4 Bytecodes'LUSHR,           "lushr",           "b",     -1)
        (Bytecodes'def-5 Bytecodes'IAND,            "iand",            "b",     -1, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-5 Bytecodes'LAND,            "land",            "b",     -2, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-5 Bytecodes'IOR,             "ior",             "b",     -1, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-5 Bytecodes'LOR,             "lor",             "b",     -2, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-5 Bytecodes'IXOR,            "ixor",            "b",     -1, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-5 Bytecodes'LXOR,            "lxor",            "b",     -2, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'ASSOCIATIVE))
        (Bytecodes'def-5 Bytecodes'IINC,            "iinc",            "bic",    0, (| BytecodeFlags'LOAD BytecodeFlags'STORE))
        (Bytecodes'def-4 Bytecodes'I2L,             "i2l",             "b",      1)
        (Bytecodes'def-4 Bytecodes'L2I,             "l2i",             "b",     -1)
        (Bytecodes'def-4 Bytecodes'I2B,             "i2b",             "b",      0)
        (Bytecodes'def-4 Bytecodes'I2C,             "i2c",             "b",      0)
        (Bytecodes'def-4 Bytecodes'I2S,             "i2s",             "b",      0)
        (Bytecodes'def-4 Bytecodes'LCMP,            "lcmp",            "b",     -3)
        (Bytecodes'def-5 Bytecodes'IFEQ,            "ifeq",            "boo",   -1, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IFNE,            "ifne",            "boo",   -1, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IFLT,            "iflt",            "boo",   -1, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IFGE,            "ifge",            "boo",   -1, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IFGT,            "ifgt",            "boo",   -1, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IFLE,            "ifle",            "boo",   -1, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IF_ICMPEQ,       "if_icmpeq",       "boo",   -2, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IF_ICMPNE,       "if_icmpne",       "boo",   -2, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IF_ICMPLT,       "if_icmplt",       "boo",   -2, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IF_ICMPGE,       "if_icmpge",       "boo",   -2, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IF_ICMPGT,       "if_icmpgt",       "boo",   -2, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IF_ICMPLE,       "if_icmple",       "boo",   -2, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IF_ACMPEQ,       "if_acmpeq",       "boo",   -2, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IF_ACMPNE,       "if_acmpne",       "boo",   -2, (| BytecodeFlags'COMMUTATIVE BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'GOTO,            "goto",            "boo",    0, (| BytecodeFlags'STOP BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'JSR,             "jsr",             "boo",    0, (| BytecodeFlags'STOP BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'RET,             "ret",             "bi",     0,    BytecodeFlags'STOP)
        (Bytecodes'def-5 Bytecodes'TABLESWITCH,     "tableswitch",     "",      -1,    BytecodeFlags'STOP)
        (Bytecodes'def-5 Bytecodes'LOOKUPSWITCH,    "lookupswitch",    "",      -1,    BytecodeFlags'STOP)
        (Bytecodes'def-5 Bytecodes'IRETURN,         "ireturn",         "b",     -1, (| BytecodeFlags'TRAP BytecodeFlags'STOP))
        (Bytecodes'def-5 Bytecodes'LRETURN,         "lreturn",         "b",     -2, (| BytecodeFlags'TRAP BytecodeFlags'STOP))
        (Bytecodes'def-5 Bytecodes'ARETURN,         "areturn",         "b",     -1, (| BytecodeFlags'TRAP BytecodeFlags'STOP))
        (Bytecodes'def-5 Bytecodes'RETURN,          "return",          "b",      0, (| BytecodeFlags'TRAP BytecodeFlags'STOP))
        (Bytecodes'def-5 Bytecodes'GETSTATIC,       "getstatic",       "bjj",    1, (| BytecodeFlags'TRAP BytecodeFlags'FIELD_READ))
        (Bytecodes'def-5 Bytecodes'PUTSTATIC,       "putstatic",       "bjj",   -1, (| BytecodeFlags'TRAP BytecodeFlags'FIELD_WRITE))
        (Bytecodes'def-5 Bytecodes'GETFIELD,        "getfield",        "bjj",    0, (| BytecodeFlags'TRAP BytecodeFlags'FIELD_READ))
        (Bytecodes'def-5 Bytecodes'PUTFIELD,        "putfield",        "bjj",   -2, (| BytecodeFlags'TRAP BytecodeFlags'FIELD_WRITE))
        (Bytecodes'def-5 Bytecodes'INVOKEVIRTUAL,   "invokevirtual",   "bjj",   -1, (| BytecodeFlags'TRAP BytecodeFlags'INVOKE))
        (Bytecodes'def-5 Bytecodes'INVOKESPECIAL,   "invokespecial",   "bjj",   -1, (| BytecodeFlags'TRAP BytecodeFlags'INVOKE))
        (Bytecodes'def-5 Bytecodes'INVOKESTATIC,    "invokestatic",    "bjj",    0, (| BytecodeFlags'TRAP BytecodeFlags'INVOKE))
        (Bytecodes'def-5 Bytecodes'INVOKEINTERFACE, "invokeinterface", "bjja_", -1, (| BytecodeFlags'TRAP BytecodeFlags'INVOKE))
        (Bytecodes'def-5 Bytecodes'INVOKEDYNAMIC,   "invokedynamic",   "bjjjj",  0, (| BytecodeFlags'TRAP BytecodeFlags'INVOKE))
        (Bytecodes'def-5 Bytecodes'NEW,             "new",             "bii",    1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'NEWARRAY,        "newarray",        "bc",     0,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'ANEWARRAY,       "anewarray",       "bii",    0,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'ARRAYLENGTH,     "arraylength",     "b",      0,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'CHECKCAST,       "checkcast",       "bii",    0,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'INSTANCEOF,      "instanceof",      "bii",    0,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'MONITORENTER,    "monitorenter",    "b",     -1,    BytecodeFlags'TRAP)
        (Bytecodes'def-5 Bytecodes'MONITOREXIT,     "monitorexit",     "b",     -1,    BytecodeFlags'TRAP)
        (Bytecodes'def-4 Bytecodes'WIDE,            "wide",            "",       0)
        (Bytecodes'def-5 Bytecodes'IFNULL,          "ifnull",          "boo",   -1, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'IFNONNULL,       "ifnonnull",       "boo",   -1, (| BytecodeFlags'FALL_THROUGH BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'GOTO_W,          "goto_w",          "boooo",  0, (| BytecodeFlags'STOP BytecodeFlags'BRANCH))
        (Bytecodes'def-5 Bytecodes'JSR_W,           "jsr_w",           "boooo",  0, (| BytecodeFlags'STOP BytecodeFlags'BRANCH))
    )

    ;;;
     ; Determines if an opcode is commutative.
     ;;
    #_unused
    (§ defn #_"boolean" Bytecodes'isCommutative-1 [#_"int" opcode]
        (not (zero? (& (nth Bytecodes'flagsArray (& opcode 0xff)) BytecodeFlags'COMMUTATIVE)))
    )

    ;;;
     ; Gets the length of an instruction denoted by a given opcode.
     ;
     ; @return the length of the instruction denoted by {@code opcode}. If {@code opcode} is an
     ;         illegal instruction or denotes a variable length instruction (e.g. #TABLESWITCH),
     ;         then 0 is returned.
     ;;
    (§ defn #_"int" Bytecodes'lengthOf-1 [#_"int" opcode]
        (nth Bytecodes'lengthArray (& opcode 0xff))
    )

    ;;;
     ; Gets the effect on the depth of the expression stack of an instruction denoted by a given opcode.
     ;
     ; @return the change in the stack caused by the instruction denoted by {@code opcode}.
     ;         If {@code opcode} is an illegal instruction then 0 is returned. Note that invoke
     ;         instructions may pop more arguments so this value is a minimum stack effect.
     ;;
    #_unused
    (§ defn #_"int" Bytecodes'stackEffectOf-1 [#_"int" opcode]
        (nth Bytecodes'stackEffectArray (& opcode 0xff))
    )

    ;;;
     ; Gets the lower-case mnemonic for a given opcode.
     ;
     ; @return the mnemonic for {@code opcode} or {@code "<illegal opcode: " + opcode + ">"} if
     ;         {@code opcode} is not a legal opcode
     ;;
    (§ defn #_"String" Bytecodes'nameOf-1 [#_"int" opcode]
        (or (nth Bytecodes'nameArray (& opcode 0xff)) (str "<illegal opcode: " opcode ">"))
    )

    ;;;
     ; Allocation-free version of {@linkplain #nameOf(int)}.
     ;
     ; @return the mnemonic for {@code opcode} or {@code "<illegal opcode>"} if {@code opcode} is not a legal opcode
     ;;
    #_unused
    (§ defn #_"String" Bytecodes'baseNameOf-1 [#_"int" opcode]
        (or (nth Bytecodes'nameArray (& opcode 0xff)) "<illegal opcode>")
    )

    ;;;
     ; Determines if a given opcode denotes an instruction that can cause an implicit exception.
     ;
     ; @return true iff {@code opcode} can cause an implicit exception, false otherwise
     ;;
    #_unused
    (§ defn #_"boolean" Bytecodes'canTrap-1 [#_"int" opcode]
        (not (zero? (& (nth Bytecodes'flagsArray (& opcode 0xff)) BytecodeFlags'TRAP)))
    )

    ;;;
     ; Determines if a given opcode denotes an instruction that loads a local variable to the operand stack.
     ;
     ; @return true iff {@code opcode} loads a local variable to the operand stack, false otherwise
     ;;
    #_unused
    (§ defn #_"boolean" Bytecodes'isLoad-1 [#_"int" opcode]
        (not (zero? (& (nth Bytecodes'flagsArray (& opcode 0xff)) BytecodeFlags'LOAD)))
    )

    ;;;
     ; Determines if a given opcode denotes an instruction that ends a basic block and does not let
     ; control flow fall through to its lexical successor.
     ;
     ; @return true iff {@code opcode} properly ends a basic block
     ;;
    #_unused
    (§ defn #_"boolean" Bytecodes'isStop-1 [#_"int" opcode]
        (not (zero? (& (nth Bytecodes'flagsArray (& opcode 0xff)) BytecodeFlags'STOP)))
    )

    ;;;
     ; Determines if a given opcode denotes an instruction that stores a value to a local variable
     ; after popping it from the operand stack.
     ;
     ; @return true iff {@code opcode} stores a value to a local variable, false otherwise
     ;;
    #_unused
    (§ defn #_"boolean" Bytecodes'isInvoke-1 [#_"int" opcode]
        (not (zero? (& (nth Bytecodes'flagsArray (& opcode 0xff)) BytecodeFlags'INVOKE)))
    )

    ;;;
     ; Determines if a given opcode denotes an instruction that stores a value to a local variable
     ; after popping it from the operand stack.
     ;
     ; @return true iff {@code opcode} stores a value to a local variable, false otherwise
     ;;
    #_unused
    (§ defn #_"boolean" Bytecodes'isStore-1 [#_"int" opcode]
        (not (zero? (& (nth Bytecodes'flagsArray (& opcode 0xff)) BytecodeFlags'STORE)))
    )

    ;;;
     ; Determines if a given opcode is an instruction that delimits a basic block.
     ;
     ; @return true iff {@code opcode} delimits a basic block
     ;;
    #_unused
    (§ defn #_"boolean" Bytecodes'isBlockEnd-1 [#_"int" opcode]
        (not (zero? (& (nth Bytecodes'flagsArray (& opcode 0xff)) (| BytecodeFlags'STOP BytecodeFlags'FALL_THROUGH))))
    )

    ;;;
     ; Determines if a given opcode is an instruction that has a 2 or 4 byte operand that is an offset to another
     ; instruction in the same method. This does not include the {@linkplain #TABLESWITCH switch} instructions.
     ;
     ; @return true iff {@code opcode} is a branch instruction with a single operand
     ;;
    #_unused
    (§ defn #_"boolean" Bytecodes'isBranch-1 [#_"int" opcode]
        (not (zero? (& (nth Bytecodes'flagsArray (& opcode 0xff)) BytecodeFlags'BRANCH)))
    )

    ;;;
     ; Determines if a given opcode denotes a conditional branch.
     ;;
    #_unused
    (§ defn #_"boolean" Bytecodes'isConditionalBranch-1 [#_"int" opcode]
        (not (zero? (& (nth Bytecodes'flagsArray (& opcode 0xff)) BytecodeFlags'FALL_THROUGH)))
    )

    ;;;
     ; Gets the arithmetic operator name for a given opcode. If {@code opcode} does not denote an
     ; arithmetic instruction, then the {@linkplain #nameOf(int) name} of the opcode is returned instead.
     ;;
    #_unused
    (§ defn #_"String" Bytecodes'operator-1 [#_"int" opcode]
        (condp =? opcode
            ;; arithmetic ops
            [Bytecodes'IADD  Bytecodes'LADD ] "+"
            [Bytecodes'ISUB  Bytecodes'LSUB ] "-"
            [Bytecodes'IMUL  Bytecodes'LMUL ] "*"
            [Bytecodes'IDIV  Bytecodes'LDIV ] "/"
            [Bytecodes'IREM  Bytecodes'LREM ] "%"
            ;; shift ops
            [Bytecodes'ISHL  Bytecodes'LSHL ] "<<"
            [Bytecodes'ISHR  Bytecodes'LSHR ] ">>"
            [Bytecodes'IUSHR Bytecodes'LUSHR] ">>>"
            ;; logic ops
            [Bytecodes'IAND  Bytecodes'LAND ] "&"
            [Bytecodes'IOR   Bytecodes'LOR  ] "|"
            [Bytecodes'IXOR  Bytecodes'LXOR ] "^"
                                              (Bytecodes'nameOf-1 opcode)
        )
    )

    #_unused
    (§ defn #_"boolean" Bytecodes'isIfBytecode-1 [#_"int" bytecode]
        (any = bytecode
            Bytecodes'IFEQ
            Bytecodes'IFNE
            Bytecodes'IFLT
            Bytecodes'IFGE
            Bytecodes'IFGT
            Bytecodes'IFLE
            Bytecodes'IF_ICMPEQ
            Bytecodes'IF_ICMPNE
            Bytecodes'IF_ICMPLT
            Bytecodes'IF_ICMPGE
            Bytecodes'IF_ICMPGT
            Bytecodes'IF_ICMPLE
            Bytecodes'IF_ACMPEQ
            Bytecodes'IF_ACMPNE
            Bytecodes'IFNULL
            Bytecodes'IFNONNULL
        )
    )
)

;;;
 ; A collection of flags describing various bytecode attributes.
 ;
 ; @anno Bytecodes.BytecodeFlags
 ;;
(value-ns BytecodeFlags
    ;;;
     ; Denotes an instruction that ends a basic block and does not let control flow fall through
     ; to its lexical successor.
     ;;
    (def #_"int" BytecodeFlags'STOP 0x00000001)
    ;;;
     ; Denotes an instruction that ends a basic block and may let control flow fall through to
     ; its lexical successor. In practice this means it is a conditional branch.
     ;;
    (def #_"int" BytecodeFlags'FALL_THROUGH 0x00000002)
    ;;;
     ; Denotes an instruction that has a 2 or 4 byte operand that is an offset to another
     ; instruction in the same method. This does not include the Bytecodes#TABLESWITCH
     ; or Bytecodes#LOOKUPSWITCH instructions.
     ;;
    (def #_"int" BytecodeFlags'BRANCH 0x00000004)
    ;;;
     ; Denotes an instruction that reads the value of a static or instance field.
     ;;
    (def #_"int" BytecodeFlags'FIELD_READ 0x00000008)
    ;;;
     ; Denotes an instruction that writes the value of a static or instance field.
     ;;
    (def #_"int" BytecodeFlags'FIELD_WRITE 0x00000010)
    ;;;
     ; Denotes an instruction that can cause a trap.
     ;;
    (def #_"int" BytecodeFlags'TRAP 0x00000080)
    ;;;
     ; Denotes an instruction that is commutative.
     ;;
    (def #_"int" BytecodeFlags'COMMUTATIVE 0x00000100)
    ;;;
     ; Denotes an instruction that is associative.
     ;;
    (def #_"int" BytecodeFlags'ASSOCIATIVE 0x00000200)
    ;;;
     ; Denotes an instruction that loads an operand.
     ;;
    (def #_"int" BytecodeFlags'LOAD 0x00000400)
    ;;;
     ; Denotes an instruction that stores an operand.
     ;;
    (def #_"int" BytecodeFlags'STORE 0x00000800)
    ;;;
     ; Denotes the 4 INVOKE* instructions.
     ;;
    (def #_"int" BytecodeFlags'INVOKE 0x00001000)
)

;;;
 ; A utility class that makes iterating over bytecodes and reading operands simpler and less error prone.
 ; For example, it handles the Bytecodes#WIDE instruction and wide variants of instructions internally.
 ;;
(final-ns BytecodeStream
    (§ final #_"byte[]" :code nil)
    (§ mutable #_"int" :opcode 0)
    ;;;
     ; Current bytecode index.
     ;;
    (§ mutable #_"int" :curBCI 0)
    ;;;
     ; Next bytecode index (no side-effects).
     ;;
    (§ mutable #_"int" :nextBCI 0)

    ;;;
     ; Creates a new BytecodeStream for the specified bytecode.
     ;;
    (§ defn #_"BytecodeStream" BytecodeStream'new-1 [#_"byte[]" code]
        (let [
            #_"BytecodeStream" this (Object.)
            this (assoc this :code code)
            this (BytecodeStream''setBCI-2 this, 0)
        ]
            this
        )
    )

    ;;;
     ; Advances to the next bytecode.
     ;;
    (§ method! #_"BytecodeStream" BytecodeStream''next-1 [#_"BytecodeStream" this]
        (BytecodeStream''setBCI-2 this, (:nextBCI this))
    )

    ;;;
     ; Gets the bytecode index of the end of the code.
     ;;
    (§ method! #_"int" BytecodeStream''endBCI-1 [#_"BytecodeStream" this]
        (count (:code this))
    )

    ;;;
     ; Gets the current opcode. This method will never return the {@link Bytecodes#WIDE WIDE}
     ; opcode, but will instead return the opcode that is modified by the WIDE opcode.
     ;
     ; @return the current opcode; Bytecodes#END if at or beyond the end of the code
     ;;
    (§ method! #_"int" BytecodeStream''currentBC-1 [#_"BytecodeStream" this]
        (when (= (:opcode this) Bytecodes'WIDE) => (:opcode this)
            (Bytes'beU1-2 (:code this), (inc (:curBCI this)))
        )
    )

    ;;;
     ; Reads the index of a local variable for one of the load or store instructions.
     ; The WIDE modifier is handled internally.
     ;
     ; @return the index of the local variable
     ;;
    (§ method! #_"int" BytecodeStream''readLocalIndex-1 [#_"BytecodeStream" this]
        ;; read local variable index for load/store
        (if (= (:opcode this) Bytecodes'WIDE)
            (Bytes'beU2-2 (:code this), (+ (:curBCI this) 2))
            (Bytes'beU1-2 (:code this), (+ (:curBCI this) 1))
        )
    )

    ;;;
     ; Read the delta for an Bytecodes#IINC bytecode.
     ;
     ; @return the delta for the IINC
     ;;
    (§ method! #_"int" BytecodeStream''readIncrement-1 [#_"BytecodeStream" this]
        ;; read the delta for the iinc bytecode
        (if (= (:opcode this) Bytecodes'WIDE)
            (Bytes'beS2-2 (:code this), (+ (:curBCI this) 4))
            (Bytes'beS1-2 (:code this), (+ (:curBCI this) 2))
        )
    )

    ;;;
     ; Read the destination of a Bytecodes#GOTO or IF instructions.
     ;
     ; @return the destination bytecode index
     ;;
    (§ method! #_"int" BytecodeStream''readBranchDest-1 [#_"BytecodeStream" this]
        ;; reads the destination for a branch bytecode
        (if (or (= (:opcode this) Bytecodes'GOTO_W) (= (:opcode this) Bytecodes'JSR_W))
            (+ (:curBCI this) (Bytes'beS4-2 (:code this), (inc (:curBCI this))))
            (+ (:curBCI this) (Bytes'beS2-2 (:code this), (inc (:curBCI this))))
        )
    )

    ;;;
     ; Read a signed 4-byte integer from the bytecode stream at the specified bytecode index.
     ;
     ; @param bci the bytecode index
     ; @return the integer value
     ;;
    (§ method! #_"int" BytecodeStream''readInt-2 [#_"BytecodeStream" this, #_"int" bci]
        ;; reads a 4-byte signed value
        (Bytes'beS4-2 (:code this), bci)
    )

    ;;;
     ; Reads an unsigned, 1-byte value from the bytecode stream at the specified bytecode index.
     ;
     ; @param bci the bytecode index
     ; @return the byte
     ;;
    (§ method! #_"int" BytecodeStream''readUByte-2 [#_"BytecodeStream" this, #_"int" bci]
        (Bytes'beU1-2 (:code this), bci)
    )

    ;;;
     ; Reads a constant pool index for the current instruction.
     ;
     ; @return the constant pool index
     ;;
    (§ method! #_"char" BytecodeStream''readCPI-1 [#_"BytecodeStream" this]
        (if (= (:opcode this) Bytecodes'LDC)
            (char (Bytes'beU1-2 (:code this), (inc (:curBCI this))))
            (char (Bytes'beU2-2 (:code this), (inc (:curBCI this))))
        )
    )

    ;;;
     ; Reads a constant pool index for an invokedynamic instruction.
     ;
     ; @return the constant pool index
     ;;
    (§ method! #_"int" BytecodeStream''readCPI4-1 [#_"BytecodeStream" this]
        (Bytes'beS4-2 (:code this), (inc (:curBCI this)))
    )

    ;;;
     ; Reads a signed, 1-byte value for the current instruction (e.g. BIPUSH).
     ;
     ; @return the byte
     ;;
    (§ method! #_"byte" BytecodeStream''readByte-1 [#_"BytecodeStream" this]
        (nth (:code this) (inc (:curBCI this)))
    )

    ;;;
     ; Reads a signed, 2-byte short for the current instruction (e.g. SIPUSH).
     ;
     ; @return the short value
     ;;
    (§ method! #_"short" BytecodeStream''readShort-1 [#_"BytecodeStream" this]
        (short (Bytes'beS2-2 (:code this), (inc (:curBCI this))))
    )

    ;;;
     ; Sets the bytecode index to the specified value. If {@code bci} is beyond the end of the array,
     ; #currentBC will return Bytecodes#END and other methods may throw ArrayIndexOutOfBoundsException.
     ;
     ; @param bci the new bytecode index
     ;;
    (§ method! #_"BytecodeStream" BytecodeStream''setBCI-2 [#_"BytecodeStream" this, #_"int" bci]
        (let [
            this (assoc this :curBCI bci)
        ]
            (if (< (:curBCI this) (count (:code this)))
                (let [
                    this (assoc this :opcode (Bytes'beU1-2 (:code this), bci))
                    this (assoc this :nextBCI (+ bci (BytecodeStream''lengthOf-1 this)))
                ]
                    this
                )
                (let [
                    this (assoc this :opcode Bytecodes'END)
                    this (assoc this :nextBCI (:curBCI this))
                ]
                    this
                )
            )
        )
    )

    ;;;
     ; Gets the length of the current bytecode.
     ;;
    (§ method- #_"int" BytecodeStream''lengthOf-1 [#_"BytecodeStream" this]
        (let [
            #_"int" n (Bytecodes'lengthOf-1 (:opcode this))
        ]
            (when (zero? n) => n
                (condp = (:opcode this)
                    Bytecodes'TABLESWITCH
                        (BytecodeTableSwitch''size-1 (BytecodeTableSwitch'new-2 this, (:curBCI this)))
                    Bytecodes'LOOKUPSWITCH
                        (BytecodeLookupSwitch''size-1 (BytecodeLookupSwitch'new-2 this, (:curBCI this)))
                    Bytecodes'WIDE
                        (condp = (Bytes'beU1-2 (:code this), (inc (:curBCI this)))
                            Bytecodes'RET  4
                            Bytecodes'IINC 6
                                           4 ;; a load or store bytecode
                        )
                )
            )
        )
    )
)

;;;
 ; An abstract class that provides the state and methods common to Bytecodes#LOOKUPSWITCH and
 ; Bytecodes#TABLESWITCH instructions.
 ;;
(class-ns BytecodeSwitch
    ;;;
     ; The BytecodeStream containing the bytecode array.
     ;;
    (§ final #_"BytecodeStream" :stream nil)
    ;;;
     ; Index of start of switch instruction.
     ;;
    (§ final #_"int" :bci 0)
    ;;;
     ; Index of the start of the additional data for the switch instruction, aligned to a multiple
     ; of four from the method start.
     ;;
    (§ final #_"int" :alignedBci 0)

    ;;;
     ; Constructor for a BytecodeStream.
     ;
     ; @param stream the BytecodeStream containing the switch instruction
     ; @param bci the index in the stream of the switch instruction
     ;;
    (§ defn #_"BytecodeSwitch" BytecodeSwitch'new-2 [#_"BytecodeStream" stream, #_"int" bci]
        (let [
            #_"BytecodeSwitch" this (Object.)
            this (assoc this :stream stream)
            this (assoc this :bci bci)
            this (assoc this :alignedBci (& (+ bci 4) 0xfffffffc))
        ]
            this
        )
    )

    ;;;
     ; Gets the index of the instruction denoted by the {@code i}'th switch target.
     ;
     ; @param i index of the switch target
     ; @return the index of the instruction denoted by the {@code i}'th switch target
     ;;
    (§ method! #_"int" BytecodeSwitch''targetAt-2 [#_"BytecodeSwitch" this, #_"int" i]
        (+ (:bci this) (BytecodeSwitch''offsetAt-2 this, i))
    )

    ;;;
     ; Gets the index of the instruction for the default switch target.
     ;
     ; @return the index of the instruction for the default switch target
     ;;
    (§ method! #_"int" BytecodeSwitch''defaultTarget-1 [#_"BytecodeSwitch" this]
        (+ (:bci this) (BytecodeSwitch''defaultOffset-1 this))
    )

    ;;;
     ; Gets the offset from the start of the switch instruction to the default switch target.
     ;
     ; @return the offset to the default switch target
     ;;
    (§ method! #_"int" BytecodeSwitch''defaultOffset-1 [#_"BytecodeSwitch" this]
        (BytecodeStream''readInt-2 (:stream this), (:alignedBci this))
    )

    ;;;
     ; Gets the key at {@code i}'th switch target index.
     ;
     ; @param i the switch target index
     ; @return the key at {@code i}'th switch target index
     ;;
    (§ abstract #_"int" BytecodeSwitch''keyAt-2 [#_"BytecodeSwitch" this, #_"int" i])

    ;;;
     ; Gets the offset from the start of the switch instruction for the {@code i}'th switch target.
     ;
     ; @param i the switch target index
     ; @return the offset to the {@code i}'th switch target
     ;;
    (§ abstract #_"int" BytecodeSwitch''offsetAt-2 [#_"BytecodeSwitch" this, #_"int" i])

    ;;;
     ; Gets the number of switch targets.
     ;
     ; @return the number of switch targets
     ;;
    (§ abstract #_"int" BytecodeSwitch''numberOfCases-1 [#_"BytecodeSwitch" this])

    ;;;
     ; Gets the total size in bytes of the switch instruction.
     ;
     ; @return the total size in bytes of the switch instruction
     ;;
    #_unused
    (§ abstract #_"int" BytecodeSwitch''size-1 [#_"BytecodeSwitch" this])
)

;;;
 ; A utility for processing Bytecodes#TABLESWITCH bytecodes.
 ;;
(final-ns BytecodeTableSwitch (§ extends BytecodeSwitch)
    (def- #_"int" BytecodeTableSwitch'OFFSET_TO_LOW_KEY 4)
    (def- #_"int" BytecodeTableSwitch'OFFSET_TO_HIGH_KEY 8)
    (def- #_"int" BytecodeTableSwitch'OFFSET_TO_FIRST_JUMP_OFFSET 12)
    (def- #_"int" BytecodeTableSwitch'JUMP_OFFSET_SIZE 4)

    ;;;
     ; Constructor for a BytecodeStream.
     ;
     ; @param stream the BytecodeStream containing the switch instruction
     ; @param bci the index in the stream of the switch instruction
     ;;
    (§ defn #_"BytecodeTableSwitch" BytecodeTableSwitch'new-2 [#_"BytecodeStream" stream, #_"int" bci]
        (BytecodeSwitch'new-2 stream, bci)
    )

    ;;;
     ; Gets the low key of the table switch.
     ;;
    (§ method! #_"int" BytecodeTableSwitch''lowKey-1 [#_"BytecodeTableSwitch" this]
        (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeTableSwitch'OFFSET_TO_LOW_KEY))
    )

    ;;;
     ; Gets the high key of the table switch.
     ;;
    (§ method! #_"int" BytecodeTableSwitch''highKey-1 [#_"BytecodeTableSwitch" this]
        (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeTableSwitch'OFFSET_TO_HIGH_KEY))
    )

    #_unused
    (§ override! #_"int" BytecodeTableSwitch''keyAt-2 [#_"BytecodeTableSwitch" this, #_"int" i]
        (+ (BytecodeTableSwitch''lowKey-1 this) i)
    )

    #_unused
    (§ override! #_"int" BytecodeTableSwitch''offsetAt-2 [#_"BytecodeTableSwitch" this, #_"int" i]
        (BytecodeStream''readInt-2 (:stream this), (+ (:alignedBci this) BytecodeTableSwitch'OFFSET_TO_FIRST_JUMP_OFFSET (* BytecodeTableSwitch'JUMP_OFFSET_SIZE i)))
    )

    (§ override! #_"int" BytecodeTableSwitch''numberOfCases-1 [#_"BytecodeTableSwitch" this]
        (inc (- (BytecodeTableSwitch''highKey-1 this) (BytecodeTableSwitch''lowKey-1 this)))
    )

    (§ override! #_"int" BytecodeTableSwitch''size-1 [#_"BytecodeTableSwitch" this]
        (- (+ (:alignedBci this) BytecodeTableSwitch'OFFSET_TO_FIRST_JUMP_OFFSET (* BytecodeTableSwitch'JUMP_OFFSET_SIZE (BytecodeTableSwitch''numberOfCases-1 this))) (:bci this))
    )
)

;;;
 ; A collection of utility methods for dealing with bytes, particularly in byte arrays.
 ;;
(value-ns Bytes
    ;;;
     ; Gets a signed 1-byte value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the signed 1-byte value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beS1-2 [#_"byte[]" data, #_"int" bci]
        (nth data bci)
    )

    ;;;
     ; Gets a signed 2-byte big-endian value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the signed 2-byte, big-endian, value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beS2-2 [#_"byte[]" data, #_"int" bci]
        (| (<< (nth data bci) 8) (& (nth data (inc bci)) 0xff))
    )

    ;;;
     ; Gets an unsigned 1-byte value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the unsigned 1-byte value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beU1-2 [#_"byte[]" data, #_"int" bci]
        (& (nth data bci) 0xff)
    )

    ;;;
     ; Gets an unsigned 2-byte big-endian value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the unsigned 2-byte, big-endian, value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beU2-2 [#_"byte[]" data, #_"int" bci]
        (| (<< (& (nth data bci) 0xff) 8) (& (nth data (inc bci)) 0xff))
    )

    ;;;
     ; Gets a signed 4-byte big-endian value.
     ;
     ; @param data the array containing the data
     ; @param bci the start index of the value to retrieve
     ; @return the signed 4-byte, big-endian, value at index {@code bci} in array {@code data}
     ;;
    (defn #_"int" Bytes'beS4-2 [#_"byte[]" data, #_"int" bci]
        (| (<< (nth data bci) 24) (<< (& (nth data (inc bci)) 0xff) 16) (<< (& (nth data (+ bci 2)) 0xff) 8) (& (nth data (+ bci 3)) 0xff))
    )
)

;;;
 ; Direct access to the bytecode of a ResolvedJavaMethod that will reflect any
 ; instrumentation and rewriting performed on the ResolvedJavaMethod.
 ;;
(final-ns ResolvedJavaMethodBytecode (§ implements Bytecode)
    (§ final #_"ResolvedJavaMethod" :method nil)

    (§ defn #_"ResolvedJavaMethodBytecode" ResolvedJavaMethodBytecode'new-1 [#_"ResolvedJavaMethod" method]
        (let [
            #_"ResolvedJavaMethodBytecode" this (Object.)
            this (assoc this :method method)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"ResolvedJavaMethod" ResolvedJavaMethodBytecode''getMethod-1 [#_"ResolvedJavaMethodBytecode" this]
        (:method this)
    )

    #_unused
    (§ override! #_"byte[]" ResolvedJavaMethodBytecode''getCode-1 [#_"ResolvedJavaMethodBytecode" this]
        (#_"ResolvedJavaMethod" .getCode (:method this))
    )

    #_unused
    (§ override! #_"int" ResolvedJavaMethodBytecode''getCodeSize-1 [#_"ResolvedJavaMethodBytecode" this]
        (#_"ResolvedJavaMethod" .getCodeSize (:method this))
    )

    #_unused
    (§ override! #_"int" ResolvedJavaMethodBytecode''getMaxStackSize-1 [#_"ResolvedJavaMethodBytecode" this]
        (#_"ResolvedJavaMethod" .getMaxStackSize (:method this))
    )

    #_unused
    (§ override! #_"int" ResolvedJavaMethodBytecode''getMaxLocals-1 [#_"ResolvedJavaMethodBytecode" this]
        (#_"ResolvedJavaMethod" .getMaxLocals (:method this))
    )

    #_unused
    (§ override! #_"ConstantPool" ResolvedJavaMethodBytecode''getConstantPool-1 [#_"ResolvedJavaMethodBytecode" this]
        (#_"ResolvedJavaMethod" .getConstantPool (:method this))
    )
)

;;;
 ; BytecodeProvider that returns ResolvedJavaMethodBytecode objects.
 ;;
(final-ns ResolvedJavaMethodBytecodeProvider (§ implements BytecodeProvider)
    ;;;
     ; A state-less, shared ResolvedJavaMethodBytecodeProvider instance.
     ;;
    (§ def #_"ResolvedJavaMethodBytecodeProvider" ResolvedJavaMethodBytecodeProvider'INSTANCE (ResolvedJavaMethodBytecodeProvider'new-0))

    (§ defn- #_"ResolvedJavaMethodBytecodeProvider" ResolvedJavaMethodBytecodeProvider'new-0 []
        (Object.)
    )

    #_unused
    (§ override! #_"Bytecode" ResolvedJavaMethodBytecodeProvider''getBytecode-2 [#_"ResolvedJavaMethodBytecodeProvider" this, #_"ResolvedJavaMethod" method]
        (ResolvedJavaMethodBytecode'new-1 method)
    )

    #_unused
    (§ override! #_"boolean" ResolvedJavaMethodBytecodeProvider''supportsInvokedynamic-1 [#_"ResolvedJavaMethodBytecodeProvider" this]
        true
    )
)

;;;
 ; Represents the output from compiling a method, including the compiled machine code, associated
 ; data and references, relocation information, deoptimization information, etc.
 ;;
(final-ns CompilationResult
    (§ mutable #_"boolean" :closed false)

    (§ final #_"DataSection" :dataSection (DataSection'new-0))
    (§ final #_"List<DataPatch>" :dataPatches (ArrayList.))
    (§ final #_"List<Mark>" :marks (ArrayList.))

    ;;;
     ; Total frame size in bytes. This includes the return address pushed onto the stack, if any.
     ;;
    (§ final #_"int" :totalFrameSize -1)
    ;;;
     ; The buffer containing the emitted machine code.
     ;;
    (§ mutable #_"byte[]" :targetCode nil)
    ;;;
     ; The leading number of bytes in #targetCode containing the emitted machine code.
     ;;
    (§ mutable #_"int" :targetCodeSize 0)

    (§ defn #_"CompilationResult" CompilationResult'new-1 [#_"int" totalFrameSize]
        (let [
            #_"CompilationResult" this (Object.)
            this (assoc this :totalFrameSize totalFrameSize)
        ]
            this
        )
    )

    (§ method- #_"void" CompilationResult''checkOpen-1 [#_"CompilationResult" this]
        (when (:closed this)
            (throw (IllegalStateException.))
        )
        nil
    )

    ;;;
     ; Records a data patch in the code section. The data patch can refer to something in the
     ; {@link DataSectionReference data section} or directly to an {@link ConstantReference inlined constant}.
     ;
     ; @param codePos the position in the code that needs to be patched
     ; @param ref the reference that should be inserted in the code
     ;;
    (§ method! #_"void" CompilationResult''recordDataPatch-3 [#_"CompilationResult" this, #_"int" codePos, #_"jdk.vm.ci.code.site.Reference" ref]
        (CompilationResult''checkOpen-1 this)
        (#_"List" .add (:dataPatches this), (DataPatch. codePos, ref))
        nil
    )

    ;;;
     ; Records an instruction mark within this method.
     ;
     ; @param codePos the position in the code that is covered by the handler
     ; @param markId the identifier for this mark
     ;;
    (§ method! #_"Mark" CompilationResult''recordMark-3 [#_"CompilationResult" this, #_"int" codePos, #_"Object" markId]
        (CompilationResult''checkOpen-1 this)
        (let [
            #_"Mark" mark (Mark. codePos, markId)
        ]
            (#_"List" .add (:marks this), mark)
            mark
        )
    )

    ;;;
     ; Sets the machine that has been generated by the compiler.
     ;
     ; @param code the machine code generated
     ; @param size the size of the machine code
     ;;
    (§ method! #_"CompilationResult" CompilationResult''setTargetCode-3 [#_"CompilationResult" this, #_"byte[]" code, #_"int" size]
        (CompilationResult''checkOpen-1 this)
        (let [
            this (assoc this :targetCode code)
            this (assoc this :targetCodeSize size)
        ]
            this
        )
    )

    ;;;
     ; Closes this compilation result to future updates.
     ;;
    (§ method! #_"CompilationResult" CompilationResult''close-1 [#_"CompilationResult" this]
        (CompilationResult''checkOpen-1 this)
        (let [
            this (update this :dataSection DataSection''close-1)
        ]
            (assoc this :closed true)
        )
    )
)

(final-ns DataSection
    (§ final #_"ArrayList<Data>" :dataItems (ArrayList.))

    (§ mutable #_"boolean" :closed false)
    (§ mutable #_"int" :sectionAlignment 0)
    (§ mutable #_"int" :sectionSize 0)

    (§ defn #_"DataSection" DataSection'new-0 []
        (Object.)
    )

    (§ method- #_"void" DataSection''checkOpen-1 [#_"DataSection" this]
        (when (:closed this)
            (throw (IllegalStateException.))
        )
        nil
    )

    (§ method- #_"void" DataSection''checkClosed-1 [#_"DataSection" this]
        (when-not (:closed this)
            (throw (IllegalStateException.))
        )
        nil
    )

    ;;;
     ; Inserts a Data item into the data section. If the item is already in the
     ; data section, the same DataSectionReference is returned.
     ;
     ; @param data the Data item to be inserted
     ; @return a unique DataSectionReference identifying the Data item
     ;;
    (§ method! #_"DataSectionReference" DataSection''insertData-2 [#_"DataSection" this, #_"Data" data]
        (DataSection''checkOpen-1 this)
        (locking data
            (when (nil? (:ref data))
                (§ ass data (assoc data :ref (DataSectionReference.)))
                (#_"ArrayList" .add (:dataItems this), data)
            )
            (:ref data)
        )
    )

    (§ defn #_"int" DataSection'lcm-2 [#_"int" x, #_"int" y]
        (cond
            (zero? x) y
            (zero? y) x
            :else     (loop-when-recur [#_"int" a (max x y) #_"int" b (min x y)] (pos? b) [b (% a b)] => (quot (* x y) a))
        )
    )

    (§ defn- #_"int" DataSection'align-2 [#_"int" position, #_"int" alignment]
        (* (quot (dec (+ position alignment)) alignment) alignment)
    )

    ;;;
     ; Computes the layout of the data section and closes this object to further updates.
     ;
     ; This must be called exactly once.
     ;;
    (§ method! #_"DataSection" DataSection''close-1 [#_"DataSection" this]
        (DataSection''checkOpen-1 this)
        (let [
            this (assoc this :closed true)
        ]
            ;; simple heuristic: put items with larger alignment requirement first
            (#_"ArrayList" .sort (:dataItems this), (ß (a, b) -> (§ fun (- (:alignment a) (:alignment b)))))

            (let [
                [#_"int" alignment #_"int" position]
                    (loop-when [alignment 1 position 0 #_"ISeq" s (seq (:dataItems this))] (some? s) => [alignment position]
                        (let [
                            #_"Data" d (first s)
                            alignment (DataSection'lcm-2 alignment, (:alignment d))
                            position (DataSection'align-2 position, (:alignment d))
                        ]
                            (#_"DataSectionReference" .setOffset (:ref d), position)
                            (recur alignment (+ position (:size d)) (next s))
                        )
                    )
                this (assoc this :sectionAlignment alignment)
                this (assoc this :sectionSize position)
            ]
                this
            )
        )
    )

    ;;;
     ; Gets the size of the data section.
     ;
     ; This must only be called once this object has been {@linkplain #closed() closed}.
     ;;
    (§ method! #_"int" DataSection''getSectionSize-1 [#_"DataSection" this]
        (DataSection''checkClosed-1 this)
        (:sectionSize this)
    )

    ;;;
     ; Gets the minimum alignment requirement of the data section.
     ;
     ; This must only be called once this object has been {@linkplain #closed() closed}.
     ;;
    (§ method! #_"int" DataSection''getSectionAlignment-1 [#_"DataSection" this]
        (DataSection''checkClosed-1 this)
        (:sectionAlignment this)
    )

    ;;;
     ; Builds the data section into a given buffer.
     ;
     ; This must only be called once this object has been {@linkplain #closed() closed}.
     ; When this method returns, the buffers' position is just after the last data item.
     ;
     ; @param buffer the ByteBuffer where the data section should be built, that must hold at least #getSectionSize() bytes
     ; @param patch a Patches instance to receive {@link VMConstant constants} for relocations in the data section
     ;;
    (§ method! #_"void" DataSection''buildDataSection-3 [#_"DataSection" this, #_"ByteBuffer" buffer, #_"Patches" patch]
        (DataSection''checkClosed-1 this)
        (let [
            #_"int" start (#_"ByteBuffer" .position buffer)
        ]
            (doseq [#_"Data" data (:dataItems this)]
                (#_"ByteBuffer" .position buffer, (+ start (#_"DataSectionReference" .getOffset (:ref data))))
                (Data''emit-3 data, buffer, patch)
            )
            (#_"ByteBuffer" .position buffer, (+ start (:sectionSize this)))
        )
        nil
    )
)

;;;
 ; @anno DataSection.Patches
 ;;
(§ interface Patches
    (§ abstract #_"void" Patches''registerPatch-3 [#_"Patches" this, #_"int" position, #_"VMConstant" constant])
)

;;;
 ; @anno DataSection.Data
 ;;
(class-ns Data
    (§ mutable #_"int" :alignment 0)
    (§ final #_"int" :size 0)

    (§ mutable #_"DataSectionReference" :ref nil)

    (§ defn #_"Data" Data'new-2 [#_"int" alignment, #_"int" size]
        (let [
            #_"Data" this (Object.)
            this (assoc this :alignment alignment)
            this (assoc this :size size)
            ;; initialized in DataSection.insertData(Data)
            this (assoc this :ref nil)
        ]
            this
        )
    )

    (§ abstract #_"void" Data''emit-3 [#_"Data" this, #_"ByteBuffer" buffer, #_"Patches" patches])

    (§ method! #_"Data" Data''updateAlignment-2 [#_"Data" this, #_"int" alignment]
        (when-not (= alignment (:alignment this)) => this
            (update this :alignment DataSection'lcm-2 alignment)
        )
    )
)

;;;
 ; @anno DataSection.RawData
 ;;
(final-ns RawData (§ extends Data)
    (§ final #_"byte[]" :data nil)

    (§ defn #_"RawData" RawData'new-2 [#_"byte[]" data, #_"int" alignment]
        (let [
            #_"RawData" this (Data'new-2 alignment, (count data))
            this (assoc this :data data)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" RawData''emit-3 [#_"RawData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
        (#_"ByteBuffer" .put buffer, (:data this))
        nil
    )
)

;;;
 ; @anno DataSection.SerializableData
 ;;
(final-ns SerializableData (§ extends Data)
    (§ final #_"SerializableConstant" :constant nil)

    (§ defn #_"SerializableData" SerializableData'new-1 [#_"SerializableConstant" constant]
        (SerializableData'new-2 constant, 1)
    )

    (§ defn #_"SerializableData" SerializableData'new-2 [#_"SerializableConstant" constant, #_"int" alignment]
        (let [
            #_"SerializableData" this (Data'new-2 alignment, (#_"SerializableConstant" .getSerializedSize constant))
            this (assoc this :constant constant)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" SerializableData''emit-3 [#_"SerializableData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
        (#_"SerializableConstant" .serialize (:constant this), buffer)
        nil
    )
)

;;;
 ; @anno DataSection.ZeroData
 ;;
(class-ns ZeroData (§ extends Data)
    (§ defn #_"ZeroData" ZeroData'new-2 [#_"int" alignment, #_"int" size]
        (Data'new-2 alignment, size)
    )

    (§ defn #_"ZeroData" ZeroData'create-2 [#_"int" alignment, #_"int" size]
        (case size
            1   (§ reify #_"ZeroData" (ZeroData'new-2 alignment, size)
                    #_unused
                    (§ override! #_"void" ZeroData''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                        (#_"ByteBuffer" .put buffer, (byte 0))
                        nil
                    )
                )
            2   (§ reify #_"ZeroData" (ZeroData'new-2 alignment, size)
                    #_unused
                    (§ override! #_"void" ZeroData''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                        (#_"ByteBuffer" .putShort buffer, (short 0))
                        nil
                    )
                )
            4   (§ reify #_"ZeroData" (ZeroData'new-2 alignment, size)
                    #_unused
                    (§ override! #_"void" ZeroData''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                        (#_"ByteBuffer" .putInt buffer, 0)
                        nil
                    )
                )
            8   (§ reify #_"ZeroData" (ZeroData'new-2 alignment, size)
                    #_unused
                    (§ override! #_"void" ZeroData''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                        (#_"ByteBuffer" .putLong buffer, 0)
                        nil
                    )
                )
            (ZeroData'new-2 alignment, size)
        )
    )

    #_unused
    (§ override #_"void" ZeroData''emit-3 [#_"ZeroData" this, #_"ByteBuffer" buffer, #_"Patches" patches]
        (let [
            #_"int" n
                (loop-when-recur [n (Data''getSize-1 this)] (< 8 n) [(- n 8)] => n
                    (#_"ByteBuffer" .putLong buffer, 0)
                )
        ]
            (loop-when-recur n (pos? n) (dec n)
                (#_"ByteBuffer" .put buffer, (byte 0))
            )
        )
        nil
    )
)

;;;
 ; Represents an address of the form [base + index*scale + displacement]. Both base and index are optional.
 ;;
(final-ns AMD64AddressNode (§ extends AddressNode) (§ implements Simplifiable, LIRLowerable)
    (§ def #_"NodeClass<AMD64AddressNode>" AMD64AddressNode'TYPE (NodeClass'create-1 AMD64AddressNode))

    ; @OptionalInput
    (§ mutable #_"ValueNode" :base nil)

    ; @OptionalInput
    (§ mutable #_"ValueNode" :index nil)
    (§ mutable #_"Scale" :scale nil)

    (§ mutable #_"int" :displacement 0)

    (§ defn #_"AMD64AddressNode" AMD64AddressNode'new-2 [#_"ValueNode" base, #_"ValueNode" index]
        (let [
            #_"AMD64AddressNode" this (AddressNode'new-1 AMD64AddressNode'TYPE)
            this (assoc this :base base)
            this (assoc this :index index)
            this (assoc this :scale Scale'Times1)
        ]
            this
        )
    )

    (§ method! #_"AMD64AddressNode" AMD64AddressNode''canonicalizeIndex-2 [#_"AMD64AddressNode" this, #_"SimplifierTool" tool]
        (when (and (instance? AddNode (:index this)) (= (:bits (:stamp (:index this))) 64)) => this
            (let [
                #_"AddNode" add (:index this)
            ]
                (when (and (instance? PhiNode (:x add)) (instance? LoopBeginNode (PhiNode''merge-1 (:x add)))) => this
                    (let [
                        #_"LoopBeginNode" loopNode (PhiNode''merge-1 (:x add))
                    ]
                        (when (and (not (LoopBeginNode''isSimpleLoop-1 loopNode)) (instance? ConstantNode (:y add))) => this
                            (let [
                                #_"int" addBy (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y add)))
                                this (assoc this :displacement (+ (:displacement this) (* (:value (:scale this)) addBy)))
                            ]
                                (Node''replaceFirstInput-3 this, (:index this), (:x add))
                                (SimplifierTool''addToWorkList-2 tool, (:index this))
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" AMD64AddressNode''generate-2 [#_"AMD64AddressNode" this, #_"LIRBuilder" builder]
        (let [
            #_"AllocatableValue" baseValue (if (some? (:base this)) (LIRGenerator''asAllocatable-2 (:gen builder), (LIRBuilder''operand-2 builder, (:base this))) Value/ILLEGAL)
            #_"AllocatableValue" indexValue (if (some? (:index this)) (LIRGenerator''asAllocatable-2 (:gen builder), (LIRBuilder''operand-2 builder, (:index this))) Value/ILLEGAL)
            #_"AllocatableValue" baseReference (LIRKind'derivedBaseFromValue-1 baseValue)
            #_"AllocatableValue" indexReference
                (cond
                    (nil? (:index this))           nil
                    (= (:scale this) Scale'Times1) (LIRKind'derivedBaseFromValue-1 indexValue)
                    (LIRKind'isValue-1 indexValue) nil
                    :else                          Value/ILLEGAL
                )
            #_"LIRKind" kind (LIRKind'combineDerived-3 (Stamp''getLIRKind-1 (:stamp this)), baseReference, indexReference)
        ]
            (LIRBuilder''setResult-3 builder, this, (AMD64AddressValue'new-5 kind, baseValue, indexValue, (:scale this), (:displacement this)))
        )
        nil
    )

    (§ override! #_"ValueNode" AMD64AddressNode''getBase-1 [#_"AMD64AddressNode" this]
        (:base this)
    )

    (§ method! #_"AMD64AddressNode" AMD64AddressNode''setBase-2 [#_"AMD64AddressNode" this, #_"ValueNode" base]
        ;; allow modification before inserting into the graph
        (when (Node''isAlive-1 this)
            (Node''updateUsages-3 this, (:base this), base)
        )
        (assoc this :base base)
    )

    (§ override! #_"ValueNode" AMD64AddressNode''getIndex-1 [#_"AMD64AddressNode" this]
        (:index this)
    )

    (§ method! #_"AMD64AddressNode" AMD64AddressNode''setIndex-2 [#_"AMD64AddressNode" this, #_"ValueNode" index]
        ;; allow modification before inserting into the graph
        (when (Node''isAlive-1 this)
            (Node''updateUsages-3 this, (:index this), index)
        )
        (assoc this :index index)
    )

    (§ method! #_"AMD64AddressNode" AMD64AddressNode''setScale-2 [#_"AMD64AddressNode" this, #_"Scale" scale]
        (assoc this :scale scale)
    )

    (§ method! #_"AMD64AddressNode" AMD64AddressNode''setDisplacement-2 [#_"AMD64AddressNode" this, #_"int" displacement]
        (assoc this :displacement displacement)
    )

    #_unused
    (§ override! #_"long" AMD64AddressNode''getMaxConstantDisplacement-1 [#_"AMD64AddressNode" this]
        (:displacement this)
    )

    #_unused
    (§ override! #_"void" AMD64AddressNode''simplify-2 [#_"AMD64AddressNode" this, #_"SimplifierTool" tool]
        (§ ass! this (AMD64AddressNode''canonicalizeIndex-2 this, tool))
        nil
    )
)

(final-ns AddressLowering
    (def- #_"int" AddressLowering'ADDRESS_BITS 64)
    (def- #_"int" AddressLowering'INT_BITS 32)

    #_unused
    (§ defn- #_"boolean" AddressLowering'checkAddressBitWidth-1 [#_"ValueNode" value]
        (or (nil? value) (instance? AbstractPointerStamp (:stamp value)) (= (PrimitiveStamp'getBits-1 (:stamp value)) AddressLowering'ADDRESS_BITS))
    )

    (§ final #_"long" :heapBase 0)
    (§ final #_"Register" :heapBaseRegister nil)

    (§ defn #_"AddressLowering" AddressLowering'new-1 [#_"Register" heapBaseRegister]
        (let [
            #_"AddressLowering" this (Object.)
            this (assoc this :heapBase (:base HotSpot'oopEncoding))
            this (assoc this :heapBaseRegister (if (zero? (:heapBase this)) nil heapBaseRegister))
        ]
            this
        )
    )

    (§ defn- #_"ValueNode" AddressLowering'improveInput-4 [#_"AMD64AddressNode" address, #_"ValueNode" node, #_"int" shift, #_"boolean" negateExtractedDisplacement]
        (when (some? node)
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 node)
            ]
                (cond
                    (some? constant)
                        (AddressLowering'improveConstDisp-6 address, node, constant, nil, shift, negateExtractedDisplacement)
                    ;; we can't swallow zero-extends because of multiple reasons:
                    ;;
                    ;; (a) we might encounter something like the following: ZeroExtend(Add(negativeValue,
                    ;; positiveValue)). if we swallow the zero-extend in this case and subsequently
                    ;; optimize the add, we might end up with a negative value that has less than 64
                    ;; bits in base or index. such a value would require sign extension instead of
                    ;; zero-extension but the backend can only do (implicit) zero-extension by using a
                    ;; larger register (e.g. rax instead of eax).
                    ;;
                    ;; (b) our backend does not guarantee that the upper half of a 64-bit register equals
                    ;; 0 if a 32-bit value is stored in there.
                    ;;
                    ;; (c) we also can't swallow zero-extends with less than 32 bits as most of these
                    ;; values are immediately sign-extended to 32 bit by the backend (therefore, the
                    ;; subsequent implicit zero-extension to 64 bit won't do what we expect).
                    (and (instance? IntegerStamp (:stamp node)) (instance? AddNode node))
                        (cond
                            (instance? ConstantNode (:x node))
                                (AddressLowering'improveConstDisp-6 address, node, (ValueNode''asJavaConstant-1 (:x node)), (:y node), shift, negateExtractedDisplacement)
                            (instance? ConstantNode (:y node))
                                (AddressLowering'improveConstDisp-6 address, node, (ValueNode''asJavaConstant-1 (:y node)), (:x node), shift, negateExtractedDisplacement)
                            :else
                                node
                        )
                    :else
                        node
                )
            )
        )
    )

    (§ defn- #_"ValueNode" AddressLowering'improveConstDisp-6 [#_"AMD64AddressNode" address, #_"ValueNode" original, #_"JavaConstant" constant, #_"ValueNode" other, #_"int" shift, #_"boolean" negateExtractedDisplacement]
        (when (#_"JavaKind" .isNumericInteger (#_"JavaConstant" .getJavaKind constant)) => original
            (when (AddressLowering'updateDisplacement-3 address, (<< (#_"JavaConstant" .asLong constant) shift), negateExtractedDisplacement) => original
                other
            )
        )
    )

    (§ defn #_"boolean" AddressLowering'updateDisplacement-3 [#_"AMD64AddressNode" address, #_"long" displacementDelta, #_"boolean" negateDelta]
        (let [
            #_"long" disp (+ (:displacement address) (* displacementDelta (if negateDelta -1 1)))
        ]
            (and (NumUtil'isInt-1 disp)
                (do
                    (§ ass! address (AMD64AddressNode''setDisplacement-2 address, (int disp)))
                    true
                )
            )
        )
    )

    (§ defn- #_"ValueNode" AddressLowering'considerNegation-3 [#_"Graph" graph, #_"ValueNode" value, #_"boolean" negate?]
        (if (and negate? (some? value)) (Graph''maybeAddOrUnique-2 graph, (NegateNode'create-1 value)) value)
    )

    (§ method- #_"boolean" AddressLowering''improveNegation-5 [#_"AddressLowering" this, #_"Graph" graph, #_"AMD64AddressNode" addr, #_"boolean" o'baseNegated, #_"boolean" o'indexNegated]
        (let [
            #_"ValueNode" o'base (AMD64AddressNode''getBase-1 addr)
            #_"ValueNode" o'index (AMD64AddressNode''getIndex-1 addr)
            #_"boolean" baseNegated o'baseNegated
            #_"boolean" indexNegated o'indexNegated
            [baseNegated indexNegated]
                (when (instance? NegateNode (AMD64AddressNode''getBase-1 addr)) => [baseNegated indexNegated]
                    (§ ass! addr (AMD64AddressNode''setBase-2 addr, (UnaryNode''getValue-1 (AMD64AddressNode''getBase-1 addr))))
                    [(not baseNegated) indexNegated]
                )
            [baseNegated indexNegated]
                (when (instance? NegateNode (AMD64AddressNode''getIndex-1 addr)) => [baseNegated indexNegated]
                    (§ ass! addr (AMD64AddressNode''setIndex-2 addr, (UnaryNode''getValue-1 (AMD64AddressNode''getIndex-1 addr))))
                    [baseNegated (not indexNegated)]
                )
        ]
            (and (not (and (= baseNegated o'baseNegated) (= indexNegated o'indexNegated)))
                (let [
                    #_"ValueNode" base (AMD64AddressNode''getBase-1 addr)
                    #_"ValueNode" index (AMD64AddressNode''getIndex-1 addr)
                    #_"boolean" improved? (AddressLowering''improve-5 this, graph, addr, baseNegated, indexNegated)
                ]
                    (when-not (= baseNegated o'baseNegated)
                        (cond
                            (= base (AMD64AddressNode''getBase-1 addr))
                                (§ ass! addr (AMD64AddressNode''setBase-2 addr, o'base))
                            (some? (AMD64AddressNode''getBase-1 addr))
                                (§ ass! addr (AMD64AddressNode''setBase-2 addr, (Graph''maybeAddOrUnique-2 graph, (NegateNode'create-1 (AMD64AddressNode''getBase-1 addr)))))
                        )
                    )
                    (when-not (= indexNegated o'indexNegated)
                        (cond
                            (= index (AMD64AddressNode''getIndex-1 addr))
                                (§ ass! addr (AMD64AddressNode''setIndex-2 addr, o'index))
                            (some? (AMD64AddressNode''getIndex-1 addr))
                                (§ ass! addr (AMD64AddressNode''setIndex-2 addr, (Graph''maybeAddOrUnique-2 graph, (NegateNode'create-1 (AMD64AddressNode''getIndex-1 addr)))))
                        )
                    )
                    improved?
                )
            )
        )
    )

    (§ method! #_"boolean" AddressLowering''improveUncompression-4 [#_"AddressLowering" this, #_"AMD64AddressNode" addr, #_"CompressionNode" compression, #_"ValueNode" other]
        (let [
            #_"CompressEncoding" encoding (CompressionNode''getEncoding-1 compression)
            #_"Scale" scale (Scale'fromShift-1 (:shift encoding))
        ]
            (and (some? scale)
                (cond
                    (and (some? (:heapBaseRegister this)) (= (:base encoding) (:heapBase this)))
                        (and (nil? other)
                            (do
                                (§ ass! addr (AMD64AddressNode''setBase-2 addr, (Graph''add-2 (:graph compression), (HeapBaseNode'new-1 (:heapBaseRegister this)))))
                                true
                            )
                        )
                    (not (zero? (:base encoding)))
                        (and (AddressLowering'updateDisplacement-3 addr, (:base encoding), false)
                            (do
                                (§ ass! addr (AMD64AddressNode''setBase-2 addr, other))
                                true
                            )
                        )
                    :else
                        (do
                            (§ ass! addr (AMD64AddressNode''setBase-2 addr, other))
                            true
                        )
                )
                (do
                    (§ ass! addr (AMD64AddressNode''setScale-2 addr, scale))
                    (§ ass! addr (AMD64AddressNode''setIndex-2 addr, (UnaryNode''getValue-1 compression)))
                    true
                )
            )
        )
    )

    (§ method- #_"boolean" AddressLowering''tryToImproveUncompression-4 [#_"AddressLowering" this, #_"AMD64AddressNode" addr, #_"ValueNode" value, #_"ValueNode" other]
        (and (instance? CompressionNode value) (= (CompressionNode''getOp-1 value) CompressionOp'Uncompress)
            (AddressLowering''improveUncompression-4 this, addr, value, other)
        )
    )

    ;;;
     ; Tries to optimize addresses so that they match the AMD64-specific addressing mode better (base + index * scale + displacement).
     ;
     ; @param addr the address that should be optimized
     ; @param isBaseNegated determines if the address base is negated - if so, all values that are extracted from the base will be negated as well
     ; @param isIndexNegated determines if the index is negated - if so, all values that are extracted from the index will be negated as well
     ; @return true if the address was modified
     ;;
    (§ method! #_"boolean" AddressLowering''improve-5 [#_"AddressLowering" this, #_"Graph" graph, #_"AMD64AddressNode" addr, #_"boolean" isBaseNegated, #_"boolean" isIndexNegated]
        (let [
            #_"ValueNode" base (AMD64AddressNode''getBase-1 addr)
            #_"ValueNode" index (AMD64AddressNode''getIndex-1 addr)
        ]
            (or
                (let [
                    #_"ValueNode" newBase (AddressLowering'improveInput-4 addr, base, 0, isBaseNegated)
                ]
                    (and (not= newBase base)
                        (do
                            (§ ass! addr (AMD64AddressNode''setBase-2 addr, newBase))
                            true
                        )
                    )
                )

                (let [
                    #_"ValueNode" newIndex (AddressLowering'improveInput-4 addr, index, (:shift (:scale addr)), isIndexNegated)
                ]
                    (and (not= newIndex index)
                        (do
                            (§ ass! addr (AMD64AddressNode''setIndex-2 addr, newIndex))
                            true
                        )
                    )
                )

                (and (instance? LeftShiftNode index) (instance? ConstantNode (:y index))
                    (let [
                        #_"int" amount (+ (:shift (:scale addr)) (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y index))))
                        #_"Scale" scale (Scale'fromShift-1 amount)
                    ]
                        (and (some? scale)
                            (do
                                (§ ass! addr (AMD64AddressNode''setIndex-2 addr, (:x index)))
                                (§ ass! addr (AMD64AddressNode''setScale-2 addr, scale))
                                true
                            )
                        )
                    )
                )

                (and (= (:scale addr) Scale'Times1)
                    (or
                        (and (nil? index) (instance? AddNode base)
                            (do
                                (§ ass! addr (AMD64AddressNode''setBase-2 addr, (:x base)))
                                (§ ass! addr (AMD64AddressNode''setIndex-2 addr, (AddressLowering'considerNegation-3 graph, (:y base), isBaseNegated)))
                                true
                            )
                        )

                        (and (nil? base) (instance? AddNode index)
                            (do
                                (§ ass! addr (AMD64AddressNode''setBase-2 addr, (AddressLowering'considerNegation-3 graph, (:x index), isIndexNegated)))
                                (§ ass! addr (AMD64AddressNode''setIndex-2 addr, (:y index)))
                                true
                            )
                        )

                        (and (instance? LeftShiftNode base) (not (instance? LeftShiftNode index))
                            (do
                                (§ ass! addr (AMD64AddressNode''setBase-2 addr, (AddressLowering'considerNegation-3 graph, index, (not= isIndexNegated isBaseNegated))))
                                (§ ass! addr (AMD64AddressNode''setIndex-2 addr, (AddressLowering'considerNegation-3 graph, base, (not= isIndexNegated isBaseNegated))))
                                true
                            )
                        )
                    )
                )

                (AddressLowering''improveNegation-5 this, graph, addr, isBaseNegated, isIndexNegated)

                (and (not isBaseNegated) (not isIndexNegated) (= (:scale addr) Scale'Times1)
                    (or (AddressLowering''tryToImproveUncompression-4 this, addr, index, base)
                        (AddressLowering''tryToImproveUncompression-4 this, addr, base, index)
                    )
                )
            )
        )
    )

    (§ method! #_"AddressNode" AddressLowering''lower-3 [#_"AddressLowering" this, #_"ValueNode" base, #_"ValueNode" offset]
        (let [
            #_"AMD64AddressNode" addr (AMD64AddressNode'new-2 base, offset)
        ]
            (while (AddressLowering''improve-5 this, (:graph base), addr, false, false)
                nil
            )
            (Graph''add-2 (:graph base), addr)
        )
    )

    (§ defn- #_"void" AddressLowering'tryOptimize-2 [#_"OffsetAddressNode" offsetAddress, #_"LoopEx" loop]
        (loop-when [#_"InductionVariable" iv (get (LoopEx''getInductionVariables-1 loop) (:offset offsetAddress))] (some? iv)
            (when (instance? DerivedInductionVariable iv)
                (let [
                    #_"ValueNode" value (InductionVariable''valueNode-1 iv)
                ]
                    (when-not (Node''isDeleted-1 value)
                        (when (and (instance? ZeroExtendNode value) (AddressLowering'applicableToImplicitZeroExtend-1 value))
                            (let [
                                #_"ValueNode" input (UnaryNode''getValue-1 value)
                            ]
                                (when (instance? AddNode input)
                                    (cond
                                        (instance? ConstantNode (:x input)) (AddressLowering'optimizeAdd-4 value, (:x input), (:y input), loop)
                                        (instance? ConstantNode (:y input)) (AddressLowering'optimizeAdd-4 value, (:y input), (:x input), loop)
                                    )
                                )
                            )
                        )
                        (recur (DerivedInductionVariable''getBase-1 iv))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Given that Add(a, cst) is always positive, performs the following: ZeroExtend(Add(a, cst)) -> Add(SignExtend(a), SignExtend(cst)).
     ;;
    (§ defn- #_"void" AddressLowering'optimizeAdd-4 [#_"ZeroExtendNode" node, #_"ConstantNode" constant, #_"ValueNode" other, #_"LoopEx" loop]
        (§ ass! node (Node''replaceAtUsages-2 node, (Graph''add-2 (:graph node), (AddNode'new-2 (AddressLowering'signExtend-2 other, loop), (ConstantNode'forLong-2 (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 constant)), (:graph node))))))
        nil
    )

    ;;;
     ; Create a sign extend for {@code input}, or zero extend if {@code input} can be proven positive.
     ;;
    (§ defn- #_"ValueNode" AddressLowering'signExtend-2 [#_"ValueNode" input, #_"LoopEx" loop]
        (let [
            #_"Graph" graph (:graph input)
        ]
            (when (instance? PhiNode input)
                (let [
                    #_"EconomicMap<Node, InductionVariable>" ivs (LoopEx''getInductionVariables-1 loop)
                    #_"InductionVariable" inductionVariable (get ivs input)
                ]
                    (when (and (some? inductionVariable) (instance? BasicInductionVariable inductionVariable))
                        (let [
                            #_"CountedLoopInfo" countedLoopInfo (:counted loop)
                            #_"IntegerStamp" initStamp (:stamp (InductionVariable''initNode-1 inductionVariable))
                        ]
                            (when (IntegerStamp''isPositive-1 initStamp)
                                (when (InductionVariable''isConstantExtremum-1 inductionVariable)
                                    (let [
                                        #_"long" init (InductionVariable''constantInit-1 inductionVariable)
                                        #_"long" stride (InductionVariable''constantStride-1 inductionVariable)
                                        #_"long" extremum (InductionVariable''constantExtremum-1 inductionVariable)
                                    ]
                                        (when (and (<= 0 init) (<= 0 extremum))
                                            (let [
                                                #_"long" shortestTrip (inc (quot (- extremum init) stride))
                                            ]
                                                (when (= (CountedLoopInfo''constantMaxTripCount-1 countedLoopInfo) shortestTrip)
                                                    (§ return (Graph''add-2 graph, (ZeroExtendNode'new-4 input, AddressLowering'INT_BITS, AddressLowering'ADDRESS_BITS, true)))
                                                )
                                            )
                                        )
                                    )
                                )
                                (when (and (= (:iv countedLoopInfo) inductionVariable) (= (InductionVariable''direction-1 inductionVariable) :Direction'Up) (some? (CountedLoopInfo''getOverFlowGuard-1 countedLoopInfo)))
                                    (§ return (Graph''add-2 graph, (ZeroExtendNode'new-4 input, AddressLowering'INT_BITS, AddressLowering'ADDRESS_BITS, true)))
                                )
                            )
                        )
                    )
                )
            )
            (Graph''maybeAddOrUnique-2 (:graph input), (SignExtendNode'create-2 input, AddressLowering'ADDRESS_BITS))
        )
    )

    (§ defn- #_"boolean" AddressLowering'applicableToImplicitZeroExtend-1 [#_"ZeroExtendNode" node]
        (and (:inputAlwaysPositive node) (= (IntegerConvertNode''getInputBits-1 node) AddressLowering'INT_BITS) (= (IntegerConvertNode''getResultBits-1 node) AddressLowering'ADDRESS_BITS))
    )

    (§ defn- #_"ValueNode" AddressLowering'tryImplicitZeroExtend-1 [#_"ValueNode" input]
        (when (and (instance? ZeroExtendNode input) (AddressLowering'applicableToImplicitZeroExtend-1 input)) => input
            (UnaryNode''getValue-1 input)
        )
    )

    (§ method! #_"void" AddressLowering''preProcess-2 [#_"AddressLowering" this, #_"Graph" graph]
        (when (Graph''hasLoops-1 graph)
            (let [
                #_"LoopsData" loopsData (LoopsData'new-1 graph)
            ]
                (LoopsData''detectedCountedLoops-1 loopsData)
                (doseq [#_"LoopEx" loop (LoopsData''countedLoops-1 loopsData)]
                    (doseq [#_"OffsetAddressNode" offsetAdressNode (NodeIterable''filter-2 (LoopFragmentWhole''nodes-1 (LoopEx''whole-1 loop)), OffsetAddressNode)]
                        (AddressLowering'tryOptimize-2 offsetAdressNode, loop)
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" AddressLowering''postProcess-2 [#_"AddressLowering" this, #_"AddressNode" lowered]
        ;; Allow implicit zero extend for always positive input. This assumes
        ;; that the upper bits of the operand is zero out by the backend.
        (§ ass! lowered (AMD64AddressNode''setBase-2 lowered, (AddressLowering'tryImplicitZeroExtend-1 (AMD64AddressNode''getBase-1 lowered))))
        (§ ass! lowered (AMD64AddressNode''setIndex-2 lowered, (AddressLowering'tryImplicitZeroExtend-1 (AMD64AddressNode''getIndex-1 lowered))))
        nil
    )
)

;;;
 ; @anno AddressLowering.HeapBaseNode
 ;;
(final-ns HeapBaseNode (§ extends FloatingNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<HeapBaseNode>" HeapBaseNode'TYPE (NodeClass'create-1 HeapBaseNode))

    (§ final #_"Register" :heapBaseRegister nil)

    (§ defn #_"HeapBaseNode" HeapBaseNode'new-1 [#_"Register" heapBaseRegister]
        (let [
            #_"HeapBaseNode" this (FloatingNode'new-2 HeapBaseNode'TYPE, StampFactory'rawPointer)
            this (assoc this :heapBaseRegister heapBaseRegister)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" HeapBaseNode''generate-2 [#_"HeapBaseNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (#_"Register" .asValue (:heapBaseRegister this), (Stamp''getLIRKind-1 (:stamp this))))
        nil
    )
)

(value-ns LIRKindTool
    ;;;
     ; Get an architecture specific integer kind of a certain size.
     ;;
    (§ defn #_"LIRKind" LIRKindTool'getIntegerKind-1 [#_"int" bits]
        (LIRKind'value-1
            (cond
                (<= bits 8)  AMD64Kind/BYTE
                (<= bits 16) AMD64Kind/WORD
                (<= bits 32) AMD64Kind/DWORD
                :else        AMD64Kind/QWORD
            )
        )
    )

    ;;;
     ; Get the architecture specific kind used to represent Java objects.
     ;;
    (§ defn #_"LIRKind" LIRKindTool'getObjectKind-0 []
        (LIRKind'reference-1 AMD64Kind/QWORD)
    )

    ;;;
     ; Get the architecture specific kind pointer-sized integer kind.
     ;;
    (§ defn #_"LIRKind" LIRKindTool'getWordKind-0 []
        (LIRKind'value-1 AMD64Kind/QWORD)
    )

    ;;;
     ; Get the platform specific kind used to represent compressed oops.
     ;;
    (§ defn #_"LIRKind" LIRKindTool'getNarrowOopKind-0 []
        (LIRKind'compressedReference-1 AMD64Kind/DWORD)
    )

    ;;;
     ; Gets the platform specific kind used to represent compressed metaspace pointers.
     ;;
    (§ defn #_"LIRKind" LIRKindTool'getNarrowPointerKind-0 []
        (LIRKind'value-1 AMD64Kind/DWORD)
    )
)

;;;
 ; Factory for creating moves.
 ;;
(final-ns MoveFactory
    (§ final #_"BackupSlotProvider" :backupSlotProvider nil)

    (§ defn #_"MoveFactory" MoveFactory'new-1 [#_"BackupSlotProvider" backupSlotProvider]
        (let [
            #_"MoveFactory" this (Object.)
            this (assoc this :backupSlotProvider backupSlotProvider)
        ]
            this
        )
    )

    ;;;
     ; Checks whether the supplied constant can be used without loading it into a register for
     ; most operations, i.e. for commonly used arithmetic, logical, and comparison operations.
     ;
     ; @return true if the constant can be used directly, false if the constant needs to be in a register
     ;;
    (§ method! #_"boolean" MoveFactory''canInlineConstant-2 [#_"MoveFactory" this, #_"Constant" constant]
        (or (= constant HotSpotCompressedNullConstant/COMPRESSED_NULL)
            (condp instance? constant
                HotSpotObjectConstant    (KlassPointerStamp''isCompressed-1 constant)
                HotSpotMetaspaceConstant (KlassPointerStamp''isCompressed-1 constant)
                JavaConstant
                    (condp = (#_"JavaConstant" .getJavaKind constant)
                        JavaKind/Long   (NumUtil'isInt-1 (#_"JavaConstant" .asLong constant))
                        JavaKind/Object (#_"JavaConstant" .isNull constant)
                        true
                    )
                false
            )
        )
    )

    ;;;
     ; @param constant The constant that might be moved to a stack slot.
     ; @return true if constant to stack moves are supported for this constant
     ;;
    #_unused
    (§ method! #_"boolean" MoveFactory''allowConstantToStackMove-2 [#_"MoveFactory" this, #_"Constant" constant]
        (condp instance? constant
            HotSpotConstant     (#_"HotSpotConstant" .isCompressed constant)
            DataPointerConstant false
            JavaConstant        (AMD64Move'canMoveConst2Stack-1 constant)
                                true
        )
    )

    (§ method! #_"LIRInstruction" MoveFactory''createMove-3 [#_"MoveFactory" this, #_"AllocatableValue" dst, #_"Value" src]
        (cond
            (instance? AMD64AddressValue src)                                        (LeaOp'new-3 dst, src, OperandSize'QWORD)
            (instance? ConstantValue src)                                            (MoveFactory''createLoad-3 this, dst, (:constant src))
            (or (instance? RegisterValue src) (LIRValueUtil'isStackSlotValue-1 dst)) (MoveFromRegOp'new-3 (#_"AllocatableValue" .getPlatformKind dst), dst, src)
            :else                                                                    (MoveToRegOp'new-3 (#_"AllocatableValue" .getPlatformKind dst), dst, src)
        )
    )

    (§ method! #_"LIRInstruction" MoveFactory''createStackMove-3 [#_"MoveFactory" this, #_"AllocatableValue" result, #_"AllocatableValue" input]
        (case (#_"AMD64Kind" .getSizeInBytes (#_"AllocatableValue" .getPlatformKind result))
            2 (AMD64PushPopStackMove'new-3 OperandSize'WORD, result, input)
            8 (AMD64PushPopStackMove'new-3 OperandSize'QWORD, result, input)
            (let [
                #_"RegisterBackupPair" backup (BackupSlotProvider''getScratchRegister-2 (:backupSlotProvider this), (#_"AllocatableValue" .getPlatformKind input))
            ]
                (AMD64StackMove'new-4 result, input, (:register backup), (:backupSlot backup))
            )
        )
    )

    (§ defn- #_"LIRInstruction" MoveFactory'createLoad-2 [#_"AllocatableValue" dst, #_"Constant" src]
        (condp instance? src
            JavaConstant        (MoveFromConstOp'new-2 dst, src)
            DataPointerConstant (LeaDataOp'new-2 dst, src)
        )
    )

    (§ method! #_"LIRInstruction" MoveFactory''createLoad-3 [#_"MoveFactory" this, #_"AllocatableValue" dst, #_"Constant" src]
        (when-not (= src HotSpotCompressedNullConstant/COMPRESSED_NULL) => (MoveFactory'createLoad-2 dst, JavaConstant/INT_0)
            (condp instance? src
                HotSpotObjectConstant    (HotSpotLoadObjectConstantOp'new-2 dst, src)
                HotSpotMetaspaceConstant (HotSpotLoadMetaspaceConstantOp'new-2 dst, src)
                                         (MoveFactory'createLoad-2 dst, src)
            )
        )
    )

    (§ defn- #_"LIRInstruction" MoveFactory'createStackLoad-2 [#_"AllocatableValue" dst, #_"Constant" src]
        (condp instance? src
            JavaConstant (MoveFromConstOp'new-2 dst, src)
        )
    )

    (§ method! #_"LIRInstruction" MoveFactory''createStackLoad-3 [#_"MoveFactory" this, #_"AllocatableValue" dst, #_"Constant" src]
        (when-not (= src HotSpotCompressedNullConstant/COMPRESSED_NULL) => (MoveFactory'createStackLoad-2 dst, JavaConstant/INT_0)
            (condp instance? src
                HotSpotObjectConstant    (HotSpotLoadObjectConstantOp'new-2 dst, src)
                HotSpotMetaspaceConstant (HotSpotLoadMetaspaceConstantOp'new-2 dst, src)
                                         (MoveFactory'createStackLoad-2 dst, src)
            )
        )
    )
)

;;;
 ; @anno MoveFactory.RegisterBackupPair
 ;;
(final-ns RegisterBackupPair
    (§ final #_"Register" :register nil)
    (§ final #_"VirtualStackSlot" :backupSlot nil)

    (§ defn #_"RegisterBackupPair" RegisterBackupPair'new-2 [#_"Register" register, #_"VirtualStackSlot" backupSlot]
        (let [
            #_"RegisterBackupPair" this (Object.)
            this (assoc this :register register)
            this (assoc this :backupSlot backupSlot)
        ]
            this
        )
    )
)

;;;
 ; @anno MoveFactory.BackupSlotProvider
 ;;
(final-ns BackupSlotProvider
    (§ final #_"FrameMapBuilder" :frameMapBuilder nil)

    (§ final #_"EconomicMap<PlatformKind$Key, RegisterBackupPair>" :categorized (EconomicMap/create Equivalence/DEFAULT))

    (§ defn #_"BackupSlotProvider" BackupSlotProvider'new-1 [#_"FrameMapBuilder" frameMapBuilder]
        (let [
            #_"BackupSlotProvider" this (Object.)
            this (assoc this :frameMapBuilder frameMapBuilder)
        ]
            this
        )
    )

    (§ method! #_"RegisterBackupPair" BackupSlotProvider''getScratchRegister-2 [#_"BackupSlotProvider" this, #_"PlatformKind" kind]
        (let [
            #_"PlatformKind$Key" key (#_"PlatformKind" .getKey kind)
        ]
            (or (get (:categorized this) key)
                (let [
                    #_"RegisterArray" available (#_"RegisterConfig" .filterAllocatableRegisters HotSpot'registerConfig, kind, (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig))
                    #_"Register" scratch (#_"RegisterArray" .get available, 0)
                    #_"LIRKind" largest (LIRKind'value-1 (#_"Architecture" .getLargestStorableKind (.arch HotSpot'target), (#_"Register" .getRegisterCategory scratch)))
                    #_"VirtualStackSlot" backup (FrameMapBuilder''allocateSpillSlot-2 (:frameMapBuilder this), largest)
                    #_"RegisterBackupPair" value (RegisterBackupPair'new-2 scratch, backup)
                ]
                    (#_"EconomicMap" .put (:categorized this), key, value)
                    value
                )
            )
        )
    )
)

;;;
 ; Computes an ordering of the block that can be used by the linear scan register allocator and the
 ; machine code generator. The machine code generation order will start with the first block and
 ; produce a straight sequence always following the most likely successor. Then it will continue
 ; with the most likely path that was left out during this process. The process iteratively
 ; continues until all blocks are scheduled. Additionally, it is guaranteed that all blocks of a
 ; loop are scheduled before any block following the loop is scheduled.
 ;
 ; The machine code generator order includes reordering of loop headers such that the backward jump
 ; is a conditional jump if there is only one loop end block. Additionally, the target of loop
 ; backward jumps are always marked as aligned. Aligning the target of conditional jumps does not
 ; bring a measurable benefit and is therefore avoided to keep the code size small.
 ;
 ; The linear scan register allocator order has an additional mechanism that prevents merge nodes
 ; from being scheduled if there is at least one highly likely predecessor still unscheduled. This
 ; increases the probability that the merge node and the corresponding predecessor are more closely
 ; together in the schedule thus decreasing the probability for inserted phi moves. Also, the
 ; algorithm sets the linear scan order number of the block that corresponds to its index in the
 ; linear scan order.
 ;;
(value-ns ComputeBlockOrder
    ;;;
     ; The initial capacities of the worklists used for iteratively finding the block order.
     ;;
    (def- #_"int" ComputeBlockOrder'INITIAL_WORKLIST_CAPACITY 10)

    ;;;
     ; Divisor used for degrading the probability of the current path versus unscheduled paths at
     ; a merge node when calculating the linear scan order. A high value means that predecessors
     ; of merge nodes are more likely to be scheduled before the merge node.
     ;;
    (def- #_"int" ComputeBlockOrder'PENALTY_VERSUS_UNSCHEDULED 10)

    ;;;
     ; Find the highest likely unvisited successor block of a given block.
     ;;
    (§ defn- #_"Block" ComputeBlockOrder'findAndMarkMostLikelySuccessor-2 [#_"Block" block, #_"BitSet" visitedBlocks]
        (let [
            #_"Block" result
                (loop-when [result nil #_"ISeq" s (seq (:successors block))] (some? s) => result
                    (let [
                        #_"Block" successor (first s)
                        result
                            (when (and (not (#_"BitSet" .get visitedBlocks, (:id successor))) (<= (Block''getLoopDepth-1 block) (Block''getLoopDepth-1 successor)) (or (nil? result) (<= (:probability result) (:probability successor)))) => result
                                successor
                            )
                    ]
                        (recur result (next s))
                    )
                )
        ]
            (when (some? result)
                (#_"BitSet" .set visitedBlocks, (:id result))
            )
            result
        )
    )

    ;;;
     ; Add successor blocks into the given work list if they are not already marked as visited.
     ;;
    (§ defn- #_"void" ComputeBlockOrder'enqueueSuccessors-3 [#_"Block" block, #_"PriorityQueue<Block>" worklist, #_"BitSet" visitedBlocks]
        (doseq [#_"Block" successor (:successors block)]
            (when-not (#_"BitSet" .get visitedBlocks, (:id successor))
                (#_"BitSet" .set visitedBlocks, (:id successor))
                (#_"PriorityQueue" .add worklist, successor)
            )
        )
        nil
    )

    ;;;
     ; Add a linear path to the linear scan order greedily following the most likely successor.
     ;;
    (§ defn- #_"Block" ComputeBlockOrder'addPathToLinearScanOrder-4 [#_"Block" block, #_"List<Block>" order, #_"PriorityQueue<Block>" worklist, #_"BitSet" visitedBlocks]
        (§ ass! block (Block''setLinearScanNumber-2 block, (count order)))
        (#_"List" .add order, block)
        (let [
            #_"Block" mostLikelySuccessor (ComputeBlockOrder'findAndMarkMostLikelySuccessor-2 block, visitedBlocks)
        ]
            (ComputeBlockOrder'enqueueSuccessors-3 block, worklist, visitedBlocks)
            (when (and (some? mostLikelySuccessor) (not (Block''isLoopHeader-1 mostLikelySuccessor)) (< 1 (count (:predecessors mostLikelySuccessor)))) => mostLikelySuccessor
                ;; We are at a merge. Check probabilities of predecessors that are not yet scheduled.
                (let [
                    #_"double" unscheduledSum
                        (loop-when [unscheduledSum 0.0 #_"ISeq" s (seq (:predecessors mostLikelySuccessor))] (some? s) => unscheduledSum
                            (let [
                                #_"Block" pred (first s)
                                unscheduledSum
                                    (when (= (:linearScanNumber pred) -1) => unscheduledSum
                                        (+ unscheduledSum (:probability pred))
                                    )
                            ]
                                (recur unscheduledSum (next s))
                            )
                        )
                ]
                    (when (< (/ (:probability block) ComputeBlockOrder'PENALTY_VERSUS_UNSCHEDULED) unscheduledSum) => mostLikelySuccessor
                        ;; Add this merge only after at least one additional predecessor gets scheduled.
                        (#_"BitSet" .clear visitedBlocks, (:id mostLikelySuccessor))
                        nil
                    )
                )
            )
        )
    )

    ;;;
     ; Iteratively adds paths to the linear scan block order.
     ;;
    (§ defn- #_"void" ComputeBlockOrder'computeLinearScanOrder-3 [#_"List<Block>" order, #_"PriorityQueue<Block>" worklist, #_"BitSet" visitedBlocks]
        (while (seq worklist)
            (loop [#_"Block" path (#_"PriorityQueue" .poll worklist)]
                (let [
                    path (ComputeBlockOrder'addPathToLinearScanOrder-4 path, order, worklist, visitedBlocks)
                ]
                    (recur-if (some? path) [path])
                )
            )
        )
        nil
    )

    ;;;
     ; Initializes the priority queue used for the work list of blocks and adds the start block.
     ;;
    (§ defn- #_"PriorityQueue<Block>" ComputeBlockOrder'initializeWorklist-2 [#_"Block" startBlock, #_"BitSet" visitedBlocks]
        (let [
            #_"PriorityQueue<Block>" result (PriorityQueue. ComputeBlockOrder'INITIAL_WORKLIST_CAPACITY, (BlockOrderComparator'new-0))
        ]
            (#_"PriorityQueue" .add result, startBlock)
            (#_"BitSet" .set visitedBlocks, (:id startBlock))
            result
        )
    )

    ;;;
     ; Computes the block order used for the linear scan register allocator.
     ;
     ; @return sorted list of blocks
     ;;
    (§ defn #_"Block[]" ComputeBlockOrder'computeLinearScanOrder-2 [#_"int" blockCount, #_"Block" startBlock]
        (let [
            #_"List<Block>" order (ArrayList.)
            #_"BitSet" visitedBlocks (BitSet. blockCount)
        ]
            (ComputeBlockOrder'computeLinearScanOrder-3 order, (ComputeBlockOrder'initializeWorklist-2 startBlock, visitedBlocks), visitedBlocks)
            (#_"List" .toArray order, (make-array Block 0))
        )
    )

    ;;;
     ; Skip the loop header block if the loop consists of more than one block and it has only a single loop end block.
     ;;
    (§ defn- #_"boolean" ComputeBlockOrder'skipLoopHeader-1 [#_"Block" block]
        (and (Block''isLoopHeader-1 block) (not (Block''isLoopEnd-1 block)) (= (Loop''numBackedges-1 (:loop block)) 1))
    )

    ;;;
     ; Add a linear path to the code emission order greedily following the most likely successor.
     ;;
    (§ defn- #_"void" ComputeBlockOrder'addPathToCodeEmittingOrder-4 [#_"Block" block, #_"List<Block>" order, #_"PriorityQueue<Block>" worklist, #_"BitSet" visitedBlocks]
        (loop-when [block block] (some? block)
            ;; Skip loop headers if there is only a single loop end block to make
            ;; the backward jump be a conditional jump.
            (when-not (ComputeBlockOrder'skipLoopHeader-1 block)
                ;; Align unskipped loop headers as they are the target of the backward jump.
                (when (Block''isLoopHeader-1 block)
                    (§ ass! block (Block''setAlign-2 block, true))
                )
                (#_"List" .add order, block)
            )

            (let [
                #_"Loop" loop (:loop block)
            ]
                (when (and (Block''isLoopEnd-1 block) (ComputeBlockOrder'skipLoopHeader-1 (:header loop)))
                    ;; This is the only loop end of a skipped loop header.
                    ;; Add the header immediately afterwards.
                    (#_"List" .add order, (:header loop))

                    ;; Make sure the loop successors of the loop header are aligned,
                    ;; as they are the target of the backward jump.
                    (doseq [#_"Block" successor (:successors (:header loop))]
                        (when (= (Block''getLoopDepth-1 successor) (Block''getLoopDepth-1 block))
                            (§ ass! successor (Block''setAlign-2 successor, true))
                        )
                    )
                )

                (let [
                    #_"Block" mostLikelySuccessor (ComputeBlockOrder'findAndMarkMostLikelySuccessor-2 block, visitedBlocks)
                ]
                    (ComputeBlockOrder'enqueueSuccessors-3 block, worklist, visitedBlocks)
                    (recur mostLikelySuccessor)
                )
            )
        )
        nil
    )

    ;;;
     ; Iteratively adds paths to the code emission block order.
     ;;
    (§ defn- #_"void" ComputeBlockOrder'computeCodeEmittingOrder-3 [#_"List<Block>" order, #_"PriorityQueue<Block>" worklist, #_"BitSet" visitedBlocks]
        (while (seq worklist)
            (ComputeBlockOrder'addPathToCodeEmittingOrder-4 (#_"PriorityQueue" .poll worklist), order, worklist, visitedBlocks)
        )
        nil
    )

    ;;;
     ; Computes the block order used for code emission.
     ;
     ; @return sorted list of blocks
     ;;
    (§ defn #_"Block[]" ComputeBlockOrder'computeCodeEmittingOrder-2 [#_"int" blockCount, #_"Block" startBlock]
        (let [
            #_"List<Block>" order (ArrayList.)
            #_"BitSet" visitedBlocks (BitSet. blockCount)
        ]
            (ComputeBlockOrder'computeCodeEmittingOrder-3 order, (ComputeBlockOrder'initializeWorklist-2 startBlock, visitedBlocks), visitedBlocks)
            (#_"List" .toArray order, (make-array Block 0))
        )
    )
)

;;;
 ; Comparator for sorting blocks based on loop depth and probability.
 ;
 ; @anno ComputeBlockOrder.BlockOrderComparator
 ;;
(final-ns BlockOrderComparator (§ implements Comparator #_"<Block>")
    (§ defn #_"BlockOrderComparator" BlockOrderComparator'new-0 []
        (Object.)
    )

    (§ def- #_"double" BlockOrderComparator'EPSILON 1e-6)

    #_unused
    (§ override! #_"int" BlockOrderComparator''compare-3 [#_"BlockOrderComparator" this, #_"Block" a, #_"Block" b]
        ;; Loop blocks before any loop exit block. The only exception are blocks that are (almost) impossible to reach.
        (when (and (< BlockOrderComparator'EPSILON (:probability a)) (< BlockOrderComparator'EPSILON (:probability b)))
            (let [
                #_"int" diff (- (Block''getLoopDepth-1 b) (Block''getLoopDepth-1 a))
            ]
                (when-not (zero? diff)
                    (§ return diff)
                )
            )
        )

        ;; Blocks with high probability before blocks with low probability.
        (if (< (:probability b) (:probability a)) -1 1)
    )
)

;;;
 ; Configuration for register allocation. This is different to RegisterConfig.
 ;;
(class-ns RegisterAllocationConfig
    (§ final #_"EconomicMap<PlatformKind$Key, AllocatableRegisters>" :categorized (EconomicMap/create Equivalence/DEFAULT))
    (§ mutable #_"RegisterArray" :cachedRegisters nil)

    (§ defn #_"RegisterAllocationConfig" RegisterAllocationConfig'new-0 []
        (Object.)
    )

    (§ method #_"RegisterArray" RegisterAllocationConfig''initAllocatable-2 [#_"RegisterAllocationConfig" this, #_"RegisterArray" registers]
        registers
    )

    ;;;
     ; Gets the set of registers that can be used by the register allocator for a value of a particular kind.
     ;;
    (§ method! #_"AllocatableRegisters" RegisterAllocationConfig''getAllocatableRegisters-2 [#_"RegisterAllocationConfig" this, #_"PlatformKind" kind]
        (let [
            #_"PlatformKind$Key" key (#_"PlatformKind" .getKey kind)
        ]
            (if (contains? (:categorized this) key)
                (get (:categorized this) key)
                (let [
                    #_"AllocatableRegisters" ret (RegisterAllocationConfig''createAllocatableRegisters-2 this, (#_"RegisterConfig" .filterAllocatableRegisters HotSpot'registerConfig, kind, (RegisterAllocationConfig''getAllocatableRegisters-1 this)))
                ]
                    (#_"EconomicMap" .put (:categorized this), key, ret)
                    ret
                )
            )
        )
    )

    ;;;
     ; Gets the {@link Register$RegisterCategory} for the given PlatformKind.
     ;;
    #_unused
    (§ method! #_"Register$RegisterCategory" RegisterAllocationConfig''getRegisterCategory-2 [#_"RegisterAllocationConfig" this, #_"PlatformKind" kind]
        (#_"Register" .getRegisterCategory (nth (:allocatableRegisters (RegisterAllocationConfig''getAllocatableRegisters-2 this, kind)) 0))
    )

    (§ method! #_"AllocatableRegisters" RegisterAllocationConfig''createAllocatableRegisters-2 [#_"RegisterAllocationConfig" this, #_"RegisterArray" registers]
        (loop-when [#_"int" min Integer/MAX_VALUE #_"int" max Integer/MIN_VALUE #_"ISeq" s (seq registers)] (some? s) => (AllocatableRegisters'new-3 registers, min, max)
            (let [
                #_"int" n (.number (first s))
            ]
                (recur (if (< n min) n min) (if (< max n) n max) (next s))
            )
        )
    )

    ;;;
     ; Gets the set of registers that can be used by the register allocator.
     ;;
    (§ method! #_"RegisterArray" RegisterAllocationConfig''getAllocatableRegisters-1 [#_"RegisterAllocationConfig" this]
        (when (nil? (:cachedRegisters this))
            (§ ass! this (assoc this :cachedRegisters (RegisterAllocationConfig''initAllocatable-2 this, (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig))))
        )
        (:cachedRegisters this)
    )
)

;;;
 ; @anno RegisterAllocationConfig.AllocatableRegisters
 ;;
(final-ns AllocatableRegisters
    (§ final #_"Register[]" :allocatableRegisters nil)
    (§ final #_"int" :minRegisterNumber 0)
    (§ final #_"int" :maxRegisterNumber 0)

    (§ defn #_"AllocatableRegisters" AllocatableRegisters'new-3 [#_"RegisterArray" allocatableRegisters, #_"int" minRegisterNumber, #_"int" maxRegisterNumber]
        (let [
            #_"AllocatableRegisters" this (Object.)
            this (assoc this :allocatableRegisters (#_"RegisterArray" .toArray allocatableRegisters))
            this (assoc this :minRegisterNumber minRegisterNumber)
            this (assoc this :maxRegisterNumber maxRegisterNumber)
        ]
            this
        )
    )
)

;;;
 ; Condition codes used in conditionals.
 ;;
(final-ns Condition
    (§ final #_"String" :operator nil)

    (§ defn- #_"Condition" Condition'new-1 [#_"String" operator]
        (let [
            #_"Condition" this (Object.)
            this (assoc this :operator operator)
        ]
            this
        )
    )

    (§ def #_"Condition" Condition'EQ (Condition'new-1 "=="))   ;; equal
    (§ def #_"Condition" Condition'NE (Condition'new-1 "!="))   ;; not equal
    (§ def #_"Condition" Condition'LT (Condition'new-1 "<"))    ;; signed less than
    (§ def #_"Condition" Condition'LE (Condition'new-1 "<="))   ;; signed less than or equal
    (§ def #_"Condition" Condition'GT (Condition'new-1 ">"))    ;; signed greater than
    (§ def #_"Condition" Condition'GE (Condition'new-1 ">="))   ;; signed greater than or equal
    (§ def #_"Condition" Condition'AE (Condition'new-1 "|>=|")) ;; unsigned greater than or equal ("above than or equal")
    (§ def #_"Condition" Condition'BE (Condition'new-1 "|<=|")) ;; unsigned less than or equal ("below than or equal")
    (§ def #_"Condition" Condition'AT (Condition'new-1 "|>|"))  ;; unsigned greater than ("above than")
    (§ def #_"Condition" Condition'BT (Condition'new-1 "|<|"))  ;; unsigned less than ("below than")

    (§ method! #_"CanonicalizedCondition" Condition''canonicalize-1 [#_"Condition" this]
        (let [
            #_"CanonicalCondition" canonicalCondition
                (condp =? this
                    [Condition'EQ Condition'NE]                           CanonicalCondition'EQ
                    [Condition'LT Condition'LE Condition'GT Condition'GE] CanonicalCondition'LT
                    [Condition'BT Condition'BE Condition'AT Condition'AE] CanonicalCondition'BT
                )
        ]
            (CanonicalizedCondition'new-3 canonicalCondition, (Condition''canonicalMirror-1 this), (Condition''canonicalNegate-1 this))
        )
    )

    ;;;
     ; Given a condition and its negation, this method returns true for one of the two and false
     ; for the other one. This can be used to keep comparisons in a canonical form.
     ;
     ; @return true if this condition is considered to be the canonical form, false otherwise
     ;;
    #_unused
    (§ method! #_"boolean" Condition''isCanonical-1 [#_"Condition" this]
        (condp = this
            Condition'EQ true
            Condition'NE false
            Condition'LT true
            Condition'LE false
            Condition'GT false
            Condition'GE false
            Condition'BT true
            Condition'BE false
            Condition'AT false
            Condition'AE false
        )
    )

    ;;;
     ; Returns true if the condition needs to be mirrored to get to a canonical condition. The
     ; result of the mirroring operation might still need to be negated to achieve a canonical form.
     ;;
    (§ method- #_"boolean" Condition''canonicalMirror-1 [#_"Condition" this]
        (condp = this
            Condition'EQ false
            Condition'NE false
            Condition'LT false
            Condition'LE true
            Condition'GT true
            Condition'GE false
            Condition'BT false
            Condition'BE true
            Condition'AT true
            Condition'AE false
        )
    )

    ;;;
     ; Returns true if the condition needs to be negated to get to a canonical condition. The result
     ; of the negation might still need to be mirrored to achieve a canonical form.
     ;;
    (§ method- #_"boolean" Condition''canonicalNegate-1 [#_"Condition" this]
        (condp = this
            Condition'EQ false
            Condition'NE true
            Condition'LT false
            Condition'LE true
            Condition'GT false
            Condition'GE true
            Condition'BT false
            Condition'BE true
            Condition'AT false
            Condition'AE true
        )
    )

    ;;;
     ; Negate this conditional.
     ;
     ; @return the condition that represents the negation
     ;;
    (§ method! #_"Condition" Condition''negate-1 [#_"Condition" this]
        (condp = this
            Condition'EQ Condition'NE
            Condition'NE Condition'EQ
            Condition'LT Condition'GE
            Condition'LE Condition'GT
            Condition'GT Condition'LE
            Condition'GE Condition'LT
            Condition'BT Condition'AE
            Condition'BE Condition'AT
            Condition'AT Condition'BE
            Condition'AE Condition'BT
        )
    )

    #_unused
    (§ method! #_"boolean" Condition''implies-2 [#_"Condition" this, #_"Condition" other]
        (condp = this
            other        true
            Condition'EQ (any = other Condition'LE Condition'GE Condition'BE Condition'AE)
            Condition'NE false
            Condition'LT (any = other Condition'LE Condition'NE)
            Condition'LE false
            Condition'GT (any = other Condition'GE Condition'NE)
            Condition'GE false
            Condition'BT (any = other Condition'BE Condition'NE)
            Condition'BE false
            Condition'AT (any = other Condition'AE Condition'NE)
            Condition'AE false
        )
    )

    ;;;
     ; Mirror this conditional (i.e. commute "a op b" to "b op' a")
     ;
     ; @return the condition representing the equivalent commuted operation
     ;;
    (§ method! #_"Condition" Condition''mirror-1 [#_"Condition" this]
        (condp = this
            Condition'EQ Condition'EQ
            Condition'NE Condition'NE
            Condition'LT Condition'GT
            Condition'LE Condition'GE
            Condition'GT Condition'LT
            Condition'GE Condition'LE
            Condition'BT Condition'AT
            Condition'BE Condition'AE
            Condition'AT Condition'BT
            Condition'AE Condition'BE
        )
    )

    ;;;
     ; Returns true if this condition represents an unsigned comparison.
     ; EQ and NE are not considered to be unsigned.
     ;;
    #_unused
    (§ method! #_"boolean" Condition''isUnsigned-1 [#_"Condition" this]
        (any = this Condition'BT Condition'BE Condition'AT Condition'AE)
    )

    ;;;
     ; Checks if this conditional operation is commutative.
     ;
     ; @return true if this operation is commutative
     ;;
    #_unused
    (§ method! #_"boolean" Condition''isCommutative-1 [#_"Condition" this]
        (any = this Condition'EQ Condition'NE)
    )

    ;;;
     ; Attempts to fold a comparison between two constants and return the result.
     ;
     ; @param lt the constant on the left side of the comparison
     ; @param rt the constant on the right side of the comparison
     ; @return Boolean#TRUE if the comparison is known to be true,
     ;         Boolean#FALSE if the comparison is known to be false
     ;;
    (§ method! #_"boolean" Condition''foldCondition-3 [#_"Condition" this, #_"Constant" lt, #_"Constant" rt]
        (if (instance? PrimitiveConstant lt)
            (Condition''foldCondition-3 this, lt, rt)
            (let [
                #_"Boolean" equal (#_"ConstantReflectionProvider" .constantEquals HotSpot'constantReflection, lt, rt)
            ]
                (when (some? equal) => (throw! (str "could not fold " lt " " this " " rt))
                    (condp = this
                        Condition'EQ (#_"Boolean" .booleanValue equal)
                        Condition'NE (not (#_"Boolean" .booleanValue equal))
                    )
                )
            )
        )
    )

    ;;;
     ; Attempts to fold a comparison between two primitive constants and return the result.
     ;
     ; @param lp the constant on the left side of the comparison
     ; @param rp the constant on the right side of the comparison
     ; @return true if the comparison is known to be true, false if the comparison is known to be false
     ;;
    (§ method! #_"boolean" Condition''foldCondition-3 [#_"Condition" this, #_"PrimitiveConstant" lp, #_"PrimitiveConstant" rp]
        (condp =? (#_"PrimitiveConstant" .getJavaKind lp)
           [JavaKind/Boolean JavaKind/Byte JavaKind/Char JavaKind/Short JavaKind/Int]
            (let [
                #_"int" x (#_"PrimitiveConstant" .asInt lp)
                #_"int" y (#_"PrimitiveConstant" .asInt rp)
            ]
                (condp = this
                    Condition'EQ (= x y)
                    Condition'NE (not= x y)
                    Condition'LT (< x y)
                    Condition'LE (<= x y)
                    Condition'GT (< y x)
                    Condition'GE (<= y x)
                    Condition'AE (UnsignedMath'aboveOrEqual-2 x, y)
                    Condition'BE (UnsignedMath'belowOrEqual-2 x, y)
                    Condition'AT (UnsignedMath'aboveThan-2 x, y)
                    Condition'BT (UnsignedMath'belowThan-2 x, y)
                )
            )
            JavaKind/Long
            (let [
                #_"long" x (#_"PrimitiveConstant" .asLong lp)
                #_"long" y (#_"PrimitiveConstant" .asLong rp)
            ]
                (condp = this
                    Condition'EQ (= x y)
                    Condition'NE (not= x y)
                    Condition'LT (< x y)
                    Condition'LE (<= x y)
                    Condition'GT (< y x)
                    Condition'GE (<= y x)
                    Condition'AE (UnsignedMath'aboveOrEqual-2 x, y)
                    Condition'BE (UnsignedMath'belowOrEqual-2 x, y)
                    Condition'AT (UnsignedMath'aboveThan-2 x, y)
                    Condition'BT (UnsignedMath'belowThan-2 x, y)
                )
            )
        )
    )

    (§ method! #_"Condition" Condition''join-2 [#_"Condition" this, #_"Condition" other]
        (condp = this
            other this
            Condition'EQ
                (cond
                    (any = other Condition'LE Condition'GE Condition'BE Condition'AE) Condition'EQ
                )
            Condition'NE
                (cond
                    (any = other Condition'LT Condition'GT Condition'BT Condition'AT) other
                    (= other Condition'LE) Condition'LT
                    (= other Condition'GE) Condition'GT
                    (= other Condition'BE) Condition'BT
                    (= other Condition'AE) Condition'AT
                )
            Condition'LE
                (cond
                    (any = other Condition'GE Condition'EQ) Condition'EQ
                    (any = other Condition'NE Condition'LT) Condition'LT
                )
            Condition'LT
                (cond
                    (any = other Condition'NE Condition'LE) Condition'LT
                )
            Condition'GE
                (cond
                    (any = other Condition'LE Condition'EQ) Condition'EQ
                    (any = other Condition'NE Condition'GT) Condition'GT
                )
            Condition'GT
                (cond
                    (any = other Condition'NE Condition'GE) Condition'GT
                )
            Condition'BE
                (cond
                    (any = other Condition'AE Condition'EQ) Condition'EQ
                    (any = other Condition'NE Condition'BT) Condition'BT
                )
            Condition'BT
                (cond
                    (any = other Condition'NE Condition'BE) Condition'BT
                )
            Condition'AE
                (cond
                    (any = other Condition'BE Condition'EQ) Condition'EQ
                    (any = other Condition'NE Condition'AT) Condition'AT
                )
            Condition'AT
                (cond
                    (any = other Condition'NE Condition'AE) Condition'AT
                )
        )
    )

    #_unused
    (§ method! #_"Condition" Condition''meet-2 [#_"Condition" this, #_"Condition" other]
        (condp = this
            other this
            Condition'EQ
                (cond
                    (any = other Condition'LE Condition'GE Condition'BE Condition'AE) other
                    (= other Condition'LT) Condition'LE
                    (= other Condition'GT) Condition'GE
                    (= other Condition'BT) Condition'BE
                    (= other Condition'AT) Condition'AE
                )
            Condition'NE
                (cond
                    (any = other Condition'LT Condition'GT Condition'BT Condition'AT) Condition'NE
                )
            Condition'LE
                (cond
                    (any = other Condition'EQ Condition'LT) Condition'LE
                )
            Condition'LT
                (cond
                    (any = other Condition'EQ Condition'LE) Condition'LE
                    (any = other Condition'NE Condition'GT) Condition'NE
                )
            Condition'GE
                (cond
                    (any = other Condition'EQ Condition'GT) Condition'GE
                )
            Condition'GT
                (cond
                    (any = other Condition'EQ Condition'GE) Condition'GE
                    (any = other Condition'NE Condition'LT) Condition'NE
                )
            Condition'BE
                (cond
                    (any = other Condition'EQ Condition'BT) Condition'BE
                )
            Condition'BT
                (cond
                    (any = other Condition'EQ Condition'BE) Condition'BE
                    (any = other Condition'NE Condition'AT) Condition'NE
                )
            Condition'AE
                (cond
                    (any = other Condition'EQ Condition'AT) Condition'AE
                )
            Condition'AT
                (cond
                    (any = other Condition'EQ Condition'AE) Condition'AE
                    (any = other Condition'NE Condition'BT) Condition'NE
                )
        )
    )
)

;;;
 ; @anno Condition.CanonicalizedCondition
 ;;
(final-ns CanonicalizedCondition
    (§ final #_"CanonicalCondition" :canonicalCondition nil)
    (§ final #_"boolean" :mirror? false)
    (§ final #_"boolean" :negate? false)

    (§ defn- #_"CanonicalizedCondition" CanonicalizedCondition'new-3 [#_"CanonicalCondition" canonicalCondition, #_"boolean" mirror?, #_"boolean" negate?]
        (let [
            #_"CanonicalizedCondition" this (Object.)
            this (assoc this :canonicalCondition canonicalCondition)
            this (assoc this :mirror? mirror?)
            this (assoc this :negate? negate?)
        ]
            this
        )
    )
)

(final-ns CanonicalCondition
    (§ final #_"Condition" :condition nil)

    (§ defn- #_"CanonicalCondition" CanonicalCondition'new-1 [#_"Condition" condition]
        (let [
            #_"CanonicalCondition" this (Object.)
            this (assoc this :condition condition)
        ]
            this
        )
    )

    (§ def #_"CanonicalCondition" CanonicalCondition'EQ (CanonicalCondition'new-1 Condition'EQ))
    (§ def #_"CanonicalCondition" CanonicalCondition'LT (CanonicalCondition'new-1 Condition'LT))
    (§ def #_"CanonicalCondition" CanonicalCondition'BT (CanonicalCondition'new-1 Condition'BT))
)

;;;
 ; Utilities for unsigned comparisons. All methods have correct, but slow, standard Java
 ; implementations so that they can be used with compilers not supporting the intrinsics.
 ;;
(value-ns UnsignedMath
    (§ defn #_"boolean" UnsignedMath'aboveThan-2    [#_"int" a, #_"int" b] (>  (Integer/compareUnsigned a, b) 0))
    (§ defn #_"boolean" UnsignedMath'aboveOrEqual-2 [#_"int" a, #_"int" b] (>= (Integer/compareUnsigned a, b) 0))
    (§ defn #_"boolean" UnsignedMath'belowThan-2    [#_"int" a, #_"int" b] (<  (Integer/compareUnsigned a, b) 0))
    (§ defn #_"boolean" UnsignedMath'belowOrEqual-2 [#_"int" a, #_"int" b] (<= (Integer/compareUnsigned a, b) 0))

    (§ defn #_"boolean" UnsignedMath'aboveThan-2    [#_"long" a, #_"long" b] (>  (Long/compareUnsigned a, b) 0))
    (§ defn #_"boolean" UnsignedMath'aboveOrEqual-2 [#_"long" a, #_"long" b] (>= (Long/compareUnsigned a, b) 0))
    (§ defn #_"boolean" UnsignedMath'belowThan-2    [#_"long" a, #_"long" b] (<  (Long/compareUnsigned a, b) 0))
    (§ defn #_"boolean" UnsignedMath'belowOrEqual-2 [#_"long" a, #_"long" b] (<= (Long/compareUnsigned a, b) 0))
)

(final-ns BlockMap #_"<T>"
    (§ final #_"T[]" :data nil)

    (§ defn #_"BlockMap" BlockMap'new-1 [#_"ControlFlowGraph" cfg]
        (let [
            #_"BlockMap" this (Object.)
            this (assoc this :data (§ cast #_"T[]" (make-array Object (count (:reversePostOrder cfg)))))
        ]
            this
        )
    )

    (§ method! #_"T" BlockMap''get-2 [#_"BlockMap<T>" this, #_"Block" block]
        (nth (:data this) (:id block))
    )

    (§ method! #_"void" BlockMap''put-3 [#_"BlockMap<T>" this, #_"Block" block, #_"T" value]
        (aset (:data this) (:id block) value)
        nil
    )
)

;;;
 ; This class represents a dominator tree problem, i.e. a problem which can be solved by traversing
 ; the dominator (sub-)tree.
 ;
 ; @param <E> An enum that describes the flags that can be associated with a block.
 ; @param <C> An arbitrary cost type that is associated with a block. It is intended to carry
 ;            information needed to calculate the solution. Note that C should not contain
 ;            boolean flags. Use an enum entry in E instead.
 ;;
(class-ns DominatorOptimizationProblem #_"<E extends Enum<E>, C>"
    (§ mutable #_"Block[]" :blocks nil)
    (§ mutable #_"EnumMap<E, BitSet>" :flags nil)
    (§ mutable #_"BlockMap<C>" :costs nil)

    (§ defn #_"DominatorOptimizationProblem" DominatorOptimizationProblem'new-2 [#_"Class<E>" flagType, #_"ControlFlowGraph" cfg]
        (let [
            #_"DominatorOptimizationProblem" this (Object.)
            this (assoc this :blocks (:reversePostOrder cfg))
            this (assoc this :flags (EnumMap. flagType))
            this (assoc this :costs (BlockMap'new-1 cfg))
        ]
            this
        )
    )

    (§ method! #_"Block[]" DominatorOptimizationProblem''getBlocks-1 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this]
        (:blocks this)
    )

    #_unused
    (§ method! #_"Block" DominatorOptimizationProblem''getBlockForId-2 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"int" id]
        (nth (:blocks this) id)
    )

    ;;;
     ; Sets a flag for a block.
     ;;
    (§ method! #_"void" DominatorOptimizationProblem''set-3 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"E" flag, #_"Block" block]
        (let [
            #_"BitSet" bitSet (get (:flags this) flag)
        ]
            (when (nil? bitSet)
                (§ ass bitSet (BitSet. (count (:blocks this))))
                (#_"EnumMap" .put (:flags this), flag, bitSet)
            )
            (#_"BitSet" .set bitSet, (:id block))
        )
        nil
    )

    ;;;
     ; Checks whether a flag is set for a block.
     ;;
    (§ method! #_"boolean" DominatorOptimizationProblem''get-3 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"E" flag, #_"Block" block]
        (let [
            #_"BitSet" bitSet (get (:flags this) flag)
        ]
            (and (some? bitSet) (#_"BitSet" .get bitSet, (:id block)))
        )
    )

    ;;;
     ; Returns a Stream of blocks for which {@code flag} is set.
     ;;
    (§ method! #_"Stream<Block>" DominatorOptimizationProblem''stream-2 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"E" flag]
        (#_"Stream" .filter (#_"List" .stream (Arrays/asList (DominatorOptimizationProblem''getBlocks-1 this))), (ß block -> (§ fun (DominatorOptimizationProblem''get-3 this, flag, block))))
    )

    ;;;
     ; Returns the cost object associated with {@code block}. Might return nil if not set.
     ;;
    (§ method! #_"C" DominatorOptimizationProblem''getCost-2 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"Block" block]
        (BlockMap''get-2 (:costs this), block)
    )

    ;;;
     ; Sets the cost for a {@code block}.
     ;;
    (§ method! #_"void" DominatorOptimizationProblem''setCost-3 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"Block" block, #_"C" cost]
        (BlockMap''put-3 (:costs this), block, cost)
        nil
    )

    ;;;
     ; Sets {@code flag} for all blocks along the dominator path from {@code block} to the root
     ; until a block it finds a block where {@code flag} is already set.
     ;;
    (§ method! #_"void" DominatorOptimizationProblem''setDominatorPath-3 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"E" flag, #_"Block" block]
        (let [
            #_"BitSet" bitSet (get (:flags this) flag)
        ]
            (when (nil? bitSet)
                (§ ass bitSet (BitSet. (count (:blocks this))))
                (#_"EnumMap" .put (:flags this), flag, bitSet)
            )
            (loop-when-recur [#_"Block" b block] (and (some? b) (not (#_"BitSet" .get bitSet, (:id b)))) [(:dominator b)]
                ;; mark block
                (#_"BitSet" .set bitSet, (:id b))
            )
        )
        nil
    )

    ;;;
     ; Returns a Stream of flags associated with {@code block}.
     ;;
    #_unused
    (§ method! #_"Stream<E>" DominatorOptimizationProblem''getFlagsForBlock-2 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"Block" block]
        (#_"Stream" .filter (#_"Set" .stream (DominatorOptimizationProblem''getFlags-1 this)), (ß flag -> (§ fun (DominatorOptimizationProblem''get-3 this, flag, block))))
    )

    ;;;
     ; Returns the Set of flags that can be set for this problem.
     ;;
    (§ method! #_"Set<E>" DominatorOptimizationProblem''getFlags-1 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this]
        (#_"EnumMap" .keySet (:flags this))
    )

    ;;;
     ; Returns the name of a flag.
     ;;
    (§ method #_"String" DominatorOptimizationProblem''getName-2 [#_"DominatorOptimizationProblem<E extends Enum<E>, C>" this, #_"E" flag]
        (#_"Object" .toString flag)
    )
)

(final-ns Loop
    (§ final #_"Loop" :parent nil)
    (§ final #_"List<Loop>" :children nil)

    (§ final #_"int" :depth 0)
    (§ final #_"int" :index 0)
    (§ final #_"Block" :header nil)
    (§ final #_"List<Block>" :blocks nil)
    (§ final #_"List<Block>" :exits nil)

    (§ mutable #_"LocationSet" :killLocations nil)

    (§ defn #_"Loop" Loop'new-3 [#_"Loop" parent, #_"int" index, #_"Block" header]
        (let [
            #_"Loop" this (Object.)
            this (assoc this :parent parent)
            this (assoc this :depth (if (some? parent) (inc (:depth parent)) 1))
            this (assoc this :index index)
            this (assoc this :header header)
            this (assoc this :blocks (ArrayList.))
            this (assoc this :children (ArrayList.))
            this (assoc this :exits (ArrayList.))
        ]
            this
        )
    )

    (§ method! #_"long" Loop''numBackedges-1 [#_"Loop" this]
        (NodeIterable''count-1 (LoopBeginNode''loopEnds-1 (:beginNode (:header this))))
    )

    (§ method! #_"void" Loop''addExit-2 [#_"Loop" this, #_"Block" block]
        (#_"List" .add (:exits this), block)
        nil
    )

    ;;;
     ; Determines if one loop is a transitive parent of another loop.
     ;
     ; @param childLoop The loop for which parentLoop might be a transitive parent loop.
     ; @param parentLoop The loop which might be a transitive parent loop of child loop.
     ; @return true if parentLoop is a (transitive) parent loop of childLoop, false otherwise
     ;;
    #_unused
    (§ defn #_"boolean" Loop'transitiveParentLoop-2 [#_"Loop" childLoop, #_"Loop" parentLoop]
        (loop-when [#_"Loop" l childLoop] (some? l) => false
            (or (= l parentLoop) (recur (:parent l)))
        )
    )

    (§ method! #_"LocationSet" Loop''getKillLocations-1 [#_"Loop" this]
        (when (nil? (:killLocations this))
            (§ ass! this (assoc this :killLocations (LocationSet'new-0)))
            (loop-when [#_"ISeq" s (seq (:blocks this))] (some? s)
                (let [
                    #_"Block" block (first s)
                ]
                    (when (= (:loop block) this) => (recur (next s))
                        (§ ass! (:killLocations this) (LocationSet''addAll-2 (:killLocations this), (Block''getKillLocations-1 block)))
                        (when-not (LocationSet''isAny-1 (:killLocations this))
                            (recur (next s))
                        )
                    )
                )
            )
        )
        (loop-when [#_"ISeq" s (seq (:children this))] (some? s)
            (let [
                #_"Loop" child (first s)
            ]
                (when-not (LocationSet''isAny-1 (:killLocations this))
                    (§ ass! (:killLocations this) (LocationSet''addAll-2 (:killLocations this), (Loop''getKillLocations-1 child)))
                    (recur (next s))
                )
            )
        )
        (:killLocations this)
    )

    (§ method! #_"boolean" Loop''canKill-2 [#_"Loop" this, #_"LocationIdentity" location]
        (LocationSet''contains-2 (Loop''getKillLocations-1 this), location)
    )
)

;;;
 ; A compact representation of the different encoding strategies for objects and metadata.
 ;;
(final-ns CompressEncoding
    (§ final #_"long" :base 0)
    (§ final #_"int" :shift 0)

    (§ defn #_"CompressEncoding" CompressEncoding'new-2 [#_"long" base, #_"int" shift]
        (let [
            #_"CompressEncoding" this (Object.)
            this (assoc this :base base)
            this (assoc this :shift shift)
        ]
            this
        )
    )

    (§ method! #_"boolean" CompressEncoding''hasBase-1 [#_"CompressEncoding" this]
        (not= (:base this) 0)
    )

    #_unused
    (§ method! #_"boolean" CompressEncoding''hasShift-1 [#_"CompressEncoding" this]
        (not= (:shift this) 0)
    )
)

(class-ns FieldIntrospection #_"<T>"
    (§ final #_"Class<T>" :class nil)

    ;;;
     ; The set of fields in #clazz that do long belong to a more specific category.
     ;;
    (§ mutable #_"Fields" :data nil)

    (§ defn #_"FieldIntrospection" FieldIntrospection'new-1 [#_"Class<T>" clazz]
        (let [
            #_"FieldIntrospection" this (Object.)
            this (assoc this :class clazz)
        ]
            this
        )
    )

    #_unused
    (§ abstract #_"Fields[]" FieldIntrospection''getAllFields-1 [#_"FieldIntrospection<T>" this])
)

;;;
 ; Describes fields in a class, primarily for access via Unsafe.
 ;;
(class-ns Fields
    ;;;
     ; Offsets used with Unsafe to access the fields.
     ;;
    (§ final #_"long[]" :offsets nil)
    ;;;
     ; The names of the fields.
     ;;
    (§ final #_"String[]" :names nil)
    ;;;
     ; The types of the fields.
     ;;
    (§ final #_"Class[]" :types nil)

    (§ final #_"Class[]" :declaringClasses nil)

    (§ defn #_"Fields" Fields'new-1 [#_"ArrayList<? extends FieldInfo>" fields]
        (Collections/sort fields)
        (let [
            #_"Fields" this (Object.)
            #_"int" n (count fields)
            this (assoc this :offsets (long-array n))
            this (assoc this :names (make-array String n))
            this (assoc this :types (make-array Class n))
            this (assoc this :declaringClasses (make-array Class n))
        ]
            (loop-when-recur [#_"int" i 0 #_"ISeq" s (seq fields)] (some? s) [(inc i) (next s)]
                (let [
                    #_"FieldInfo" f (first s)
                ]
                    (aset (:offsets this) i (:offset f))
                    (aset (:names this) i (:name f))
                    (aset (:types this) i (:type f))
                    (aset (:declaringClasses this) i (:declaringClass f))
                )
            )
            this
        )
    )

    (§ defn #_"void" Fields'translateInto-2 [#_"Fields" fields, #_"ArrayList<FieldInfo>" infos]
        (dotimes [#_"int" i (count (:offsets fields))]
            (#_"ArrayList" .add infos, (FieldInfo'new-4 (nth (:offsets fields) i), (nth (:names fields) i), (nth (:types fields) i), (nth (:declaringClasses fields) i)))
        )
        nil
    )

    ;;;
     ; Copies fields from {@code from} to {@code to}, both of which must be of the same type.
     ;
     ; @param from the object from which the fields should be copied
     ; @param to the object to which the fields should be copied
     ;;
    (§ method #_"void" Fields''copy-3 [#_"Fields" this, #_"Object" from, #_"Object" to]
        (Fields''copy-4 this, from, to, nil)
        nil
    )

    ;;;
     ; Copies fields from {@code from} to {@code to}, both of which must be of the same type.
     ;
     ; @param from the object from which the fields should be copied
     ; @param to the object to which the fields should be copied
     ; @param trans function to applied to object field values as they are copied. If nil, the value is copied unchanged.
     ;;
    (§ method #_"void" Fields''copy-4 [#_"Fields" this, #_"Object" from, #_"Object" to, #_"ObjectTransformer" trans]
        (dotimes [#_"int" index (count (:offsets this))]
            (let [
                #_"Class" type (nth (:types this) index)
                #_"long" offset (nth (:offsets this) index)
            ]
                (if (#_"Class" .isPrimitive type)
                    (condp = type
                        int'class     (.putInt     HotSpot'unsafe, to, offset, (.getInt     HotSpot'unsafe, from, offset))
                        long'class    (.putLong    HotSpot'unsafe, to, offset, (.getLong    HotSpot'unsafe, from, offset))
                        boolean'class (.putBoolean HotSpot'unsafe, to, offset, (.getBoolean HotSpot'unsafe, from, offset))
                        short'class   (.putShort   HotSpot'unsafe, to, offset, (.getShort   HotSpot'unsafe, from, offset))
                        char'class    (.putChar    HotSpot'unsafe, to, offset, (.getChar    HotSpot'unsafe, from, offset))
                        byte'class    (.putByte    HotSpot'unsafe, to, offset, (.getByte    HotSpot'unsafe, from, offset))
                    )
                    (let [
                        #_"Object" obj (.getObject HotSpot'unsafe, from, offset)
                    ]
                        (.putObject HotSpot'unsafe, to, offset, (if (some? trans) (ObjectTransformer''apply-3 trans, index, obj) obj))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Gets the value of a field for a given object.
     ;
     ; @param object the object whose field is to be read
     ; @param index the index of the field (between 0 and #getCount())
     ; @return the value of the specified field which will be boxed if the field type is primitive
     ;;
    #_unused
    (§ method #_"Object" Fields''get-3 [#_"Fields" this, #_"Object" object, #_"int" index]
        (let [
            #_"Class" type (nth (:types this) index)
            #_"long" offset (nth (:offsets this) index)
        ]
            (if (#_"Class" .isPrimitive type)
                (condp = type
                    int'class     (.getInt     HotSpot'unsafe, object, offset)
                    long'class    (.getLong    HotSpot'unsafe, object, offset)
                    boolean'class (.getBoolean HotSpot'unsafe, object, offset)
                    short'class   (.getShort   HotSpot'unsafe, object, offset)
                    char'class    (.getChar    HotSpot'unsafe, object, offset)
                    byte'class    (.getByte    HotSpot'unsafe, object, offset)
                )
                (.getObject HotSpot'unsafe, object, offset)
            )
        )
    )

    ;;;
     ; Gets the value of a field for a given object.
     ;
     ; @param object the object whose field is to be read
     ; @param index the index of the field (between 0 and #getCount())
     ; @return the value of the specified field which will be boxed if the field type is primitive
     ;;
    #_unused
    (§ method! #_"long" Fields''getRawPrimitive-3 [#_"Fields" this, #_"Object" object, #_"int" index]
        (let [
            #_"Class" type (nth (:types this) index)
            #_"long" offset (nth (:offsets this) index)
        ]
            (condp = type
                int'class         (.getInt     HotSpot'unsafe, object, offset)
                long'class        (.getLong    HotSpot'unsafe, object, offset)
                boolean'class (if (.getBoolean HotSpot'unsafe, object, offset) 1 0)
                short'class       (.getShort   HotSpot'unsafe, object, offset)
                char'class        (.getChar    HotSpot'unsafe, object, offset)
                byte'class        (.getByte    HotSpot'unsafe, object, offset)
            )
        )
    )

    ;;;
     ; Determines if a field in the domain of this object is the same as the field denoted by the
     ; same index in another Fields object.
     ;;
    (§ method! #_"boolean" Fields''isSame-3 [#_"Fields" this, #_"Fields" other, #_"int" index]
        (= (nth (:offsets other) index) (nth (:offsets this) index))
    )

    ;;;
     ; Gets the name of a field.
     ;;
    (§ method #_"String" Fields''getName-2 [#_"Fields" this, #_"int" index]
        (nth (:names this) index)
    )

    ;;;
     ; Gets the type of a field.
     ;;
    (§ method #_"Class" Fields''getType-2 [#_"Fields" this, #_"int" index]
        (nth (:types this) index)
    )

    (§ method! #_"Class" Fields''getDeclaringClass-2 [#_"Fields" this, #_"int" index]
        (nth (:declaringClasses this) index)
    )

    #_unused
    (§ method #_"void" Fields''set-4 [#_"Fields" this, #_"Object" object, #_"int" index, #_"Object" value]
        (let [
            #_"Class" type (nth (:types this) index)
            #_"long" offset (nth (:offsets this) index)
        ]
            (if (#_"Class" .isPrimitive type)
                (condp = type
                    int'class     (.putInt     HotSpot'unsafe, object, offset, value)
                    long'class    (.putLong    HotSpot'unsafe, object, offset, value)
                    boolean'class (.putBoolean HotSpot'unsafe, object, offset, value)
                    short'class   (.putShort   HotSpot'unsafe, object, offset, value)
                    char'class    (.putChar    HotSpot'unsafe, object, offset, value)
                    byte'class    (.putByte    HotSpot'unsafe, object, offset, value)
                )
                (.putObject HotSpot'unsafe, object, offset, value)
            )
        )
        nil
    )

    #_unused
    (§ method! #_"void" Fields''setRawPrimitive-4 [#_"Fields" this, #_"Object" object, #_"int" index, #_"long" value]
        (let [
            #_"Class" type (nth (:types this) index)
            #_"long" offset (nth (:offsets this) index)
        ]
            (condp = type
                int'class     (.putInt     HotSpot'unsafe, object, offset, (int value))
                long'class    (.putLong    HotSpot'unsafe, object, offset, value)
                boolean'class (.putBoolean HotSpot'unsafe, object, offset, (not (zero? value)))
                short'class   (.putShort   HotSpot'unsafe, object, offset, (short value))
                char'class    (.putChar    HotSpot'unsafe, object, offset, (char value))
                byte'class    (.putByte    HotSpot'unsafe, object, offset, (byte value))
            )
        )
        nil
    )

    (§ method! #_"boolean" Fields''getBoolean-3 [#_"Fields" this, #_"Object" n, #_"int" i]
        (.getBoolean HotSpot'unsafe, n, (nth (:offsets this) i))
    )

    (§ method #_"byte" Fields''getByte-3 [#_"Fields" this, #_"Object" n, #_"int" i]
        (.getByte HotSpot'unsafe, n, (nth (:offsets this) i))
    )

    (§ method #_"short" Fields''getShort-3 [#_"Fields" this, #_"Object" n, #_"int" i]
        (.getShort HotSpot'unsafe, n, (nth (:offsets this) i))
    )

    (§ method! #_"char" Fields''getChar-3 [#_"Fields" this, #_"Object" n, #_"int" i]
        (.getChar HotSpot'unsafe, n, (nth (:offsets this) i))
    )

    (§ method #_"int" Fields''getInt-3 [#_"Fields" this, #_"Object" n, #_"int" i]
        (.getInt HotSpot'unsafe, n, (nth (:offsets this) i))
    )

    (§ method! #_"long" Fields''getLong-3 [#_"Fields" this, #_"Object" n, #_"int" i]
        (.getLong HotSpot'unsafe, n, (nth (:offsets this) i))
    )

    #_unused
    (§ method! #_"float" Fields''getFloat-3 [#_"Fields" this, #_"Object" n, #_"int" i]
        (.getFloat HotSpot'unsafe, n, (nth (:offsets this) i))
    )

    #_unused
    (§ method! #_"double" Fields''getDouble-3 [#_"Fields" this, #_"Object" n, #_"int" i]
        (.getDouble HotSpot'unsafe, n, (nth (:offsets this) i))
    )

    (§ method #_"Object" Fields''getObject-3 [#_"Fields" this, #_"Object" object, #_"int" i]
        (.getObject HotSpot'unsafe, object, (nth (:offsets this) i))
    )

    (§ method! #_"void" Fields''putObject-4 [#_"Fields" this, #_"Object" object, #_"int" i, #_"Object" value]
        (.putObject HotSpot'unsafe, object, (nth (:offsets this) i), value)
        nil
    )
)

;;;
 ; Function enabling an object field value to be replaced with another value when being copied
 ; within Fields#copy(Object, Object, ObjectTransformer).
 ;
 ; @anno Fields.ObjectTransformer
 ;;
; @FunctionalInterface
(§ interface ObjectTransformer
    (§ abstract #_"Object" ObjectTransformer''apply-3 [#_"ObjectTransformer" this, #_"int" index, #_"Object" from])
)

;;;
 ; Scans the fields in a class hierarchy.
 ;;
(class-ns FieldsScanner
    ;;;
     ; Fields not belonging to a more specific category defined by scanner subclasses are added to this list.
     ;;
    (§ final #_"ArrayList<FieldInfo>" :data (ArrayList.))

    (§ defn #_"FieldsScanner" FieldsScanner'new-0 []
        (Object.)
    )

    ;;;
     ; Scans the fields in a class hierarchy.
     ;
     ; @param clazz the class at which to start scanning
     ; @param endClazz scanning stops when this class is encountered (i.e. {@code endClazz} is not scanned)
     ;;
    (§ method #_"void" FieldsScanner''scan-4 [#_"FieldsScanner" this, #_"Class" clazz, #_"Class" endClazz, #_"boolean" includeTransient]
        (loop-when-recur clazz (not= clazz endClazz) (#_"Class" .getSuperclass clazz)
            (doseq [#_"Field" field (#_"Class" .getDeclaredFields clazz)]
                (let [
                    #_"int" modifiers (#_"Field" .getModifiers field)
                ]
                    (when (and (not (Modifier/isStatic modifiers)) (or includeTransient (not (Modifier/isTransient modifiers))))
                        (FieldsScanner''scanField-3 this, field, (.objectFieldOffset HotSpot'unsafe, field))
                    )
                )
            )
        )
        nil
    )

    (§ method #_"void" FieldsScanner''scanField-3 [#_"FieldsScanner" this, #_"Field" field, #_"long" offset]
        (#_"ArrayList" .add (:data this), (FieldInfo'new-4 offset, (#_"Field" .getName field), (#_"Field" .getType field), (#_"Field" .getDeclaringClass field)))
        nil
    )
)

;;;
 ; Describes a field in a class during scanning.
 ;
 ; @anno FieldsScanner.FieldInfo
 ;;
(class-ns FieldInfo (§ implements Comparable #_"<FieldInfo>")
    (§ final #_"long" :offset 0)
    (§ final #_"String" :name nil)
    (§ final #_"Class" :type nil)
    (§ final #_"Class" :declaringClass nil)

    (§ defn #_"FieldInfo" FieldInfo'new-4 [#_"long" offset, #_"String" name, #_"Class" type, #_"Class" declaringClass]
        (let [
            #_"FieldInfo" this (Object.)
            this (assoc this :offset offset)
            this (assoc this :name name)
            this (assoc this :type type)
            this (assoc this :declaringClass declaringClass)
        ]
            this
        )
    )

    ;;;
     ; Sorts fields in ascending order by their #offsets.
     ;;
    (§ override #_"int" FieldInfo''compareTo-2 [#_"FieldInfo" this, #_"FieldInfo" o]
        (cond (< (:offset this) (:offset o)) -1 (< (:offset o) (:offset this)) 1 :else 0)
    )
)

;;;
 ; This class encapsulates options that control the behavior of the Graal compiler.
 ;;
(value-ns GraalOptions
    ;; @Option "Maximum desired size of the compiler graph in nodes."
    (def #_"int" GraalOptions'maximumDesiredSize 20000)

    ;; @Option "Maximum level of recursive inlining."
    (def #_"int" GraalOptions'maximumRecursiveInlining 5)

    ;; @Option "Graphs with less than this number of nodes are trivial and therefore always inlined."
    (def #_"int" GraalOptions'trivialInliningSize 10)

    ;; @Option "Inlining is explored up to this number of nodes in the graph for each call site."
    (def #_"int" GraalOptions'maximumInliningSize 300)

    (def #_"double" GraalOptions'limitInlinedInvokes 5.0)

    (def #_"boolean" GraalOptions'inlineEverything false)

    ;; escape analysis settings
    (def #_"boolean" GraalOptions'partialEscapeAnalysis true)
    (def #_"int" GraalOptions'escapeAnalysisIterations 2)
    (def #_"int" GraalOptions'escapeAnalysisLoopCutoff 20)
    (def #_"int" GraalOptions'maximumEscapeAnalysisArrayLength 32)
    (def #_"boolean" GraalOptions'loopPeeling true)
    (def #_"boolean" GraalOptions'reassociateInvariants true)
    (def #_"boolean" GraalOptions'fullUnroll true)
    (def #_"boolean" GraalOptions'loopUnswitch true)
    (def #_"boolean" GraalOptions'partialUnroll true)
    (def #_"float" GraalOptions'minimumPeelProbability 0.35 #_"f")
    (def #_"int" GraalOptions'loopMaxUnswitch 3)
    (def #_"boolean" GraalOptions'useLoopLimitChecks true)

    ;; debugging settings
    (def #_"boolean" GraalOptions'zapStackOnMethodEntry false)
    (def #_"boolean" GraalOptions'deoptALot false)

    ;; @Option "Stress the code by emitting reads at earliest instead of latest point."
    (def #_"boolean" GraalOptions'stressTestEarlyReads false)

    ;; register allocator debugging
    (def #_"boolean" GraalOptions'conditionalElimination true)
    (def #_"boolean" GraalOptions'rawConditionalElimination true)
    (def #_"boolean" GraalOptions'replaceInputsWithConstantsBasedOnStamps true)
    (def #_"boolean" GraalOptions'removeNeverExecutedCode true)
    (def #_"boolean" GraalOptions'genLoopSafepoints true)
    (def #_"boolean" GraalOptions'inlineVTableStubs true)
    (def #_"boolean" GraalOptions'alwaysInlineVTableStubs false)
    (def #_"boolean" GraalOptions'resolveClassBeforeStaticInvoke false)
    (def #_"boolean" GraalOptions'canOmitFrame true)

    ;; runtime settings
    (def #_"boolean" GraalOptions'optConvertDeoptsToGuards true)
    (def #_"boolean" GraalOptions'optReadElimination true)
    (def #_"int" GraalOptions'readEliminationMaxLoopVisits 5)
    (def #_"boolean" GraalOptions'optDeoptimizationGrouping true)
    (def #_"boolean" GraalOptions'optScheduleOutOfLoops true)
    (def #_"boolean" GraalOptions'guardPriorities true)
    (def #_"boolean" GraalOptions'optEliminateGuards true)
    (def #_"boolean" GraalOptions'optImplicitNullChecks true)
    (def #_"boolean" GraalOptions'optClearNonLiveLocals true)
    (def #_"boolean" GraalOptions'optLoopTransform true)
    (def #_"boolean" GraalOptions'optFloatingReads true)
    (def #_"boolean" GraalOptions'optDevirtualizeInvokesOptimistically true)

    ;; @Option "Eagerly construct extra snippet info."
    (def #_"boolean" GraalOptions'eagerSnippets false)

    ;;;
     ; @anno LIRBuilder.Options
     ;;
    ;; @Option "AMD64: Emit lfence instructions at the beginning of basic blocks."
    (def #_"boolean" GraalOptions'mitigateSpeculativeExecutionAttacks false)

    ;;;
     ; @anno ConstantFields.Options
     ;;
    ;; @Option "Determines whether to treat final fields with default values as constant."
    (def #_"boolean" GraalOptions'trustFinalDefaultFields true)

    ;;;
     ; @anno HighTier.Options
     ;;
    ;; @Option "Enable inlining."
    (def #_"boolean" GraalOptions'inline true)

    ;;;
     ; Options related to HotSpot snippets in this package.
     ;;
    ;; @Option "Handle simple cases for inflated monitors in the fast-path."
    (def #_"boolean" GraalOptions'simpleFastInflatedLocking true)

    ;;;
     ; Options related to BytecodeParser.
     ;;
    ;; @Option "Inlines trivial methods during bytecode parsing."
    (def #_"boolean" GraalOptions'inlineDuringParsing true)

    ;; @Option "Inlines partial intrinsic exits during bytecode parsing when possible. A partial intrinsic exit is a call within an intrinsic to the method being intrinsified and denotes semantics of the original method that the intrinsic does not support."
    (def #_"boolean" GraalOptions'inlinePartialIntrinsicExitDuringParsing true)

    ;; @Option "Maximum depth when inlining during bytecode parsing."
    (def #_"int" GraalOptions'inlineDuringParsingMaxDepth 10)

    ;;;
     ; @anno LIRPhase.Options
     ;;
    ;; @Option "Enable LIR level optimiztations."
    (def #_"boolean" GraalOptions'lirOptimization true)

    ;;;
     ; @anno LinearScan.Options
     ;;
    ;; @Option "Enable spill position optimization."
    (def #_"boolean" GraalOptions'lirOptLSRAOptimizeSpillPosition (and GraalOptions'lirOptimization true))

    ;;;
     ; @anno LinearScanEliminateSpillMovePhase.Options
     ;;
    ;; @Option "Enable spill move elimination."
    (def #_"boolean" GraalOptions'lirOptLSRAEliminateSpillMoves (and GraalOptions'lirOptimization true))

    ;;;
     ; @anno OptimizingLinearScanWalker.Options
     ;;
    ;; @Option "Enable LSRA optimization."
    (def #_"boolean" GraalOptions'lsraOptimization false)
    ;; @Option "LSRA optimization: Only split but do not reassign."
    (def #_"boolean" GraalOptions'lsraOptSplitOnly false)

    ;;;
     ; @anno StackMoveOptimizationPhase.Options
     ;;
    (def #_"boolean" GraalOptions'lirOptStackMoveOptimizer (and GraalOptions'lirOptimization true))

    ;;;
     ; @anno ConstantLoadOptimization.Options
     ;;
    ;; @Option "Enable constant load optimization."
    (def #_"boolean" GraalOptions'lirOptConstantLoadOptimization (and GraalOptions'lirOptimization true))

    ;;;
     ; @anno PostAllocationOptimizationStage.Options
     ;;
    (def #_"boolean" GraalOptions'lirOptEdgeMoveOptimizer (and GraalOptions'lirOptimization true))
    (def #_"boolean" GraalOptions'lirOptControlFlowOptimizer (and GraalOptions'lirOptimization true))
    (def #_"boolean" GraalOptions'lirOptRedundantMoveElimination (and GraalOptions'lirOptimization true))
    (def #_"boolean" GraalOptions'lirOptNullCheckOptimizer (and GraalOptions'lirOptimization true))

    ;;;
     ; @anno LSStackSlotAllocator.Options
     ;;
    ;; @Option "Use linear scan stack slot allocation."
    (def #_"boolean" GraalOptions'lirOptLSStackSlotAllocator (and GraalOptions'lirOptimization true))

    ;;;
     ; @anno DefaultLoopPolicies.Options
     ;;
    (def #_"int" GraalOptions'loopUnswitchMaxIncrease 500)
    (def #_"int" GraalOptions'loopUnswitchTrivial 10)
    (def #_"double" GraalOptions'loopUnswitchFrequencyBoost 10.0)

    (def #_"int" GraalOptions'fullUnrollMaxNodes 300)
    (def #_"int" GraalOptions'fullUnrollMaxIterations 600)
    (def #_"int" GraalOptions'exactFullUnrollMaxNodes 1200)
    (def #_"int" GraalOptions'exactPartialUnrollMaxNodes 200)

    (def #_"int" GraalOptions'unrollMaxIterations 16)

    ;;;
     ; @anno DeadCodeEliminationPhase.Options
     ;;
    ;; @Option "Disable optional dead code eliminations."
    (def #_"boolean" GraalOptions'reduceDCE true)

    ;;;
     ; @anno InliningPhase.Options
     ;;
    ;;;
     ; This is a defensive measure against known pathologies of the inliner where the breadth of
     ; the inlining call tree exploration can be wide enough to prevent inlining from completing
     ; in reasonable time.
     ;;
    ;; @Option "Per-compilation method inlining exploration limit before giving up (use 0 to disable)."
    (def #_"int" GraalOptions'methodInlineBailoutLimit 5000)

    ;;;
     ; @anno UseTrappingNullChecksPhase.Options
     ;;
    ;; @Option "Use traps for nil-checks instead of explicit nil-checks."
    (def #_"boolean" GraalOptions'useTrappingNullChecks true)

    ;;;
     ; @anno PartialEscapePhase.Options
     ;;
    (def #_"boolean" GraalOptions'optEarlyReadElimination true)
)

;;;
 ; Represents the type of values in the LIR. It is composed of a PlatformKind that gives the
 ; low level representation of the value, a #referenceMask that describes the location of
 ; object references in the value, a #referenceCompressionMask that indicates which of these
 ; references are compressed references, and for derived references a #derivedReferenceBase.
 ;
 ; Constructing LIRKind instances
 ;
 ; During LIR generation, every new Value should get a LIRKind of the correct
 ; PlatformKind that also contains the correct reference information. {@linkplain LIRKind
 ; LIRKinds} should be created as follows:
 ;
 ; If the result value is created from one or more input values, the LIRKind should be
 ; created with LIRKind#combine(inputs). If the result has a different PlatformKind
 ; than the inputs, LIRKind#combine(inputs).#changeType(resultKind) should be used.
 ;
 ; If the result is an exact copy of one of the inputs, Value#getValueKind() can be used.
 ; Note that this is only correct for move-like operations, like conditional move or
 ; compare-and-swap. For convert operations, LIRKind#combine should be used.
 ;
 ; If it is known that the result will be a reference (e.g. pointer arithmetic where the end result
 ; is a valid oop), #reference or LIRKind#compressedReference should be used.
 ;
 ; If it is known that the result will neither be a reference nor be derived from a reference,
 ; LIRKind#value can be used. If the operation producing this value has inputs, this is very
 ; likely wrong, and LIRKind#combine should be used instead.
 ;
 ; If it is known that the result is derived from a reference in a way that the garbage collector
 ; can not track, LIRKind#unknownReference can be used. In most cases,
 ; LIRKind#combine should be used instead, since it is able to detect this automatically.
 ;;
(final-ns LIRKind (§ extends ValueKind #_"<LIRKind>")
    (def- #_"int" LIRKind'UNKNOWN_REFERENCE -1)

    (§ def #_"LIRKind" LIRKind'Illegal (LIRKind'unknownReference-1 (#_"ValueKind" .getPlatformKind ValueKind/Illegal)))

    ;;;
     ; The location of object references in the value. If the value is a vector type, each bit
     ; represents one component of the vector.
     ;;
    (§ final #_"int" :referenceMask 0)

    ;;;
     ; Mask with 1-bits indicating which references in #referenceMask are compressed.
     ;;
    (§ final #_"int" :referenceCompressionMask 0)

    ;;;
     ; Base value of a derived reference.
     ;;
    (§ mutable #_"AllocatableValue" :derivedReferenceBase nil)

    (§ defn- #_"LIRKind" LIRKind'new-4 [#_"PlatformKind" platformKind, #_"int" referenceMask, #_"int" referenceCompressionMask, #_"AllocatableValue" derivedReferenceBase]
        (let [
            #_"LIRKind" this (ValueKind. platformKind)
            this (assoc this :referenceMask referenceMask)
            this (assoc this :referenceCompressionMask referenceCompressionMask)
            this (assoc this :derivedReferenceBase derivedReferenceBase)
        ]
            this
        )
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a primitive value.
     ; Should be only used when it's guaranteed that the value is not even indirectly derived
     ; from a reference. Otherwise, #combine(Value...) should be used instead.
     ;;
    (§ defn #_"LIRKind" LIRKind'value-1 [#_"PlatformKind" platformKind]
        (LIRKind'new-4 platformKind, 0, 0, nil)
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a single, tracked,
     ; uncompressed oop reference.
     ;;
    (§ defn #_"LIRKind" LIRKind'reference-1 [#_"PlatformKind" platformKind]
        (LIRKind'derivedReference-3 platformKind, nil, false)
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a single, tracked,
     ; compressed oop reference.
     ;;
    (§ defn #_"LIRKind" LIRKind'compressedReference-1 [#_"PlatformKind" platformKind]
        (LIRKind'derivedReference-3 platformKind, nil, true)
    )

    ;;;
     ; Create the correct LIRKind for a given Architecture and JavaKind.
     ;;
    (§ defn #_"LIRKind" LIRKind'fromJavaKind-2 [#_"Architecture" arch, #_"JavaKind" javaKind]
        (let [
            #_"PlatformKind" platformKind (#_"Architecture" .getPlatformKind arch, javaKind)
        ]
            (if (#_"JavaKind" .isObject javaKind) (LIRKind'reference-1 platformKind) (LIRKind'value-1 platformKind))
        )
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a derived reference.
     ;;
    (§ defn #_"LIRKind" LIRKind'derivedReference-3 [#_"PlatformKind" platformKind, #_"AllocatableValue" base, #_"boolean" compressed?]
        (let [
            #_"int" length (#_"PlatformKind" .getVectorLength platformKind)
            #_"int" referenceMask (dec (<< 1 length))
            #_"int" referenceCompressionMask (if compressed? referenceMask 0)
        ]
            (LIRKind'new-4 platformKind, referenceMask, referenceCompressionMask, base)
        )
    )

    ;;;
     ; Create a LIRKind of type {@code platformKind} that contains a value that is derived
     ; from a reference in a non-linear way. Values of this LIRKind can not be live at
     ; safepoints. In most cases, this should not be called directly. #combine should be
     ; used instead to automatically propagate this information.
     ;;
    (§ defn #_"LIRKind" LIRKind'unknownReference-1 [#_"PlatformKind" platformKind]
        (LIRKind'new-4 platformKind, LIRKind'UNKNOWN_REFERENCE, LIRKind'UNKNOWN_REFERENCE, nil)
    )

    ;;;
     ; Create a derived reference.
     ;
     ; @param base An AllocatableValue containing the base pointer of the derived reference.
     ;;
    (§ method! #_"LIRKind" LIRKind''makeDerivedReference-2 [#_"LIRKind" this, #_"AllocatableValue" base]
        (cond
            (= base Value/ILLEGAL)    (LIRKind''makeUnknownReference-1 this)
            (LIRKind''isValue-1 this) (LIRKind'derivedReference-3 (#_"ValueKind" .getPlatformKind this), base, false)
            :else                     (LIRKind'new-4 (#_"ValueKind" .getPlatformKind this), (:referenceMask this), (:referenceCompressionMask this), base)
        )
    )

    ;;;
     ; Derive a new type from inputs. The result will have the PlatformKind of one of the inputs.
     ; If all inputs are values, the result is a value. Otherwise, the result is an unknown reference.
     ;
     ; This method should be used to construct the result LIRKind of any operation that
     ; modifies values (e.g. arithmetics).
     ;;
    (§ defn #_"LIRKind" LIRKind'combine-1* [#_"Value..." inputs]
        (loop-when [#_"ISeq" s (seq inputs)] (some? s) => (#_"Value" .getValueKind (nth inputs 0), LIRKind) ;; all inputs are values, just return one of them
            (let [
                #_"LIRKind" kind (#_"Value" .getValueKind (first s), LIRKind)
            ]
                (cond
                    (LIRKind''isUnknownReference-1 kind) kind
                    (not (LIRKind''isValue-1 kind))      (LIRKind''makeUnknownReference-1 kind)
                    :else                                (recur (next s))
                )
            )
        )
    )

    ;;;
     ; Helper method to construct derived reference kinds. Returns the base value of a reference or
     ; derived reference. For values it returns nil, and for unknown references it returns Value#ILLEGAL.
     ;;
    (§ defn #_"AllocatableValue" LIRKind'derivedBaseFromValue-1 [#_"AllocatableValue" value]
        (let [
            #_"ValueKind" valueKind (#_"AllocatableValue" .getValueKind value)
        ]
            (when (instance? LIRKind valueKind) => Value/ILLEGAL
                (let [
                    #_"LIRKind" kind (#_"AllocatableValue" .getValueKind value, LIRKind)
                ]
                    (cond
                        (LIRKind''isValue-1 kind)            nil
                        (LIRKind''isDerivedReference-1 kind) (:derivedReferenceBase kind)
                        (LIRKind''isUnknownReference-1 kind) Value/ILLEGAL
                        :else                                value ;; kind is a reference
                    )
                )
            )
        )
    )

    ;;;
     ; Helper method to construct derived reference kinds. If one of {@code base1} or {@code base2}
     ; are set, it creates a derived reference using it as the base. If both are set, the result is
     ; an unknown reference.
     ;;
    (§ defn #_"LIRKind" LIRKind'combineDerived-3 [#_"LIRKind" kind, #_"AllocatableValue" base1, #_"AllocatableValue" base2]
        (cond
            (and (nil? base1) (nil? base2)) kind
            (nil? base1)                    (LIRKind''makeDerivedReference-2 kind, base2)
            (nil? base2)                    (LIRKind''makeDerivedReference-2 kind, base1)
            :else                           (LIRKind''makeUnknownReference-1 kind)
        )
    )

    ;;;
     ; Merges the reference information of the inputs. The result will have the PlatformKind
     ; of {@code mergeKind}. If all inputs are values (references), the result is a value (reference).
     ; Otherwise, the result is an unknown reference.
     ;
     ; The correctness of the PlatformKind is not verified.
     ;;
    (§ defn #_"LIRKind" LIRKind'mergeReferenceInformation-2 [#_"LIRKind" mergeKind, #_"LIRKind" inputKind]
        (cond
            ;; mergeKind is an unknown reference: the result should be also an unknown reference
            (LIRKind''isUnknownReference-1 mergeKind) mergeKind
            ;; mergeKind is a value: if input consists of values and references, make the result an unknown reference
            (LIRKind''isValue-1 mergeKind) (if (LIRKind''isValue-1 inputKind) mergeKind (LIRKind''makeUnknownReference-1 mergeKind))
            ;; mergeKind is a reference and reference masks do not match: the result can only be an unknown reference
            (not (and (= (:referenceMask mergeKind) (:referenceMask inputKind))
                      (= (:referenceCompressionMask mergeKind) (:referenceCompressionMask inputKind)))
            )
                (LIRKind''makeUnknownReference-1 mergeKind)
            ;; both are references
            (LIRKind''isDerivedReference-1 mergeKind)
                (if (and (LIRKind''isDerivedReference-1 inputKind)
                         (= (:derivedReferenceBase mergeKind) (:derivedReferenceBase inputKind))
                    )
                    ;; same reference base: they must be equal
                    mergeKind
                    ;; base pointers differ: make the result an unknown reference
                    (LIRKind''makeUnknownReference-1 mergeKind)
                )
            ;; mergeKind is not derived, but inputKind is: make the result an unknown reference
            (LIRKind''isDerivedReference-1 inputKind) (LIRKind''makeUnknownReference-1 mergeKind)
            ;; both are not derived references: they must be equal
            :else mergeKind
        )
    )

    ;;;
     ; Create a new LIRKind with the same reference information and a new platform kind.
     ; If the new kind is a longer vector than this, the new elements are marked as untracked values.
     ;;
    (§ override! #_"LIRKind" LIRKind''changeType-2 [#_"LIRKind" this, #_"PlatformKind" kind]
        (cond
            (= kind (#_"ValueKind" .getPlatformKind this)) this
            (LIRKind''isUnknownReference-1 this)           (LIRKind'unknownReference-1 kind)
            (zero? (:referenceMask this))                  (LIRKind'value-1 kind) ;; value type
            :else ;; reference type
                (let [
                    #_"int" n (min 32 (#_"PlatformKind" .getVectorLength kind))
                    #_"int" lengthMask (>>> 0xffffffff (- 32 n))
                    #_"int" referenceMask (& (:referenceMask this) lengthMask)
                    #_"int" referenceCompressionMask (& (:referenceCompressionMask this) lengthMask)
                ]
                    (LIRKind'new-4 kind, referenceMask, referenceCompressionMask, (:derivedReferenceBase this))
                )
        )
    )

    ;;;
     ; Create a new LIRKind with a new platform kind. If the new kind is longer than this,
     ; the reference positions are repeated to fill the vector.
     ;;
    #_unused
    (§ method! #_"LIRKind" LIRKind''repeat-2 [#_"LIRKind" this, #_"PlatformKind" kind]
        (cond
            (LIRKind''isUnknownReference-1 this) (LIRKind'unknownReference-1 kind)
            (zero? (:referenceMask this))        (LIRKind'value-1 kind) ;; value type
            :else ;; reference type
                (let [
                    #_"int" n (#_"PlatformKind" .getVectorLength kind)
                    ;; repeat reference mask to fill new kind
                    [#_"int" referenceMask #_"int" referenceCompressionMask]
                        (loop-when-recur [referenceMask 0 referenceCompressionMask 0 #_"int" i 0]
                                         (< i n)
                                         [(| referenceMask (<< (:referenceMask this) i))
                                          (| referenceCompressionMask (<< (:referenceCompressionMask this) i))
                                          (+ i (#_"PlatformKind" .getVectorLength (#_"ValueKind" .getPlatformKind this)))]
                                      => [referenceMask referenceCompressionMask]
                        )
                ]
                    (LIRKind'new-4 kind, referenceMask, referenceCompressionMask, (:derivedReferenceBase this))
                )
        )
    )

    ;;;
     ; Create a new LIRKind with the same type, but marked as containing an LIRKind#unknownReference.
     ;;
    (§ method! #_"LIRKind" LIRKind''makeUnknownReference-1 [#_"LIRKind" this]
        (LIRKind'new-4 (#_"ValueKind" .getPlatformKind this), LIRKind'UNKNOWN_REFERENCE, LIRKind'UNKNOWN_REFERENCE, nil)
    )

    ;;;
     ; Check whether this value is a derived reference.
     ;;
    (§ method! #_"boolean" LIRKind''isDerivedReference-1 [#_"LIRKind" this]
        (some? (:derivedReferenceBase this))
    )

    ;;;
     ; Change the base value of a derived reference. This must be called on derived references only.
     ;;
    #_unused
    (§ method! #_"LIRKind" LIRKind''setDerivedReferenceBase-2 [#_"LIRKind" this, #_"AllocatableValue" derivedReferenceBase]
        (assoc this :derivedReferenceBase derivedReferenceBase)
    )

    ;;;
     ; Check whether this value is derived from a reference in a non-linear way. If this returns
     ; true, this value must not be live at safepoints.
     ;;
    (§ method! #_"boolean" LIRKind''isUnknownReference-1 [#_"LIRKind" this]
        (= (:referenceMask this) LIRKind'UNKNOWN_REFERENCE)
    )

    (§ defn #_"boolean" LIRKind'isUnknownReference-1 [#_"ValueKind" kind]
        (or (not (instance? LIRKind kind)) (LIRKind''isUnknownReference-1 kind))
    )

    (§ defn #_"boolean" LIRKind'isUnknownReference-1 [#_"Value" value]
        (LIRKind'isUnknownReference-1 (#_"Value" .getValueKind value))
    )

    #_unused
    (§ method! #_"int" LIRKind''getReferenceCount-1 [#_"LIRKind" this]
        (Integer/bitCount (:referenceMask this))
    )

    ;;;
     ; Check whether the {@code idx}th part of this value is a reference that must be tracked at safepoints.
     ;
     ; @param idx The index into the vector if this is a vector kind. Must be 0 if this is a scalar kind.
     ;;
    (§ method! #_"boolean" LIRKind''isReference-2 [#_"LIRKind" this, #_"int" idx]
        (and (not (LIRKind''isUnknownReference-1 this)) (not (zero? (& (:referenceMask this) (<< 1 idx)))))
    )

    ;;;
     ; Check whether the {@code idx}th part of this value is a <b>compressed</b> reference.
     ;
     ; @param idx The index into the vector if this is a vector kind. Must be 0 if this is a scalar kind.
     ;;
    #_unused
    (§ method! #_"boolean" LIRKind''isCompressedReference-2 [#_"LIRKind" this, #_"int" idx]
        (and (not (LIRKind''isUnknownReference-1 this)) (not (zero? (& (:referenceCompressionMask this) (<< 1 idx)))))
    )

    ;;;
     ; Check whether this kind is a value type that doesn't need to be tracked at safepoints.
     ;;
    (§ method! #_"boolean" LIRKind''isValue-1 [#_"LIRKind" this]
        (zero? (:referenceMask this))
    )

    (§ defn #_"boolean" LIRKind'isValue-1 [#_"ValueKind" kind]
        (and (instance? LIRKind kind) (LIRKind''isValue-1 kind))
    )

    (§ defn #_"boolean" LIRKind'isValue-1 [#_"Value" value]
        (LIRKind'isValue-1 (#_"Value" .getValueKind value))
    )

    (§ override! #_"boolean" #_"Object" .equals [#_"LIRKind" this, #_"Object" that]
        (or (= this that)
            (and (instance? LIRKind that)
                (= (#_"ValueKind" .getPlatformKind this) (#_"ValueKind" .getPlatformKind that))
                (= (:referenceMask this) (:referenceMask that))
                (= (:referenceCompressionMask this) (:referenceCompressionMask that))
                (when (LIRKind''isDerivedReference-1 this) => (not (LIRKind''isDerivedReference-1 that))
                    (and (LIRKind''isDerivedReference-1 that)
                        (= (:derivedReferenceBase this) (:derivedReferenceBase that))
                    )
                )
            )
        )
    )
)

;;;
 ; A collection of static utility functions that check ranges of numbers.
 ;;
(value-ns NumUtil
    #_unused
    (§ defn #_"boolean" NumUtil'isShiftCount-1 [#_"int" x]
        (<= 0 x 31)
    )

    ;;;
     ; Determines if a given {@code int} value is the range of unsigned byte values.
     ;;
    #_unused
    (§ defn #_"boolean" NumUtil'isUByte-1 [#_"int" x]
        (= (& x 0xff) x)
    )

    ;;;
     ; Determines if a given {@code int} value is the range of signed byte values.
     ;;
    (§ defn #_"boolean" NumUtil'isByte-1 [#_"int" x]
        (= (byte x) x)
    )

    ;;;
     ; Determines if a given {@code long} value is the range of unsigned byte values.
     ;;
    #_unused
    (§ defn #_"boolean" NumUtil'isUByte-1 [#_"long" x]
        (= (& x 0xff) x)
    )

    ;;;
     ; Determines if a given {@code long} value is the range of signed byte values.
     ;;
    (§ defn #_"boolean" NumUtil'isByte-1 [#_"long" l]
        (= (byte l) l)
    )

    ;;;
     ; Determines if a given {@code long} value is the range of unsigned int values.
     ;;
    #_unused
    (§ defn #_"boolean" NumUtil'isUInt-1 [#_"long" x]
        (= (& x 0xffffffff) x)
    )

    ;;;
     ; Determines if a given {@code long} value is the range of signed int values.
     ;;
    (§ defn #_"boolean" NumUtil'isInt-1 [#_"long" l]
        (= (int l) l)
    )

    ;;;
     ; Determines if a given {@code int} value is the range of signed short values.
     ;;
    #_unused
    (§ defn #_"boolean" NumUtil'isShort-1 [#_"int" x]
        (= (short x) x)
    )

    ;;;
     ; Determines if a given {@code long} value is the range of signed short values.
     ;;
    #_unused
    (§ defn #_"boolean" NumUtil'isShort-1 [#_"long" x]
        (= (short x) x)
    )

    #_unused
    (§ defn #_"boolean" NumUtil'isUShort-1 [#_"int" s]
        (= s (& s 0xffff))
    )

    #_unused
    (§ defn #_"boolean" NumUtil'isUShort-1 [#_"long" s]
        (= s (& s 0xffff))
    )

    (§ defn #_"boolean" NumUtil'is32bit-1 [#_"long" x]
        (and (<= -0x80000000 x) (< x 0x80000000))
    )

    #_unused
    (§ defn #_"short" NumUtil'safeToShort-1 [#_"int" v]
        (short v)
    )

    (§ defn #_"int" NumUtil'roundUp-2 [#_"int" number, #_"int" mod]
        (* (quot (+ number mod -1) mod) mod)
    )

    (§ defn #_"long" NumUtil'roundUp-2 [#_"long" number, #_"long" mod]
        (* (quot (+ number mod -1) mod) mod)
    )

    #_unused
    (§ defn #_"int" NumUtil'roundDown-2 [#_"int" number, #_"int" mod]
        (* (quot number mod) mod)
    )

    #_unused
    (§ defn #_"long" NumUtil'roundDown-2 [#_"long" number, #_"long" mod]
        (* (quot number mod) mod)
    )

    #_unused
    (§ defn #_"int" NumUtil'log2Ceil-1 [#_"int" val]
        (loop-when-recur [#_"int" log2 0 #_"int" x 1] (< x val) [(inc log2) (<< x 1)] => log2)
    )

    #_unused
    (§ defn #_"boolean" NumUtil'isUnsignedNbit-2 [#_"int" n, #_"int" value]
        (<= (- 32 (Integer/numberOfLeadingZeros value)) n)
    )

    #_unused
    (§ defn #_"boolean" NumUtil'isUnsignedNbit-2 [#_"int" n, #_"long" value]
        (<= (- 64 (Long/numberOfLeadingZeros value)) n)
    )

    #_unused
    (§ defn #_"boolean" NumUtil'isSignedNbit-2 [#_"int" n, #_"int" value]
        (let [
            #_"int" m (<< 1 (dec n))
        ]
            (<= (- m) value (dec m))
        )
    )

    #_unused
    (§ defn #_"boolean" NumUtil'isSignedNbit-2 [#_"int" n, #_"long" value]
        (let [
            #_"long" m (<< 1 (dec n))
        ]
            (<= (- m) value (dec m))
        )
    )

    ;;;
     ; @param n Number of bits that should be set to 1. Must be between 0 and 32 (inclusive).
     ; @return a number with n bits set to 1
     ;;
    #_unused
    (§ defn #_"int" NumUtil'getNbitNumberInt-1 [#_"int" n]
        (if (< n 32) (dec (<< 1 n)) 0xffffffff)
    )

    ;;;
     ; @param n Number of bits that should be set to 1. Must be between 0 and 64 (inclusive).
     ; @return a number with n bits set to 1
     ;;
    (§ defn #_"long" NumUtil'getNbitNumberLong-1 [#_"int" n]
        (if (< n 64) (dec (<< 1 n)) 0xffffffffffffffff)
    )

    ;;;
     ; Get the minimum value representable in a {@code bits} bit signed integer.
     ;;
    (§ defn #_"long" NumUtil'minValue-1 [#_"int" bits]
        (CodeUtil/minValue bits)
    )

    ;;;
     ; Get the maximum value representable in a {@code bits} bit signed integer.
     ;;
    (§ defn #_"long" NumUtil'maxValue-1 [#_"int" bits]
        (CodeUtil/maxValue bits)
    )

    ;;;
     ; Get the maximum value representable in a {@code bits} bit unsigned integer.
     ;;
    (§ defn #_"long" NumUtil'maxValueUnsigned-1 [#_"int" bits]
        (NumUtil'getNbitNumberLong-1 bits)
    )

    (§ defn #_"long" NumUtil'maxUnsigned-2 [#_"long" a, #_"long" b]
        (if (pos? (Long/compareUnsigned a, b)) b a)
    )

    (§ defn #_"long" NumUtil'minUnsigned-2 [#_"long" a, #_"long" b]
        (if (pos? (Long/compareUnsigned a, b)) a b)
    )

    (§ defn #_"boolean" NumUtil'sameSign-2 [#_"long" a, #_"long" b]
        (= (neg? a) (neg? b))
    )
)

;;;
 ; Type describing all pointers to Java objects.
 ;;
(class-ns AbstractObjectStamp (§ extends AbstractPointerStamp)
    (§ final #_"ResolvedJavaType" :type nil)
    (§ final #_"boolean" :exactType false)

    (§ defn #_"AbstractObjectStamp" AbstractObjectStamp'new-4 [#_"ResolvedJavaType" type, #_"boolean" exactType, #_"boolean" never-nil?, #_"boolean" always-nil?]
        (let [
            #_"AbstractObjectStamp" this (AbstractPointerStamp'new-2 never-nil?, always-nil?)
            this (assoc this :type type)
            this (assoc this :exactType exactType)
        ]
            this
        )
    )

    (§ abstract #_"AbstractObjectStamp" AbstractObjectStamp''copyWith-5 [#_"AbstractObjectStamp" this, #_"ResolvedJavaType" newType, #_"boolean" newExactType, #_"boolean" newNonNull, #_"boolean" newAlwaysNull])

    #_unused
    (§ override! #_"AbstractPointerStamp" AbstractObjectStamp''copyWith-3 [#_"AbstractObjectStamp" this, #_"boolean" newNonNull, #_"boolean" newAlwaysNull]
        (AbstractObjectStamp''copyWith-5 this, (:type this), (:exactType this), newNonNull, newAlwaysNull)
    )

    #_unused
    (§ override #_"Stamp" AbstractObjectStamp''unrestricted-1 [#_"AbstractObjectStamp" this]
        (AbstractObjectStamp''copyWith-5 this, nil, false, false, false)
    )

    (§ override #_"Stamp" AbstractObjectStamp''empty-1 [#_"AbstractObjectStamp" this]
        (AbstractObjectStamp''copyWith-5 this, nil, true, true, false)
    )

    #_unused
    (§ override #_"Stamp" AbstractObjectStamp''constant-2 [#_"AbstractObjectStamp" this, #_"Constant" c]
        (let [
            #_"ResolvedJavaType" constType (when-not (#_"JavaConstant" .isNull c) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, c))
        ]
            (AbstractObjectStamp''copyWith-5 this, constType, (#_"JavaConstant" .isNonNull c), (#_"JavaConstant" .isNonNull c), (#_"JavaConstant" .isNull c))
        )
    )

    #_unused
    (§ override #_"boolean" AbstractObjectStamp''hasValues-1 [#_"AbstractObjectStamp" this]
        (or (not (:exactType this)) (and (some? (:type this)) (AbstractObjectStamp'isConcreteType-1 (:type this))))
    )

    #_unused
    (§ override #_"JavaKind" AbstractObjectStamp''getStackKind-1 [#_"AbstractObjectStamp" this]
        JavaKind/Object
    )

    #_unused
    (§ override #_"ResolvedJavaType" AbstractObjectStamp''javaType-1 [#_"AbstractObjectStamp" this]
        (or (:type this) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Object))
    )

    (§ method #_"ResolvedJavaType" AbstractObjectStamp''type-1 [#_"AbstractObjectStamp" this]
        (:type this)
    )

    (§ method! #_"boolean" AbstractObjectStamp''isExactType-1 [#_"AbstractObjectStamp" this]
        (and (:exactType this) (some? (:type this)))
    )

    #_unused
    (§ override #_"Stamp" AbstractObjectStamp''meet-2 [#_"AbstractObjectStamp" this, #_"Stamp" that]
        (if (= this that)
            this
            (let [
                #_"AbstractObjectStamp" a this
                #_"AbstractObjectStamp" b that
            ]
                (cond
                    (Stamp''isEmpty-1 a) b
                    (Stamp''isEmpty-1 b) a
                    :else
                        (let [
                            [#_"ResolvedJavaType" type #_"boolean" exactType #_"boolean" never-nil? #_"boolean" always-nil?]
                                (cond
                                    (:always-nil? b)
                                        [(AbstractObjectStamp''type-1 a) (:exactType a) false (:always-nil? a)]
                                    (:always-nil? a)
                                        [(AbstractObjectStamp''type-1 b) (:exactType b) false (:always-nil? b)]
                                    :else
                                        (let [
                                            type (AbstractObjectStamp'meetTypes-2 (AbstractObjectStamp''type-1 a), (AbstractObjectStamp''type-1 b))
                                            exactType (and (:exactType a) (:exactType b))
                                            exactType
                                                (when (and exactType (some? (:type a)) (some? (:type b))) => exactType
                                                    ;; meeting two valid exact types may result in a non-exact type
                                                    (= type (:type a) (:type b))
                                                )
                                            never-nil? (and (:never-nil? a) (:never-nil? b))
                                            always-nil? false
                                        ]
                                            [type exactType never-nil? always-nil?]
                                        )
                                )
                        ]
                            (cond
                                (and (= type (:type a)) (= exactType (:exactType a)) (= never-nil? (:never-nil? a)) (= always-nil? (:always-nil? a)))
                                    a
                                (and (= type (:type b)) (= exactType (:exactType b)) (= never-nil? (:never-nil? b)) (= always-nil? (:always-nil? b)))
                                    b
                                :else
                                    (AbstractObjectStamp''copyWith-5 a, type, exactType, never-nil?, always-nil?)
                            )
                        )
                )
            )
        )
    )

    #_unused
    (§ override #_"Stamp" AbstractObjectStamp''join-2 [#_"AbstractObjectStamp" this, #_"Stamp" that]
        (AbstractObjectStamp''join0-3 this, that, false)
    )

    ;;;
     ; Returns the stamp representing the type of this stamp after a cast to the type represented by
     ; the {@code to} stamp. While this is very similar to a #join operation, in the case where both
     ; types are not obviously related, the cast operation will prefer the type of the {@code to} stamp.
     ; This is necessary as long as ObjectStamps are not able to accurately represent intersection types.
     ;
     ; For example when joining the RandomAccess type with the AbstractList type, without intersection
     ; types, this would result in the most generic type (Object). For this reason, in some cases
     ; a {@code castTo} operation is preferable in order to keep at least the AbstractList type.
     ;
     ; @param that the stamp this stamp should be casted to
     ; @return the new improved stamp or nil if this stamp cannot be improved
     ;;
    #_unused
    (§ override #_"Stamp" AbstractObjectStamp''improveWith-2 [#_"AbstractObjectStamp" this, #_"Stamp" that]
        (AbstractObjectStamp''join0-3 this, that, true)
    )

    (§ method- #_"Stamp" AbstractObjectStamp''join0-3 [#_"AbstractObjectStamp" this, #_"Stamp" that, #_"boolean" improve?]
        (if (= this that)
            this
            (let [
                #_"AbstractObjectStamp" a this
                #_"AbstractObjectStamp" b that
            ]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    :else
                        (let [
                            #_"boolean" always-nil? (or (:always-nil? a) (:always-nil? b))
                            #_"boolean" never-nil? (or (:never-nil? a) (:never-nil? b))
                            #_"boolean" exactType (or (:exactType a) (:exactType b))
                            [#_"ResolvedJavaType" type exactType always-nil?]
                                (cond
                                    (= (:type a) (:type b))                                     [(:type a) exactType always-nil?]
                                    (nil? (:type a))                                            [(:type b) exactType always-nil?]
                                    (nil? (:type b))                                            [(:type a) exactType always-nil?]
                                    (#_"ResolvedJavaType" .isAssignableFrom (:type a), (:type b)) [(:type b) exactType (or (:exactType a) always-nil?)]
                                    (#_"ResolvedJavaType" .isAssignableFrom (:type b), (:type a)) [(:type a) exactType (or (:exactType b) always-nil?)]
                                    :else
                                        (let [
                                            [type exactType] (if improve? [(:type a) (:exactType a)] [nil exactType])
                                            always-nil?
                                                (or exactType
                                                    (and (not (AbstractObjectStamp'isInterfaceOrArrayOfInterface-1 (:type a)))
                                                         (not (AbstractObjectStamp'isInterfaceOrArrayOfInterface-1 (:type b)))
                                                    )
                                                    always-nil?
                                                )
                                        ]
                                            [type exactType always-nil?]
                                        )
                                )
                            [type exactType] (if always-nil? [nil false] [type exactType])
                        ]
                            (cond
                                (and exactType (nil? type))                                       (AbstractObjectStamp''empty-1 a)
                                (and always-nil? never-nil?)                                      (AbstractObjectStamp''empty-1 a)
                                (and exactType (not (AbstractObjectStamp'isConcreteType-1 type))) (AbstractObjectStamp''empty-1 a)
                                (and (= type (:type a)) (= exactType (:exactType a)) (= never-nil? (:never-nil? a)) (= always-nil? (:always-nil? a)))
                                    a
                                (and (= type (:type b)) (= exactType (:exactType b)) (= never-nil? (:never-nil? b)) (= always-nil? (:always-nil? b)))
                                    b
                                :else
                                    (AbstractObjectStamp''copyWith-5 a, type, exactType, never-nil?, always-nil?)
                            )
                        )
                )
            )
        )
    )

    (§ defn- #_"boolean" AbstractObjectStamp'isInterfaceOrArrayOfInterface-1 [#_"ResolvedJavaType" t]
        (or (#_"ResolvedJavaType" .isInterface t) (and (#_"ResolvedJavaType" .isArray t) (#_"ResolvedJavaType" .isInterface (#_"ResolvedJavaType" .getElementalType t))))
    )

    (§ defn #_"boolean" AbstractObjectStamp'isConcreteType-1 [#_"ResolvedJavaType" type]
        (not (and (#_"ResolvedJavaType" .isAbstract type) (not (#_"ResolvedJavaType" .isArray type))))
    )

    (§ defn- #_"ResolvedJavaType" AbstractObjectStamp'meetTypes-2 [#_"ResolvedJavaType" a, #_"ResolvedJavaType" b]
        (cond
            (= a b) a
            (or (nil? a) (nil? b))  nil
            :else
                ;; The 'meetTypes' operation must be commutative. One way to achieve this is
                ;; to totally order the types and always call 'meetOrderedNonNullTypes' in the
                ;; same order. We establish the order by first comparing the hash-codes for
                ;; performance reasons, and then comparing the internal names of the types.
                (let [
                    #_"int" hashA (#_"Object" .hashCode (#_"ResolvedJavaType" .getName a))
                    #_"int" hashB (#_"Object" .hashCode (#_"ResolvedJavaType" .getName b))
                ]
                    (cond
                        (< hashA hashB) (AbstractObjectStamp'meetOrderedNonNullTypes-2 a, b)
                        (< hashB hashA) (AbstractObjectStamp'meetOrderedNonNullTypes-2 b, a)
                        :else
                            (if (<= (#_"String" .compareTo (#_"ResolvedJavaType" .getName a), (#_"ResolvedJavaType" .getName b)) 0)
                                (AbstractObjectStamp'meetOrderedNonNullTypes-2 a, b)
                                (AbstractObjectStamp'meetOrderedNonNullTypes-2 b, a)
                            )
                    )
                )
        )
    )

    (§ defn- #_"ResolvedJavaType" AbstractObjectStamp'meetOrderedNonNullTypes-2 [#_"ResolvedJavaType" a, #_"ResolvedJavaType" b]
        (let [
            #_"ResolvedJavaType" type (#_"ResolvedJavaType" .findLeastCommonAncestor a, b)
        ]
            (when (and (#_"ResolvedJavaType" .isJavaLangObject type) (#_"ResolvedJavaType" .isInterface a) (#_"ResolvedJavaType" .isInterface b)) => type
                ;; Both types are incompatible interfaces => search for first possible common
                ;; ancestor match among super interfaces.
                (let [
                    #_"ResolvedJavaType[]" a* (#_"ResolvedJavaType" .getInterfaces a)
                    #_"ResolvedJavaType[]" b* (#_"ResolvedJavaType" .getInterfaces b)
                ]
                    (loop-when [#_"int" i 0] (< i (count a*)) => type
                        (loop-when [#_"int" j 0] (< j (count b*))
                            (let [
                                #_"ResolvedJavaType" leastCommon (AbstractObjectStamp'meetTypes-2 (nth a* i), (nth b* j))
                            ]
                                (when (#_"ResolvedJavaType" .isInterface leastCommon) => (recur (inc j))
                                    (§ return leastCommon)
                                )
                            )
                        )
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (§ override #_"boolean" #_"Object" .equals [#_"AbstractObjectStamp" this, #_"Object" that]
        (or (= this that)
            (and (some? that) (= (#_"Object" .getClass this) (#_"Object" .getClass that))
                (let [
                    #_"AbstractObjectStamp" a this
                    #_"AbstractObjectStamp" b that
                ]
                    (and (= (:exactType a) (:exactType b))
                        ;; nil == java.lang.Object
                        (cond
                            (nil? (:type a)) (or (nil? (:type b)) (#_"ResolvedJavaType" .isJavaLangObject (:type b)))
                            (nil? (:type b)) (or (nil? (:type a)) (#_"ResolvedJavaType" .isJavaLangObject (:type a)))
                            :else                                 (= (:type a) (:type b))
                        )
                        (= (§ super ) b)
                    )
                )
            )
        )
    )
)

;;;
 ; Abstract base class of all pointer types.
 ;;
(class-ns AbstractPointerStamp (§ extends Stamp)
    (§ final #_"boolean" :never-nil? false)
    (§ final #_"boolean" :always-nil? false)

    (§ defn #_"AbstractPointerStamp" AbstractPointerStamp'new-2 [#_"boolean" never-nil?, #_"boolean" always-nil?]
        (let [
            #_"AbstractPointerStamp" this (Stamp'new-0)
            this (assoc this :never-nil? never-nil?)
            this (assoc this :always-nil? always-nil?)
        ]
            this
        )
    )

    (§ abstract #_"AbstractPointerStamp" AbstractPointerStamp''copyWith-3 [#_"AbstractPointerStamp" this, #_"boolean" newNonNull, #_"boolean" newAlwaysNull])

    (§ method! #_"Stamp" AbstractPointerStamp''defaultPointerJoin-2 [#_"AbstractPointerStamp" this, #_"Stamp" other]
        (let [
            #_"boolean" joinNonNull (or (:never-nil? this) (:never-nil? other))
            #_"boolean" joinAlwaysNull (or (:always-nil? this) (:always-nil? other))
        ]
            (if (and joinNonNull joinAlwaysNull)
                (Stamp''empty-1 this)
                (AbstractPointerStamp''copyWith-3 this, joinNonNull, joinAlwaysNull)
            )
        )
    )

    (§ override #_"Stamp" AbstractPointerStamp''improveWith-2 [#_"AbstractPointerStamp" this, #_"Stamp" other]
        (Stamp''join-2 this, other)
    )

    #_unused
    (§ override #_"Stamp" AbstractPointerStamp''meet-2 [#_"AbstractPointerStamp" this, #_"Stamp" other]
        (let [
            #_"boolean" meetNonNull (and (:never-nil? this) (:never-nil? other))
            #_"boolean" meetAlwaysNull (and (:always-nil? this) (:always-nil? other))
        ]
            (AbstractPointerStamp''copyWith-3 this, meetNonNull, meetAlwaysNull)
        )
    )

    #_unused
    (§ override #_"Stamp" AbstractPointerStamp''unrestricted-1 [#_"AbstractPointerStamp" this]
        (AbstractPointerStamp''copyWith-3 this, false, false)
    )

    (§ defn #_"Stamp" AbstractPointerStamp'pointerNonNull-1 [#_"Stamp" stamp]
        (AbstractPointerStamp''asNonNull-1 stamp)
    )

    #_unused
    (§ defn #_"Stamp" AbstractPointerStamp'pointerMaybeNull-1 [#_"Stamp" stamp]
        (AbstractPointerStamp''asMaybeNull-1 stamp)
    )

    #_unused
    (§ defn #_"Stamp" AbstractPointerStamp'pointerAlwaysNull-1 [#_"Stamp" stamp]
        (AbstractPointerStamp''asAlwaysNull-1 stamp)
    )

    (§ method! #_"Stamp" AbstractPointerStamp''asNonNull-1 [#_"AbstractPointerStamp" this]
        (when-not (Stamp''isEmpty-1 this) => this
            (AbstractPointerStamp''copyWith-3 this, true, false)
        )
    )

    (§ method! #_"Stamp" AbstractPointerStamp''asMaybeNull-1 [#_"AbstractPointerStamp" this]
        (when-not (Stamp''isEmpty-1 this) => this
            (AbstractPointerStamp''copyWith-3 this, false, false)
        )
    )

    (§ method! #_"Stamp" AbstractPointerStamp''asAlwaysNull-1 [#_"AbstractPointerStamp" this]
        (when-not (Stamp''isEmpty-1 this) => this
            (AbstractPointerStamp''copyWith-3 this, false, true)
        )
    )

    #_unused
    (§ override #_"Constant" AbstractPointerStamp''asConstant-1 [#_"AbstractPointerStamp" this]
        (when (:always-nil? this) JavaConstant/NULL_POINTER)
    )

    #_unused
    (§ override #_"JavaKind" AbstractPointerStamp''getStackKind-1 [#_"AbstractPointerStamp" this]
        JavaKind/Illegal
    )
)

;;;
 ; Information about arithmetic operations.
 ;;
(final-ns ArithmeticOpTable
    (§ final #_"UnaryOp<Neg>" :neg nil)                        ;; unary negation operation
    (§ final #_"BinaryOp<Add>" :add nil)                       ;; addition operation
    (§ final #_"BinaryOp<Sub>" :sub nil)                       ;; subtraction operation

    (§ final #_"BinaryOp<Mul>" :mul nil)                       ;; multiplication operation
    (§ final #_"BinaryOp<MulHigh>" :mulHigh nil)               ;; signed operation that multiples the upper 32-bits of two long values
    (§ final #_"BinaryOp<UMulHigh>" :umulHigh nil)             ;; unsigned operation that multiples the upper 32-bits of two long values
    (§ final #_"BinaryOp<Div>" :div nil)                       ;; division operation
    (§ final #_"BinaryOp<Rem>" :rem nil)                       ;; remainder operation

    (§ final #_"UnaryOp<Not>" :not nil)                        ;; bitwise not operation
    (§ final #_"BinaryOp<And>" :and nil)                       ;; bitwise and operation
    (§ final #_"BinaryOp<Or>" :or nil)                         ;; bitwise or operation
    (§ final #_"BinaryOp<Xor>" :xor nil)                       ;; bitwise xor operation

    (§ final #_"ShiftOp<Shl>" :shl nil)                        ;; shift left operation
    (§ final #_"ShiftOp<Shr>" :shr nil)                        ;; signed shift right operation
    (§ final #_"ShiftOp<UShr>" :ushr nil)                      ;; unsigned shift right operation

    (§ final #_"UnaryOp<Abs>" :abs nil)                        ;; absolute value operation

    (§ final #_"IntegerConvertOp<ZeroExtend>" :zeroExtend nil) ;; zero extend conversion
    (§ final #_"IntegerConvertOp<SignExtend>" :signExtend nil) ;; sign extend conversion
    (§ final #_"IntegerConvertOp<Narrow>" :narrow nil)         ;; narrowing conversion

    (§ defn #_"ArithmeticOpTable" ArithmeticOpTable'new-19 [#_"UnaryOp<Neg>" neg, #_"BinaryOp<Add>" add, #_"BinaryOp<Sub>" sub, #_"BinaryOp<Mul>" mul, #_"BinaryOp<MulHigh>" mulHigh, #_"BinaryOp<UMulHigh>" umulHigh, #_"BinaryOp<Div>" div, #_"BinaryOp<Rem>" rem, #_"UnaryOp<Not>" not, #_"BinaryOp<And>" and, #_"BinaryOp<Or>" or, #_"BinaryOp<Xor>" xor, #_"ShiftOp<Shl>" shl, #_"ShiftOp<Shr>" shr, #_"ShiftOp<UShr>" ushr, #_"UnaryOp<Abs>" abs, #_"IntegerConvertOp<ZeroExtend>" zeroExtend, #_"IntegerConvertOp<SignExtend>" signExtend, #_"IntegerConvertOp<Narrow>" narrow]
        (let [
            #_"ArithmeticOpTable" this (Object.)
            this (assoc this :neg neg)
            this (assoc this :add add)
            this (assoc this :sub sub)
            this (assoc this :mul mul)
            this (assoc this :mulHigh mulHigh)
            this (assoc this :umulHigh umulHigh)
            this (assoc this :div div)
            this (assoc this :rem rem)
            this (assoc this :not not)
            this (assoc this :and and)
            this (assoc this :or or)
            this (assoc this :xor xor)
            this (assoc this :shl shl)
            this (assoc this :shr shr)
            this (assoc this :ushr ushr)
            this (assoc this :abs abs)
            this (assoc this :zeroExtend zeroExtend)
            this (assoc this :signExtend signExtend)
            this (assoc this :narrow narrow)
        ]
            this
        )
    )

    (§ def #_"ArithmeticOpTable" ArithmeticOpTable'EMPTY (ArithmeticOpTable'new-19 nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil))

    (§ defn #_"ArithmeticOpTable" ArithmeticOpTable'forStamp-1 [#_"Stamp" stamp]
        (if (instance? ArithmeticStamp stamp) (:ops stamp) ArithmeticOpTable'EMPTY)
    )

    #_unused
    (§ method! #_"BinaryOp[]" ArithmeticOpTable''getBinaryOps-1 [#_"ArithmeticOpTable" this]
        (into-array BinaryOp [ (:add this), (:sub this), (:mul this), (:mulHigh this), (:umulHigh this), (:div this), (:rem this), (:and this), (:or this), (:xor this) ])
    )

    #_unused
    (§ method! #_"UnaryOp[]" ArithmeticOpTable''getUnaryOps-1 [#_"ArithmeticOpTable" this]
        (into-array UnaryOp [ (:neg this), (:not this), (:abs this) ])
    )

    #_unused
    (§ method! #_"ShiftOp[]" ArithmeticOpTable''getShiftOps-1 [#_"ArithmeticOpTable" this]
        (into-array ShiftOp [ (:shl this), (:shr this), (:ushr this) ])
    )

    #_unused
    (§ method! #_"IntegerConvertOp[]" ArithmeticOpTable''getIntegerConvertOps-1 [#_"ArithmeticOpTable" this]
        (into-array IntegerConvertOp [ (:zeroExtend this), (:signExtend this), (:narrow this) ])
    )
)

;;;
 ; @anno ArithmeticOpTable.ArithmeticOp
 ;;
(class-ns ArithmeticOp
    (§ final #_"String" :operator nil)

    (§ defn #_"ArithmeticOp" ArithmeticOp'new-1 [#_"String" operator]
        (let [
            #_"ArithmeticOp" this (Object.)
            this (assoc this :operator operator)
        ]
            this
        )
    )
)

;;;
 ; Describes a unary arithmetic operation.
 ;
 ; @anno ArithmeticOpTable.UnaryOp
 ;;
(class-ns UnaryOp #_"<T>" (§ extends ArithmeticOp)
    (§ defn #_"UnaryOp" UnaryOp'new-1 [#_"String" operation]
        (ArithmeticOp'new-1 operation)
    )

    ;;;
     ; Apply the operation to a Constant.
     ;;
    (§ abstract #_"Constant" UnaryOp''foldConstant-2 [#_"UnaryOp<T>" this, #_"Constant" value])

    ;;;
     ; Apply the operation to a Stamp.
     ;;
    (§ abstract #_"Stamp" UnaryOp''foldStamp-2 [#_"UnaryOp<T>" this, #_"Stamp" stamp])

    #_unused
    (§ method #_"UnaryOp<T>" UnaryOp''unwrap-1 [#_"UnaryOp<T>" this]
        this
    )
)

;;;
 ; @anno ArithmeticOpTable.UnaryOp.Neg
 ;;
(class-ns Neg (§ extends UnaryOp #_"<Neg>")
    (§ defn #_"Neg" Neg'new-0 []
        (UnaryOp'new-1 "-")
    )
)

;;;
 ; @anno ArithmeticOpTable.UnaryOp.Not
 ;;
(class-ns Not (§ extends UnaryOp #_"<Not>")
    (§ defn #_"Not" Not'new-0 []
        (UnaryOp'new-1 "~")
    )
)

;;;
 ; @anno ArithmeticOpTable.UnaryOp.Abs
 ;;
(class-ns Abs (§ extends UnaryOp #_"<Abs>")
    (§ defn #_"Abs" Abs'new-0 []
        (UnaryOp'new-1 "ABS")
    )
)

;;;
 ; Describes a binary arithmetic operation.
 ;
 ; @anno ArithmeticOpTable.BinaryOp
 ;;
(class-ns BinaryOp #_"<T>" (§ extends ArithmeticOp)
    (§ final #_"boolean" :associative? false)
    (§ final #_"boolean" :commutative? false)

    (§ defn #_"BinaryOp" BinaryOp'new-3 [#_"String" operation, #_"boolean" associative?, #_"boolean" commutative?]
        (let [
            #_"BinaryOp" this (ArithmeticOp'new-1 operation)
            this (assoc this :associative? associative?)
            this (assoc this :commutative? commutative?)
        ]
            this
        )
    )

    ;;;
     ; Applies this operation to {@code a} and {@code b}.
     ;
     ; @return the result of applying this operation or nil if applying it would raise
     ;         an exception (e.g. ArithmeticException for dividing by 0)
     ;;
    (§ abstract #_"Constant" BinaryOp''foldConstant-3 [#_"BinaryOp<T>" this, #_"Constant" a, #_"Constant" b])

    ;;;
     ; Apply the operation to two Stamps.
     ;;
    (§ abstract #_"Stamp" BinaryOp''foldStamp-3 [#_"BinaryOp<T>" this, #_"Stamp" a, #_"Stamp" b])

    ;;;
     ; Checks whether this operation is associative. An operation is associative when
     ; {@code (a . b) . c == a . (b . c)} for all a, b, c. Note that you still have to be
     ; careful with inverses. For example the integer subtraction operation will report true
     ; here, since you can still reassociate as long as the correct negations are inserted.
     ;;
    (§ method! #_"boolean" BinaryOp''isAssociative-1 [#_"BinaryOp<T>" this]
        (:associative? this)
    )

    ;;;
     ; Checks whether this operation is commutative. An operation is commutative when
     ; {@code a . b == b . a} for all a, b.
     ;;
    #_unused
    (§ method! #_"boolean" BinaryOp''isCommutative-1 [#_"BinaryOp<T>" this]
        (:commutative? this)
    )

    ;;;
     ; Check whether a Constant is a neutral element for this operation. A neutral
     ; element is any element {@code n} where {@code a . n == a} for all a.
     ;
     ; @param n the Constant that should be tested
     ; @return true iff for all {@code a}: {@code a . n == a}
     ;;
    (§ method #_"boolean" BinaryOp''isNeutral-2 [#_"BinaryOp<T>" this, #_"Constant" n]
        false
    )

    ;;;
     ; Check whether this operation has a zero {@code z == a . a} for each a. Examples of
     ; operations having such an element are subtraction and exclusive-or. Note that this
     ; may be different from the numbers tested by #isNeutral.
     ;
     ; @param stamp a Stamp
     ; @return a unique {@code z} such that {@code z == a . a} for each {@code a} in
     ;         {@code stamp} if it exists, otherwise nil
     ;;
    (§ method #_"Constant" BinaryOp''getZero-2 [#_"BinaryOp<T>" this, #_"Stamp" stamp]
        nil
    )

    #_unused
    (§ method #_"BinaryOp<T>" BinaryOp''unwrap-1 [#_"BinaryOp<T>" this]
        this
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.Add
 ;;
(class-ns Add (§ extends BinaryOp #_"<Add>")
    (§ defn #_"Add" Add'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "+", associative?, commutative?)
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.Sub
 ;;
(class-ns Sub (§ extends BinaryOp #_"<Sub>")
    (§ defn #_"Sub" Sub'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "-", associative?, commutative?)
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.Mul
 ;;
(class-ns Mul (§ extends BinaryOp #_"<Mul>")
    (§ defn #_"Mul" Mul'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "*", associative?, commutative?)
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.MulHigh
 ;;
(class-ns MulHigh (§ extends BinaryOp #_"<MulHigh>")
    (§ defn #_"MulHigh" MulHigh'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "*H", associative?, commutative?)
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.UMulHigh
 ;;
(class-ns UMulHigh (§ extends BinaryOp #_"<UMulHigh>")
    (§ defn #_"UMulHigh" UMulHigh'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "|*H|", associative?, commutative?)
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.Div
 ;;
(class-ns Div (§ extends BinaryOp #_"<Div>")
    (§ defn #_"Div" Div'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "/", associative?, commutative?)
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.Rem
 ;;
(class-ns Rem (§ extends BinaryOp #_"<Rem>")
    (§ defn #_"Rem" Rem'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "%", associative?, commutative?)
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.And
 ;;
(class-ns And (§ extends BinaryOp #_"<And>")
    (§ defn #_"And" And'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "&", associative?, commutative?)
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.Or
 ;;
(class-ns Or (§ extends BinaryOp #_"<Or>")
    (§ defn #_"Or" Or'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "|", associative?, commutative?)
    )
)

;;;
 ; @anno ArithmeticOpTable.BinaryOp.Xor
 ;;
(class-ns Xor (§ extends BinaryOp #_"<Xor>")
    (§ defn #_"Xor" Xor'new-2 [#_"boolean" associative?, #_"boolean" commutative?]
        (BinaryOp'new-3 "^", associative?, commutative?)
    )
)

;;;
 ; Describes a shift operation. The right argument of a shift operation always has kind JavaKind#Int.
 ;
 ; @anno ArithmeticOpTable.ShiftOp
 ;;
(class-ns ShiftOp #_"<OP>" (§ extends ArithmeticOp)
    (§ defn #_"ShiftOp" ShiftOp'new-1 [#_"String" operation]
        (ArithmeticOp'new-1 operation)
    )

    ;;;
     ; Apply the shift to a constant.
     ;;
    (§ abstract #_"Constant" ShiftOp''foldConstant-3 [#_"ShiftOp<OP>" this, #_"Constant" constant, #_"int" amount])

    ;;;
     ; Apply the shift to a stamp.
     ;;
    (§ abstract #_"Stamp" ShiftOp''foldStamp-3 [#_"ShiftOp<OP>" this, #_"Stamp" stamp, #_"IntegerStamp" amount])

    ;;;
     ; Get the shift amount mask for a given result stamp.
     ;;
    (§ abstract #_"int" ShiftOp''getShiftAmountMask-2 [#_"ShiftOp<OP>" this, #_"Stamp" stamp])
)

;;;
 ; @anno ArithmeticOpTable.ShiftOp.Shl
 ;;
(class-ns Shl (§ extends ShiftOp #_"<Shl>")
    (§ defn #_"Shl" Shl'new-0 []
        (ShiftOp'new-1 "<<")
    )
)

;;;
 ; @anno ArithmeticOpTable.ShiftOp.Shr
 ;;
(class-ns Shr (§ extends ShiftOp #_"<Shr>")
    (§ defn #_"Shr" Shr'new-0 []
        (ShiftOp'new-1 ">>")
    )
)

;;;
 ; @anno ArithmeticOpTable.ShiftOp.UShr
 ;;
(class-ns UShr (§ extends ShiftOp #_"<UShr>")
    (§ defn #_"UShr" UShr'new-0 []
        (ShiftOp'new-1 ">>>")
    )
)

;;;
 ; @anno ArithmeticOpTable.IntegerConvertOp
 ;;
(class-ns IntegerConvertOp #_"<T>" (§ extends ArithmeticOp)
    (§ defn #_"IntegerConvertOp" IntegerConvertOp'new-1 [#_"String" op]
        (ArithmeticOp'new-1 op)
    )

    (§ abstract #_"Constant" IntegerConvertOp''foldConstant-4 [#_"IntegerConvertOp<T>" this, #_"int" inputBits, #_"int" resultBits, #_"Constant" value])

    (§ abstract #_"Stamp" IntegerConvertOp''foldStamp-4 [#_"IntegerConvertOp<T>" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp])

    #_unused
    (§ method #_"IntegerConvertOp<T>" IntegerConvertOp''unwrap-1 [#_"IntegerConvertOp<T>" this]
        this
    )

    ;;;
     ; Computes the stamp of the input for the given output stamp.
     ;;
    (§ abstract #_"Stamp" IntegerConvertOp''invertStamp-4 [#_"IntegerConvertOp<T>" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" outStamp])
)

;;;
 ; @anno ArithmeticOpTable.IntegerConvertOp.ZeroExtend
 ;;
(class-ns ZeroExtend (§ extends IntegerConvertOp #_"<ZeroExtend>")
    (§ defn #_"ZeroExtend" ZeroExtend'new-0 []
        (IntegerConvertOp'new-1 "ZeroExtend")
    )
)

;;;
 ; @anno ArithmeticOpTable.IntegerConvertOp.SignExtend
 ;;
(class-ns SignExtend (§ extends IntegerConvertOp #_"<SignExtend>")
    (§ defn #_"SignExtend" SignExtend'new-0 []
        (IntegerConvertOp'new-1 "SignExtend")
    )
)

;;;
 ; @anno ArithmeticOpTable.IntegerConvertOp.Narrow
 ;;
(class-ns Narrow (§ extends IntegerConvertOp #_"<Narrow>")
    (§ defn #_"Narrow" Narrow'new-0 []
        (IntegerConvertOp'new-1 "Narrow")
    )

    #_unused
    (§ override #_"Stamp" Narrow''invertStamp-4 [#_"Narrow" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" outStamp]
        nil
    )
)

;;;
 ; Type describing values that support arithmetic operations.
 ;;
(class-ns ArithmeticStamp (§ extends Stamp)
    (§ final #_"ArithmeticOpTable" :ops nil)

    (§ defn #_"ArithmeticStamp" ArithmeticStamp'new-1 [#_"ArithmeticOpTable" ops]
        (let [
            #_"ArithmeticStamp" this (Stamp'new-0)
            this (assoc this :ops ops)
        ]
            this
        )
    )

    (§ abstract #_"SerializableConstant" ArithmeticStamp''deserialize-2 [#_"ArithmeticStamp" this, #_"ByteBuffer" buffer])

    #_unused
    (§ override #_"Stamp" ArithmeticStamp''improveWith-2 [#_"ArithmeticStamp" this, #_"Stamp" other]
        (when (Stamp''isCompatible-2 this, other) => this
            (Stamp''join-2 this, other)
        )
    )
)

;;;
 ; Base class for {@link Constant constants} that represent a pointer to the data section.
 ;;
(class-ns DataPointerConstant (§ implements SerializableConstant)
    ;;;
     ; The minimum alignment of the data in the data section.
     ;;
    (§ final #_"int" :alignment 0)

    (§ defn #_"DataPointerConstant" DataPointerConstant'new-1 [#_"int" alignment]
        (let [
            #_"DataPointerConstant" this (Object.)
            this (assoc this :alignment alignment)
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" DataPointerConstant''isDefaultForKind-1 [#_"DataPointerConstant" this]
        false
    )
)

;;;
 ; This stamp represents the type of the JavaKind#Illegal value in the second slot
 ; of JavaKind#Long values. It can only appear in framestates or virtual objects.
 ;;
(final-ns IllegalStamp (§ extends Stamp)
    (§ defn- #_"IllegalStamp" IllegalStamp'new-0 []
        (Stamp'new-0)
    )

    #_unused
    (§ override! #_"JavaKind" IllegalStamp''getStackKind-1 [#_"IllegalStamp" this]
        JavaKind/Illegal
    )

    #_unused
    (§ override! #_"LIRKind" IllegalStamp''getLIRKind-1 [#_"IllegalStamp" this]
        LIRKind'Illegal
    )

    #_unused
    (§ override! #_"Stamp" IllegalStamp''unrestricted-1 [#_"IllegalStamp" this]
        this
    )

    #_unused
    (§ override! #_"boolean" IllegalStamp''isUnrestricted-1 [#_"IllegalStamp" this]
        true
    )

    #_unused
    (§ override! #_"Stamp" IllegalStamp''empty-1 [#_"IllegalStamp" this]
        this
    )

    #_unused
    (§ override! #_"Stamp" IllegalStamp''constant-2 [#_"IllegalStamp" this, #_"Constant" constant]
        this
    )

    #_unused
    (§ override! #_"ResolvedJavaType" IllegalStamp''javaType-1 [#_"IllegalStamp" this]
        (throw! "illegal stamp has no Java type")
    )

    #_unused
    (§ override! #_"Stamp" IllegalStamp''meet-2 [#_"IllegalStamp" this, #_"Stamp" other]
        this
    )

    #_unused
    (§ override! #_"Stamp" IllegalStamp''join-2 [#_"IllegalStamp" this, #_"Stamp" other]
        this
    )

    #_unused
    (§ override! #_"boolean" IllegalStamp''isCompatible-2 [#_"IllegalStamp" this, #_"Stamp" stamp]
        (instance? IllegalStamp stamp)
    )

    #_unused
    (§ override! #_"boolean" IllegalStamp''isCompatible-2 [#_"IllegalStamp" this, #_"Constant" constant]
        (and (instance? PrimitiveConstant constant) (= (#_"PrimitiveConstant" .getJavaKind constant) JavaKind/Illegal))
    )

    #_unused
    (§ override! #_"boolean" IllegalStamp''hasValues-1 [#_"IllegalStamp" this]
        true
    )

    #_unused
    (§ override! #_"Stamp" IllegalStamp''improveWith-2 [#_"IllegalStamp" this, #_"Stamp" other]
        this
    )

    #_unused
    (§ override! #_"Constant" IllegalStamp''readConstant-4 [#_"IllegalStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
        (throw! "can't read values of illegal stamp")
    )

    (§ def #_"IllegalStamp" IllegalStamp'instance (IllegalStamp'new-0))
)

;;;
 ; Describes the possible values of a node that produces an int or long result.
 ;
 ; The description consists of (inclusive) lower and upper bounds and up (may be set) and down
 ; (always set) bit-masks.
 ;;
(final-ns IntegerStamp (§ extends PrimitiveStamp)
    ;;;
     ; The signed inclusive lower bound on the value described by this stamp.
     ;;
    (§ final #_"long" :lowerBound 0)
    ;;;
     ; The signed inclusive upper bound on the value described by this stamp.
     ;;
    (§ final #_"long" :upperBound 0)
    ;;;
     ; This bit-mask describes the bits that are always set in the value described by this stamp.
     ;;
    (§ final #_"long" :downMask 0)
    ;;;
     ; This bit-mask describes the bits that can be set in the value described by this stamp.
     ;;
    (§ final #_"long" :upMask 0)

    (§ defn- #_"IntegerStamp" IntegerStamp'new-5 [#_"int" bits, #_"long" lowerBound, #_"long" upperBound, #_"long" downMask, #_"long" upMask]
        (let [
            #_"IntegerStamp" this (PrimitiveStamp'new-2 bits, IntegerStamp'OPS)
            this (assoc this :lowerBound lowerBound)
            this (assoc this :upperBound upperBound)
            this (assoc this :downMask downMask)
            this (assoc this :upMask upMask)
        ]
            this
        )
    )

    #_unused
    (§ defn #_"IntegerStamp" IntegerStamp'create-3 [#_"int" bits, #_"long" lowerBoundInput, #_"long" upperBoundInput]
        (IntegerStamp'create-5 bits, lowerBoundInput, upperBoundInput, 0, (CodeUtil/mask bits))
    )

    (§ defn #_"IntegerStamp" IntegerStamp'create-5 [#_"int" bits, #_"long" lowerBoundInput, #_"long" upperBoundInput, #_"long" downMask, #_"long" upMask]
        ;; Set lower bound, use masks to make it more precise.
        (let [
            #_"long" minValue (IntegerStamp'minValueForMasks-3 bits, downMask, upMask)
            #_"long" lowerBoundTmp (max lowerBoundInput minValue)
            ;; Set upper bound, use masks to make it more precise.
            #_"long" maxValue (IntegerStamp'maxValueForMasks-3 bits, downMask, upMask)
            #_"long" upperBoundTmp (min upperBoundInput maxValue)
            ;; Assign masks now with the bounds in mind.
            #_"long" defaultMask (CodeUtil/mask bits)
            [#_"long" boundedDownMask #_"long" boundedUpMask]
                (cond
                    (= lowerBoundTmp upperBoundTmp) [lowerBoundTmp lowerBoundTmp]
                    (<= 0 lowerBoundTmp)
                        (let [
                            #_"int" upperBoundLeadingZeros (Long/numberOfLeadingZeros upperBoundTmp)
                            #_"long" differentBits (bit-xor lowerBoundTmp upperBoundTmp)
                            #_"int" sameBitCount (Long/numberOfLeadingZeros (<< differentBits upperBoundLeadingZeros))
                        ]
                           [(& upperBoundTmp (bit-not (>>> -1 (+ upperBoundLeadingZeros sameBitCount))))
                            (| upperBoundTmp          (>>> -1 (+ upperBoundLeadingZeros sameBitCount)))]
                        )
                    (<= 0 upperBoundTmp) [0 defaultMask]
                    :else
                        (let [
                            #_"int" lowerBoundLeadingOnes (Long/numberOfLeadingZeros (bit-not lowerBoundTmp))
                            #_"long" differentBits (bit-xor lowerBoundTmp upperBoundTmp)
                            #_"int" sameBitCount (Long/numberOfLeadingZeros (<< differentBits lowerBoundLeadingOnes))
                        ]
                           [(| (& lowerBoundTmp (bit-not (>>> -1 (+ lowerBoundLeadingOnes sameBitCount)))) (bit-not (>>> -1 lowerBoundLeadingOnes)))
                            (|    lowerBoundTmp          (>>> -1 (+ lowerBoundLeadingOnes sameBitCount))   (bit-not (>>> -1 lowerBoundLeadingOnes)))]
                        )
                )
        ]
            (IntegerStamp'new-5 bits, lowerBoundTmp, upperBoundTmp, (& defaultMask (| downMask boundedDownMask)), (& defaultMask upMask boundedUpMask))
        )
    )

    (§ defn- #_"long" IntegerStamp'significantBit-2 [#_"long" bits, #_"long" value]
        (& (>>> value (dec bits)) 1)
    )

    (§ defn- #_"long" IntegerStamp'minValueForMasks-3 [#_"int" bits, #_"long" downMask, #_"long" upMask]
        (if (zero? (IntegerStamp'significantBit-2 bits, upMask))
            ;; Value is always positive. Minimum value always positive.
            downMask
            ;; Value can be positive or negative. Minimum value always negative.
            (| downMask (<< -1 (dec bits)))
        )
    )

    (§ defn- #_"long" IntegerStamp'maxValueForMasks-3 [#_"int" bits, #_"long" downMask, #_"long" upMask]
        (if (= (IntegerStamp'significantBit-2 bits, downMask) 1)
            ;; Value is always negative. Maximum value always negative.
            (CodeUtil/signExtend upMask, bits)
            ;; Value can be positive or negative. Maximum value always positive.
            (& upMask (>>> (CodeUtil/mask bits) 1))
        )
    )

    (§ defn #_"IntegerStamp" IntegerStamp'stampForMask-3 [#_"int" bits, #_"long" downMask, #_"long" upMask]
        (IntegerStamp'new-5 bits, (IntegerStamp'minValueForMasks-3 bits, downMask, upMask), (IntegerStamp'maxValueForMasks-3 bits, downMask, upMask), downMask, upMask)
    )

    (§ override! #_"IntegerStamp" IntegerStamp''unrestricted-1 [#_"IntegerStamp" this]
        (IntegerStamp'new-5 (:bits this), (CodeUtil/minValue (:bits this)), (CodeUtil/maxValue (:bits this)), 0, (CodeUtil/mask (:bits this)))
    )

    (§ override! #_"IntegerStamp" IntegerStamp''empty-1 [#_"IntegerStamp" this]
        (IntegerStamp'new-5 (:bits this), (CodeUtil/maxValue (:bits this)), (CodeUtil/minValue (:bits this)), (CodeUtil/mask (:bits this)), 0)
    )

    #_unused
    (§ override! #_"Stamp" IntegerStamp''constant-2 [#_"IntegerStamp" this, #_"Constant" constant]
        (when (instance? PrimitiveConstant constant) => this
            (let [
                #_"long" value (#_"PrimitiveConstant" .asLong constant)
            ]
                (StampFactory'forInteger-3 (:bits this), value, value)
            )
        )
    )

    #_unused
    (§ override! #_"SerializableConstant" IntegerStamp''deserialize-2 [#_"IntegerStamp" this, #_"ByteBuffer" buffer]
        (case (:bits this)
             1 (JavaConstant/forBoolean (not (zero? (#_"ByteBuffer" .get buffer))))
             8 (JavaConstant/forByte (#_"ByteBuffer" .get buffer))
            16 (JavaConstant/forShort (#_"ByteBuffer" .getShort buffer))
            32 (JavaConstant/forInt (#_"ByteBuffer" .getInt buffer))
            64 (JavaConstant/forLong (#_"ByteBuffer" .getLong buffer))
        )
    )

    #_unused
    (§ override! #_"boolean" IntegerStamp''hasValues-1 [#_"IntegerStamp" this]
        (<= (:lowerBound this) (:upperBound this))
    )

    (§ override! #_"JavaKind" IntegerStamp''getStackKind-1 [#_"IntegerStamp" this]
        (if (< 32 (:bits this)) JavaKind/Long JavaKind/Int)
    )

    #_unused
    (§ override! #_"LIRKind" IntegerStamp''getLIRKind-1 [#_"IntegerStamp" this]
        (LIRKindTool'getIntegerKind-1 (:bits this))
    )

    #_unused
    (§ override! #_"ResolvedJavaType" IntegerStamp''javaType-1 [#_"IntegerStamp" this]
        (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess,
            (case (:bits this) 1 boolean'class 8 byte'class 16 short'class 32 int'class 64 long'class)
        )
    )

    (§ override! #_"boolean" IntegerStamp''isUnrestricted-1 [#_"IntegerStamp" this]
        (and (= (:lowerBound this) (CodeUtil/minValue (:bits this))) (= (:upperBound this) (CodeUtil/maxValue (:bits this))) (zero? (:downMask this)) (= (:upMask this) (CodeUtil/mask (:bits this))))
    )

    (§ method! #_"boolean" IntegerStamp''contains-2 [#_"IntegerStamp" this, #_"long" value]
        (and (<= (:lowerBound this) value (:upperBound this)) (= (& value (:downMask this)) (:downMask this)) (= (& value (:upMask this)) (& value (CodeUtil/mask (:bits this)))))
    )

    (§ method! #_"boolean" IntegerStamp''isPositive-1 [#_"IntegerStamp" this]
        (<= 0 (:lowerBound this))
    )

    (§ method! #_"boolean" IntegerStamp''isNegative-1 [#_"IntegerStamp" this]
        (<= (:upperBound this) 0)
    )

    (§ method! #_"boolean" IntegerStamp''isStrictlyPositive-1 [#_"IntegerStamp" this]
        (< 0 (:lowerBound this))
    )

    (§ method! #_"boolean" IntegerStamp''isStrictlyNegative-1 [#_"IntegerStamp" this]
        (< (:upperBound this) 0)
    )

    (§ method! #_"boolean" IntegerStamp''canBePositive-1 [#_"IntegerStamp" this]
        (< 0 (:upperBound this))
    )

    (§ method! #_"boolean" IntegerStamp''canBeNegative-1 [#_"IntegerStamp" this]
        (< (:lowerBound this) 0)
    )

    (§ method- #_"IntegerStamp" IntegerStamp''createStamp-6 [#_"IntegerStamp" this, #_"IntegerStamp" other, #_"long" lb, #_"long" ub, #_"long" dm, #_"long" um]
        (cond
            (or (< ub lb) (not (zero? (& dm (bit-not um)))) (and (zero? um) (or (pos? lb) (neg? ub))))
                (IntegerStamp''empty-1 this)
            (and (= lb (:lowerBound this)) (= ub (:upperBound this)) (= dm (:downMask this)) (= um (:upMask this)))
                this
            (and (= lb (:lowerBound other)) (= ub (:upperBound other)) (= dm (:downMask other)) (= um (:upMask other)))
                other
            :else
                (IntegerStamp'create-5 (:bits this), lb, ub, dm, um)
        )
    )

    #_unused
    (§ override! #_"Stamp" IntegerStamp''meet-2 [#_"IntegerStamp" this, #_"Stamp" stamp]
        (cond
            (= stamp this)           this
            (Stamp''isEmpty-1 this)  stamp
            (Stamp''isEmpty-1 stamp) this
            :else                    (IntegerStamp''createStamp-6 this, stamp, (min (:lowerBound this) (:lowerBound stamp)), (max (:upperBound this) (:upperBound stamp)), (& (:downMask this) (:downMask stamp)), (| (:upMask this) (:upMask stamp)))
        )
    )

    (§ override! #_"IntegerStamp" IntegerStamp''join-2 [#_"IntegerStamp" this, #_"Stamp" stamp]
        (cond
            (= stamp this) this
            :else          (IntegerStamp''createStamp-6 this, stamp, (max (:lowerBound this) (:lowerBound stamp)), (min (:upperBound this) (:upperBound stamp)), (| (:downMask this) (:downMask stamp)), (& (:upMask this) (:upMask stamp)))
        )
    )

    #_unused
    (§ override! #_"boolean" IntegerStamp''isCompatible-2 [#_"IntegerStamp" this, #_"Stamp" stamp]
        (or (= this stamp)
            (and (instance? IntegerStamp stamp)
                (= (:bits this) (:bits stamp))
            )
        )
    )

    #_unused
    (§ override! #_"boolean" IntegerStamp''isCompatible-2 [#_"IntegerStamp" this, #_"Constant" constant]
        (and (instance? PrimitiveConstant constant)
            (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind constant))
        )
    )

    (§ method! #_"long" IntegerStamp''unsignedUpperBound-1 [#_"IntegerStamp" this]
        (if (IntegerStamp''sameSignBounds-1 this)
            (CodeUtil/zeroExtend (:upperBound this), (:bits this))
            (NumUtil'maxValueUnsigned-1 (:bits this))
        )
    )

    (§ method! #_"long" IntegerStamp''unsignedLowerBound-1 [#_"IntegerStamp" this]
        (if (IntegerStamp''sameSignBounds-1 this)
            (CodeUtil/zeroExtend (:lowerBound this), (:bits this))
            0
        )
    )

    (§ method- #_"boolean" IntegerStamp''sameSignBounds-1 [#_"IntegerStamp" this]
        (NumUtil'sameSign-2 (:lowerBound this), (:upperBound this))
    )

    (§ defn- #_"long" IntegerStamp'upMaskFor-3 [#_"int" bits, #_"long" lowerBound, #_"long" upperBound]
        (let [
            #_"long" mask (| lowerBound upperBound)
        ]
            (if (zero? mask) 0 (& (>>> -1 (Long/numberOfLeadingZeros mask)) (CodeUtil/mask bits)))
        )
    )

    ;;;
     ; Checks if the 2 stamps represent values of the same sign. Returns true if the two stamps are
     ; both positive or nil or if they are both strictly negative.
     ;;
    (§ defn #_"boolean" IntegerStamp'sameSign-2 [#_"IntegerStamp" s1, #_"IntegerStamp" s2]
        (or (and (IntegerStamp''isPositive-1 s1) (IntegerStamp''isPositive-1 s2))
            (and (IntegerStamp''isStrictlyNegative-1 s1) (IntegerStamp''isStrictlyNegative-1 s2))
        )
    )

    (§ override! #_"JavaConstant" IntegerStamp''asConstant-1 [#_"IntegerStamp" this]
        (when (= (:lowerBound this) (:upperBound this))
            (case (:bits this)
                 1 (JavaConstant/forBoolean (not (zero? (:lowerBound this))))
                 8 (JavaConstant/forByte          (byte (:lowerBound this)))
                16 (JavaConstant/forShort        (short (:lowerBound this)))
                32 (JavaConstant/forInt            (int (:lowerBound this)))
                64 (JavaConstant/forLong                (:lowerBound this))
                nil
            )
        )
    )

    (§ defn #_"boolean" IntegerStamp'addCanOverflow-2 [#_"IntegerStamp" a, #_"IntegerStamp" b]
        (or (IntegerStamp'addOverflowsPositively-3 (:upperBound a), (:upperBound b), (:bits a))
            (IntegerStamp'addOverflowsNegatively-3 (:lowerBound a), (:lowerBound b), (:bits a))
        )
    )

    (§ defn #_"boolean" IntegerStamp'addOverflowsPositively-3 [#_"long" x, #_"long" y, #_"int" bits]
        (let [
            #_"long" z (+ x y)
        ]
            (if (= bits 64) (neg? (& (bit-not x) (bit-not y) z)) (< (CodeUtil/maxValue bits) z))
        )
    )

    (§ defn #_"boolean" IntegerStamp'addOverflowsNegatively-3 [#_"long" x, #_"long" y, #_"int" bits]
        (let [
            #_"long" z (+ x y)
        ]
            (if (= bits 64) (neg? (& x y (bit-not z))) (< z (CodeUtil/minValue bits)))
        )
    )

    (§ defn #_"long" IntegerStamp'carryBits-2 [#_"long" x, #_"long" y]
        (bit-xor (+ x y) x y)
    )

    (§ defn- #_"long" IntegerStamp'saturate-2 [#_"long" v, #_"int" bits]
        (when (< bits 64) => v
            (min (max (CodeUtil/minValue bits) v) (CodeUtil/maxValue bits))
        )
    )

    (§ defn #_"boolean" IntegerStamp'multiplicationOverflows-3 [#_"long" a, #_"long" b, #_"int" bits]
        (let [
            #_"long" result (* a b)
            ;; result is positive if the sign is the same
            #_"boolean" positive (or (and (<= 0 a) (<= 0 b)) (and (neg? a) (neg? b)))
        ]
            (if (= bits 64)
                (cond
                    (and (pos? a) (pos? b)) (> a (quot 0x7fffffffffffffff b))
                    (and (pos? a) (<= b 0)) (< b (quot 0x8000000000000000 a))
                    (and (<= a 0) (pos? b)) (< a (quot 0x8000000000000000 b))
                    :else ;; a <= 0 && b <= 0
                       (and (not (zero? a)) (< b (quot 0x7fffffffffffffff a)))
                )
                (if positive (< (CodeUtil/maxValue bits) result) (< result (CodeUtil/minValue bits)))
            )
        )
    )

    (§ defn #_"boolean" IntegerStamp'multiplicationCanOverflow-2 [#_"IntegerStamp" a, #_"IntegerStamp" b]
        ;; see IntegerStamp#foldStamp for details
        (cond
            (zero? (:upMask a)) false
            (zero? (:upMask b)) false
            (IntegerStamp''isUnrestricted-1 a) true
            (IntegerStamp''isUnrestricted-1 b) true
            :else
                (let [
                    #_"int" bits (:bits a)
                    #_"long" minNegA (:lowerBound a)
                    #_"long" maxNegA (min 0 (:upperBound a))
                    #_"long" minPosA (max 0 (:lowerBound a))
                    #_"long" maxPosA (:upperBound a)
                    #_"long" minNegB (:lowerBound b)
                    #_"long" maxNegB (min 0 (:upperBound b))
                    #_"long" minPosB (max 0 (:lowerBound b))
                    #_"long" maxPosB (:upperBound b)
                    #_"boolean" mayOverflow false
                ]
                    (when (IntegerStamp''canBePositive-1 a)
                        (when (IntegerStamp''canBePositive-1 b)
                            (§ ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 maxPosA, maxPosB, bits)))
                            (§ ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 minPosA, minPosB, bits)))
                        )
                        (when (IntegerStamp''canBeNegative-1 b)
                            (§ ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 minPosA, maxNegB, bits)))
                            (§ ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 maxPosA, minNegB, bits)))
                        )
                    )
                    (when (IntegerStamp''canBeNegative-1 a)
                        (when (IntegerStamp''canBePositive-1 b)
                            (§ ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 maxNegA, minPosB, bits)))
                            (§ ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 minNegA, maxPosB, bits)))
                        )
                        (when (IntegerStamp''canBeNegative-1 b)
                            (§ ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 minNegA, minNegB, bits)))
                            (§ ass mayOverflow (or mayOverflow (IntegerStamp'multiplicationOverflows-3 maxNegA, maxNegB, bits)))
                        )
                    )
                    mayOverflow
                )
        )
    )

    (§ defn #_"boolean" IntegerStamp'subtractionCanOverflow-2 [#_"IntegerStamp" x, #_"IntegerStamp" y]
        (or (IntegerStamp'subtractionOverflows-3 (:lowerBound x), (:upperBound y), (:bits x))
            (IntegerStamp'subtractionOverflows-3 (:upperBound x), (:lowerBound y), (:bits x))
        )
    )

    (§ defn #_"boolean" IntegerStamp'subtractionOverflows-3 [#_"long" x, #_"long" y, #_"int" bits]
        (if (= bits 64)
            (neg? (& (bit-xor x y) (bit-xor x (- x y))))
            (not (<= (CodeUtil/minValue bits) (- x y) (CodeUtil/maxValue bits)))
        )
    )

    (§ def #_"ArithmeticOpTable" IntegerStamp'OPS (ß ArithmeticOpTable'new
    (§ args
        (§ reify #_"Neg" (Neg'new-0)
            #_unused
            (§ override! #_"Constant" Neg''foldConstant-2 [#_"Neg" this, #_"Constant" value]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind value), (- (#_"PrimitiveConstant" .asLong value)))
            )

            #_unused
            (§ override! #_"Stamp" Neg''foldStamp-2 [#_"Neg" this, #_"Stamp" stamp]
                (when-not (Stamp''isEmpty-1 stamp) => stamp
                    (let [
                        #_"int" bits (:bits stamp)
                    ]
                        (cond
                            (= (:lowerBound stamp) (:upperBound stamp))
                                (let [
                                    #_"long" value (CodeUtil/convert (- (:lowerBound stamp)), bits, false)
                                ]
                                    (StampFactory'forInteger-3 bits, value, value)
                                )
                            (not= (:lowerBound stamp) (CodeUtil/minValue bits))
                                ;; TODO check if the mask calculation is correct
                                (StampFactory'forInteger-3 bits, (- (:upperBound stamp)), (- (:lowerBound stamp)))
                            :else
                                (IntegerStamp''unrestricted-1 stamp)
                        )
                    )
                )
            )
        )

        (§ reify #_"Add" (Add'new-2 true, true)
            #_unused
            (§ override! #_"Constant" Add''foldConstant-3 [#_"Add" this, #_"Constant" a, #_"Constant" b]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (+ (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
            )

            #_unused
            (§ override! #_"Stamp" Add''foldStamp-3 [#_"Add" this, #_"Stamp" a, #_"Stamp" b]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    :else
                        (let [
                            #_"int" bits (:bits a)
                        ]
                            (cond
                                (and (= (:lowerBound a) (:upperBound a)) (= (:lowerBound b) (:upperBound b)))
                                    (let [
                                        #_"long" value (CodeUtil/convert (+ (:lowerBound a) (:lowerBound b)), bits, false)
                                    ]
                                        (StampFactory'forInteger-3 bits, value, value)
                                    )
                                (IntegerStamp''isUnrestricted-1 a) a
                                (IntegerStamp''isUnrestricted-1 b) b
                                :else
                                    (let [
                                        #_"long" defaultMask (CodeUtil/mask bits)
                                        #_"long" variableBits (| (bit-xor (:downMask a) (:upMask a)) (bit-xor (:downMask b) (:upMask b)))
                                        #_"long" variableBitsWithCarry (| variableBits (bit-xor (IntegerStamp'carryBits-2 (:downMask a), (:downMask b)) (IntegerStamp'carryBits-2 (:upMask a), (:upMask b))))
                                        #_"long" newDownMask (& (+ (:downMask a) (:downMask b)) (bit-not variableBitsWithCarry))
                                        #_"long" newUpMask (| (+ (:downMask a) (:downMask b)) variableBitsWithCarry)
                                        newDownMask (& newDownMask defaultMask)
                                        newUpMask (& newUpMask defaultMask)
                                        [#_"long" lower #_"long" upper]
                                            (if (or (and (IntegerStamp'addOverflowsNegatively-3 (:lowerBound a), (:lowerBound b), bits) (not (IntegerStamp'addOverflowsNegatively-3 (:upperBound a), (:upperBound b), bits))) (and (not (IntegerStamp'addOverflowsPositively-3 (:lowerBound a), (:lowerBound b), bits)) (IntegerStamp'addOverflowsPositively-3 (:upperBound a), (:upperBound b), bits)))
                                                [(CodeUtil/minValue bits) (CodeUtil/maxValue bits)]
                                                [(CodeUtil/signExtend (& (+ (:lowerBound a) (:lowerBound b)) defaultMask), bits) (CodeUtil/signExtend (& (+ (:upperBound a) (:upperBound b)) defaultMask), bits)]
                                            )
                                        #_"IntegerStamp" limit (StampFactory'forInteger-3 bits, lower, upper)
                                        newUpMask (& newUpMask (:upMask limit))
                                        upper (CodeUtil/signExtend (& upper newUpMask), bits)
                                        newDownMask (| newDownMask (:downMask limit))
                                        lower (| lower newDownMask)
                                    ]
                                        (IntegerStamp'new-5 bits, lower, upper, newDownMask, newUpMask)
                                    )
                            )
                        )
                )
            )

            #_unused
            (§ override! #_"boolean" Add''isNeutral-2 [#_"Add" this, #_"Constant" value]
                (zero? (#_"PrimitiveConstant" .asLong value))
            )
        )

        (§ reify #_"Sub" (Sub'new-2 true, false)
            #_unused
            (§ override! #_"Constant" Sub''foldConstant-3 [#_"Sub" this, #_"Constant" a, #_"Constant" b]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (- (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
            )

            #_unused
            (§ override! #_"Stamp" Sub''foldStamp-3 [#_"Sub" this, #_"Stamp" a, #_"Stamp" b]
                (BinaryOp''foldStamp-3 (:add IntegerStamp'OPS), a, (UnaryOp''foldStamp-2 (:neg IntegerStamp'OPS), b))
            )

            #_unused
            (§ override! #_"boolean" Sub''isNeutral-2 [#_"Sub" this, #_"Constant" value]
                (zero? (#_"PrimitiveConstant" .asLong value))
            )

            #_unused
            (§ override! #_"Constant" Sub''getZero-2 [#_"Sub" this, #_"Stamp" stamp]
                (JavaConstant/forPrimitiveInt (:bits stamp), 0)
            )
        )

        (§ reify #_"Mul" (Mul'new-2 true, true)
            #_unused
            (§ override! #_"Constant" Mul''foldConstant-3 [#_"Mul" this, #_"Constant" a, #_"Constant" b]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (* (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
            )

            #_unused
            (§ override! #_"Stamp" Mul''foldStamp-3 [#_"Mul" this, #_"Stamp" a, #_"Stamp" b]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    :else
                        (let [
                            #_"int" bits (:bits a)
                        ]
                            (cond
                                (and (= (:lowerBound a) (:upperBound a)) (= (:lowerBound b) (:upperBound b)))
                                    (let [
                                        #_"long" value (CodeUtil/convert (* (:lowerBound a) (:lowerBound b)), bits, false)
                                    ]
                                        (StampFactory'forInteger-3 bits, value, value)
                                    )
                                ;; if a==0 or b==0 result of a*b is always 0
                                (zero? (:upMask a)) a
                                (zero? (:upMask b)) b
                                ;; if a or b has the full range, the result will also have it
                                (IntegerStamp''isUnrestricted-1 a) a
                                (IntegerStamp''isUnrestricted-1 b) b
                                :else
                                    ;; a != 0 && b != 0 holds
                                    (let [
                                        #_"long" lower Long/MAX_VALUE
                                        #_"long" upper Long/MIN_VALUE
                                        ;; Based on the signs of the incoming stamps lower and upper bound
                                        ;; of the result of the multiplication may be swapped. LowerBound
                                        ;; can become upper bound if both signs are negative, and so on. To
                                        ;; determine the new values for lower and upper bound we need to
                                        ;; look at the max and min of the cases blow:
                                        ;;
                                        ;; a.lowerBound * b.lowerBound
                                        ;; a.lowerBound * b.upperBound
                                        ;; a.upperBound * b.lowerBound
                                        ;; a.upperBound * b.upperBound
                                        ;;
                                        ;; We are only interested in those cases that are relevant due to
                                        ;; the sign of the involved stamps (whether a stamp includes
                                        ;; negative and/or positive values). Based on the signs, the maximum
                                        ;; or minimum of the above multiplications form the new lower and
                                        ;; upper bounds.
                                        ;;
                                        ;; The table below contains the interesting candidates for lower and
                                        ;; upper bound after multiplication.
                                        ;;
                                        ;; For example if we consider two stamps a & b that both contain
                                        ;; negative and positive values, the product of minNegA * minNegB
                                        ;; (both the smallest negative value for each stamp) can only be the
                                        ;; highest positive number. The other candidates can be computed in
                                        ;; a similar fashion. Some of them can never be a new minimum or
                                        ;; maximum and are therefore excluded.
                                        ;;
                                        ;;          [x................0................y]
                                        ;;          -------------------------------------
                                        ;;          [minNeg     maxNeg minPos     maxPos]
                                        ;;
                                        ;;          where maxNeg = min(0,y) && minPos = max(0,x)
                                        ;;
                                        ;;                 |minNegA  maxNegA    minPosA  maxPosA
                                        ;;         _______ |____________________________________
                                        ;;         minNegB | MAX        /     :     /      MIN
                                        ;;         maxNegB |  /        MIN    :    MAX      /
                                        ;;                 |------------------+-----------------
                                        ;;         minPosB |  /        MAX    :    MIN      /
                                        ;;         maxPosB | MIN        /     :     /      MAX

                                        ;; We materialize all factors here. If they are needed, the signs of
                                        ;; the stamp will ensure the correct value is used.
                                        #_"long" minNegA (:lowerBound a)
                                        #_"long" maxNegA (min 0 (:upperBound a))
                                        #_"long" minPosA (max 0 (:lowerBound a))
                                        #_"long" maxPosA (:upperBound a)
                                        #_"long" minNegB (:lowerBound b)
                                        #_"long" maxNegB (min 0 (:upperBound b))
                                        #_"long" minPosB (max 0 (:lowerBound b))
                                        #_"long" maxPosB (:upperBound b)
                                        ;; multiplication has shift semantics
                                        #_"long" newUpMask (& (bit-not (CodeUtil/mask (min 64 (+ (Long/numberOfTrailingZeros (:upMask a)) (Long/numberOfTrailingZeros (:upMask b)))))) (CodeUtil/mask bits))
                                    ]
                                        (when (IntegerStamp''canBePositive-1 a)
                                            (when (IntegerStamp''canBePositive-1 b)
                                                (when (IntegerStamp'multiplicationOverflows-3 maxPosA, maxPosB, bits)
                                                    (§ return (IntegerStamp''unrestricted-1 a))
                                                )
                                                (let [
                                                    #_"long" maxCandidate (* maxPosA maxPosB)
                                                ]
                                                    (when (IntegerStamp'multiplicationOverflows-3 minPosA, minPosB, bits)
                                                        (§ return (IntegerStamp''unrestricted-1 a))
                                                    )
                                                    (let [
                                                        #_"long" minCandidate (* minPosA minPosB)
                                                    ]
                                                        (§ ass lower (min lower minCandidate))
                                                        (§ ass upper (max upper maxCandidate))
                                                    )
                                                )
                                            )
                                            (when (IntegerStamp''canBeNegative-1 b)
                                                (when (IntegerStamp'multiplicationOverflows-3 minPosA, maxNegB, bits)
                                                    (§ return (IntegerStamp''unrestricted-1 a))
                                                )
                                                (let [
                                                    #_"long" maxCandidate (* minPosA maxNegB)
                                                ]
                                                    (when (IntegerStamp'multiplicationOverflows-3 maxPosA, minNegB, bits)
                                                        (§ return (IntegerStamp''unrestricted-1 a))
                                                    )
                                                    (let [
                                                        #_"long" minCandidate (* maxPosA minNegB)
                                                    ]
                                                        (§ ass lower (min lower minCandidate))
                                                        (§ ass upper (max upper maxCandidate))
                                                    )
                                                )
                                            )
                                        )
                                        (when (IntegerStamp''canBeNegative-1 a)
                                            (when (IntegerStamp''canBePositive-1 b)
                                                (when (IntegerStamp'multiplicationOverflows-3 maxNegA, minPosB, bits)
                                                    (§ return (IntegerStamp''unrestricted-1 a))
                                                )
                                                (let [
                                                    #_"long" maxCandidate (* maxNegA minPosB)
                                                ]
                                                    (when (IntegerStamp'multiplicationOverflows-3 minNegA, maxPosB, bits)
                                                        (§ return (IntegerStamp''unrestricted-1 a))
                                                    )
                                                    (let [
                                                        #_"long" minCandidate (* minNegA maxPosB)
                                                    ]
                                                        (§ ass lower (min lower minCandidate))
                                                        (§ ass upper (max upper maxCandidate))
                                                    )
                                                )
                                            )
                                            (when (IntegerStamp''canBeNegative-1 b)
                                                (when (IntegerStamp'multiplicationOverflows-3 minNegA, minNegB, bits)
                                                    (§ return (IntegerStamp''unrestricted-1 a))
                                                )
                                                (let [
                                                    #_"long" maxCandidate (* minNegA minNegB)
                                                ]
                                                    (when (IntegerStamp'multiplicationOverflows-3 maxNegA, maxNegB, bits)
                                                        (§ return (IntegerStamp''unrestricted-1 a))
                                                    )
                                                    (let [
                                                        #_"long" minCandidate (* maxNegA maxNegB)
                                                    ]
                                                        (§ ass lower (min lower minCandidate))
                                                        (§ ass upper (max upper maxCandidate))
                                                    )
                                                )
                                            )
                                        )

                                        (StampFactory'forIntegerWithMask-5 bits, lower, upper, 0, newUpMask)
                                    )
                            )
                        )
                )
            )

            #_unused
            (§ override! #_"boolean" Mul''isNeutral-2 [#_"Mul" this, #_"Constant" value]
                (= (#_"PrimitiveConstant" .asLong value) 1)
            )
        )

        (§ reify #_"MulHigh" (MulHigh'new-2 true, true)
            #_unused
            (§ override! #_"Constant" MulHigh''foldConstant-3 [#_"MulHigh" this, #_"Constant" a, #_"Constant" b]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (PrimitiveStamp''multiplyHigh-4 this, (#_"PrimitiveConstant" .asLong a), (#_"PrimitiveConstant" .asLong b), (#_"PrimitiveConstant" .getJavaKind a)))
            )

            #_unused
            (§ override! #_"Stamp" MulHigh''foldStamp-3 [#_"MulHigh" this, #_"Stamp" a, #_"Stamp" b]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    (or (Stamp''isEmpty-1 a)               (Stamp''isEmpty-1 b))               (IntegerStamp''empty-1 a)
                    (or (IntegerStamp''isUnrestricted-1 a) (IntegerStamp''isUnrestricted-1 b)) (IntegerStamp''unrestricted-1 a)
                    :else
                        (let [
                            #_"JavaKind" javaKind (IntegerStamp''getStackKind-1 a)
                            #_"long[]" xExtremes (§ array (:lowerBound a), (:upperBound a) )
                            #_"long[]" yExtremes (§ array (:lowerBound b), (:upperBound b) )
                            [#_"long" lower #_"long" upper]
                                (loop-when [lower Long/MAX_VALUE upper Long/MIN_VALUE #_"ISeq" s (seq xExtremes)] (some? s) => [lower upper]
                                    (let [
                                        #_"long" x (first s)
                                        [lower upper]
                                            (loop-when [lower lower upper upper #_"ISeq" s (seq yExtremes)] (some? s) => [lower upper]
                                                (let [
                                                    #_"long" y (first s)
                                                    #_"long" z (PrimitiveStamp''multiplyHigh-4 this, x, y, javaKind)
                                                ]
                                                    (recur (min lower z) (max upper z) (next s))
                                                )
                                            )
                                    ]
                                        (recur lower upper (next s))
                                    )
                                )
                        ]
                            (StampFactory'forInteger-3 javaKind, lower, upper)
                        )
                )
            )

            #_unused
            (§ override! #_"boolean" MulHigh''isNeutral-2 [#_"MulHigh" this, #_"Constant" value]
                false
            )

            #_unused
            (§ method- #_"long" MulHigh''multiplyHigh-4 [#_"MulHigh" this, #_"long" x, #_"long" y, #_"JavaKind" javaKind]
                (if (= javaKind JavaKind/Int)
                    (>> (* x y) 32)
                    (let [
                        #_"long" x0 (& x 0xffffffff)
                        #_"long" x1 (>> x 32)
                        #_"long" y0 (& y 0xffffffff)
                        #_"long" y1 (>> y 32)
                        #_"long" z0 (* x0 y0)
                        #_"long" t (+ (* x1 y0) (>>> z0 32))
                        #_"long" z1 (& t 0xffffffff)
                        #_"long" z2 (>> t 32)
                        z1 (+ z1 (* x0 y1))
                    ]
                        (+ (* x1 y1) z2 (>> z1 32))
                    )
                )
            )
        )

        (§ reify #_"UMulHigh" (UMulHigh'new-2 true, true)
            #_unused
            (§ override! #_"Constant" UMulHigh''foldConstant-3 [#_"UMulHigh" this, #_"Constant" a, #_"Constant" b]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (PrimitiveStamp''multiplyHighUnsigned-4 this, (#_"PrimitiveConstant" .asLong a), (#_"PrimitiveConstant" .asLong b), (#_"PrimitiveConstant" .getJavaKind a)))
            )

            #_unused
            (§ override! #_"Stamp" UMulHigh''foldStamp-3 [#_"UMulHigh" this, #_"Stamp" a, #_"Stamp" b]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    (or (Stamp''isEmpty-1 a)               (Stamp''isEmpty-1 b))               (IntegerStamp''empty-1 a)
                    (or (IntegerStamp''isUnrestricted-1 a) (IntegerStamp''isUnrestricted-1 b)) (IntegerStamp''unrestricted-1 a)
                    :else
                        ;; Note that the minima and maxima are calculated using signed min/max
                        ;; functions, while the values themselves are unsigned.
                        (let [
                            #_"JavaKind" javaKind (IntegerStamp''getStackKind-1 a)
                            #_"long[]" xExtremes (PrimitiveStamp''getUnsignedExtremes-2 this, a)
                            #_"long[]" yExtremes (PrimitiveStamp''getUnsignedExtremes-2 this, b)
                            [#_"long" lower #_"long" upper]
                                (loop-when [lower Long/MAX_VALUE upper Long/MIN_VALUE #_"ISeq" s (seq xExtremes)] (some? s) => [lower upper]
                                    (let [
                                        #_"long" x (first s)
                                        [lower upper]
                                            (loop-when [lower lower upper upper #_"ISeq" s (seq yExtremes)] (some? s) => [lower upper]
                                                (let [
                                                    #_"long" y (first s)
                                                    #_"long" z (PrimitiveStamp''multiplyHighUnsigned-4 this, x, y, javaKind)
                                                ]
                                                    (recur (min lower z) (max upper z) (next s))
                                                )
                                            )
                                    ]
                                        (recur lower upper (next s))
                                    )
                                )
                        ]
                            ;; if min is negative, then the value can reach into the unsigned range
                            (if (or (= lower upper) (<= 0 lower))
                                (StampFactory'forInteger-3 javaKind, lower, upper)
                                (StampFactory'forKind-1 javaKind)
                            )
                        )
                )
            )

            #_unused
            (§ override! #_"boolean" UMulHigh''isNeutral-2 [#_"UMulHigh" this, #_"Constant" value]
                false
            )

            #_unused
            (§ method- #_"long[]" UMulHigh''getUnsignedExtremes-2 [#_"UMulHigh" this, #_"IntegerStamp" stamp]
                (if (and (< (:lowerBound stamp) 0) (<= 0 (:upperBound stamp)))
                    ;; If -1 and 0 are both in the signed range, then we can't say anything
                    ;; about the unsigned range, so we have to return [0, MAX_UNSIGNED].
                    (long-array [ 0, -1 ])
                    (long-array [ (:lowerBound stamp), (:upperBound stamp) ])
                )
            )

            #_unused
            (§ method- #_"long" UMulHigh''multiplyHighUnsigned-4 [#_"UMulHigh" this, #_"long" x, #_"long" y, #_"JavaKind" javaKind]
                (if (= javaKind JavaKind/Int)
                    (let [
                        #_"long" xl (& x 0xffffffff)
                        #_"long" yl (& y 0xffffffff)
                        #_"long" r (* xl yl)
                    ]
                        (int (>>> r 32))
                    )
                    (let [
                        #_"long" x0 (& x 0xffffffff)
                        #_"long" x1 (>>> x 32)
                        #_"long" y0 (& y 0xffffffff)
                        #_"long" y1 (>>> y 32)
                        #_"long" z0 (* x0 y0)
                        #_"long" t (+ (* x1 y0) (z0 >>> 32))
                        #_"long" z1 (& t 0xffffffff)
                        #_"long" z2 (>>> t 32)
                        z1 (+ z1 (* x0 y1))
                    ]
                        (+ (* x1 y1) z2 (>>> z1 32))
                    )
                )
            )
        )

        (§ reify #_"Div" (Div'new-2 true, false)
            #_unused
            (§ override! #_"Constant" Div''foldConstant-3 [#_"Div" this, #_"Constant" a, #_"Constant" b]
                (when-not (zero? (#_"PrimitiveConstant" .asLong b))
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (quot (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                )
            )

            #_unused
            (§ override! #_"Stamp" Div''foldStamp-3 [#_"Div" this, #_"Stamp" a, #_"Stamp" b]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    :else
                        (let [
                            #_"int" bits (:bits a)
                        ]
                            (cond
                                (and (= (:lowerBound a) (:upperBound a)) (= (:lowerBound b) (:upperBound b)) (not (zero? (:lowerBound b))))
                                    (let [
                                        #_"long" value (CodeUtil/convert (quot (:lowerBound a) (:lowerBound b)), bits, false)
                                    ]
                                        (StampFactory'forInteger-3 bits, value, value)
                                    )
                                (IntegerStamp''isStrictlyPositive-1 b)
                                    (let [
                                        #_"long" lower (if (neg? (:lowerBound a)) (quot (:lowerBound a) (:lowerBound b)) (quot (:lowerBound a) (:upperBound b)))
                                        #_"long" upper (if (neg? (:upperBound a)) (quot (:upperBound a) (:upperBound b)) (quot (:upperBound a) (:lowerBound b)))
                                    ]
                                        (StampFactory'forInteger-3 bits, lower, upper)
                                    )
                                :else
                                    (IntegerStamp''unrestricted-1 a)
                            )
                        )
                )
            )

            #_unused
            (§ override! #_"boolean" Div''isNeutral-2 [#_"Div" this, #_"Constant" value]
                (= (#_"PrimitiveConstant" .asLong value) 1)
            )
        )

        (§ reify #_"Rem" (Rem'new-2 false, false)
            #_unused
            (§ override! #_"Constant" Rem''foldConstant-3 [#_"Rem" this, #_"Constant" a, #_"Constant" b]
                (when-not (zero? (#_"PrimitiveConstant" .asLong b))
                    (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (% (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
                )
            )

            #_unused
            (§ override! #_"Stamp" Rem''foldStamp-3 [#_"Rem" this, #_"Stamp" a, #_"Stamp" b]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    :else
                        (let [
                            #_"int" bits (:bits a)
                        ]
                            (if (and (= (:lowerBound a) (:upperBound a)) (= (:lowerBound b) (:upperBound b)) (not (zero? (:lowerBound b))))
                                (let [
                                    #_"long" value (CodeUtil/convert (% (:lowerBound a) (:lowerBound b)), bits, false)
                                ]
                                    (StampFactory'forInteger-3 bits, value, value)
                                )
                                ;; zero is always possible
                                (let [
                                    #_"long" lower (min (:lowerBound a) 0)
                                    #_"long" upper (max (:upperBound a) 0)
                                    ;; the maximum absolute value of the result, derived from b
                                    #_"long" magnitude
                                        (if (= (:lowerBound b) (CodeUtil/minValue (:bits b)))
                                            ;; Math.abs(...) - 1 does not work in a case
                                            (CodeUtil/maxValue (:bits b))
                                            (dec (max (abs (:lowerBound b)) (abs (:upperBound b))))
                                        )
                                    lower (max lower (- magnitude))
                                    upper (min upper magnitude)
                                ]
                                    (StampFactory'forInteger-3 bits, lower, upper)
                                )
                            )
                        )
                )
            )
        )

        (§ reify #_"Not" (Not'new-0)
            #_unused
            (§ override! #_"Constant" Not''foldConstant-2 [#_"Not" this, #_"Constant" constant]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind constant), (bit-not (#_"PrimitiveConstant" .asLong constant)))
            )

            #_unused
            (§ override! #_"Stamp" Not''foldStamp-2 [#_"Not" this, #_"Stamp" stamp]
                (when-not (Stamp''isEmpty-1 stamp) => stamp
                    (let [
                        #_"int" bits (:bits stamp)
                        #_"long" mask (CodeUtil/mask bits)
                    ]
                        (IntegerStamp'new-5 bits, (bit-not (:upperBound stamp)), (bit-not (:lowerBound stamp)), (& (bit-not (:upMask stamp)) mask), (& (bit-not (:downMask stamp)) mask))
                    )
                )
            )
        )

        (§ reify #_"And" (And'new-2 true, true)
            #_unused
            (§ override! #_"Constant" And''foldConstant-3 [#_"And" this, #_"Constant" a, #_"Constant" b]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (& (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
            )

            #_unused
            (§ override! #_"Stamp" And''foldStamp-3 [#_"And" this, #_"Stamp" a, #_"Stamp" b]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    :else                (IntegerStamp'stampForMask-3 (:bits a), (& (:downMask a) (:downMask b)), (& (:upMask a) (:upMask b)))
                )
            )

            #_unused
            (§ override! #_"boolean" And''isNeutral-2 [#_"And" this, #_"Constant" value]
                (let [
                    #_"long" mask (CodeUtil/mask (#_"JavaKind" .getBitCount (#_"PrimitiveConstant" .getJavaKind value)))
                ]
                    (= (& (#_"PrimitiveConstant" .asLong value) mask) mask)
                )
            )
        )

        (§ reify #_"Or" (Or'new-2 true, true)
            #_unused
            (§ override! #_"Constant" Or''foldConstant-3 [#_"Or" this, #_"Constant" a, #_"Constant" b]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (| (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
            )

            #_unused
            (§ override! #_"Stamp" Or''foldStamp-3 [#_"Or" this, #_"Stamp" a, #_"Stamp" b]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    :else                (IntegerStamp'stampForMask-3 (:bits a), (| (:downMask a) (:downMask b)), (| (:upMask a) (:upMask b)))
                )
            )

            #_unused
            (§ override! #_"boolean" Or''isNeutral-2 [#_"Or" this, #_"Constant" value]
                (zero? (#_"PrimitiveConstant" .asLong value))
            )
        )

        (§ reify #_"Xor" (Xor'new-2 true, true)
            #_unused
            (§ override! #_"Constant" Xor''foldConstant-3 [#_"Xor" this, #_"Constant" a, #_"Constant" b]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind a), (bit-xor (#_"PrimitiveConstant" .asLong a) (#_"PrimitiveConstant" .asLong b)))
            )

            #_unused
            (§ override! #_"Stamp" Xor''foldStamp-3 [#_"Xor" this, #_"Stamp" a, #_"Stamp" b]
                (cond
                    (Stamp''isEmpty-1 a) a
                    (Stamp''isEmpty-1 b) b
                    :else
                        (let [
                            #_"long" variableBits (| (bit-xor (:downMask a) (:upMask a)) (bit-xor (:downMask b) (:upMask b)))
                            #_"long" downMask (& (bit-xor (:downMask a) (:downMask b)) (bit-not variableBits))
                            #_"long" upMask (| (bit-xor (:downMask a) (:downMask b)) variableBits)
                        ]
                            (IntegerStamp'stampForMask-3 (:bits a), downMask, upMask)
                        )
                )
            )

            #_unused
            (§ override! #_"boolean" Xor''isNeutral-2 [#_"Xor" this, #_"Constant" value]
                (zero? (#_"PrimitiveConstant" .asLong value))
            )

            #_unused
            (§ override! #_"Constant" Xor''getZero-2 [#_"Xor" this, #_"Stamp" stamp]
                (JavaConstant/forPrimitiveInt (:bits stamp), 0)
            )
        )

        (§ reify #_"Shl" (Shl'new-0)
            #_unused
            (§ override! #_"Constant" Shl''foldConstant-3 [#_"Shl" this, #_"Constant" value, #_"int" amount]
                (condp = (#_"PrimitiveConstant" .getJavaKind value)
                    JavaKind/Int  (JavaConstant/forInt (<< (#_"PrimitiveConstant" .asInt value) amount))
                    JavaKind/Long (JavaConstant/forLong (<< (#_"PrimitiveConstant" .asLong value) amount))
                )
            )

            #_unused
            (§ override! #_"Stamp" Shl''foldStamp-3 [#_"Shl" this, #_"Stamp" stamp, #_"IntegerStamp" shift]
                (let [
                    #_"int" bits (:bits stamp)
                ]
                    (cond
                        (Stamp''isEmpty-1 stamp) stamp
                        (Stamp''isEmpty-1 shift) (IntegerStamp''empty-1 (StampFactory'forInteger-1 bits))
                        (zero? (:upMask stamp))  stamp
                        :else
                            (let [
                                #_"int" shiftMask (PrimitiveStamp''getShiftAmountMask-2 this, stamp)
                                #_"int" shiftBits (Integer/bitCount shiftMask)
                            ]
                                (when (= (:lowerBound shift) (:upperBound shift))
                                    (let [
                                        #_"int" shiftAmount (int (& (:lowerBound shift) shiftMask))
                                    ]
                                        (when (zero? shiftAmount)
                                            (§ return stamp)
                                        )
                                        ;; the mask of bits that will be lost or shifted into the sign bit
                                        (let [
                                            #_"long" removedBits (<< -1 (- bits shiftAmount 1))
                                        ]
                                            (when (and (zero? (& (:lowerBound stamp) removedBits)) (zero? (& (:upperBound stamp) removedBits)))
                                                ;; use a better stamp if neither lower nor upper bound can lose bits
                                                (§ return (IntegerStamp'new-5 bits, (<< (:lowerBound stamp) shiftAmount), (<< (:upperBound stamp) shiftAmount), (<< (:downMask stamp) shiftAmount), (<< (:upMask stamp) shiftAmount)))
                                            )
                                        )
                                    )
                                )
                                (when (= (>>> (:lowerBound shift) shiftBits) (>>> (:upperBound shift) shiftBits)) => (IntegerStamp''unrestricted-1 stamp)
                                    (let [
                                        #_"long" defaultMask (CodeUtil/mask bits)
                                        [#_"long" downMask #_"long" upMask]
                                            (loop-when [downMask defaultMask upMask 0 #_"long" i (:lowerBound shift)] (<= i (:upperBound shift)) => [downMask upMask]
                                                (let [
                                                    [downMask upMask]
                                                        (when (IntegerStamp''contains-2 shift, i) => [downMask upMask]
                                                            [(& downMask (<< (:downMask stamp) (& i shiftMask))) (| upMask (<< (:upMask stamp) (& i shiftMask)))]
                                                        )
                                                ]
                                                    (recur downMask upMask (inc i))
                                                )
                                            )
                                    ]
                                        (IntegerStamp'stampForMask-3 bits, downMask, (& upMask defaultMask))
                                    )
                                )
                            )
                    )
                )
            )

            #_unused
            (§ override! #_"int" Shl''getShiftAmountMask-2 [#_"Shl" this, #_"Stamp" stamp]
                (dec (:bits stamp))
            )
        )

        (§ reify #_"Shr" (Shr'new-0)
            #_unused
            (§ override! #_"Constant" Shr''foldConstant-3 [#_"Shr" this, #_"Constant" value, #_"int" amount]
                (condp = (#_"PrimitiveConstant" .getJavaKind value)
                    JavaKind/Int  (JavaConstant/forInt (>> (#_"PrimitiveConstant" .asInt value) amount))
                    JavaKind/Long (JavaConstant/forLong (>> (#_"PrimitiveConstant" .asLong value) amount))
                )
            )

            #_unused
            (§ override! #_"Stamp" Shr''foldStamp-3 [#_"Shr" this, #_"Stamp" stamp, #_"IntegerStamp" shift]
                (let [
                    #_"int" bits (:bits stamp)
                ]
                    (cond
                        (Stamp''isEmpty-1 stamp) stamp
                        (Stamp''isEmpty-1 shift) (IntegerStamp''empty-1 (StampFactory'forInteger-1 bits))
                        (= (:lowerBound shift) (:upperBound shift))
                            (let [
                                #_"long" shiftAmount (& (:lowerBound shift) (PrimitiveStamp''getShiftAmountMask-2 this, stamp))
                            ]
                                (when-not (zero? shiftAmount) => stamp
                                    (let [
                                        #_"int" extraBits (- 64 bits)
                                        #_"long" defaultMask (CodeUtil/mask bits)
                                        ;; shifting back and forth performs sign extension
                                        #_"long" downMask (& (>> (<< (:downMask stamp) extraBits) (+ shiftAmount extraBits)) defaultMask)
                                        #_"long" upMask (& (>> (<< (:upMask stamp) extraBits) (+ shiftAmount extraBits)) defaultMask)
                                    ]
                                        (IntegerStamp'new-5 bits, (>> (:lowerBound stamp) shiftAmount), (>> (:upperBound stamp) shiftAmount), downMask, upMask)
                                    )
                                )
                            )
                        :else
                            (IntegerStamp'stampForMask-3 bits, 0, (IntegerStamp'upMaskFor-3 bits, (:lowerBound stamp), (:upperBound stamp)))
                    )
                )
            )

            #_unused
            (§ override! #_"int" Shr''getShiftAmountMask-2 [#_"Shr" this, #_"Stamp" stamp]
                (dec (:bits stamp))
            )
        )

        (§ reify #_"UShr" (UShr'new-0)
            #_unused
            (§ override! #_"Constant" UShr''foldConstant-3 [#_"UShr" this, #_"Constant" value, #_"int" amount]
                (condp = (#_"PrimitiveConstant" .getJavaKind value)
                    JavaKind/Int  (JavaConstant/forInt (>>> (#_"PrimitiveConstant" .asInt value) amount))
                    JavaKind/Long (JavaConstant/forLong (>>> (#_"PrimitiveConstant" .asLong value) amount))
                )
            )

            #_unused
            (§ override! #_"Stamp" UShr''foldStamp-3 [#_"UShr" this, #_"Stamp" stamp, #_"IntegerStamp" shift]
                (let [
                    #_"int" bits (:bits stamp)
                ]
                    (cond
                        (Stamp''isEmpty-1 stamp) stamp
                        (Stamp''isEmpty-1 shift) (IntegerStamp''empty-1 (StampFactory'forInteger-1 bits))
                        (= (:lowerBound shift) (:upperBound shift))
                            (let [
                                #_"long" shiftAmount (& (:lowerBound shift) (PrimitiveStamp''getShiftAmountMask-2 this, stamp))
                            ]
                                (when-not (zero? shiftAmount) => stamp
                                    (let [
                                        #_"long" downMask (>>> (:downMask stamp) shiftAmount)
                                        #_"long" upMask (>>> (:upMask stamp) shiftAmount)
                                    ]
                                        (if (neg? (:lowerBound stamp))
                                            (IntegerStamp'new-5 bits, downMask, upMask, downMask, upMask)
                                            (IntegerStamp'new-5 bits, (>>> (:lowerBound stamp) shiftAmount), (>>> (:upperBound stamp) shiftAmount), downMask, upMask)
                                        )
                                    )
                                )
                            )
                        :else
                            (IntegerStamp'stampForMask-3 bits, 0, (IntegerStamp'upMaskFor-3 bits, (:lowerBound stamp), (:upperBound stamp)))
                    )
                )
            )

            #_unused
            (§ override! #_"int" UShr''getShiftAmountMask-2 [#_"UShr" this, #_"Stamp" stamp]
                (dec (:bits stamp))
            )
        )

        (§ reify #_"Abs" (Abs'new-0)
            #_unused
            (§ override! #_"Constant" Abs''foldConstant-2 [#_"Abs" this, #_"Constant" constant]
                (JavaConstant/forIntegerKind (#_"PrimitiveConstant" .getJavaKind constant), (abs (#_"PrimitiveConstant" .asLong constant)))
            )

            #_unused
            (§ override! #_"Stamp" Abs''foldStamp-2 [#_"Abs" this, #_"Stamp" stamp]
                (cond
                    (Stamp''isEmpty-1 stamp)
                        stamp
                    (= (:lowerBound stamp) (:upperBound stamp))
                        (let [
                            #_"long" value (CodeUtil/convert (abs (:lowerBound stamp)), (:bits stamp), false)
                        ]
                            (StampFactory'forInteger-3 (:bits stamp), value, value)
                        )
                    (= (:lowerBound stamp) (CodeUtil/minValue (:bits stamp)))
                        (Stamp''unrestricted-1 stamp)
                    :else
                        (StampFactory'forInteger-3 (:bits stamp), 0, (max (- (:lowerBound stamp)) (:upperBound stamp)))
                )
            )
        )

        (§ reify #_"ZeroExtend" (ZeroExtend'new-0)
            #_unused
            (§ override! #_"Constant" ZeroExtend''foldConstant-4 [#_"ZeroExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Constant" constant]
                (JavaConstant/forPrimitiveInt resultBits, (CodeUtil/zeroExtend (#_"PrimitiveConstant" .asLong constant), inputBits))
            )

            #_unused
            (§ override! #_"Stamp" ZeroExtend''foldStamp-4 [#_"ZeroExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                (cond
                    (Stamp''isEmpty-1 stamp) (IntegerStamp''empty-1 (StampFactory'forInteger-1 resultBits))
                    (= inputBits resultBits) stamp
                    :else
                        (let [
                            #_"long" downMask (CodeUtil/zeroExtend (:downMask stamp), inputBits)
                            #_"long" upMask (CodeUtil/zeroExtend (:upMask stamp), inputBits)
                            #_"long" lowerBound (IntegerStamp''unsignedLowerBound-1 stamp)
                            #_"long" upperBound (IntegerStamp''unsignedUpperBound-1 stamp)
                        ]
                            (IntegerStamp'create-5 resultBits, lowerBound, upperBound, downMask, upMask)
                        )
                )
            )

            #_unused
            (§ override! #_"Stamp" ZeroExtend''invertStamp-4 [#_"ZeroExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                (if (Stamp''isEmpty-1 stamp)
                    (IntegerStamp''empty-1 (StampFactory'forInteger-1 inputBits))
                    (StampFactory'forUnsignedInteger-5 inputBits, (:lowerBound stamp), (:upperBound stamp), (:downMask stamp), (:upMask stamp))
                )
            )
        )

        (§ reify #_"SignExtend" (SignExtend'new-0)
            #_unused
            (§ override! #_"Constant" SignExtend''foldConstant-4 [#_"SignExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Constant" constant]
                (JavaConstant/forPrimitiveInt resultBits, (CodeUtil/signExtend (#_"PrimitiveConstant" .asLong constant), inputBits))
            )

            #_unused
            (§ override! #_"Stamp" SignExtend''foldStamp-4 [#_"SignExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                (if (Stamp''isEmpty-1 stamp)
                    (IntegerStamp''empty-1 (StampFactory'forInteger-1 resultBits))
                    (let [
                        #_"long" defaultMask (CodeUtil/mask resultBits)
                        #_"long" downMask (CodeUtil/signExtend (:downMask stamp), (& inputBits defaultMask))
                        #_"long" upMask (CodeUtil/signExtend (:upMask stamp), (& inputBits defaultMask))
                    ]
                        (IntegerStamp'new-5 resultBits, (:lowerBound stamp), (:upperBound stamp), downMask, upMask)
                    )
                )
            )

            #_unused
            (§ override! #_"Stamp" SignExtend''invertStamp-4 [#_"SignExtend" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                (if (Stamp''isEmpty-1 stamp)
                    (IntegerStamp''empty-1 (StampFactory'forInteger-1 inputBits))
                    (let [
                        #_"long" mask (CodeUtil/mask inputBits)
                    ]
                        (StampFactory'forIntegerWithMask-5 inputBits, (:lowerBound stamp), (:upperBound stamp), (& (:downMask stamp) mask), (& (:upMask stamp) mask))
                    )
                )
            )
        )

        (§ reify #_"Narrow" (Narrow'new-0)
            #_unused
            (§ override! #_"Constant" Narrow''foldConstant-4 [#_"Narrow" this, #_"int" inputBits, #_"int" resultBits, #_"Constant" constant]
                (JavaConstant/forPrimitiveInt resultBits, (CodeUtil/narrow (#_"PrimitiveConstant" .asLong constant), resultBits))
            )

            #_unused
            (§ override! #_"Stamp" Narrow''foldStamp-4 [#_"Narrow" this, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
                (cond
                    (Stamp''isEmpty-1 stamp) (IntegerStamp''empty-1 (StampFactory'forInteger-1 resultBits))
                    (= inputBits resultBits) stamp
                    :else
                        (let [
                            #_"long" upperBound
                                (if (< (:lowerBound stamp) (CodeUtil/minValue resultBits))
                                    (CodeUtil/maxValue resultBits)
                                    (IntegerStamp'saturate-2 (:upperBound stamp), resultBits)
                                )
                            #_"long" lowerBound
                                (if (< (CodeUtil/maxValue resultBits) (:upperBound stamp))
                                    (CodeUtil/minValue resultBits)
                                    (IntegerStamp'saturate-2 (:lowerBound stamp), resultBits)
                                )
                            #_"long" defaultMask (CodeUtil/mask resultBits)
                            #_"long" downMask (& (:downMask stamp) defaultMask)
                            #_"long" upMask (& (:upMask stamp) defaultMask)
                            #_"long" lower (CodeUtil/signExtend (& (| lowerBound downMask) upMask), resultBits)
                            #_"long" upper (CodeUtil/signExtend (& (| upperBound downMask) upMask), resultBits)
                        ]
                            (IntegerStamp'new-5 resultBits, lower, upper, downMask, upMask)
                        )
                )
            )
        )
    )))
)

(class-ns ObjectStamp (§ extends AbstractObjectStamp)
    (§ defn #_"ObjectStamp" ObjectStamp'new-4 [#_"ResolvedJavaType" type, #_"boolean" exactType, #_"boolean" never-nil?, #_"boolean" always-nil?]
        (AbstractObjectStamp'new-4 type, exactType, never-nil?, always-nil?)
    )

    #_unused
    (§ override #_"ObjectStamp" ObjectStamp''copyWith-5 [#_"ObjectStamp" this, #_"ResolvedJavaType" type, #_"boolean" exactType, #_"boolean" never-nil?, #_"boolean" always-nil?]
        (ObjectStamp'new-4 type, exactType, never-nil?, always-nil?)
    )

    #_unused
    (§ override #_"Stamp" ObjectStamp''unrestricted-1 [#_"ObjectStamp" this]
        StampFactory'objectStamp
    )

    #_unused
    (§ override #_"boolean" ObjectStamp''isCompatible-2 [#_"ObjectStamp" this, #_"Stamp" other]
        (or (= this other) (instance? ObjectStamp other))
    )

    #_unused
    (§ override #_"boolean" ObjectStamp''isCompatible-2 [#_"ObjectStamp" this, #_"Constant" constant]
        (and (instance? JavaConstant constant)
            (#_"JavaKind" .isObject (#_"JavaConstant" .getJavaKind constant))
        )
    )

    #_unused
    (§ override #_"LIRKind" ObjectStamp''getLIRKind-1 [#_"ObjectStamp" this]
        (LIRKindTool'getObjectKind-0)
    )

    #_unused
    (§ override #_"Constant" ObjectStamp''readConstant-4 [#_"ObjectStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
        (try
            (#_"MemoryAccessProvider" .readObjectConstant provider, base, displacement)
            (catch IllegalArgumentException _
                nil ;; it's possible that the base and displacement aren't valid together, so simply return nil
            )
        )
    )
)

;;;
 ; Type describing primitive values.
 ;;
(class-ns PrimitiveStamp (§ extends ArithmeticStamp)
    ;;;
     ; The width in bits of the value described by this stamp.
     ;;
    (§ final #_"int" :bits 0)

    (§ defn #_"PrimitiveStamp" PrimitiveStamp'new-2 [#_"int" bits, #_"ArithmeticOpTable" ops]
        (let [
            #_"PrimitiveStamp" this (ArithmeticStamp'new-1 ops)
            this (assoc this :bits bits)
        ]
            this
        )
    )

    (§ defn #_"int" PrimitiveStamp'getBits-1 [#_"Stamp" stamp]
        (if (instance? PrimitiveStamp stamp) (:bits stamp) 0)
    )

    #_unused
    (§ override #_"Constant" PrimitiveStamp''readConstant-4 [#_"PrimitiveStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
        (try
            (#_"MemoryAccessProvider" .readPrimitiveConstant provider, (Stamp''getStackKind-1 this), base, displacement, (:bits this))
            (catch IllegalArgumentException _
                nil ;; it's possible that the base and displacement aren't valid together, so simply return nil
            )
        )
    )
)

;;;
 ; Type describing pointers to raw memory. This stamp is used for example for direct pointers
 ; to fields or array elements.
 ;;
(final-ns RawPointerStamp (§ extends AbstractPointerStamp)
    (§ defn #_"RawPointerStamp" RawPointerStamp'new-0 []
        (AbstractPointerStamp'new-2 false, false)
    )

    #_unused
    (§ override! #_"LIRKind" RawPointerStamp''getLIRKind-1 [#_"RawPointerStamp" this]
        (LIRKindTool'getWordKind-0)
    )

    #_unused
    (§ override! #_"AbstractPointerStamp" RawPointerStamp''copyWith-3 [#_"RawPointerStamp" this, #_"boolean" newNonNull, #_"boolean" newAlwaysNull]
        ;; RawPointerStamp is a singleton
        this
    )

    #_unused
    (§ override! #_"Stamp" RawPointerStamp''meet-2 [#_"RawPointerStamp" this, #_"Stamp" other]
        this
    )

    #_unused
    (§ override! #_"Stamp" RawPointerStamp''improveWith-2 [#_"RawPointerStamp" this, #_"Stamp" other]
        this
    )

    #_unused
    (§ override! #_"Stamp" RawPointerStamp''join-2 [#_"RawPointerStamp" this, #_"Stamp" other]
        this
    )

    #_unused
    (§ override! #_"Stamp" RawPointerStamp''unrestricted-1 [#_"RawPointerStamp" this]
        this
    )

    #_unused
    (§ override! #_"Stamp" RawPointerStamp''empty-1 [#_"RawPointerStamp" this]
        ;; there is no empty pointer stamp
        this
    )

    #_unused
    (§ override! #_"boolean" RawPointerStamp''hasValues-1 [#_"RawPointerStamp" this]
        true
    )

    #_unused
    (§ override! #_"ResolvedJavaType" RawPointerStamp''javaType-1 [#_"RawPointerStamp" this]
        (throw! "pointer has no Java type")
    )

    #_unused
    (§ override! #_"Stamp" RawPointerStamp''constant-2 [#_"RawPointerStamp" this, #_"Constant" constant]
        this
    )

    #_unused
    (§ override! #_"boolean" RawPointerStamp''isCompatible-2 [#_"RawPointerStamp" this, #_"Stamp" other]
        (instance? RawPointerStamp other)
    )

    #_unused
    (§ override! #_"boolean" RawPointerStamp''isCompatible-2 [#_"RawPointerStamp" this, #_"Constant" constant]
        (when (instance? PrimitiveConstant constant) => (instance? DataPointerConstant constant)
            (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind constant))
        )
    )

    #_unused
    (§ override! #_"Constant" RawPointerStamp''readConstant-4 [#_"RawPointerStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
        (throw! "can't read raw pointer")
    )
)

;;;
 ; A stamp is the basis for a type system.
 ;;
(class-ns Stamp
    (§ defn #_"Stamp" Stamp'new-0 []
        (Object.)
    )

    ;;;
     ; Returns the type of the stamp, guaranteed to be non-nil. In some cases, it requires the
     ; lookup of class metadata.
     ;;
    (§ abstract #_"ResolvedJavaType" Stamp''javaType-1 [#_"Stamp" this])

    (§ method #_"boolean" Stamp''alwaysDistinct-2 [#_"Stamp" this, #_"Stamp" other]
        (Stamp''isEmpty-1 (Stamp''join-2 this, other))
    )

    ;;;
     ; Gets a Java JavaKind that can be used to store a value of this stamp on the Java
     ; bytecode stack. Returns JavaKind#Illegal if a value of this stamp can not be stored
     ; on the bytecode stack.
     ;;
    (§ abstract #_"JavaKind" Stamp''getStackKind-1 [#_"Stamp" this])

    ;;;
     ; Gets a platform dependent LIRKind that can be used to store a value of this stamp.
     ;;
    (§ abstract #_"LIRKind" Stamp''getLIRKind-1 [#_"Stamp" this])

    ;;;
     ; Returns the union of this stamp and the given stamp. Typically used to create stamps for phi nodes.
     ;
     ; @param other The stamp that will enlarge this stamp.
     ; @return the union of this stamp and the given stamp
     ;;
    (§ abstract #_"Stamp" Stamp''meet-2 [#_"Stamp" this, #_"Stamp" other])

    ;;;
     ; Returns the intersection of this stamp and the given stamp.
     ;
     ; @param other The stamp that will tighten this stamp.
     ; @return the intersection of this stamp and the given stamp
     ;;
    (§ abstract #_"Stamp" Stamp''join-2 [#_"Stamp" this, #_"Stamp" other])

    ;;;
     ; Returns a stamp of the same kind, but allowing the full value range of the kind.
     ;
     ; #unrestricted() is the neutral element of the #join(Stamp) operation.
     ;;
    (§ abstract #_"Stamp" Stamp''unrestricted-1 [#_"Stamp" this])

    ;;;
     ; Returns a stamp of the same kind, but with no allowed values.
     ;
     ; #empty() is the neutral element of the #meet(Stamp) operation.
     ;;
    (§ abstract #_"Stamp" Stamp''empty-1 [#_"Stamp" this])

    ;;;
     ; If it is possible to represent single value stamps of this kind, this method returns the
     ; stamp representing the single value c. stamp.constant(c).asConstant() should be equal to c.
     ;
     ; If it is not possible to represent single value stamps, this method returns a stamp that
     ; includes c, and is otherwise as narrow as possible.
     ;;
    (§ abstract #_"Stamp" Stamp''constant-2 [#_"Stamp" this, #_"Constant" constant])

    ;;;
     ; Test whether two stamps have the same base type.
     ;;
    (§ abstract #_"boolean" Stamp''isCompatible-2 [#_"Stamp" this, #_"Stamp" other])

    ;;;
     ; Check that the constant {@code other} is compatible with this stamp.
     ;;
    (§ abstract #_"boolean" Stamp''isCompatible-2 [#_"Stamp" this, #_"Constant" constant])

    ;;;
     ; Test whether this stamp has legal values.
     ;;
    (§ abstract #_"boolean" Stamp''hasValues-1 [#_"Stamp" this])

    ;;;
     ; Tests whether this stamp represents an illegal value.
     ;;
    (§ method! #_"boolean" Stamp''isEmpty-1 [#_"Stamp" this]
        (not (Stamp''hasValues-1 this))
    )

    ;;;
     ; Tests whether this stamp represents all values of this kind.
     ;;
    (§ method #_"boolean" Stamp''isUnrestricted-1 [#_"Stamp" this]
        (= this (Stamp''unrestricted-1 this))
    )

    ;;;
     ; If this stamp represents a single value, the methods returns this single value, nil otherwise.
     ;
     ; @return the constant corresponding to the single value of this stamp and nil if this stamp
     ;         can represent less or more than one value.
     ;;
    (§ method #_"Constant" Stamp''asConstant-1 [#_"Stamp" this]
        nil
    )

    ;;;
     ; Read a value of this stamp from memory.
     ;
     ; @return the value read or nil if the value can't be read for some reason
     ;;
    (§ abstract #_"Constant" Stamp''readConstant-4 [#_"Stamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement])

    ;;;
     ; Tries to improve this stamp with the stamp given as parameter. If successful, returns the new
     ; improved stamp. Otherwise, returns a stamp equal to this.
     ;
     ; @param other the stamp that should be used to improve this stamp
     ; @return the newly improved stamp or a stamp equal to {@code this} if an improvement was not possible
     ;;
    (§ abstract #_"Stamp" Stamp''improveWith-2 [#_"Stamp" this, #_"Stamp" other])

    ;;;
     ; Tries to improve this stamp with the stamp given as parameter. If successful, returns the new
     ; improved stamp. Otherwise, returns nil.
     ;
     ; @param other the stamp that should be used to improve this stamp
     ; @return the newly improved stamp or nil if an improvement was not possible
     ;;
    (§ method! #_"Stamp" Stamp''tryImproveWith-2 [#_"Stamp" this, #_"Stamp" other]
        (let [
            #_"Stamp" improved (Stamp''improveWith-2 this, other)
        ]
            (when-not (= improved this)
                improved
            )
        )
    )

    (§ method! #_"boolean" Stamp''neverDistinct-2 [#_"Stamp" this, #_"Stamp" other]
        (let [
            #_"Constant" constant (Stamp''asConstant-1 this)
        ]
            (and (some? constant)
                (let [
                    #_"Constant" otherConstant (Stamp''asConstant-1 other)
                ]
                    (and (some? otherConstant) (= constant otherConstant))
                )
            )
        )
    )
)

(value-ns StampFactory
    (§ def- #_"Stamp[]" StampFactory'stampCache      (make-array Stamp (count (JavaKind/values))))
    (§ def- #_"Stamp[]" StampFactory'emptyStampCache (make-array Stamp (count (JavaKind/values))))

    (§ defn- #_"void" StampFactory'setCache-2 [#_"JavaKind" kind, #_"Stamp" stamp]
        (aset StampFactory'stampCache (#_"JavaKind" .ordinal kind) stamp)
        nil
    )

    (§ defn- #_"void" StampFactory'setIntCache-1 [#_"JavaKind" kind]
        (let [
            #_"int" bits (#_"JavaKind" .getBitCount (#_"JavaKind" .getStackKind kind))
            #_"long" mask (CodeUtil/mask (if (#_"JavaKind" .isUnsigned kind) (#_"JavaKind" .getBitCount kind) bits))
        ]
            (StampFactory'setCache-2 kind, (IntegerStamp'create-5 bits, (#_"JavaKind" .getMinValue kind), (#_"JavaKind" .getMaxValue kind), 0, mask))
        )
        nil
    )

    (§ init
        (StampFactory'setIntCache-1 JavaKind/Boolean)
        (StampFactory'setIntCache-1 JavaKind/Byte)
        (StampFactory'setIntCache-1 JavaKind/Short)
        (StampFactory'setIntCache-1 JavaKind/Char)
        (StampFactory'setIntCache-1 JavaKind/Int)
        (StampFactory'setIntCache-1 JavaKind/Long)

        (StampFactory'setCache-2 JavaKind/Object, StampFactory'objectStamp)
        (StampFactory'setCache-2 JavaKind/Void, (VoidStamp'getInstance-0))
        (StampFactory'setCache-2 JavaKind/Illegal, IllegalStamp'instance)

        (doseq [#_"JavaKind" k (JavaKind/values)]
            (when (some? (nth StampFactory'stampCache (#_"JavaKind" .ordinal k)))
                (aset StampFactory'emptyStampCache (#_"JavaKind" .ordinal k) (Stamp''empty-1 (nth StampFactory'stampCache (#_"JavaKind" .ordinal k))))
            )
        )
    )

    ;;;
     ; Return a stamp for a Java kind, as it would be represented on the bytecode stack.
     ;;
    (§ defn #_"Stamp" StampFactory'forKind-1 [#_"JavaKind" kind]
        (nth StampFactory'stampCache (#_"JavaKind" .ordinal kind))
    )

    ;;;
     ; Return the stamp for the {@code void} type. This will return a singleton instance
     ; than can be compared using {@code ==}.
     ;;
    (§ defn #_"Stamp" StampFactory'forVoid-0 []
        (VoidStamp'getInstance-0)
    )

    (§ defn #_"Stamp" StampFactory'intValue-0 []
        (StampFactory'forKind-1 JavaKind/Int)
    )

    #_unused
    (§ defn #_"Stamp" StampFactory'empty-1 [#_"JavaKind" kind]
        (nth StampFactory'emptyStampCache (#_"JavaKind" .ordinal kind))
    )

    (§ defn #_"IntegerStamp" StampFactory'forInteger-5 [#_"JavaKind" kind, #_"long" lowerBound, #_"long" upperBound, #_"long" downMask, #_"long" upMask]
        (IntegerStamp'create-5 (#_"JavaKind" .getBitCount kind), lowerBound, upperBound, downMask, upMask)
    )

    (§ defn #_"IntegerStamp" StampFactory'forInteger-3 [#_"JavaKind" kind, #_"long" lowerBound, #_"long" upperBound]
        (StampFactory'forInteger-3 (#_"JavaKind" .getBitCount kind), lowerBound, upperBound)
    )

    ;;;
     ; Create a new stamp use {@code lower} and {@code upper} computing the appropriate
     ; IntegerStamp#upMask and IntegerStamp#downMask and incorporating
     ; any mask information from {@code maskStamp}.
     ;
     ; @return a new stamp with the appropriate bounds and masks
     ;;
    #_unused
    (§ defn #_"IntegerStamp" StampFactory'forIntegerWithMask-4 [#_"int" bits, #_"long" lower, #_"long" upper, #_"IntegerStamp" maskStamp]
        (let [
            #_"IntegerStamp" limit (StampFactory'forInteger-3 bits, lower, upper)
        ]
            (IntegerStamp'create-5 bits, lower, upper, (| (:downMask limit) (:downMask maskStamp)), (& (:upMask limit) (:upMask maskStamp)))
        )
    )

    (§ defn #_"IntegerStamp" StampFactory'forIntegerWithMask-5 [#_"int" bits, #_"long" lower, #_"long" upper, #_"long" newDownMask, #_"long" newUpMask]
        (let [
            #_"IntegerStamp" limit (StampFactory'forInteger-3 bits, lower, upper)
        ]
            (IntegerStamp'create-5 bits, lower, upper, (| (:downMask limit) newDownMask), (& (:upMask limit) newUpMask))
        )
    )

    (§ defn #_"IntegerStamp" StampFactory'forInteger-1 [#_"int" bits]
        (IntegerStamp'create-5 bits, (CodeUtil/minValue bits), (CodeUtil/maxValue bits), 0, (CodeUtil/mask bits))
    )

    #_unused
    (§ defn #_"IntegerStamp" StampFactory'forUnsignedInteger-1 [#_"int" bits]
        (StampFactory'forUnsignedInteger-5 bits, 0, (NumUtil'maxValueUnsigned-1 bits), 0, (CodeUtil/mask bits))
    )

    (§ defn #_"IntegerStamp" StampFactory'forUnsignedInteger-3 [#_"int" bits, #_"long" unsignedLowerBound, #_"long" unsignedUpperBound]
        (StampFactory'forUnsignedInteger-5 bits, unsignedLowerBound, unsignedUpperBound, 0, (CodeUtil/mask bits))
    )

    (§ defn #_"IntegerStamp" StampFactory'forUnsignedInteger-5 [#_"int" bits, #_"long" unsignedLowerBound, #_"long" unsignedUpperBound, #_"long" downMask, #_"long" upMask]
        (let [
            #_"long" lowerBound (CodeUtil/signExtend unsignedLowerBound, bits)
            #_"long" upperBound (CodeUtil/signExtend unsignedUpperBound, bits)
            [lowerBound upperBound]
                (when-not (NumUtil'sameSign-2 lowerBound, upperBound) => [lowerBound upperBound]
                    [(CodeUtil/minValue bits) (CodeUtil/maxValue bits)]
                )
            #_"long" mask (CodeUtil/mask bits)
        ]
            (IntegerStamp'create-5 bits, lowerBound, upperBound, (& downMask mask), (& upMask mask))
        )
    )

    (§ defn #_"IntegerStamp" StampFactory'forInteger-3 [#_"int" bits, #_"long" lowerBound, #_"long" upperBound]
        (IntegerStamp'create-5 bits, lowerBound, upperBound, 0, (CodeUtil/mask bits))
    )

    (§ defn #_"Stamp" StampFactory'forPrimitiveConstant-1 [#_"JavaConstant" value]
        (let [
            #_"JavaKind" kind (#_"JavaConstant" .getJavaKind value)
        ]
            (condp =? kind
               [JavaKind/Boolean JavaKind/Byte JavaKind/Char JavaKind/Short JavaKind/Int JavaKind/Long]
                    (let [
                        #_"long" mask (& (#_"JavaConstant" .asLong value) (CodeUtil/mask (#_"JavaKind" .getBitCount kind)))
                    ]
                        (StampFactory'forInteger-5 (#_"JavaKind" .getStackKind kind), (#_"JavaConstant" .asLong value), (#_"JavaConstant" .asLong value), mask, mask)
                    )
                JavaKind/Illegal
                    (StampFactory'forKind-1 JavaKind/Illegal)
                JavaKind/Object
                    (if (#_"JavaConstant" .isNull value) StampFactory'objectAlwaysNullStamp StampFactory'objectNonNullStamp)
            )
        )
    )

    (§ defn #_"Stamp" StampFactory'forConstant-1 [#_"JavaConstant" value]
        (when (= (#_"JavaConstant" .getJavaKind value) JavaKind/Object) => (StampFactory'forPrimitiveConstant-1 value)
            (let [
                #_"ResolvedJavaType" type (when-not (#_"JavaConstant" .isNull value) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, value))
            ]
                (ObjectStamp'new-4 type, (#_"JavaConstant" .isNonNull value), (#_"JavaConstant" .isNonNull value), (#_"JavaConstant" .isNull value))
            )
        )
    )

    (§ defn #_"ObjectStamp" StampFactory'object-1 [#_"TypeReference" type]
        (StampFactory'object-2 type, false)
    )

    (§ defn #_"ObjectStamp" StampFactory'objectNonNull-1 [#_"TypeReference" type]
        (StampFactory'object-2 type, true)
    )

    (§ defn #_"ObjectStamp" StampFactory'object-2 [#_"TypeReference" type, #_"boolean" never-nil?]
        (if (some? type)
            (ObjectStamp'new-4 (:type type), (:exactReference type), never-nil?, false)
            (ObjectStamp'new-4 nil, false, never-nil?, false)
        )
    )

    (§ defn #_"StampPair" StampFactory'forDeclaredType-2 [#_"JavaType" type, #_"boolean" never-nil?]
        (if (and (= (#_"JavaType" .getJavaKind type) JavaKind/Object) (instance? ResolvedJavaType type))
            (let [
                #_"TypeReference" reference (TypeReference'create-1 type)
                #_"ResolvedJavaType" elementalType (#_"ResolvedJavaType" .getElementalType type)
            ]
                (if (#_"ResolvedJavaType" .isInterface elementalType)
                    (let [
                        #_"ResolvedJavaType" elementalImplementor (#_"ResolvedJavaType" .getSingleImplementor elementalType)
                        #_"TypeReference" uncheckedType
                            (if (and (some? elementalImplementor) (not (= elementalType elementalImplementor)))
                                (let [
                                    #_"ResolvedJavaType" implementor
                                        (loop-when-recur [implementor elementalImplementor #_"ResolvedJavaType" t type]
                                                         (#_"ResolvedJavaType" .isArray t)
                                                         [(#_"ResolvedJavaType" .getArrayClass implementor) (#_"ResolvedJavaType" .getComponentType t)]
                                                      => implementor
                                        )
                                ]
                                    (TypeReference'createTrusted-1 implementor)
                                )
                                (TypeReference'createTrusted-1 type)
                            )
                    ]
                        (StampPair'new-2 (StampFactory'object-2 reference, never-nil?), (StampFactory'object-2 uncheckedType, never-nil?))
                    )
                    (StampPair'new-2 (StampFactory'object-2 reference, never-nil?), nil)
                )
            )
            (StampPair'new-2 (StampFactory'forKind-1 (#_"JavaType" .getJavaKind type)), nil)
        )
    )

    (§ def #_"Stamp" StampFactory'objectStamp           (ObjectStamp'new-4 nil, false, false, false))
    (§ def #_"Stamp" StampFactory'objectNonNullStamp    (ObjectStamp'new-4 nil, false, true, false))
    (§ def #_"Stamp" StampFactory'objectAlwaysNullStamp (ObjectStamp'new-4 nil, false, false, true))

    (§ def #_"Stamp" StampFactory'nonNegativeInt (StampFactory'forInteger-5 JavaKind/Int, 0, Integer/MAX_VALUE, 0, Integer/MAX_VALUE))
    (§ def #_"Stamp" StampFactory'booleanTrue    (StampFactory'forInteger-5 JavaKind/Boolean, -1, -1, 1, 1))
    (§ def #_"Stamp" StampFactory'booleanFalse   (StampFactory'forInteger-5 JavaKind/Boolean, 0, 0, 0, 0))

    (§ def #_"Stamp" StampFactory'rawPointer (RawPointerStamp'new-0))
)

;;;
 ; A pair of stamp with one being the stamp that can be trusted and the other one being a guess that
 ; needs a dynamic check to be used.
 ;;
(final-ns StampPair
    (§ final #_"Stamp" :trustedStamp nil)
    (§ final #_"Stamp" :uncheckedStamp nil)

    (§ defn #_"StampPair" StampPair'new-2 [#_"Stamp" trustedStamp, #_"Stamp" uncheckedStamp]
        (let [
            #_"StampPair" this (Object.)
            this (assoc this :trustedStamp trustedStamp)
            this (assoc this :uncheckedStamp uncheckedStamp)
        ]
            this
        )
    )
)

;;;
 ; This class represents a reference to a Java type and whether this reference is referring only
 ; to the represented type or also to its sub types in the class hierarchy. When creating a type
 ; reference, the following options have to be considered:
 ;
 ; (1) The reference should always only refer to the given concrete type. Use
 ; #createExactTrusted(ResolvedJavaType) for this purpose.
 ;
 ; (2) The reference should be created without assumptions about the class hierarchy. The returned
 ; reference is exact only when the type is a leaf type (i.e. it cannot have subclasses). Depending
 ; on whether interface types can be trusted for this type reference use
 ; #createWithoutAssumptions or #createTrustedWithoutAssumptions.
 ;
 ; (3) The reference should be created using assumptions about the class hierarchy. The returned
 ; reference is also exact, when there is only a single concrete sub type for the given type.
 ; Depending on whether interface types can be trusted for this type reference use #create
 ; or #createTrusted.
 ;
 ; For the methods with untrusted interface types, a nil reference will be constructed for
 ; untrusted interface types. Examples for interface types that cannot be trusted are types for
 ; parameters, fields, and return values. They are not checked by the Java verifier.
 ;;
(final-ns TypeReference
    ;;;
     ; The type this reference refers to.
     ;;
    (§ final #_"ResolvedJavaType" :type nil)
    ;;;
     ; true if this reference is exact = only refers to the given type,
     ; false if it also refers to its sub-types
     ;;
    (§ final #_"boolean" :exactReference false)

    (§ defn- #_"TypeReference" TypeReference'new-2 [#_"ResolvedJavaType" type, #_"boolean" exactReference]
        (let [
            #_"TypeReference" this (Object.)
            this (assoc this :type type)
            this (assoc this :exactReference exactReference)
        ]
            this
        )
    )

    ;;;
     ; Creates an exact type reference using the given type.
     ;;
    (§ defn #_"TypeReference" TypeReference'createExactTrusted-1 [#_"ResolvedJavaType" type]
        (when (some? type) (TypeReference'new-2 type, true))
    )

    ;;;
     ; Creates a type reference using the given type without trusting interface types.
     ;;
    (§ defn #_"TypeReference" TypeReference'create-1 [#_"ResolvedJavaType" type]
        (TypeReference'createTrusted-1 (TypeReference'filterInterfaceTypesOut-1 type))
    )

    ;;;
     ; Creates a type reference using the given type with trusting interface types.
     ;;
    (§ defn #_"TypeReference" TypeReference'createTrusted-1 [#_"ResolvedJavaType" type]
        (when (some? type)
            (let [
                #_"ResolvedJavaType" exactType (when (#_"ResolvedJavaType" .isLeaf type) type)
            ]
                (if (some? exactType) (TypeReference'new-2 exactType, true) (TypeReference'new-2 type, false))
            )
        )
    )

    ;;;
     ; @return a new reference that is guaranteed to be exact
     ;;
    #_unused
    (§ method! #_"TypeReference" TypeReference''asExactReference-1 [#_"TypeReference" this]
        (if (:exactReference this) this (TypeReference'new-2 (:type this), true))
    )

    (§ defn- #_"ResolvedJavaType" TypeReference'filterInterfaceTypesOut-1 [#_"ResolvedJavaType" type]
        (when (some? type)
            (if (#_"ResolvedJavaType" .isArray type)
                (let [
                    #_"ResolvedJavaType" componentType (TypeReference'filterInterfaceTypesOut-1 (#_"ResolvedJavaType" .getComponentType type))
                ]
                    (#_"ResolvedJavaType" .getArrayClass (or componentType (#_"ResolvedJavaType" .getSuperclass type))) ;; returns Object[].class
                )
                (when-not (#_"ResolvedJavaType" .isInterface type)
                    type
                )
            )
        )
    )
)

;;;
 ; Singleton stamp representing the value of type {@code void}.
 ;;
(final-ns VoidStamp (§ extends Stamp)
    (§ defn- #_"VoidStamp" VoidStamp'new-0 []
        (Stamp'new-0)
    )

    #_unused
    (§ override! #_"Stamp" VoidStamp''unrestricted-1 [#_"VoidStamp" this]
        this
    )

    #_unused
    (§ override! #_"boolean" VoidStamp''isUnrestricted-1 [#_"VoidStamp" this]
        true
    )

    #_unused
    (§ override! #_"JavaKind" VoidStamp''getStackKind-1 [#_"VoidStamp" this]
        JavaKind/Void
    )

    #_unused
    (§ override! #_"Stamp" VoidStamp''improveWith-2 [#_"VoidStamp" this, #_"Stamp" other]
        this
    )

    #_unused
    (§ override! #_"LIRKind" VoidStamp''getLIRKind-1 [#_"VoidStamp" this]
        (throw! "void stamp has no value")
    )

    #_unused
    (§ override! #_"ResolvedJavaType" VoidStamp''javaType-1 [#_"VoidStamp" this]
        (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, void'class)
    )

    #_unused
    (§ override! #_"boolean" VoidStamp''alwaysDistinct-2 [#_"VoidStamp" this, #_"Stamp" other]
        (not= this other)
    )

    #_unused
    (§ override! #_"Stamp" VoidStamp''meet-2 [#_"VoidStamp" this, #_"Stamp" other]
        this
    )

    #_unused
    (§ override! #_"Stamp" VoidStamp''join-2 [#_"VoidStamp" this, #_"Stamp" other]
        this
    )

    #_unused
    (§ override! #_"boolean" VoidStamp''isCompatible-2 [#_"VoidStamp" this, #_"Stamp" stamp]
        (instance? VoidStamp stamp)
    )

    #_unused
    (§ override! #_"boolean" VoidStamp''isCompatible-2 [#_"VoidStamp" this, #_"Constant" constant]
        false
    )

    #_unused
    (§ override! #_"Stamp" VoidStamp''empty-1 [#_"VoidStamp" this]
        ;; the void stamp is always empty
        this
    )

    #_unused
    (§ override! #_"boolean" VoidStamp''hasValues-1 [#_"VoidStamp" this]
        false
    )

    #_unused
    (§ override! #_"Constant" VoidStamp''readConstant-4 [#_"VoidStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
        (throw! "can't read values of void stamp")
    )

    #_unused
    (§ override! #_"Stamp" VoidStamp''constant-2 [#_"VoidStamp" this, #_"Constant" constant]
        (throw! "void stamp has no value")
    )

    (§ def- #_"VoidStamp" VoidStamp'instance (VoidStamp'new-0))

    (§ defn #_"VoidStamp" VoidStamp'getInstance-0 []
        VoidStamp'instance
    )
)

;;;
 ; This class implements a two-dimensional bitmap.
 ;;
(final-ns BitMap2D
    (§ mutable #_"BitSet" :map nil)
    (§ final #_"int" :bitsPerSlot 0)

    (§ method- #_"int" BitMap2D''bitIndex-3 [#_"BitMap2D" this, #_"int" slotIndex, #_"int" bitWithinSlotIndex]
        (+ (* slotIndex (:bitsPerSlot this)) bitWithinSlotIndex)
    )

    #_unused
    (§ method- #_"boolean" BitMap2D''verifyBitWithinSlotIndex-2 [#_"BitMap2D" this, #_"int" index]
        true
    )

    (§ defn #_"BitMap2D" BitMap2D'new-2 [#_"int" sizeInSlots, #_"int" bitsPerSlot]
        (let [
            #_"BitMap2D" this (Object.)
            this (assoc this :map (BitSet. (* sizeInSlots bitsPerSlot)))
            this (assoc this :bitsPerSlot bitsPerSlot)
        ]
            this
        )
    )

    (§ method! #_"int" BitMap2D''sizeInBits-1 [#_"BitMap2D" this]
        (#_"BitSet" .size (:map this))
    )

    ;; returns number of full slots that have been allocated
    (§ method! #_"int" BitMap2D''sizeInSlots-1 [#_"BitMap2D" this]
        (quot (#_"BitSet" .size (:map this)) (:bitsPerSlot this))
    )

    #_unused
    (§ method! #_"boolean" BitMap2D''isValidIndex-3 [#_"BitMap2D" this, #_"int" slotIndex, #_"int" bitWithinSlotIndex]
        (< (BitMap2D''bitIndex-3 this, slotIndex, bitWithinSlotIndex) (BitMap2D''sizeInBits-1 this))
    )

    (§ method! #_"boolean" BitMap2D''at-3 [#_"BitMap2D" this, #_"int" slotIndex, #_"int" bitWithinSlotIndex]
        (#_"BitSet" .get (:map this), (BitMap2D''bitIndex-3 this, slotIndex, bitWithinSlotIndex))
    )

    (§ method! #_"void" BitMap2D''setBit-3 [#_"BitMap2D" this, #_"int" slotIndex, #_"int" bitWithinSlotIndex]
        (#_"BitSet" .set (:map this), (BitMap2D''bitIndex-3 this, slotIndex, bitWithinSlotIndex))
        nil
    )

    (§ method! #_"void" BitMap2D''clearBit-3 [#_"BitMap2D" this, #_"int" slotIndex, #_"int" bitWithinSlotIndex]
        (#_"BitSet" .clear (:map this), (BitMap2D''bitIndex-3 this, slotIndex, bitWithinSlotIndex))
        nil
    )

    #_unused
    (§ method! #_"BitMap2D" BitMap2D''atPutGrow-4 [#_"BitMap2D" this, #_"int" slotIndex, #_"int" bitWithinSlotIndex, #_"boolean" value?]
        (let [
            #_"int" size (BitMap2D''sizeInSlots-1 this)
            this
                (when (<= size slotIndex) => this
                    (let [
                        #_"BitSet" newBitMap (BitSet. (* (loop-when-recur size (<= size slotIndex) (<< size 1) => size) (:bitsPerSlot this)))
                    ]
                        (#_"BitSet" .or newBitMap, (:map this))
                        (assoc this :map newBitMap)
                    )
                )
        ]
            (if value?
                (BitMap2D''setBit-3 this, slotIndex, bitWithinSlotIndex)
                (BitMap2D''clearBit-3 this, slotIndex, bitWithinSlotIndex)
            )
            this
        )
    )

    #_unused
    (§ method! #_"void" BitMap2D''clear-1 [#_"BitMap2D" this]
        (#_"BitSet" .clear (:map this))
        nil
    )
)

;;;
 ; An expandable and indexable list of {@code int}s.
 ;
 ; This class avoids the boxing/unboxing incurred by {@code ArrayList<Integer>}.
 ;;
(final-ns IntList
    (§ def- #_"int[]" IntList'EMPTY_INT_ARRAY (int-array 0))

    (§ mutable #_"int[]" :array nil)
    (§ mutable #_"int" :size 0)

    ;;;
     ; Creates an int list with a specified initial capacity.
     ;;
    (§ defn #_"IntList" IntList'new-1 [#_"int" initialCapacity]
        (let [
            #_"IntList" this (Object.)
            this (assoc this :array (int-array initialCapacity))
        ]
            this
        )
    )

    ;;;
     ; Creates an int list with a specified initial array.
     ;
     ; @param array the initial array used for the list (no copy is made)
     ; @param initialSize the initial {@linkplain #size() size} of the list (must be less than
     ;             orequal to {@code array.length})
     ;;
    (§ defn #_"IntList" IntList'new-2 [#_"int[]" array, #_"int" initialSize]
        (let [
            #_"IntList" this (Object.)
            this (assoc this :array array)
            this (assoc this :size initialSize)
        ]
            this
        )
    )

    ;;;
     ; Makes a new int list by copying a range from a given int list.
     ;
     ; @param other the list from which a range of values is to be copied into the new list
     ; @param startIndex the index in {@code other} at which to start copying
     ; @param length the number of values to copy from {@code other}
     ; @return a new int list whose {@linkplain #size() size} and capacity is {@code length}
     ;;
    (§ defn #_"IntList" IntList'copy-3 [#_"IntList" other, #_"int" startIndex, #_"int" length]
        (IntList'copy-4 other, startIndex, length, length)
    )

    ;;;
     ; Makes a new int list by copying a range from a given int list.
     ;
     ; @param other the list from which a range of values is to be copied into the new list
     ; @param startIndex the index in {@code other} at which to start copying
     ; @param length the number of values to copy from {@code other}
     ; @param initialCapacity the initial capacity of the new int list (must be greater or equal to {@code length})
     ; @return a new int list whose {@linkplain #size() size} is {@code length}
     ;;
    (§ defn #_"IntList" IntList'copy-4 [#_"IntList" other, #_"int" startIndex, #_"int" length, #_"int" initialCapacity]
        (if (zero? initialCapacity)
            (IntList'new-2 IntList'EMPTY_INT_ARRAY, 0)
            (let [
                #_"int[]" array (int-array initialCapacity)
            ]
                (System/arraycopy (:array other), startIndex, array, 0, length)
                (IntList'new-2 array, length)
            )
        )
    )

    ;;;
     ; Appends a value to the end of this list, increasing its {@linkplain #size() size} by 1.
     ;
     ; @param value the value to append
     ;;
    (§ method! #_"IntList" IntList''add-2 [#_"IntList" this, #_"int" value]
        (let [
            this
                (when (= (:size this) (count (:array this))) => this
                    (assoc this :array (Arrays/copyOf (:array this), (inc (quot (* (:size this) 3) 2))))
                )
        ]
            (aset (:array this) (:size this) value)
            (update this :size inc)
        )
    )

    ;;;
     ; Gets the value in this list at a given index.
     ;;
    (§ method! #_"int" IntList''get-2 [#_"IntList" this, #_"int" index]
        (when (< index (:size this)) => (throw (IndexOutOfBoundsException. (str "Index: " index ", Size: " (:size this))))
            (nth (:array this) index)
        )
    )

    ;;;
     ; Sets the size of this list to 0.
     ;;
    #_unused
    (§ method! #_"IntList" IntList''clear-1 [#_"IntList" this]
        (assoc this :size 0)
    )

    ;;;
     ; Sets a value at a given index in this list.
     ;;
    (§ method! #_"void" IntList''set-3 [#_"IntList" this, #_"int" index, #_"int" value]
        (when (< index (:size this)) => (throw (IndexOutOfBoundsException. (str "Index: " index ", Size: " (:size this))))
            (aset (:array this) index value)
        )
        nil
    )

    ;;;
     ; Adjusts the {@linkplain #size() size} of this int list.
     ;
     ; If {@code size < size()}, the size is changed to {@code size}. If {@code size > size()},
     ; sufficient 0 elements are {@linkplain #add(int) added} until {@code size() == size}.
     ;
     ; @param size the new size of this int list
     ;;
    (§ method! #_"IntList" IntList''setSize-2 [#_"IntList" this, #_"int" size]
        (cond
            (< size (:size this)) (assoc this :size size)
            (< (:size this) size) (assoc this :array (Arrays/copyOf (:array this), size))
            :else                        this
        )
    )
)

;;;
 ; Provides low-level value checks and conversion for signed and unsigned values of size 1, 2, and 4 bytes.
 ;;
(value-ns TypeConversion
    #_unused
    (defn #_"boolean" TypeConversion'isS1-1 [#_"long" value] (<= Byte/MIN_VALUE value Byte/MAX_VALUE))
    #_unused
    (defn #_"boolean" TypeConversion'isS2-1 [#_"long" value] (<= Short/MIN_VALUE value Short/MAX_VALUE))
    #_unused
    (defn #_"boolean" TypeConversion'isS4-1 [#_"long" value] (<= Integer/MIN_VALUE value Integer/MAX_VALUE))

    #_unused
    (defn #_"boolean" TypeConversion'isU1-1 [#_"long" value] (<= 0 value 0xff))
    #_unused
    (defn #_"boolean" TypeConversion'isU2-1 [#_"long" value] (<= 0 value 0xffff))
    #_unused
    (defn #_"boolean" TypeConversion'isU4-1 [#_"long" value] (<= 0 value 0xffffffff))

    (defn #_"byte" TypeConversion'asS1-1 [#_"long" value] (byte value))
    (defn #_"byte" TypeConversion'asU1-1 [#_"long" value] (byte value))

    (defn #_"short" TypeConversion'asS2-1 [#_"long" value] (short value))
    (defn #_"short" TypeConversion'asU2-1 [#_"long" value] (short value))

    (defn #_"int" TypeConversion'asS4-1 [#_"long" value] (int value))
    (defn #_"int" TypeConversion'asU4-1 [#_"long" value] (int value))
)

;;;
 ; Provides low-level read access for signed and unsigned values of size 1, 2, 4, and 8 bytes.
 ;;
(§ interface TypeReader
    ;;; Returns the next byte index to be read.
    #_unused
    (§ abstract #_"long" TypeReader''getByteIndex-1 [#_"TypeReader" this])

    ;;; Sets the next byte index to be read.
    #_unused
    (§ abstract #_"void" TypeReader''setByteIndex-2 [#_"TypeReader" this, #_"long" byteIndex])

    ;;; Reads a signed 1 byte value.
    #_unused
    (§ abstract #_"int" TypeReader''getS1-1 [#_"TypeReader" this])

    ;;; Reads an unsigned 1 byte value.
    (§ abstract #_"int" TypeReader''getU1-1 [#_"TypeReader" this])

    ;;; Reads a signed 2 byte value.
    (§ abstract #_"int" TypeReader''getS2-1 [#_"TypeReader" this])

    ;;; Reads an unsigned 2 byte value.
    #_unused
    (§ abstract #_"int" TypeReader''getU2-1 [#_"TypeReader" this])

    ;;; Reads a signed 4 byte value.
    (§ abstract #_"int" TypeReader''getS4-1 [#_"TypeReader" this])

    ;;; Reads an unsigned 4 byte value.
    #_unused
    (§ abstract #_"long" TypeReader''getU4-1 [#_"TypeReader" this])

    ;;; Reads a signed 8 byte value.
    #_unused
    (§ abstract #_"long" TypeReader''getS8-1 [#_"TypeReader" this])

    ;;;
     ; Reads a signed value that has been written using {@link TypeWriter#putSV variable byte size encoding}.
     ;;
    (§ default! #_"long" TypeReader''getSV-1 [#_"TypeReader" this]
        (loop [#_"long" value 0 #_"int" shift 0]
            (let [
                #_"long" b (TypeReader''getU1-1 this)
                value (| value (<< (& b 0x7f) shift))
                shift (+ shift 7)
            ]
                (cond
                         (not (zero? (& b 0x80)))               (recur value shift)
                    (and (not (zero? (& b 0x40))) (< shift 64)) (| value (<< -1 shift))
                    :else                                       value
                )
            )
        )
    )

    ;;;
     ; Reads a signed variable byte size encoded value that is known to fit into the range of int.
     ;;
    #_unused
    (§ default! #_"int" TypeReader''getSVInt-1 [#_"TypeReader" this]
        (TypeConversion'asS4-1 (TypeReader''getSV-1 this))
    )

    ;;;
     ; Reads an unsigned value that has been written using {@link TypeWriter#putUV variable byte size encoding}.
     ;;
    (§ default! #_"long" TypeReader''getUV-1 [#_"TypeReader" this]
        (loop [#_"long" value 0 #_"int" shift 0]
            (let [
                #_"long" b (TypeReader''getU1-1 this)
                value (| value (<< (& b 0x7f) shift))
                shift (+ shift 7)
            ]
                (recur-if (not (zero? (& b 0x80))) [value shift] => value)
            )
        )
    )

    ;;;
     ; Reads an unsigned variable byte size encoded value that is known to fit into the range of int.
     ;;
    #_unused
    (§ default! #_"int" TypeReader''getUVInt-1 [#_"TypeReader" this]
        (TypeConversion'asS4-1 (TypeReader''getUV-1 this))
    )
)

;;;
 ; Provides low-level sequential write access for signed and unsigned values of size 1, 2, 4, and 8 bytes.
 ;;
(§ interface TypeWriter
    ;;;
     ; Returns the number of bytes that have been written, i.e. the byte index of the next byte to be written.
     ;;
    #_unused
    (§ abstract #_"long" TypeWriter''getBytesWritten-1 [#_"TypeWriter" this])

    ;;; Writes a signed 1 byte value.
    #_unused
    (§ abstract #_"void" TypeWriter''putS1-2 [#_"TypeWriter" this, #_"long" value])

    ;;; Writes an unsigned 1 byte value.
    (§ abstract #_"void" TypeWriter''putU1-2 [#_"TypeWriter" this, #_"long" value])

    ;;; Writes a signed 2 byte value.
    (§ abstract #_"void" TypeWriter''putS2-2 [#_"TypeWriter" this, #_"long" value])

    ;;; Writes an unsigned 2 byte value.
    #_unused
    (§ abstract #_"void" TypeWriter''putU2-2 [#_"TypeWriter" this, #_"long" value])

    ;;; Writes a signed 4 byte value.
    (§ abstract #_"void" TypeWriter''putS4-2 [#_"TypeWriter" this, #_"long" value])

    ;;; Writes an unsigned 4 byte value.
    #_unused
    (§ abstract #_"void" TypeWriter''putU4-2 [#_"TypeWriter" this, #_"long" value])

    ;;; Writes a signed 8 byte value.
    #_unused
    (§ abstract #_"void" TypeWriter''putS8-2 [#_"TypeWriter" this, #_"long" value])

    ;;;
     ; Writes a signed value in a variable byte size encoding.
     ;;
    #_unused
    (§ default! #_"void" TypeWriter''putSV-2 [#_"TypeWriter" this, #_"long" value]
        (loop [value value]
            (if (and (<= -64 value) (< value 64))
                (TypeWriter''putU1-2 this, (& value 0x7f))
                (do
                    (TypeWriter''putU1-2 this, (| 0x80 (& value 0x7f)))
                    (recur (>> value 7))
                )
            )
        )
        nil
    )

    ;;;
     ; Writes an unsigned value in a variable byte size encoding.
     ;;
    #_unused
    (§ default! #_"void" TypeWriter''putUV-2 [#_"TypeWriter" this, #_"long" value]
        (loop [value value]
            (if (< value 128)
                (TypeWriter''putU1-2 this, (& value 0x7f))
                (do
                    (TypeWriter''putU1-2 this, (| 0x80 (& value 0x7f)))
                    (recur (>> value 7))
                )
            )
        )
        nil
    )
)

;;;
 ; Provides low-level read access from a byte[] array for signed and unsigned values of size 1, 2,
 ; 4, and 8 bytes.
 ;
 ; The class can either be instantiated for sequential access to the byte[] array; or static methods
 ; can be used to read values without the overhead of creating an instance.
 ;
 ; The flag {@code supportsUnalignedMemoryAccess} must be set according to the capabilities of the
 ; hardware architecture: the value true allows more efficient memory access on
 ; architectures that support unaligned memory accesses; the value false is the safe
 ; fallback that works on every hardware.
 ;;
(class-ns UnsafeArrayTypeReader (§ implements TypeReader)
    (§ defn #_"int" UnsafeArrayTypeReader'getS1-2 [#_"byte[]" data, #_"long" byteIndex]
        (.getByte HotSpot'unsafe, data, (UnsafeArrayTypeReader'readOffset-3 data, byteIndex, Byte/BYTES))
    )

    (§ defn #_"int" UnsafeArrayTypeReader'getU1-2 [#_"byte[]" data, #_"long" byteIndex]
        (& (.getByte HotSpot'unsafe, data, (UnsafeArrayTypeReader'readOffset-3 data, byteIndex, Byte/BYTES)) 0xff)
    )

    (§ defn #_"int" UnsafeArrayTypeReader'getS2-3 [#_"byte[]" data, #_"long" byteIndex, #_"boolean" supportsUnalignedMemoryAccess]
        (if supportsUnalignedMemoryAccess (UnalignedUnsafeArrayTypeReader'getS2-2 data, byteIndex) (AlignedUnsafeArrayTypeReader'getS2-2 data, byteIndex))
    )

    #_unused
    (§ defn #_"int" UnsafeArrayTypeReader'getU2-3 [#_"byte[]" data, #_"long" byteIndex, #_"boolean" supportsUnalignedMemoryAccess]
        (UnsafeArrayTypeReader'getS2-3 data, byteIndex, (& supportsUnalignedMemoryAccess 0xffff))
    )

    (§ defn #_"int" UnsafeArrayTypeReader'getS4-3 [#_"byte[]" data, #_"long" byteIndex, #_"boolean" supportsUnalignedMemoryAccess]
        (if supportsUnalignedMemoryAccess (UnalignedUnsafeArrayTypeReader'getS4-2 data, byteIndex) (AlignedUnsafeArrayTypeReader'getS4-2 data, byteIndex))
    )

    #_unused
    (§ defn #_"long" UnsafeArrayTypeReader'getU4-3 [#_"byte[]" data, #_"long" byteIndex, #_"boolean" supportsUnalignedMemoryAccess]
        (UnsafeArrayTypeReader'getS4-3 data, byteIndex, (& supportsUnalignedMemoryAccess 0xffffffff))
    )

    #_unused
    (§ defn #_"long" UnsafeArrayTypeReader'getS8-3 [#_"byte[]" data, #_"long" byteIndex, #_"boolean" supportsUnalignedMemoryAccess]
        (if supportsUnalignedMemoryAccess (UnalignedUnsafeArrayTypeReader'getS8-2 data, byteIndex) (AlignedUnsafeArrayTypeReader'getS8-2 data, byteIndex))
    )

    (§ defn #_"long" UnsafeArrayTypeReader'readOffset-3 [#_"byte[]" data, #_"long" byteIndex, #_"int" numBytes]
        (+ byteIndex Unsafe'ARRAY_BYTE_BASE_OFFSET)
    )

    #_unused
    (§ defn #_"UnsafeArrayTypeReader" UnsafeArrayTypeReader'create-3 [#_"byte[]" data, #_"long" byteIndex, #_"boolean" supportsUnalignedMemoryAccess]
        (if supportsUnalignedMemoryAccess (UnalignedUnsafeArrayTypeReader'new-2 data, byteIndex) (AlignedUnsafeArrayTypeReader'new-2 data, byteIndex))
    )

    (§ final #_"byte[]" :data nil)
    (§ mutable #_"long" :byteIndex 0)

    (§ defn #_"UnsafeArrayTypeReader" UnsafeArrayTypeReader'new-2 [#_"byte[]" data, #_"long" byteIndex]
        (let [
            #_"UnsafeArrayTypeReader" this (Object.)
            this (assoc this :data data)
            this (assoc this :byteIndex byteIndex)
        ]
            this
        )
    )

    #_unused
    (§ override #_"long" UnsafeArrayTypeReader''getByteIndex-1 [#_"UnsafeArrayTypeReader" this]
        (:byteIndex this)
    )

    #_unused
    (§ override #_"void" UnsafeArrayTypeReader''setByteIndex-2 [#_"UnsafeArrayTypeReader" this, #_"long" byteIndex]
        (§ ass! this (assoc this :byteIndex byteIndex))
        nil
    )

    #_unused
    (§ override! #_"int" UnsafeArrayTypeReader''getS1-1 [#_"UnsafeArrayTypeReader" this]
        (let [
            #_"int" result (UnsafeArrayTypeReader'getS1-2 (:data this), (:byteIndex this))
        ]
            (§ ass! this (update this :byteIndex + Byte/BYTES))
            result
        )
    )

    #_unused
    (§ override! #_"int" UnsafeArrayTypeReader''getU1-1 [#_"UnsafeArrayTypeReader" this]
        (let [
            #_"int" result (UnsafeArrayTypeReader'getU1-2 (:data this), (:byteIndex this))
        ]
            (§ ass! this (update this :byteIndex + Byte/BYTES))
            result
        )
    )

    #_unused
    (§ override! #_"int" UnsafeArrayTypeReader''getU2-1 [#_"UnsafeArrayTypeReader" this]
        (& (TypeReader''getS2-1 this) 0xffff)
    )

    #_unused
    (§ override! #_"long" UnsafeArrayTypeReader''getU4-1 [#_"UnsafeArrayTypeReader" this]
        (& (TypeReader''getS4-1 this) 0xffffffff)
    )
)

(final-ns UnalignedUnsafeArrayTypeReader (§ extends UnsafeArrayTypeReader)
    (§ defn #_"int" UnalignedUnsafeArrayTypeReader'getS2-2 [#_"byte[]" data, #_"long" byteIndex]
        (.getShort HotSpot'unsafe, data, (UnsafeArrayTypeReader'readOffset-3 data, byteIndex, Short/BYTES))
    )

    (§ defn #_"int" UnalignedUnsafeArrayTypeReader'getS4-2 [#_"byte[]" data, #_"long" byteIndex]
        (.getInt HotSpot'unsafe, data, (UnsafeArrayTypeReader'readOffset-3 data, byteIndex, Integer/BYTES))
    )

    (§ defn #_"long" UnalignedUnsafeArrayTypeReader'getS8-2 [#_"byte[]" data, #_"long" byteIndex]
        (.getLong HotSpot'unsafe, data, (UnsafeArrayTypeReader'readOffset-3 data, byteIndex, Long/BYTES))
    )

    (§ defn #_"UnalignedUnsafeArrayTypeReader" UnalignedUnsafeArrayTypeReader'new-2 [#_"byte[]" data, #_"long" byteIndex]
        (UnsafeArrayTypeReader'new-2 data, byteIndex)
    )

    #_unused
    (§ override! #_"int" UnalignedUnsafeArrayTypeReader''getS2-1 [#_"UnalignedUnsafeArrayTypeReader" this]
        (let [
            #_"int" result (UnalignedUnsafeArrayTypeReader'getS2-2 (:data this), (:byteIndex this))
        ]
            (§ ass! this (update this :byteIndex + Short/BYTES))
            result
        )
    )

    #_unused
    (§ override! #_"int" UnalignedUnsafeArrayTypeReader''getS4-1 [#_"UnalignedUnsafeArrayTypeReader" this]
        (let [
            #_"int" result (UnalignedUnsafeArrayTypeReader'getS4-2 (:data this), (:byteIndex this))
        ]
            (§ ass! this (update this :byteIndex + Integer/BYTES))
            result
        )
    )

    #_unused
    (§ override! #_"long" UnalignedUnsafeArrayTypeReader''getS8-1 [#_"UnalignedUnsafeArrayTypeReader" this]
        (let [
            #_"long" result (UnalignedUnsafeArrayTypeReader'getS8-2 (:data this), (:byteIndex this))
        ]
            (§ ass! this (update this :byteIndex + Long/BYTES))
            result
        )
    )
)

(final-ns AlignedUnsafeArrayTypeReader (§ extends UnsafeArrayTypeReader)
    (§ defn #_"int" AlignedUnsafeArrayTypeReader'getS2-2 [#_"byte[]" data, #_"long" byteIndex]
        (let [
            #_"long" offset (UnsafeArrayTypeReader'readOffset-3 data, byteIndex, Short/BYTES)
        ]
            (| (<< (& (.getByte HotSpot'unsafe, data, (+ offset 0)) 0xff) 0)
               (<<    (.getByte HotSpot'unsafe, data, (+ offset 1))       8))
        )
    )

    (§ defn #_"int" AlignedUnsafeArrayTypeReader'getS4-2 [#_"byte[]" data, #_"long" byteIndex]
        (let [
            #_"long" offset (UnsafeArrayTypeReader'readOffset-3 data, byteIndex, Integer/BYTES)
        ]
            (| (<< (& (.getByte HotSpot'unsafe, data, (+ offset 0)) 0xff) 0)
               (<< (& (.getByte HotSpot'unsafe, data, (+ offset 1)) 0xff) 8)
               (<< (& (.getByte HotSpot'unsafe, data, (+ offset 2)) 0xff) 16)
               (<<    (.getByte HotSpot'unsafe, data, (+ offset 3))       24))
        )
    )

    (§ defn #_"long" AlignedUnsafeArrayTypeReader'getS8-2 [#_"byte[]" data, #_"long" byteIndex]
        (let [
            #_"long" offset (UnsafeArrayTypeReader'readOffset-3 data, byteIndex, Long/BYTES)
        ]
            (| (<< (long (& (.getByte HotSpot'unsafe, data, (+ offset 0)) 0xff)) 0)
               (<< (long (& (.getByte HotSpot'unsafe, data, (+ offset 1)) 0xff)) 8)
               (<< (long (& (.getByte HotSpot'unsafe, data, (+ offset 2)) 0xff)) 16)
               (<< (long (& (.getByte HotSpot'unsafe, data, (+ offset 3)) 0xff)) 24)
               (<< (long (& (.getByte HotSpot'unsafe, data, (+ offset 4)) 0xff)) 32)
               (<< (long (& (.getByte HotSpot'unsafe, data, (+ offset 5)) 0xff)) 40)
               (<< (long (& (.getByte HotSpot'unsafe, data, (+ offset 6)) 0xff)) 48)
               (<< (long    (.getByte HotSpot'unsafe, data, (+ offset 7))      ) 56))
        )
    )

    (§ defn #_"AlignedUnsafeArrayTypeReader" AlignedUnsafeArrayTypeReader'new-2 [#_"byte[]" data, #_"long" byteIndex]
        (UnsafeArrayTypeReader'new-2 data, byteIndex)
    )

    #_unused
    (§ override! #_"int" AlignedUnsafeArrayTypeReader''getS2-1 [#_"AlignedUnsafeArrayTypeReader" this]
        (let [
            #_"int" result (AlignedUnsafeArrayTypeReader'getS2-2 (:data this), (:byteIndex this))
        ]
            (§ ass! this (update this :byteIndex + Short/BYTES))
            result
        )
    )

    #_unused
    (§ override! #_"int" AlignedUnsafeArrayTypeReader''getS4-1 [#_"AlignedUnsafeArrayTypeReader" this]
        (let [
            #_"int" result (AlignedUnsafeArrayTypeReader'getS4-2 (:data this), (:byteIndex this))
        ]
            (§ ass! this (update this :byteIndex + Integer/BYTES))
            result
        )
    )

    #_unused
    (§ override! #_"long" AlignedUnsafeArrayTypeReader''getS8-1 [#_"AlignedUnsafeArrayTypeReader" this]
        (let [
            #_"long" result (AlignedUnsafeArrayTypeReader'getS8-2 (:data this), (:byteIndex this))
        ]
            (§ ass! this (update this :byteIndex + Long/BYTES))
            result
        )
    )
)

;;;
 ; Provides low-level sequential write access to a byte[] array for signed and unsigned values of
 ; size 1, 2, 4, and 8 bytes. To avoid copying an array when the buffer size is no longer
 ; sufficient, the buffer is split into chunks of a fixed size.
 ;
 ; The flag {@code supportsUnalignedMemoryAccess} must be set according to the capabilities of the
 ; hardware architecture: the value true allows more efficient memory access on
 ; architectures that support unaligned memory accesses; the value false is the safe
 ; fallback that works on every hardware.
 ;;
(class-ns UnsafeArrayTypeWriter (§ implements TypeWriter)
    (def- #_"int" UnsafeArrayTypeWriter'MIN_CHUNK_LENGTH 200)
    (def- #_"int" UnsafeArrayTypeWriter'MAX_CHUNK_LENGTH 16000)

    (§ final #_"Chunk" :firstChunk nil)
    (§ mutable #_"Chunk" :writeChunk nil)
    (§ mutable #_"int" :totalSize 0)

    #_unused
    (§ defn #_"UnsafeArrayTypeWriter" UnsafeArrayTypeWriter'create-1 [#_"boolean" supportsUnalignedMemoryAccess]
        (if supportsUnalignedMemoryAccess
            (UnalignedUnsafeArrayTypeWriter'new-0)
            (AlignedUnsafeArrayTypeWriter'new-0)
        )
    )

    (§ defn #_"UnsafeArrayTypeWriter" UnsafeArrayTypeWriter'new-0 []
        (let [
            #_"UnsafeArrayTypeWriter" this (Object.)
            this (assoc this :firstChunk (Chunk'new-1 UnsafeArrayTypeWriter'MIN_CHUNK_LENGTH))
            this (assoc this :writeChunk (:firstChunk this))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"long" UnsafeArrayTypeWriter''getBytesWritten-1 [#_"UnsafeArrayTypeWriter" this]
        (:totalSize this)
    )

    ;;;
     ; Copies the buffer into the provided byte[] array of length #getBytesWritten().
     ;;
    #_unused
    (§ method! #_"byte[]" UnsafeArrayTypeWriter''toArray-2 [#_"UnsafeArrayTypeWriter" this, #_"byte[]" bytes]
        (loop-when-recur [#_"int" i 0 #_"Chunk" cur (:firstChunk this)] (some? cur) [(+ i (:size cur)) (:next cur)]
            (System/arraycopy (:data cur), 0, bytes, i, (:size cur))
        )
        bytes
    )

    #_unused
    (§ override! #_"void" UnsafeArrayTypeWriter''putS1-2 [#_"UnsafeArrayTypeWriter" this, #_"long" value]
        (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (UnsafeArrayTypeWriter''writeOffset-2 this, Byte/BYTES), (TypeConversion'asS1-1 value))
        nil
    )

    #_unused
    (§ override! #_"void" UnsafeArrayTypeWriter''putU1-2 [#_"UnsafeArrayTypeWriter" this, #_"long" value]
        (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (UnsafeArrayTypeWriter''writeOffset-2 this, Byte/BYTES), (TypeConversion'asU1-1 value))
        nil
    )

    #_unused
    (§ override! #_"void" UnsafeArrayTypeWriter''putU2-2 [#_"UnsafeArrayTypeWriter" this, #_"long" value]
        (TypeWriter''putS2-2 this, (TypeConversion'asU2-1 value))
        nil
    )

    #_unused
    (§ override! #_"void" UnsafeArrayTypeWriter''putU4-2 [#_"UnsafeArrayTypeWriter" this, #_"long" value]
        (TypeWriter''putS4-2 this, (TypeConversion'asU4-1 value))
        nil
    )

    (§ method! #_"long" UnsafeArrayTypeWriter''writeOffset-2 [#_"UnsafeArrayTypeWriter" this, #_"int" writeBytes]
        (when (<= (count (:data (:writeChunk this))) (+ (:size (:writeChunk this)) writeBytes))
            (let [
                #_"Chunk" newChunk (Chunk'new-1 (min (<< (count (:data (:writeChunk this))) 1) UnsafeArrayTypeWriter'MAX_CHUNK_LENGTH))
            ]
                (§ ass! (:next (:writeChunk this)) newChunk)
                (§ ass! this (assoc this :writeChunk newChunk))
            )
        )

        (let [
            #_"long" result (+ (:size (:writeChunk this)) Unsafe'ARRAY_BYTE_BASE_OFFSET)
        ]
            (§ ass! this (update this :totalSize + writeBytes))
            (§ ass! (:size (:writeChunk this)) (+ (:size (:writeChunk this)) writeBytes))

            result
        )
    )
)

;;;
 ; @anno UnsafeArrayTypeWriter.Chunk
 ;;
(final-ns Chunk
    (§ final #_"byte[]" :data nil)
    (§ mutable #_"int" :size 0)
    (§ mutable #_"Chunk" :next nil)

    (§ defn #_"Chunk" Chunk'new-1 [#_"int" arrayLength]
        (let [
            #_"Chunk" this (Object.)
            this (assoc this :data (byte-array arrayLength))
        ]
            this
        )
    )
)

(final-ns UnalignedUnsafeArrayTypeWriter (§ extends UnsafeArrayTypeWriter)
    (§ defn #_"UnalignedUnsafeArrayTypeWriter" UnalignedUnsafeArrayTypeWriter'new-0 []
        (UnsafeArrayTypeWriter'new-0)
    )

    #_unused
    (§ override! #_"void" UnalignedUnsafeArrayTypeWriter''putS2-2 [#_"UnalignedUnsafeArrayTypeWriter" this, #_"long" value]
        (let [
            #_"long" offset (UnsafeArrayTypeWriter''writeOffset-2 this, Short/BYTES)
        ]
            (.putShort HotSpot'unsafe, (:data (:writeChunk this)), offset, (TypeConversion'asS2-1 value))
        )
        nil
    )

    #_unused
    (§ override! #_"void" UnalignedUnsafeArrayTypeWriter''putS4-2 [#_"UnalignedUnsafeArrayTypeWriter" this, #_"long" value]
        (let [
            #_"long" offset (UnsafeArrayTypeWriter''writeOffset-2 this, Integer/BYTES)
        ]
            (.putInt HotSpot'unsafe, (:data (:writeChunk this)), offset, (TypeConversion'asS4-1 value))
        )
        nil
    )

    #_unused
    (§ override! #_"void" UnalignedUnsafeArrayTypeWriter''putS8-2 [#_"UnalignedUnsafeArrayTypeWriter" this, #_"long" value]
        (let [
            #_"long" offset (UnsafeArrayTypeWriter''writeOffset-2 this, Long/BYTES)
        ]
            (.putLong HotSpot'unsafe, (:data (:writeChunk this)), offset, value)
        )
        nil
    )
)

(final-ns AlignedUnsafeArrayTypeWriter (§ extends UnsafeArrayTypeWriter)
    (§ defn #_"AlignedUnsafeArrayTypeWriter" AlignedUnsafeArrayTypeWriter'new-0 []
        (UnsafeArrayTypeWriter'new-0)
    )

    #_unused
    (§ override! #_"void" AlignedUnsafeArrayTypeWriter''putS2-2 [#_"AlignedUnsafeArrayTypeWriter" this, #_"long" value]
        (let [
            #_"long" offset (UnsafeArrayTypeWriter''writeOffset-2 this, Short/BYTES)
        ]
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 0), (byte (>> value 0)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 1), (byte (>> value 8)))
        )
        nil
    )

    #_unused
    (§ override! #_"void" AlignedUnsafeArrayTypeWriter''putS4-2 [#_"AlignedUnsafeArrayTypeWriter" this, #_"long" value]
        (let [
            #_"long" offset (UnsafeArrayTypeWriter''writeOffset-2 this, Integer/BYTES)
        ]
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 0), (byte (>> value 0)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 1), (byte (>> value 8)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 2), (byte (>> value 16)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 3), (byte (>> value 24)))
        )
        nil
    )

    #_unused
    (§ override! #_"void" AlignedUnsafeArrayTypeWriter''putS8-2 [#_"AlignedUnsafeArrayTypeWriter" this, #_"long" value]
        (let [
            #_"long" offset (UnsafeArrayTypeWriter''writeOffset-2 this, Long/BYTES)
        ]
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 0), (byte (>> value 0)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 1), (byte (>> value 8)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 2), (byte (>> value 16)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 3), (byte (>> value 24)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 4), (byte (>> value 32)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 5), (byte (>> value 40)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 6), (byte (>> value 48)))
            (.putByte HotSpot'unsafe, (:data (:writeChunk this)), (+ offset 7), (byte (>> value 56)))
        )
        nil
    )
)

(final-ns UnsignedLong
    (§ final #_"long" :value 0)

    (§ defn #_"UnsignedLong" UnsignedLong'new-1 [#_"long" value]
        (let [
            #_"UnsignedLong" this (Object.)
            this (assoc this :value value)
        ]
            this
        )
    )

    (§ method! #_"long" UnsignedLong''asLong-1 [#_"UnsignedLong" this]
        (:value this)
    )

    (§ method! #_"boolean" UnsignedLong''equals-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (= (:value this) unsignedValue)
    )

    (§ method! #_"boolean" UnsignedLong''isLessThan-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (< (Long/compareUnsigned (:value this), unsignedValue) 0)
    )

    (§ method! #_"boolean" UnsignedLong''isLessOrEqualTo-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (<= (Long/compareUnsigned (:value this), unsignedValue) 0)
    )

    (§ method! #_"UnsignedLong" UnsignedLong''times-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (when (and (not (zero? unsignedValue)) (pos? (Long/compareUnsigned (:value this), (Long/divideUnsigned 0xffffffffffffffff, unsignedValue))))
            (throw (ArithmeticException.))
        )
        (UnsignedLong'new-1 (* (:value this) unsignedValue))
    )

    (§ method! #_"UnsignedLong" UnsignedLong''minus-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (when (neg? (Long/compareUnsigned (:value this), unsignedValue))
            (throw (ArithmeticException.))
        )
        (UnsignedLong'new-1 (- (:value this) unsignedValue))
    )

    #_unused
    (§ method! #_"UnsignedLong" UnsignedLong''plus-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (when (neg? (Long/compareUnsigned (- 0xffffffffffffffff unsignedValue), (:value this)))
            (throw (ArithmeticException.))
        )
        (UnsignedLong'new-1 (+ (:value this) unsignedValue))
    )

    (§ method! #_"UnsignedLong" UnsignedLong''wrappingPlus-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (UnsignedLong'new-1 (+ (:value this) unsignedValue))
    )

    (§ method! #_"UnsignedLong" UnsignedLong''wrappingTimes-2 [#_"UnsignedLong" this, #_"long" unsignedValue]
        (UnsignedLong'new-1 (* (:value this) unsignedValue))
    )
)

(final-ns LIRGenerationPhase (§ extends LIRPhase #_"<LIRGenerationContext>")
    (§ defn #_"LIRGenerationPhase" LIRGenerationPhase'new-0 []
        (LIRPhase'new-0)
    )

    #_unused
    (§ override! #_"void" LIRGenerationPhase''run-3 [#_"LIRGenerationPhase" this, #_"LIRGenerationResult" lirGenRes, #_"LIRGenerationContext" context]
        (doseq [#_"Block" block (:reversePostOrder (:cfg (:lir lirGenRes)))]
            (§ ass! (:nodeLirBuilder context) (LIRBuilder''doBlock-4 (:nodeLirBuilder context), block, (:graph context), (:blockToNodesMap (:schedule context))))
        )
        (LIRGenerator''beforeRegisterAllocation-1 (:lirGen context))
        nil
    )
)

;;;
 ; @anno LIRGenerationPhase.LIRGenerationContext
 ;;
(final-ns LIRGenerationContext
    (§ final #_"LIRBuilder" :nodeLirBuilder nil)
    (§ final #_"LIRGenerator" :lirGen nil)
    (§ final #_"Graph" :graph nil)
    (§ final #_"ScheduleResult" :schedule nil)

    (§ defn #_"LIRGenerationContext" LIRGenerationContext'new-4 [#_"LIRGenerator" lirGen, #_"LIRBuilder" nodeLirBuilder, #_"Graph" graph, #_"ScheduleResult" schedule]
        (let [
            #_"LIRGenerationContext" this (Object.)
            this (assoc this :nodeLirBuilder nodeLirBuilder)
            this (assoc this :lirGen lirGen)
            this (assoc this :graph graph)
            this (assoc this :schedule schedule)
        ]
            this
        )
    )
)

(final-ns HighTier (§ extends PhaseSuite #_"<HighTierContext>")
    (§ defn #_"HighTier" HighTier'new-0 []
        (let [
            #_"HighTier" this (PhaseSuite'new-0)
            #_"CanonicalizerPhase" canonicalizer (CanonicalizerPhase'new-0)
            #_"LoopPolicies" loopPolicies (DefaultLoopPolicies'new-0)
        ]
            (PhaseSuite''appendPhase-2 this, canonicalizer)
            (when GraalOptions'inline
                (PhaseSuite''appendPhase-2 this, (InliningPhase'new-1 canonicalizer))
                (PhaseSuite''appendPhase-2 this, (DeadCodeEliminationPhase'new-1 Optionality'Optional))
            )
            (when GraalOptions'optConvertDeoptsToGuards
                (PhaseSuite''appendPhase-2 this, (IncrementalCanonicalizerPhase'new-2 canonicalizer, (ConvertDeoptimizeToGuardPhase'new-0)))
            )
            (when GraalOptions'conditionalElimination
                (PhaseSuite''appendPhase-2 this, (IterativeConditionalEliminationPhase'new-2 canonicalizer, false))
            )
            (when GraalOptions'fullUnroll
                (PhaseSuite''appendPhase-2 this, (LoopFullUnrollPhase'new-2 canonicalizer, loopPolicies))
            )
            (when GraalOptions'optLoopTransform
                (when GraalOptions'loopPeeling
                    (PhaseSuite''appendPhase-2 this, (LoopPeelingPhase'new-1 loopPolicies))
                )
                (when GraalOptions'loopUnswitch
                    (PhaseSuite''appendPhase-2 this, (LoopUnswitchingPhase'new-1 loopPolicies))
                )
            )
            (PhaseSuite''appendPhase-2 this, canonicalizer)
            (when GraalOptions'partialEscapeAnalysis
                (PhaseSuite''appendPhase-2 this, (PartialEscapePhase'new-2 true, canonicalizer))
            )
            (when GraalOptions'optReadElimination
                (PhaseSuite''appendPhase-2 this, (EarlyReadEliminationPhase'new-1 canonicalizer))
            )
            (PhaseSuite''appendPhase-2 this, (RemoveValueProxyPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (LoweringPhase'new-2 canonicalizer, LoweringStage'HIGH_TIER))
            this
        )
    )
)

(final-ns LowTier (§ extends PhaseSuite #_"<LowTierContext>")
    (§ defn #_"LowTier" LowTier'new-0 []
        (let [
            #_"LowTier" this (PhaseSuite'new-0)
        ]
            (PhaseSuite''appendPhase-2 this, (LoweringPhase'new-2 (CanonicalizerPhase'new-0), LoweringStage'LOW_TIER))
            (PhaseSuite''appendPhase-2 this, (ExpandLogicPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (FixReadsPhase'new-1 (SchedulePhase'new-1 (if GraalOptions'stressTestEarlyReads SchedulingStrategy'EARLIEST SchedulingStrategy'LATEST_OUT_OF_LOOPS))))

            (PhaseSuite''appendPhase-2 this, (CanonicalizerPhase'new-0)) ;; %% anno w/o GVN

            (PhaseSuite''appendPhase-2 this, (UseTrappingNullChecksPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (DeadCodeEliminationPhase'new-1 Optionality'Required))
            (PhaseSuite''appendPhase-2 this, (PropagateDeoptimizeProbabilityPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (SchedulePhase'new-1 SchedulingStrategy'FINAL_SCHEDULE))
            this
        )
    )
)

(final-ns MidTier (§ extends PhaseSuite #_"<MidTierContext>")
    (§ defn #_"MidTier" MidTier'new-0 []
        (let [
            #_"MidTier" this (PhaseSuite'new-0)
            #_"CanonicalizerPhase" canonicalizer (CanonicalizerPhase'new-0)
            #_"LoopPolicies" loopPolicies (DefaultLoopPolicies'new-0)
        ]
            (PhaseSuite''appendPhase-2 this, (LockEliminationPhase'new-0))
            (when GraalOptions'optFloatingReads
                (PhaseSuite''appendPhase-2 this, (IncrementalCanonicalizerPhase'new-2 canonicalizer, (FloatingReadPhase'new-0)))
            )
            (when GraalOptions'conditionalElimination
                (PhaseSuite''appendPhase-2 this, (IterativeConditionalEliminationPhase'new-2 canonicalizer, true))
            )
            (PhaseSuite''appendPhase-2 this, (LoopSafepointEliminationPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (LoopSafepointInsertionPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (GuardLoweringPhase'new-0))
            (PhaseSuite''appendPhase-2 this, (LoweringPhase'new-2 canonicalizer, LoweringStage'MID_TIER))
            (PhaseSuite''appendPhase-2 this, (FrameStateAssignmentPhase'new-0))
            (when GraalOptions'optLoopTransform
                (when GraalOptions'partialUnroll
                    (PhaseSuite''appendPhase-2 this, (LoopPartialUnrollPhase'new-2 loopPolicies, canonicalizer))
                )
            )
            (when GraalOptions'reassociateInvariants
                (PhaseSuite''appendPhase-2 this, (ReassociateInvariantPhase'new-0))
            )
            (when GraalOptions'optDeoptimizationGrouping
                (PhaseSuite''appendPhase-2 this, (DeoptimizationGroupingPhase'new-0))
            )
            (PhaseSuite''appendPhase-2 this, canonicalizer)
            this
        )
    )
)

;;;
 ; Describes Node fields representing the set of inputs for the node or
 ; the set of the node's successors.
 ;;
(class-ns Edges (§ extends Fields)
    (§ final #_"EdgesType" :type nil)
    ;;;
     ; Number of direct edges represented by this object. A direct edge goes directly
     ; to another Node. An indirect edge goes via a NodeList.
     ;;
    (§ final #_"int" :directCount 0)

    (§ defn #_"Edges" Edges'new-3 [#_"EdgesType" type, #_"int" directCount, #_"ArrayList<? extends FieldInfo>" edges]
        (let [
            #_"Edges" this (Fields'new-1 edges)
            this (assoc this :type type)
            this (assoc this :directCount directCount)
        ]
            this
        )
    )

    (§ defn #_"void" Edges'translateInto-2 [#_"Edges" edges, #_"ArrayList<EdgeInfo>" infos]
        (dotimes [#_"int" i (count (:offsets edges))]
            (#_"ArrayList" .add infos, (EdgeInfo'new-4 (nth (:offsets edges) i), (Fields''getName-2 edges, i), (Fields''getType-2 edges, i), (Fields''getDeclaringClass-2 edges, i)))
        )
        nil
    )

    (§ defn #_"Node" Edges'getNodeUnsafe-2 [#_"Node" node, #_"long" offset]
        (§ cast #_"Node" (.getObject HotSpot'unsafe, node, offset))
    )

    (§ defn #_"NodeList<Node>" Edges'getNodeListUnsafe-2 [#_"Node" node, #_"long" offset]
        (§ cast #_"NodeList<Node>" (.getObject HotSpot'unsafe, node, offset))
    )

    (§ defn #_"void" Edges'putNodeUnsafe-3 [#_"Node" node, #_"long" offset, #_"Node" value]
        (.putObject HotSpot'unsafe, node, offset, value)
        nil
    )

    (§ defn #_"void" Edges'putNodeListUnsafe-3 [#_"Node" node, #_"long" offset, #_"NodeList" value]
        (.putObject HotSpot'unsafe, node, offset, value)
        nil
    )

    ;;;
     ; Gets the Node at the end point of a {@linkplain #getDirectCount() direct} edge.
     ;
     ; @param node one end point of the edge
     ; @param index the index of a non-list the edge (must be less than #getDirectCount())
     ; @return the Node at the other edge of the requested edge
     ;;
    (§ defn #_"Node" Edges'getNode-3 [#_"Node" node, #_"long[]" offsets, #_"int" index]
        (Edges'getNodeUnsafe-2 node, (nth offsets index))
    )

    ;;;
     ; Gets the NodeList at the end point of a {@linkplain #getDirectCount() direct} edge.
     ;
     ; @param node one end point of the edge
     ; @param index the index of a non-list the edge (must be equal to or greater than #getDirectCount())
     ; @return the NodeList at the other edge of the requested edge
     ;;
    (§ defn #_"NodeList<Node>" Edges'getNodeList-3 [#_"Node" node, #_"long[]" offsets, #_"int" index]
        (Edges'getNodeListUnsafe-2 node, (nth offsets index))
    )

    ;;;
     ; Clear edges in a given node. This is accomplished by setting {@linkplain #getDirectCount()
     ; direct} edges to nil and replacing the lists containing indirect edges with new lists.
     ; The latter is important so that this method can be used to clear the edges of cloned nodes.
     ;
     ; @param node the node whose edges are to be cleared
     ;;
    #_unused
    (§ method #_"void" Edges''clear-2 [#_"Edges" this, #_"Node" node]
        (let [
            #_"int" i
                (loop-when-recur [i 0] (< i (:directCount this)) [(inc i)] => i
                    (Edges''initializeNode-4 this, node, i, nil)
                )
        ]
            (loop-when-recur i (< i (count (:offsets this))) (inc i)
                (let [
                    #_"NodeList<Node>" list (Edges'getNodeList-3 node, (:offsets this), i)
                ]
                    (when (some? list)
                        (let [
                            #_"int" size (:initialSize list)
                        ]
                            ;; replacing with a new list object is the expected behavior!
                            (Edges''initializeList-4 this, node, i, (if (= (:type this) EdgesType'Inputs) (NodeInputList'new-2 node, size) (NodeSuccessorList'new-2 node, size)))
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Initializes the list edges in a given node based on the size of the list edges in a prototype node.
     ;
     ; @param node the node whose list edges are to be initialized
     ; @param prototype the node whose list edge sizes are used when creating new edge lists
     ;;
    (§ method! #_"void" Edges''initializeLists-3 [#_"Edges" this, #_"Node" node, #_"Node" prototype]
        (loop-when-recur [#_"int" i (:directCount this)] (< i (count (:offsets this))) [(inc i)]
            (let [
                #_"NodeList<Node>" list (Edges'getNodeList-3 prototype, (:offsets this), i)
            ]
                (when (some? list)
                    (let [
                        #_"int" size (:initialSize list)
                    ]
                        (Edges''initializeList-4 this, node, i, (if (= (:type this) EdgesType'Inputs) (NodeInputList'new-2 node, size) (NodeSuccessorList'new-2 node, size)))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Copies edges from {@code fromNode} to {@code toNode}. The nodes are expected to be of the exact same type.
     ;
     ; @param fromNode the node from which the edges should be copied.
     ; @param toNode the node to which the edges should be copied.
     ;;
    (§ method #_"void" Edges''copy-3 [#_"Edges" this, #_"Node" fromNode, #_"Node" toNode]
        (let [
            #_"int" i
                (loop-when-recur [i 0] (< i (:directCount this)) [(inc i)] => i
                    (Edges''initializeNode-4 this, toNode, i, (Edges'getNode-3 fromNode, (:offsets this), i))
                )
        ]
            (loop-when-recur i (< i (count (:offsets this))) (inc i)
                (let [
                    #_"NodeList<Node>" list (Edges'getNodeList-3 toNode, (:offsets this), i)
                    #_"NodeList<Node>" from (Edges'getNodeList-3 fromNode, (:offsets this), i)
                ]
                    (when (or (nil? list) (= list from)) => (NodeList''copy-2 list, from)
                        (Edges''initializeList-4 this, toNode, i, (if (= (:type this) EdgesType'Inputs) (NodeInputList'new-2 toNode, from) (NodeSuccessorList'new-2 toNode, from)))
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override #_"void" Edges''set-4 [#_"Edges" this, #_"Object" node, #_"int" index, #_"Object" value]
        (throw (IllegalArgumentException. (str "Cannot call set on " this)))
    )

    ;;;
     ; Sets the value of a given edge without notifying the new and old nodes on the other end of the edge of the change.
     ;
     ; @param node the node whose edge is to be updated
     ; @param index the index of the edge (between 0 and #getCount())
     ; @param value the node to be written to the edge
     ;;
    (§ method! #_"void" Edges''initializeNode-4 [#_"Edges" this, #_"Node" node, #_"int" index, #_"Node" value]
        (Edges''verifyUpdateValid-4 this, node, index, value)
        (Edges'putNodeUnsafe-3 node, (nth (:offsets this) index), value)
        nil
    )

    (§ method! #_"void" Edges''initializeList-4 [#_"Edges" this, #_"Node" node, #_"int" index, #_"NodeList<Node>" value]
        (Edges''verifyUpdateValid-4 this, node, index, value)
        (Edges'putNodeListUnsafe-3 node, (nth (:offsets this) index), value)
        nil
    )

    (§ method- #_"void" Edges''verifyUpdateValid-4 [#_"Edges" this, #_"Node" node, #_"int" index, #_"Object" newValue]
        (when (and (some? newValue) (not (#_"Class" .isAssignableFrom (Fields''getType-2 this, index), (#_"Object" .getClass newValue))))
            (throw (IllegalArgumentException. (str "Can not assign " (#_"Object" .getClass newValue) " to " (Fields''getType-2 this, index) " in " node)))
        )
        nil
    )

    ;;;
     ; Sets the value of a given edge and notifies the new and old nodes on the other end of the edge of the change.
     ;
     ; @param node the node whose edge is to be updated
     ; @param index the index of the edge (between 0 and #getCount())
     ; @param value the node to be written to the edge
     ;;
    (§ method! #_"void" Edges''setNode-4 [#_"Edges" this, #_"Node" node, #_"int" index, #_"Node" value]
        (let [
            #_"Node" old (Edges'getNodeUnsafe-2 node, (nth (:offsets this) index))
        ]
            (Edges''initializeNode-4 this, node, index, value)
            (Edges''update-4 this, node, old, value)
        )
        nil
    )

    (§ abstract #_"void" Edges''update-4 [#_"Edges" this, #_"Node" node, #_"Node" oldValue, #_"Node" newValue])

    #_unused
    (§ method #_"boolean" Edges''contains-3 [#_"Edges" this, #_"Node" node, #_"Node" value]
        (or
            (loop-when [#_"int" i 0] (< i (:directCount this)) => false
                (or (= (Edges'getNode-3 node, (:offsets this), i) value)
                    (recur (inc i))
                )
            )
            (loop-when [#_"int" i (:directCount this)] (< i (count (:offsets this))) => false
                (let [
                    #_"NodeList" curList (Edges'getNodeList-3 node, (:offsets this), i)
                ]
                    (or (and (some? curList) (NodeList''contains-2 curList, value))
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (§ method! #_"Iterable<Position>" Edges''getPositionsIterable-2 [#_"Edges" this, #_"Node" node]
        (let [
            #_"Edges" edges this
        ]
            (§ reify #_"Iterable<Position>" (Iterable.)
                (§ override! #_"Iterator<Position>" #_"Iterable" .iterator [#_"Iterable<Position>" this]
                    (EdgesIterator'new-2 node, edges)
                )
            )
        )
    )
)

;;;
 ; Constants denoting whether a set of edges are inputs or successors.
 ;
 ; @anno Edges.EdgesType
 ;;
(value-ns EdgesType
    (§ enum EdgesType'Inputs)
    (§ enum EdgesType'Successors)
)

;;;
 ; An iterator that will iterate over edges.
 ;
 ; An iterator of this type will not return nil values, unless edges are modified concurrently.
 ;
 ; @anno Edges.EdgesIterator
 ;;
(final-ns EdgesIterator (§ implements Iterator #_"<Position>")
    (§ final #_"Node" :node nil)
    (§ final #_"Edges" :edges nil)
    (§ mutable #_"int" :index 0)
    (§ mutable #_"int" :subIndex 0)
    (§ mutable #_"boolean" :needsForward false)
    (§ final #_"int" :directCount 0)
    (§ final #_"long[]" :offsets nil)

    ;;;
     ; Creates an iterator that will iterate over some given edges in a given node.
     ;;
    (§ defn #_"EdgesIterator" EdgesIterator'new-2 [#_"Node" node, #_"Edges" edges]
        (let [
            #_"EdgesIterator" this (Object.)
            this (assoc this :node node)
            this (assoc this :edges edges)
            this (assoc this :index Node'NOT_ITERABLE)
            this (assoc this :subIndex 0)
            this (assoc this :needsForward true)
            this (assoc this :directCount (:directCount edges))
            this (assoc this :offsets (:offsets edges))
        ]
            this
        )
    )

    (§ method! #_"EdgesIterator" EdgesIterator''forward-1 [#_"EdgesIterator" this]
        (let [
            this (assoc this :needsForward false)
            this
                (when (< (:index this) (:directCount this)) => (update this :subIndex inc)
                    (let [
                        this (update this :index inc)
                    ]
                        (when (< (:index this) (:directCount this)) => this
                            (§ return this)
                        )
                    )
                )
        ]
            (when (< (:index this) (count (:offsets (:edges this)))) => this
                (EdgesIterator''forwardNodeList-1 this)
            )
        )
    )

    (§ method- #_"EdgesIterator" EdgesIterator''forwardNodeList-1 [#_"EdgesIterator" this]
        (loop [this this]
            (let [
                #_"NodeList" list (Edges'getNodeList-3 (:node this), (:offsets this), (:index this))
            ]
                (when-not (and (some? list) (< (:subIndex this) (count list))) => this
                    (let [
                        this (assoc this :subIndex 0)
                        this (update this :index inc)
                    ]
                        (recur-if (< (:index this) (count (:offsets (:edges this)))) [this] => this)
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"boolean" EdgesIterator''hasNext-1 [#_"EdgesIterator" this]
        (when (:needsForward this)
            (§ ass! this (EdgesIterator''forward-1 this))
        )
        (< (:index this) (count (:offsets (:edges this))))
    )

    #_unused
    (§ override! #_"Position" EdgesIterator''next-1 [#_"EdgesIterator" this]
        (when (:needsForward this)
            (§ ass! this (EdgesIterator''forward-1 this))
        )
        (§ ass! this (assoc this :needsForward true))
        (Position'new-3 (:edges this), (:index this), (if (< (:index this) (:directCount this)) Node'NOT_ITERABLE (:subIndex this)))
    )
)

;;;
 ; Iterates over the nodes in a given graph.
 ;;
(final-ns GraphNodeIterator (§ implements Iterator #_"<Node>")
    (§ final #_"Graph" :graph nil)
    (§ mutable #_"int" :index 0)

    (§ defn #_"GraphNodeIterator" GraphNodeIterator'new-1 [#_"Graph" graph]
        (GraphNodeIterator'new-2 graph, 0)
    )

    (§ defn #_"GraphNodeIterator" GraphNodeIterator'new-2 [#_"Graph" graph, #_"int" index]
        (let [
            #_"GraphNodeIterator" this (Object.)
            this (assoc this :graph graph)
            this (assoc this :index (dec index))
        ]
            (§ ass! this (GraphNodeIterator''forward-1 this))
            this
        )
    )

    (§ method- #_"GraphNodeIterator" GraphNodeIterator''forward-1 [#_"GraphNodeIterator" this]
        (when (< (:index this) (:nodesSize (:graph this))) => this
            (loop [this this]
                (let [
                    this (update this :index inc)
                ]
                    (recur-if (and (< (:index this) (:nodesSize (:graph this))) (nil? (nth (:nodes (:graph this)) (:index this)))) [this] => this)
                )
            )
        )
    )

    #_unused
    (§ override! #_"boolean" GraphNodeIterator''hasNext-1 [#_"GraphNodeIterator" this]
        (§ ass! this (GraphNodeIterator''checkForDeletedNode-1 this))
        (< (:index this) (:nodesSize (:graph this)))
    )

    (§ method- #_"GraphNodeIterator" GraphNodeIterator''checkForDeletedNode-1 [#_"GraphNodeIterator" this]
        (loop-when-recur this (and (< (:index this) (:nodesSize (:graph this))) (nil? (nth (:nodes (:graph this)) (:index this)))) (update this :index inc) => this)
    )

    #_unused
    (§ override! #_"Node" GraphNodeIterator''next-1 [#_"GraphNodeIterator" this]
        (try
            (nth (:nodes (:graph this)) (:index this))
            (finally
                (§ ass! this (GraphNodeIterator''forward-1 this))
            )
        )
    )
)

(final-ns InputEdges (§ extends Edges)
    (§ final #_"InputType[]" :inputTypes nil)
    (§ final #_"boolean[]" :isOptional nil)

    (§ defn #_"InputEdges" InputEdges'new-2 [#_"int" directCount, #_"ArrayList<InputInfo>" edges]
        (let [
            #_"InputEdges" this (Edges'new-3 EdgesType'Inputs, directCount, edges)
            this (assoc this :inputTypes (make-array InputType (count edges)))
            this (assoc this :isOptional (boolean-array (count edges)))
        ]
            (dotimes [#_"int" i (count edges)]
                (aset (:inputTypes this) i (:inputType (nth edges i)))
                (aset (:isOptional this) i (:optional (nth edges i)))
            )
            this
        )
    )

    (§ defn #_"void" InputEdges'translateInto-2 [#_"InputEdges" inputs, #_"ArrayList<InputInfo>" infos]
        (dotimes [#_"int" i (count (:offsets inputs))]
            (#_"ArrayList" .add infos, (InputInfo'new-6 (nth (:offsets inputs) i), (Fields''getName-2 inputs, i), (Fields''getType-2 inputs, i), (Fields''getDeclaringClass-2 inputs, i), (nth (:inputTypes inputs) i), (InputEdges''isOptional-2 inputs, i)))
        )
        nil
    )

    (§ method! #_"InputType" InputEdges''getInputType-2 [#_"InputEdges" this, #_"int" index]
        (nth (:inputTypes this) index)
    )

    (§ method! #_"boolean" InputEdges''isOptional-2 [#_"InputEdges" this, #_"int" index]
        (nth (:isOptional this) index)
    )

    #_unused
    (§ override! #_"void" InputEdges''update-4 [#_"InputEdges" this, #_"Node" node, #_"Node" oldValue, #_"Node" newValue]
        (Node''updateUsages-3 node, oldValue, newValue)
        nil
    )
)

;;;
 ; A marker for a node type supporting {@linkplain Graph#getNodes(NodeClass) fast iteration} of its
 ; instances in a graph. The support for fast iteration comes with a memory cost (e.g. extra data
 ; structures Graph) so only node types for which fast iteration provides a compilation
 ; performance benefit should implement this interface.
 ;;
(§ interface IterableNodeType
)

(final-ns IterativeNodeWorkList (§ extends NodeWorkList)
    (def- #_"int" IterativeNodeWorkList'EXPLICIT_BITMAP_THRESHOLD 10)

    (§ mutable #_"int" :iterationLimit 0)
    (§ mutable #_"NodeBitMap" :inQueue nil)

    (§ defn #_"IterativeNodeWorkList" IterativeNodeWorkList'new-3 [#_"Graph" graph, #_"boolean" fill, #_"int" iterationLimitPerNode]
        (let [
            #_"IterativeNodeWorkList" this (NodeWorkList'new-2 graph, fill)
            this (assoc this :iterationLimit (int (Long/min (* (Graph''getNodeCount-1 graph) (long iterationLimitPerNode)), Integer/MAX_VALUE)))
        ]
            this
        )
    )

    (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"IterativeNodeWorkList" this]
        (let [
            #_"IterativeNodeWorkList" owner this
        ]
            (§ reify #_"Iterator<Node>" (Iterator.)
                (§ method- #_"void" Iterator''dropDeleted-1 [#_"Iterator<Node>" this]
                    (while (and (not (#_"Queue" .isEmpty (:worklist owner))) (Node''isDeleted-1 (#_"Queue" .peek (:worklist owner))))
                        (#_"Queue" .remove (:worklist owner))
                    )
                    nil
                )

                (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<Node>" this]
                    (Iterator''dropDeleted-1 this)
                    (and (pos? (:iterationLimit owner)) (not (#_"Queue" .isEmpty (:worklist owner))))
                )

                (§ override! #_"Node" #_"Iterator" .next [#_"Iterator<Node>" this]
                    (try
                        (when-not (pos? (:iterationLimit owner))
                            (throw (NoSuchElementException.))
                        )
                        (finally
                            (§ ass owner (update owner :iterationLimit dec))
                        )
                    )
                    (Iterator''dropDeleted-1 this)
                    (let [
                        #_"Node" node (#_"Queue" .remove (:worklist owner))
                    ]
                        (when (some? (:inQueue owner))
                            (§ ass! (:inQueue owner) (NodeBitMap''clearAndGrow-2 (:inQueue owner), node))
                        )
                        node
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" IterativeNodeWorkList''add-2 [#_"IterativeNodeWorkList" this, #_"Node" node]
        (when (some? node)
            (when (and (nil? (:inQueue this)) (< IterativeNodeWorkList'EXPLICIT_BITMAP_THRESHOLD (#_"Queue" .size (:worklist this))))
                (§ ass! this (IterativeNodeWorkList''inflateToBitMap-2 this, (:graph node)))
            )
            (or
                (if (some? (:inQueue this))
                    (when (NodeBitMap''isMarkedAndGrow-2 (:inQueue this), node)
                        :done
                    )
                    (loop-when [#_"ISeq" s (seq (:worklist this))] (some? s)
                        (when (= (first s) node) => (recur (next s))
                            :done
                        )
                    )
                )
                (do
                    (when (some? (:inQueue this))
                        (§ ass! (:inQueue this) (NodeBitMap''markAndGrow-2 (:inQueue this), node))
                    )
                    (#_"Queue" .add (:worklist this), node)
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" IterativeNodeWorkList''contains-2 [#_"IterativeNodeWorkList" this, #_"Node" node]
        (if (some? (:inQueue this))
            (NodeBitMap''isMarked-2 (:inQueue this), node)
            (loop [#_"ISeq" s (seq (:worklist this))] (and (some? s) (or (= (first s) node) (recur (next s)))))
        )
    )

    (§ method- #_"IterativeNodeWorkList" IterativeNodeWorkList''inflateToBitMap-2 [#_"IterativeNodeWorkList" this, #_"Graph" graph]
        (let [
            this (assoc this :inQueue (NodeBitMap'new-1 graph))
        ]
            (doseq [#_"Node" queuedNode (:worklist this)]
                (when (Node''isAlive-1 queuedNode)
                    (NodeBitMap''mark-2 (:inQueue this), queuedNode)
                )
            )
            this
        )
    )
)

(final-ns FilteredNodeIterable #_"<T extends Node>" (§ implements NodeIterable #_"<T>")
    (§ final #_"NodeIterable<T>" :nodeIterable nil)
    (§ mutable #_"NodePredicate" :predicate NodePredicates'TAUTOLOGY)

    (§ defn #_"FilteredNodeIterable" FilteredNodeIterable'new-1 [#_"NodeIterable<T>" nodeIterable]
        (let [
            #_"FilteredNodeIterable" this (Object.)
            this (assoc this :nodeIterable nodeIterable)
        ]
            this
        )
    )

    (§ method! #_"FilteredNodeIterable<T>" FilteredNodeIterable''and-2 [#_"FilteredNodeIterable<T extends Node>" this, #_"NodePredicate" nodePredicate]
        (§ ass this (assoc this :predicate (NodePredicate''and-2 (:predicate this), nodePredicate)))
        this
    )

    (§ override! #_"Iterator<T>" #_"Iterable" .iterator [#_"FilteredNodeIterable<T extends Node>" this]
        (PredicatedProxyNodeIterator'new-2 (#_"Iterable" .iterator (:nodeIterable this)), (:predicate this))
    )

    #_unused
    (§ override! #_"<F extends T> FilteredNodeIterable<F>" FilteredNodeIterable''filter-2 [#_"FilteredNodeIterable<T extends Node>" this, #_"Class<F>" clazz]
        (FilteredNodeIterable''and-2 this, (PositiveTypePredicate'new-1 clazz))
    )

    #_unused
    (§ override! #_"FilteredNodeIterable<T>" FilteredNodeIterable''filter-2 [#_"FilteredNodeIterable<T extends Node>" this, #_"NodePredicate" p]
        (FilteredNodeIterable''and-2 this, p)
    )
)

(§ interface NodeIterable #_"<T extends Node>" (§ extends Iterable #_"<T>")
    (§ default #_"<F extends T> NodeIterable<F>" NodeIterable''filter-2 [#_"NodeIterable<T extends Node>" this, #_"Class<F>" clazz]
        (FilteredNodeIterable''and-2 (FilteredNodeIterable'new-1 this), (PositiveTypePredicate'new-1 clazz))
    )

    (§ default #_"FilteredNodeIterable<T>" NodeIterable''filter-2 [#_"NodeIterable<T extends Node>" this, #_"NodePredicate" predicate]
        (FilteredNodeIterable''and-2 (FilteredNodeIterable'new-1 this), predicate)
    )

    (§ default #_"List<T>" NodeIterable''snapshot-1 [#_"NodeIterable<T extends Node>" this]
        (let [
            #_"ArrayList<T>" list (ArrayList.)
        ]
            (NodeIterable''snapshotTo-2 this, list)
            list
        )
    )

    (§ default #_"void" NodeIterable''snapshotTo-2 [#_"NodeIterable<T extends Node>" this, #_"Collection<? super T>" to]
        (doseq [#_"T" n this]
            (#_"Collection" .add to, n)
        )
        nil
    )

    (§ default #_"T" NodeIterable''first-1 [#_"NodeIterable<T extends Node>" this]
        (let [
            #_"Iterator<T>" it (#_"Iterable" .iterator this)
        ]
            (when (#_"Iterator" .hasNext it)
                (#_"Iterator" .next it)
            )
        )
    )

    (§ default #_"int" NodeIterable''count-1 [#_"NodeIterable<T extends Node>" this]
        (let [
            #_"Iterator<T>" it (#_"Iterable" .iterator this)
        ]
            (loop-when-recur [#_"int" n 0] (#_"Iterator" .hasNext it) [(inc n)] => n
                (#_"Iterator" .next it)
            )
        )
    )

    (§ default #_"boolean" NodeIterable''isEmpty-1 [#_"NodeIterable<T extends Node>" this]
        (not (#_"Iterator" .hasNext (#_"Iterable" .iterator this)))
    )

    (§ default #_"boolean" NodeIterable''isNotEmpty-1 [#_"NodeIterable<T extends Node>" this]
        (#_"Iterator" .hasNext (#_"Iterable" .iterator this))
    )

    (§ default #_"boolean" NodeIterable''contains-2 [#_"NodeIterable<T extends Node>" this, #_"T" node]
        (loop-when [#_"ISeq" s (seq this)] (some? s) => false
            (or (= (first s) node)
                (recur (next s))
            )
        )
    )
)

(class-ns NodeIterator #_"<T extends Node>" (§ implements Iterator #_"<T>")
    (§ defn #_"NodeIterator" NodeIterator'new-0 []
        (Object.)
    )

    (§ mutable #_"T" :current nil)

    (§ abstract #_"void" NodeIterator''forward-1 [#_"NodeIterator<T extends Node>" this])

    #_unused
    (§ override #_"boolean" NodeIterator''hasNext-1 [#_"NodeIterator<T extends Node>" this]
        (NodeIterator''forward-1 this)
        (some? (:current this))
    )

    #_unused
    (§ override #_"T" NodeIterator''next-1 [#_"NodeIterator<T extends Node>" this]
        (NodeIterator''forward-1 this)
        (let [
            #_"T" ret (:current this)
        ]
            (when (some? (:current this)) => (throw (NoSuchElementException.))
                (§ ass! this (assoc this :current nil))
                ret
            )
        )
    )
)

(§ interface NodePredicate (§ extends Predicate #_"<Node>")
    (§ abstract #_"boolean" NodePredicate''apply-2 [#_"NodePredicate" this, #_"Node" n])

    #_unused
    (§ default! #_"boolean" NodePredicate''test-2 [#_"NodePredicate" this, #_"Node" n]
        (NodePredicate''apply-2 this, n)
    )

    (§ default #_"NodePredicate" NodePredicate''and-2 [#_"NodePredicate" this, #_"NodePredicate" np]
        (AndPredicate'new-2 this, np)
    )
)

(value-ns NodePredicates
    (§ def- #_"TautologyPredicate" NodePredicates'TAUTOLOGY (TautologyPredicate'new-0))
    (§ def- #_"ContradictionPredicate" NodePredicates'CONTRADICTION (ContradictionPredicate'new-0))
)

;;;
 ; @anno NodePredicates.TautologyPredicate
 ;;
(final-ns TautologyPredicate (§ implements NodePredicate)
    (§ defn #_"TautologyPredicate" TautologyPredicate'new-0 []
        (Object.)
    )

    #_unused
    (§ override! #_"boolean" TautologyPredicate''apply-2 [#_"TautologyPredicate" this, #_"Node" n]
        true
    )

    #_unused
    (§ override! #_"NodePredicate" TautologyPredicate''and-2 [#_"TautologyPredicate" this, #_"NodePredicate" np]
        np
    )
)

;;;
 ; @anno NodePredicates.ContradictionPredicate
 ;;
(final-ns ContradictionPredicate (§ implements NodePredicate)
    (§ defn #_"ContradictionPredicate" ContradictionPredicate'new-0 []
        (Object.)
    )

    #_unused
    (§ override! #_"boolean" ContradictionPredicate''apply-2 [#_"ContradictionPredicate" this, #_"Node" n]
        false
    )

    #_unused
    (§ override! #_"NodePredicate" ContradictionPredicate''and-2 [#_"ContradictionPredicate" this, #_"NodePredicate" np]
        this
    )
)

;;;
 ; @anno NodePredicates.AndPredicate
 ;;
(final-ns AndPredicate (§ implements NodePredicate)
    (§ final #_"NodePredicate" :a nil)
    (§ final #_"NodePredicate" :b nil)

    (§ defn #_"AndPredicate" AndPredicate'new-2 [#_"NodePredicate" a, #_"NodePredicate" b]
        (let [
            #_"AndPredicate" this (Object.)
            this (assoc this :a a)
            this (assoc this :b b)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" AndPredicate''apply-2 [#_"AndPredicate" this, #_"Node" n]
        (and (NodePredicate''apply-2 (:a this), n) (NodePredicate''apply-2 (:b this), n))
    )
)

;;;
 ; @anno NodePredicates.NotPredicate
 ;;
(final-ns NotPredicate (§ implements NodePredicate)
    (§ final #_"NodePredicate" :a nil)

    #_unused
    (§ defn #_"NotPredicate" NotPredicate'new-1 [#_"NodePredicate" n]
        (let [
            #_"NotPredicate" this (Object.)
            this (assoc this :a n)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" NotPredicate''apply-2 [#_"NotPredicate" this, #_"Node" n]
        (not (NodePredicate''apply-2 (:a this), n))
    )

    #_unused
    (§ override! #_"NodePredicate" NotPredicate''negate-1 [#_"NotPredicate" this]
        (:a this)
    )
)

;;;
 ; @anno NodePredicates.PositiveTypePredicate
 ;;
(final-ns PositiveTypePredicate (§ implements NodePredicate)
    (§ final #_"Class" :type nil)
    (§ mutable #_"PositiveTypePredicate" :or nil)

    (§ defn #_"PositiveTypePredicate" PositiveTypePredicate'new-1 [#_"Class" type]
        (let [
            #_"PositiveTypePredicate" this (Object.)
            this (assoc this :type type)
        ]
            this
        )
    )

    (§ defn #_"PositiveTypePredicate" PositiveTypePredicate'new-1 [#_"NegativeTypePredicate" a]
        (let [
            #_"PositiveTypePredicate" this (Object.)
            this (assoc this :type (:type a))
            this
                (when (some? (:nor a)) => this
                    (assoc this :or (PositiveTypePredicate'new-1 (:nor a)))
                )
        ]
            this
        )
    )

    (§ override! #_"boolean" PositiveTypePredicate''apply-2 [#_"PositiveTypePredicate" this, #_"Node" n]
        (or (#_"Class" .isInstance (:type this), n) (and (some? (:or this)) (PositiveTypePredicate''apply-2 (:or this), n)))
    )

    (§ method! #_"PositiveTypePredicate" PositiveTypePredicate''or-2 [#_"PositiveTypePredicate" this, #_"Class<? extends Node>" clazz]
        (if (nil? (:or this))
            (§ ass this (assoc this :or (PositiveTypePredicate'new-1 clazz)))
            (PositiveTypePredicate''or-2 (:or this), clazz)
        )
        this
    )

    #_unused
    (§ override! #_"NodePredicate" PositiveTypePredicate''negate-1 [#_"PositiveTypePredicate" this]
        (NegativeTypePredicate'new-1 this)
    )
)

;;;
 ; @anno NodePredicates.NegativeTypePredicate
 ;;
(final-ns NegativeTypePredicate (§ implements NodePredicate)
    (§ final #_"Class" :type nil)
    (§ mutable #_"NegativeTypePredicate" :nor nil)

    (§ defn #_"NegativeTypePredicate" NegativeTypePredicate'new-1 [#_"Class" type]
        (let [
            #_"NegativeTypePredicate" this (Object.)
            this (assoc this :type type)
        ]
            this
        )
    )

    (§ defn #_"NegativeTypePredicate" NegativeTypePredicate'new-1 [#_"PositiveTypePredicate" a]
        (let [
            #_"NegativeTypePredicate" this (Object.)
            this (assoc this :type (:type a))
            this
                (when (some? (:or a)) => this
                    (assoc this :nor (NegativeTypePredicate'new-1 (:or a)))
                )
        ]
            this
        )
    )

    (§ override! #_"boolean" NegativeTypePredicate''apply-2 [#_"NegativeTypePredicate" this, #_"Node" n]
        (and (not (#_"Class" .isInstance (:type this), n)) (or (nil? (:nor this)) (NegativeTypePredicate''apply-2 (:nor this), n)))
    )

    (§ method! #_"NegativeTypePredicate" NegativeTypePredicate''nor-2 [#_"NegativeTypePredicate" this, #_"Class<? extends Node>" clazz]
        (if (nil? (:nor this))
            (§ ass this (assoc this :nor (NegativeTypePredicate'new-1 clazz)))
            (NegativeTypePredicate''nor-2 (:nor this), clazz)
        )
        this
    )

    #_unused
    (§ override! #_"NodePredicate" NegativeTypePredicate''negate-1 [#_"NegativeTypePredicate" this]
        (PositiveTypePredicate'new-1 this)
    )
)

(final-ns PredicatedProxyNodeIterator #_"<T extends Node>" (§ extends NodeIterator #_"<T>")
    (§ final #_"Iterator<T>" :iterator nil)
    (§ final #_"NodePredicate" :predicate nil)

    (§ defn #_"PredicatedProxyNodeIterator" PredicatedProxyNodeIterator'new-2 [#_"Iterator<T>" iterator, #_"NodePredicate" predicate]
        (let [
            #_"PredicatedProxyNodeIterator" this (NodeIterator'new-0)
            this (assoc this :iterator iterator)
            this (assoc this :predicate predicate)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" PredicatedProxyNodeIterator''forward-1 [#_"PredicatedProxyNodeIterator<T extends Node>" this]
        (loop-when-recur [] (and (or (nil? (:current this)) (not (Node''isAlive-1 (:current this))) (not (NodePredicate''apply-2 (:predicate this), (:current this)))) (#_"Iterator" .hasNext (:iterator this))) []
            (§ ass! this (assoc this :current (#_"Iterator" .next (:iterator this))))
        )
        (when (and (some? (:current this)) (or (not (Node''isAlive-1 (:current this))) (not (NodePredicate''apply-2 (:predicate this), (:current this)))))
            (§ ass! this (assoc this :current nil))
        )
        nil
    )
)

;;;
 ; This class is the base class for all nodes. It represents a node that can be inserted in a Graph.
 ;
 ; Once a node has been added to a graph, it has a graph-unique #id(). Edges in the subclasses are
 ; represented with annotated fields. There are two kind of edges: Input and Successor.
 ; If a field, of a type compatible with Node, annotated with either Input and
 ; Successor is not nil, then there is an edge from this node to the node this field points to.
 ;;
(class-ns Node
    (def #_"NodeClass" Node'TYPE nil)

    (def #_"int" Node'DELETED_ID_START -1000000000)
    (def #_"int" Node'INITIAL_ID -1)
    (def #_"int" Node'ALIVE_ID_START 0)

    (§ mutable #_"Graph" :graph nil)
    (§ mutable #_"int" :id 0)

    ;; this next pointer is used in Graph to implement fast iteration over NodeClass types, it
    ;; therefore points to the next Node of the same type.
    (§ mutable #_"Node" :typeCacheNext nil)

    (def #_"int" Node'INLINE_USAGE_COUNT 2)
    (§ def- #_"Node[]" Node'NO_NODES (make-array Node 0))

    ;;;
     ; Head of usage list. The elements of the usage list in order are #usage0,
     ; #usage1 and #extraUsages. The first nil entry terminates the list.
     ;;
    (§ mutable #_"Node" :usage0 nil)
    (§ mutable #_"Node" :usage1 nil)
    (§ mutable #_"Node[]" :extraUsages nil)
    (§ mutable #_"int" :extraUsagesCount 0)

    (§ mutable #_"Node" :predecessor nil)
    (§ mutable #_"NodeClass<? extends Node>" :nodeClass nil)

    (def #_"int" Node'NODE_LIST -2)
    (def #_"int" Node'NOT_ITERABLE -1)

    (§ defn #_"Node" Node'new-1 [#_"NodeClass<? extends Node>" c]
        (let [
            #_"Node" this (Object.)
        ]
            (§ ass! this (Node''init-2 this, c))
            this
        )
    )

    (§ method! #_"Node" Node''init-2 [#_"Node" this, #_"NodeClass<? extends Node>" c]
        (let [
            this (assoc this :nodeClass c)
            this (assoc this :id Node'INITIAL_ID)
            this (assoc this :extraUsages Node'NO_NODES)
        ]
            this
        )
    )

    ;;;
     ; Returns an {@link NodeIterable iterable} which can be used to traverse all non-nil input edges of this node.
     ;;
    (§ method! #_"NodeIterable<Node>" Node''inputs-1 [#_"Node" this]
        (NodeClass''getInputIterable-2 (:nodeClass this), this)
    )

    ;;;
     ; Returns an {@link Iterable iterable} which can be used to traverse all non-nil input edges of this node.
     ;;
    (§ method! #_"Iterable<Position>" Node''inputPositions-1 [#_"Node" this]
        (Edges''getPositionsIterable-2 (:inputs (:nodeClass this)), this)
    )

    ;;;
     ; Applies the given visitor to all inputs of this node.
     ;;
    (§ method #_"void" Node''applyInputs-2 [#_"Node" this, #_"EdgeVisitor" visitor]
        (NodeClass''applyInputs-3 (:nodeClass this), this, visitor)
        nil
    )

    ;;;
     ; Applies the given visitor to all successors of this node.
     ;;
    (§ method #_"void" Node''applySuccessors-2 [#_"Node" this, #_"EdgeVisitor" visitor]
        (NodeClass''applySuccessors-3 (:nodeClass this), this, visitor)
        nil
    )

    ;;;
     ; Returns an {@link NodeIterable iterable} which can be used to traverse all non-nil successor edges of this node.
     ;;
    (§ method! #_"NodeIterable<Node>" Node''successors-1 [#_"Node" this]
        (NodeClass''getSuccessorIterable-2 (:nodeClass this), this)
    )

    ;;;
     ; Returns an {@link Iterable iterable} which can be used to traverse all successor edge positions of this node.
     ;;
    (§ method! #_"Iterable<Position>" Node''successorPositions-1 [#_"Node" this]
        (Edges''getPositionsIterable-2 (:successors (:nodeClass this)), this)
    )

    ;;;
     ; Gets the maximum number of usages this node has had at any point in time.
     ;;
    (§ method! #_"int" Node''getUsageCount-1 [#_"Node" this]
        (cond
            (nil? (:usage0 this)) 0
            (nil? (:usage1 this)) 1
            :else                 (+ Node'INLINE_USAGE_COUNT (:extraUsagesCount this))
        )
    )

    ;;;
     ; Gets the list of nodes that use this node (i.e. as an input).
     ;;
    (§ method! #_"NodeIterable<Node>" Node''usages-1 [#_"Node" this]
        (NodeUsageIterable'new-1 this)
    )

    ;;;
     ; Checks whether this node has no usages.
     ;;
    (§ method! #_"boolean" Node''hasNoUsages-1 [#_"Node" this]
        (nil? (:usage0 this))
    )

    ;;;
     ; Checks whether this node has usages.
     ;;
    (§ method! #_"boolean" Node''hasUsages-1 [#_"Node" this]
        (some? (:usage0 this))
    )

    ;;;
     ; Checks whether this node has more than one usages.
     ;;
    (§ method! #_"boolean" Node''hasMoreThanOneUsage-1 [#_"Node" this]
        (some? (:usage1 this))
    )

    ;;;
     ; Checks whether this node has exactly one usgae.
     ;;
    (§ method! #_"boolean" Node''hasExactlyOneUsage-1 [#_"Node" this]
        (and (Node''hasUsages-1 this) (not (Node''hasMoreThanOneUsage-1 this)))
    )

    ;;;
     ; Adds a given node to this node's {@linkplain #usages() usages}.
     ;
     ; @param node the node to add
     ;;
    (§ method #_"void" Node''addUsage-2 [#_"Node" this, #_"Node" node]
        (cond
            (nil? (:usage0 this))
                (§ ass! this (assoc this :usage0 node))
            (nil? (:usage1 this))
                (§ ass! this (assoc this :usage1 node))
            :else
                (let [
                    #_"int" n (count (:extraUsages this))
                ]
                    (cond
                        (zero? n)
                            (§ ass! this (assoc this :extraUsages (make-array Node 4)))
                        (= (:extraUsagesCount this) n)
                            (let [
                                #_"Node[]" newExtraUsages (make-array Node (inc (* n 2)))
                            ]
                                (System/arraycopy (:extraUsages this), 0, newExtraUsages, 0, n)
                                (§ ass! this (assoc this :extraUsages newExtraUsages))
                            )
                    )
                    (aset (:extraUsages this) (:extraUsagesCount this) node)
                    (§ ass! this (update this :extraUsagesCount inc))
                )
        )
        nil
    )

    (§ method- #_"Node" Node''movUsageFromEndTo-2 [#_"Node" this, #_"int" destIndex]
        (cond
            (<= Node'INLINE_USAGE_COUNT destIndex) (Node''movUsageFromEndToExtraUsages-2 this, (- destIndex Node'INLINE_USAGE_COUNT))
            (= destIndex 1)                        (Node''movUsageFromEndToIndexOne-1 this)
            :else                                  (Node''movUsageFromEndToIndexZero-1 this)
        )
    )

    (§ method- #_"Node" Node''movUsageFromEndToExtraUsages-2 [#_"Node" this, #_"int" destExtraIndex]
        (let [
            this (update this :extraUsagesCount dec)
        ]
            (aset (:extraUsages this) destExtraIndex (nth (:extraUsages this) (:extraUsagesCount this)))
            (aset (:extraUsages this) (:extraUsagesCount this) nil)
            this
        )
    )

    (§ method- #_"Node" Node''movUsageFromEndToIndexZero-1 [#_"Node" this]
        (cond
            (pos? (:extraUsagesCount this))
                (let [
                    this (update this :extraUsagesCount dec)
                    this (assoc this :usage0 (nth (:extraUsages this) (:extraUsagesCount this)))
                ]
                    (aset (:extraUsages this) (:extraUsagesCount this) nil)
                    this
                )
            (some? (:usage1 this))
                (let [
                    this (assoc this :usage0 (:usage1 this))
                    this (assoc this :usage1 nil)
                ]
                    this
                )
            :else
                (assoc this :usage0 nil)
        )
    )

    (§ method- #_"Node" Node''movUsageFromEndToIndexOne-1 [#_"Node" this]
        (when (pos? (:extraUsagesCount this)) => (assoc this :usage1 nil)
            (let [
                this (update this :extraUsagesCount dec)
                this (assoc this :usage1 (nth (:extraUsages this) (:extraUsagesCount this)))
            ]
                (aset (:extraUsages this) (:extraUsagesCount this) nil)
                this
            )
        )
    )

    ;;;
     ; Removes a given node from this node's {@linkplain #usages() usages}.
     ;
     ; @param node the node to remove
     ; @return whether or not {@code usage} was in the usage list
     ;;
    (§ method! #_"boolean" Node''removeUsage-2 [#_"Node" this, #_"Node" node]
        ;; For large graphs, usage removal is critical for performance.
        ;; Furthermore, it is critical that this method maintains the invariant,
        ;; that the usage list has no nil element preceding a non-nil element.
        (cond
            (= (:usage0 this) node)
            (do
                (§ ass! this (Node''movUsageFromEndToIndexZero-1 this))
                true
            )
            (= (:usage1 this) node)
            (do
                (§ ass! this (Node''movUsageFromEndToIndexOne-1 this))
                true
            )
            :else
                (loop-when [#_"int" i (dec (:extraUsagesCount this))] (<= 0 i) => false
                    (when (= (nth (:extraUsages this) i) node) => (recur (dec i))
                        (do
                            (§ ass! this (Node''movUsageFromEndToExtraUsages-2 this, i))
                            true
                        )
                    )
                )
        )
    )

    (§ method! #_"boolean" Node''isDeleted-1 [#_"Node" this]
        (<= (:id this) Node'DELETED_ID_START)
    )

    (§ method! #_"boolean" Node''isAlive-1 [#_"Node" this]
        (<= Node'ALIVE_ID_START (:id this))
    )

    #_unused
    (§ method! #_"boolean" Node''isUnregistered-1 [#_"Node" this]
        (= (:id this) Node'INITIAL_ID)
    )

    ;;;
     ; Updates the usages sets of the given nodes after an input slot is changed from
     ; {@code oldInput} to {@code newInput} by removing this node from {@code oldInput}'s usages and
     ; adds this node to {@code newInput}'s usages.
     ;;
    (§ method! #_"void" Node''updateUsages-3 [#_"Node" this, #_"Node" oldInput, #_"Node" newInput]
        (when-not (= oldInput newInput)
            (when (some? oldInput)
                (Node''removeThisFromUsages-2 this, oldInput)
            )
            (Node''maybeNotifyInputChanged-2 this, this)
            (when (some? newInput)
                (Node''addUsage-2 newInput, this)
            )
            (when (and (some? oldInput) (Node''hasNoUsages-1 oldInput))
                (Node''maybeNotifyZeroUsages-2 this, oldInput)
            )
        )
        nil
    )

    ;;;
     ; Updates the predecessor of the given nodes after a successor slot is changed from
     ; oldSuccessor to newSuccessor: removes this node from oldSuccessor's predecessors and adds
     ; this node to newSuccessor's predecessors.
     ;;
    (§ method! #_"void" Node''updatePredecessor-3 [#_"Node" this, #_"Node" oldSuccessor, #_"Node" newSuccessor]
        (when-not (= oldSuccessor newSuccessor)
            (when (some? oldSuccessor)
                (§ ass! oldSuccessor (assoc oldSuccessor :predecessor nil))
            )
            (when (some? newSuccessor)
                (§ ass! newSuccessor (assoc newSuccessor :predecessor this))
            )
        )
        nil
    )

    (§ method #_"void" Node''initialize-2 [#_"Node" this, #_"Graph" newGraph]
        (§ ass! this (assoc this :graph newGraph))
        (§ ass! newGraph (Graph''register-2 newGraph, this))
        (let [
            #_"NodeClass<? extends Node>" nc (:nodeClass this)
        ]
            (NodeClass''registerAtInputsAsUsage-2 nc, this)
            (NodeClass''registerAtSuccessorsAsPredecessor-2 nc, this)
        )
        nil
    )

    ;;;
     ; Information associated with this node. A single value is stored directly in the field.
     ; Multiple values are stored by creating an Object[].
     ;;
    (§ mutable #_"Object" :annotation nil)

    #_unused
    (§ method- #_"<T> T" Node''getNodeInfo-2 [#_"Node" this, #_"Class<T>" c]
        (when (some? (:annotation this))
            (cond
                (#_"Class" .isInstance c, (:annotation this))
                    (#_"Class" .cast c, (:annotation this))
                (= (#_"Object" .getClass (:annotation this)) Object*'class)
                    (loop-when [#_"ISeq" s (seq (:annotation this))] (some? s)
                        (let [
                            #_"Object" a (first s)
                        ]
                            (when (#_"Class" .isInstance c, a) => (recur (next s))
                                (#_"Class" .cast c, a)
                            )
                        )
                    )
            )
        )
    )

    #_unused
    (§ method- #_"<T> void" Node''setNodeInfo-3 [#_"Node" this, #_"Class<T>" clazz, #_"T" value]
        (cond
            (or (nil? (:annotation this)) (#_"Class" .isInstance clazz, (:annotation this)))
                (§ ass! this (assoc this :annotation value))
            (= (#_"Object" .getClass (:annotation this)) Object*'class)
                (let [
                    #_"Object[]" a (:annotation this)
                ]
                    (or
                        (loop-when [#_"int" i 0] (< i (count a))
                            (when (#_"Class" .isInstance clazz, (nth a i)) => (recur (inc i))
                                (aset a i value)
                                :done
                            )
                        )
                        (let [
                            #_"Object[]" a' (Arrays/copyOf a, (inc (count a)))
                        ]
                            (aset a' (count a) value)
                            (§ ass! this (assoc this :annotation a'))
                        )
                    )
                )
            :else
                (§ ass! this (assoc this :annotation (into-array Object [ (:annotation this), value ])))
        )
        nil
    )

    (§ method #_"boolean" Node''isAllowedUsageType-2 [#_"Node" this, #_"InputType" type]
        (and (not= type InputType'Value) (#_"EnumSet" .contains (:allowedUsageTypes (:nodeClass this)), type))
    )

    (§ method- #_"boolean" Node''checkReplaceWith-2 [#_"Node" this, #_"Node" other]
        (when (and (some? (:graph this)) (Graph''isFrozen-1 (:graph this)))
            (throw! "cannot modify frozen graph")
        )
        (when (= other this)
            (throw! "cannot replace a node with itself")
        )
        (when (Node''isDeleted-1 this)
            (throw! "cannot replace deleted node")
        )
        (when (and (some? other) (Node''isDeleted-1 other))
            (throw! (str "cannot replace with deleted node " other))
        )
        true
    )

    (§ method! #_"Node" Node''replaceAtUsages-2 [#_"Node" this, #_"Node" other]
        (Node''replaceAtAllUsages-3 this, other, (§ cast #_"Node" nil))
    )

    (§ method! #_"void" Node''replaceAtUsages-3 [#_"Node" this, #_"Node" other, #_"Predicate<Node>" filter]
        (Node''replaceAtUsages-4 this, other, filter, nil)
        nil
    )

    (§ method! #_"void" Node''replaceAtUsagesAndDelete-2 [#_"Node" this, #_"Node" other]
        (Node''replaceAtUsages-4 this, other, nil, this)
        (Node''safeDelete-1 this)
        nil
    )

    #_unused
    (§ method! #_"void" Node''replaceAtUsagesAndDelete-3 [#_"Node" this, #_"Node" other, #_"Predicate<Node>" filter]
        (Node''replaceAtUsages-4 this, other, filter, this)
        (Node''safeDelete-1 this)
        nil
    )

    (§ method #_"void" Node''replaceAtUsages-4 [#_"Node" this, #_"Node" other, #_"Predicate<Node>" filter, #_"Node" toBeDeleted]
        (if (some? filter)
            (§ ass! this (Node''replaceAtMatchingUsages-4 this, other, filter, toBeDeleted))
            (§ ass! this (Node''replaceAtAllUsages-3 this, other, toBeDeleted))
        )
        nil
    )

    (§ method! #_"Node" Node''replaceAtAllUsages-3 [#_"Node" this, #_"Node" other, #_"Node" toBeDeleted]
        (Node''checkReplaceWith-2 this, other)
        (when (some? (:usage0 this)) => this
            (Node''replaceAtUsage-4 this, other, toBeDeleted, (:usage0 this))
            (let [
                this (assoc this :usage0 nil)
            ]
                (when (some? (:usage1 this)) => this
                    (Node''replaceAtUsage-4 this, other, toBeDeleted, (:usage1 this))
                    (let [
                        this (assoc this :usage1 nil)
                    ]
                        (when (pos? (:extraUsagesCount this)) => this
                            (dotimes [#_"int" i (:extraUsagesCount this)]
                                (Node''replaceAtUsage-4 this, other, toBeDeleted, (nth (:extraUsages this) i))
                            )
                            (let [
                                this (assoc this :extraUsages Node'NO_NODES)
                                this (assoc this :extraUsagesCount 0)
                            ]
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method- #_"void" Node''replaceAtUsage-4 [#_"Node" this, #_"Node" other, #_"Node" toBeDeleted, #_"Node" usage]
        (NodeClass''replaceFirstInput-4 (:nodeClass usage), usage, this, other)
        ;; Don't notify for nodes which are about to be deleted.
        (when (or (nil? toBeDeleted) (not= usage toBeDeleted))
            (Node''maybeNotifyInputChanged-2 this, usage)
        )
        (when (some? other)
            (Node''addUsage-2 other, usage)
        )
        nil
    )

    (§ method- #_"Node" Node''replaceAtMatchingUsages-4 [#_"Node" this, #_"Node" other, #_"Predicate<Node>" filter, #_"Node" toBeDeleted]
        (when (some? filter) => (throw! "filter cannot be nil")
            (Node''checkReplaceWith-2 this, other)
            (loop-when [this this #_"int" i 0] (< i (Node''getUsageCount-1 this)) => this
                (let [
                    #_"Node" usage (Node''getUsageAt-2 this, i)
                ]
                    (when (#_"Predicate" .test filter, usage) => (recur this (inc i))
                        (Node''replaceAtUsage-4 this, other, toBeDeleted, usage)
                        (recur (Node''movUsageFromEndTo-2 this, i) i)
                    )
                )
            )
        )
    )

    (§ method! #_"Node" Node''getUsageAt-2 [#_"Node" this, #_"int" index]
        (case index
            0 (:usage0 this)
            1 (:usage1 this)
              (nth (:extraUsages this) (- index Node'INLINE_USAGE_COUNT))
        )
    )

    (§ method! #_"Node" Node''replaceAtMatchingUsages-3 [#_"Node" this, #_"Node" other, #_"NodePredicate" usagePredicate]
        (Node''checkReplaceWith-2 this, other)
        (Node''replaceAtMatchingUsages-4 this, other, usagePredicate, nil)
    )

    (§ method #_"void" Node''replaceAtUsages-3 [#_"Node" this, #_"InputType" type, #_"Node" other]
        (Node''checkReplaceWith-2 this, other)
        (doseq [#_"Node" usage (NodeIterable''snapshot-1 (Node''usages-1 this))]
            (doseq [#_"Position" pos (Node''inputPositions-1 usage)]
                (when (and (= (Position''getInputType-1 pos) type) (= (Position''get-2 pos, usage) this))
                    (Position''set-3 pos, usage, other)
                )
            )
        )
        nil
    )

    (§ method- #_"void" Node''maybeNotifyInputChanged-2 [#_"Node" this, #_"Node" node]
        (when (some? (:graph this))
            (let [
                #_"NodeEventListener" listener (:nodeEventListener (:graph this))
            ]
                (when (some? listener)
                    (NodeEventListener''event-3 listener, NodeEvent'INPUT_CHANGED, node)
                )
            )
        )
        nil
    )

    (§ method! #_"void" Node''maybeNotifyZeroUsages-2 [#_"Node" this, #_"Node" node]
        (when (some? (:graph this))
            (let [
                #_"NodeEventListener" listener (:nodeEventListener (:graph this))
            ]
                (when (and (some? listener) (Node''isAlive-1 node))
                    (NodeEventListener''event-3 listener, NodeEvent'ZERO_USAGES, node)
                )
            )
        )
        nil
    )

    (§ method! #_"void" Node''replaceAtPredecessor-2 [#_"Node" this, #_"Node" other]
        (Node''checkReplaceWith-2 this, other)
        (when (some? (:predecessor this))
            (when-not (NodeClass''replaceFirstSuccessor-4 (:nodeClass (:predecessor this)), (:predecessor this), this, other)
                (throw! (str "not found in successors, predecessor: " (:predecessor this)))
            )
            (Node''updatePredecessor-3 (:predecessor this), this, other)
        )
        nil
    )

    (§ method! #_"Node" Node''replaceAndDelete-2 [#_"Node" this, #_"Node" other]
        (Node''checkReplaceWith-2 this, other)
        (when (some? other) => (throw! "cannot replace with nil")
            (let [
                this
                    (when (Node''hasUsages-1 this) => this
                        (Node''replaceAtUsages-2 this, other)
                    )
            ]
                (Node''replaceAtPredecessor-2 this, other)
                (Node''safeDelete-1 this)
                this
            )
        )
    )

    (§ method #_"void" Node''replaceFirstSuccessor-3 [#_"Node" this, #_"Node" oldSuccessor, #_"Node" newSuccessor]
        (when (NodeClass''replaceFirstSuccessor-4 (:nodeClass this), this, oldSuccessor, newSuccessor)
            (Node''updatePredecessor-3 this, oldSuccessor, newSuccessor)
        )
        nil
    )

    (§ method #_"void" Node''replaceFirstInput-3 [#_"Node" this, #_"Node" oldInput, #_"Node" newInput]
        (when (NodeClass''replaceFirstInput-4 (:nodeClass this), this, oldInput, newInput)
            (Node''updateUsages-3 this, oldInput, newInput)
        )
        nil
    )

    (§ method! #_"void" Node''clearInputs-1 [#_"Node" this]
        (NodeClass''unregisterAtInputsAsUsage-2 (:nodeClass this), this)
        nil
    )

    (§ method! #_"boolean" Node''removeThisFromUsages-2 [#_"Node" this, #_"Node" n]
        (Node''removeUsage-2 n, this)
    )

    (§ method! #_"void" Node''clearSuccessors-1 [#_"Node" this]
        (NodeClass''unregisterAtSuccessorsAsPredecessor-2 (:nodeClass this), this)
        nil
    )

    ;;;
     ; Removes this node from its graph. This node must have no {@linkplain Node#usages() usages}
     ; and no {@linkplain #predecessor() predecessor}.
     ;;
    (§ method! #_"void" Node''safeDelete-1 [#_"Node" this]
        (Node''clearInputs-1 this)
        (Node''clearSuccessors-1 this)
        (Node''markDeleted-1 this)
        nil
    )

    (§ method #_"void" Node''markDeleted-1 [#_"Node" this]
        (§ ass! (:graph this) (Graph''unregister-2 (:graph this), this))
        (§ ass! this (assoc this :id (- Node'DELETED_ID_START (:id this))))
        nil
    )

    (§ method! #_"Node" Node''copyWithInputs-1 [#_"Node" this]
        (Node''copyWithInputs-2 this, true)
    )

    (§ method! #_"Node" Node''copyWithInputs-2 [#_"Node" this, #_"boolean" insertIntoGraph]
        (let [
            #_"Node" newNode (Node''clone-3 this, (when insertIntoGraph (:graph this)), Node'WithOnlyInputEdges)
        ]
            (when insertIntoGraph
                (doseq [#_"Node" input (Node''inputs-1 this)]
                    (Node''addUsage-2 input, newNode)
                )
            )
            newNode
        )
    )

    ;;;
     ; Must be overridden by subclasses that implement Simplifiable. The implementation in
     ; Node exists to obviate the need to cast a node before invoking
     ; Simplifiable#simplify(SimplifierTool).
     ;;
    (§ method #_"void" Node''simplify-2 [#_"Node" this, #_"SimplifierTool" tool]
        (throw! "unsupported operation")
    )

    ;;;
     ; @param newNode the result of cloning this node or {@link Unsafe#allocateInstance(Class) raw
     ;            allocating} a copy of this node
     ; @param type the type of edges to process
     ; @param edgesToCopy if {@code type} is in this set, the edges are copied otherwise they are cleared
     ;;
    (§ method- #_"void" Node''copyOrClearEdgesForClone-4 [#_"Node" this, #_"Node" newNode, #_"EdgesType" type, #_"EnumSet<EdgesType>" edgesToCopy]
        (if (#_"EnumSet" .contains edgesToCopy, type)
            (Edges''copy-3 (NodeClass''getEdges-2 (:nodeClass this), type), this, newNode)
            ;; the direct edges are already nil
            (Edges''initializeLists-3 (NodeClass''getEdges-2 (:nodeClass this), type), newNode, this)
        )
        nil
    )

    (§ def #_"EnumSet<EdgesType>" Node'WithNoEdges (EnumSet/noneOf EdgesType))
    (§ def #_"EnumSet<EdgesType>" Node'WithAllEdges (EnumSet/allOf EdgesType))
    (§ def #_"EnumSet<EdgesType>" Node'WithOnlyInputEdges (EnumSet/of EdgesType'Inputs))
    (§ def #_"EnumSet<EdgesType>" Node'WithOnlySucessorEdges (EnumSet/of EdgesType'Successors))

    ;;;
     ; Makes a copy of this node in(to) a given graph.
     ;
     ; @param into the graph in which the copy will be registered (which may be this node's graph)
     ;            or nil if the copy should not be registered in a graph
     ; @param edgesToCopy specifies the edges to be copied. The edges not specified in this set are initialized
     ;            to their default value (i.e. nil for a direct edge, an empty list for an edge list)
     ; @return the copy of this node
     ;;
    (§ method! #_"Node" Node''clone-3 [#_"Node" this, #_"Graph" into, #_"EnumSet<EdgesType>" edgesToCopy]
        (let [
            #_"Node" node (.allocateInstance HotSpot'unsafe, (#_"Object" .getClass this))
            node (assoc node :nodeClass (:nodeClass this))
            _ (Fields''copy-3 (:data (:nodeClass this)), this, node)
            _ (Node''copyOrClearEdgesForClone-4 this, node, EdgesType'Inputs, edgesToCopy)
            _ (Node''copyOrClearEdgesForClone-4 this, node, EdgesType'Successors, edgesToCopy)
            node (assoc node :graph into)
            node (assoc node :id Node'INITIAL_ID)
            _
                (when (some? into)
                    (§ ass! into (Graph''register-2 into, node))
                )
            node (assoc node :extraUsages Node'NO_NODES)
        ]
            (Node''afterClone-2 node, this)
            node
        )
    )

    (§ method #_"void" Node''afterClone-2 [#_"Node" this, #_"Node" other]
        nil
    )

    #_unused
    (§ method #_"Iterable<? extends Node>" Node''cfgPredecessors-1 [#_"Node" this]
        (if (some? (:predecessor this)) (Collections/singleton (:predecessor this)) (Collections/emptySet))
    )

    ;;;
     ; Returns an iterator that will provide all control-flow successors of this node. Normally this
     ; will be the contents of all fields annotated with Successor, but some node classes (like EndNode)
     ; may return different nodes.
     ;;
    (§ method #_"Iterable<? extends Node>" Node''cfgSuccessors-1 [#_"Node" this]
        (Node''successors-1 this)
    )

    ;;;
     ; Nodes using their #id as the hash code. This works very well when nodes of the same graph are
     ; stored in sets. It can give bad behavior when storing nodes of different graphs in the same set.
     ;;
    (§ override! #_"int" #_"Object" .hashCode [#_"Node" this]
        (if (Node''isDeleted-1 this) (- Node'DELETED_ID_START (:id this)) (:id this))
    )

    ;;;
     ; Do not overwrite the equality test of a node in subclasses.
     ; Equality tests must rely solely on identity.
     ;;

    ;;;
     ; Determines if this node's {@link NodeClass#getData() data} fields are equal to the
     ; data fields of another node of the same type. Primitive fields are compared by value
     ; and non-primitive fields are compared by Objects#equals(Object, Object).
     ;
     ; The result of this method undefined if {@code other.getClass() != this.getClass()}.
     ;
     ; @param other a node of exactly the same type as this node
     ; @return true if the data fields of this object and {@code other} are equal
     ;;
    (§ method! #_"boolean" Node''valueEquals-2 [#_"Node" this, #_"Node" other]
        (NodeClass''dataEquals-3 (:nodeClass this), this, other)
    )

    ;;;
     ; Determines if this node is equal to the other node while ignoring differences in
     ; {@linkplain Successor control-flow} edges.
     ;;
    (§ method! #_"boolean" Node''dataFlowEquals-2 [#_"Node" this, #_"Node" other]
        (or (= this other)
            (and (= (:nodeClass this) (:nodeClass other))
                 (Node''valueEquals-2 this, other)
                 (NodeClass''equalInputs-3 (:nodeClass this), this, other)
            )
        )
    )

    #_unused
    (§ method! #_"void" Node''pushInputs-2 [#_"Node" this, #_"NodeStack" stack]
        (NodeClass''pushInputs-3 (:nodeClass this), this, stack)
        nil
    )
)

;;;
 ; Denotes a non-optional (non-nil) node input. This should be applied to exactly the fields of
 ; a node that are of type Node or NodeInputList. Nodes that update fields of
 ; type Node outside of their constructor should call
 ; Node#updateUsages(Node, Node) just prior to doing the update of the input.
 ;
 ; @anno Node.Input
 ; @target ElementType.FIELD
 ;;
(§ annotation Input
    (§ value #_"InputType" value InputType'Value)
)

;;;
 ; Denotes an optional (nullable) node input. This should be applied to exactly the fields of a
 ; node that are of type Node or NodeInputList. Nodes that update fields of type
 ; Node outside of their constructor should call Node#updateUsages(Node, Node)
 ; just prior to doing the update of the input.
 ;
 ; @anno Node.OptionalInput
 ; @target ElementType.FIELD
 ;;
(§ annotation OptionalInput
    (§ value #_"InputType" value InputType'Value)
)

;;;
 ; @anno Node.Successor
 ; @target ElementType.FIELD
 ;;
(§ annotation Successor
)

;;;
 ; Denotes that a parameter of an intrinsic method must be a compile
 ; time constant at all call sites to the intrinsic method.
 ;
 ; @anno Node.ConstantNodeParameter
 ; @target ElementType.PARAMETER
 ;;
(§ annotation ConstantNodeParameter
)

;;;
 ; Denotes an injected parameter in a node intrinsic constructor.
 ; If the constructor is called as part of node intrinsification, the node intrinsifier will inject
 ; an argument for the annotated parameter. Injected parameters must precede all non-injected
 ; parameters in a constructor. If the type of the annotated parameter is Stamp, the
 ; {@linkplain Stamp#javaType type} of the injected stamp is the return type of the annotated
 ; method (which cannot be {@code void}).
 ;
 ; @anno Node.InjectedNodeParameter
 ; @target ElementType.PARAMETER
 ;;
(§ annotation InjectedNodeParameter
)

;;;
 ; Annotates a method that can be replaced by a compiler intrinsic. A (resolved) call to the
 ; annotated method will be processed by a generated InvocationPlugin that calls either
 ; a factory method or a constructor corresponding with the annotated method.
 ;
 ; A factory method corresponding to an annotated method is a static method named
 ; {@code intrinsify} defined in the class denoted by #value(). In order, its signature
 ; is as follows:
 ;
 ; (1) A BytecodeParser parameter.
 ; (2) A ResolvedJavaMethod parameter.
 ; (3) A sequence of zero or more injected parameters.
 ; (4) Remaining parameters that match the declared parameters of the annotated method.
 ;
 ; A constructor corresponding to an annotated method is defined in the class denoted by
 ; #value(). In order, its signature is as follows:
 ;
 ; (1) A sequence of zero or more injected parameters.
 ; (2) Remaining parameters that match the declared parameters of the annotated method.
 ;
 ; There must be exactly one such factory method or constructor corresponding to a
 ; NodeIntrinsic annotated method.
 ;
 ; @anno Node.NodeIntrinsic
 ; @target ElementType.METHOD
 ;;
(§ annotation NodeIntrinsic
    ;;;
     ; The class declaring the factory method or Node subclass declaring the constructor
     ; used to intrinsify a call to the annotated method. The default value is the class in
     ; which the annotated method is declared.
     ;;
    (§ value #_"Class" value NodeIntrinsic)

    ;;;
     ; If true, the factory method or constructor selected by the annotation must have
     ; an injected Stamp parameter. Calling
     ; AbstractPointerStamp#nonNull() on the injected stamp is guaranteed to return true.
     ;;
    (§ value #_"boolean" injectedStampIsNonNull false)
)

;;;
 ; Marker interface for nodes that contains other nodes. When the inputs to this node changes,
 ; users of this node should also be placed on the work list for canonicalization.
 ;
 ; @anno Node.IndirectCanonicalization
 ;;
(§ interface IndirectCanonicalization
)

;;;
 ; @anno Node.EdgeVisitor
 ;;
(class-ns EdgeVisitor
    (§ defn #_"EdgeVisitor" EdgeVisitor'new-0 []
        (Object.)
    )

    (§ abstract #_"Node" EdgeVisitor''apply-3 [#_"EdgeVisitor" this, #_"Node" source, #_"Node" target])
)

(final-ns NodeBitMap (§ implements NodeIterable #_"<Node>")
    (def- #_"int" NodeBitMap'SHIFT 6)

    (§ defn- #_"int" NodeBitMap'sizeForNodeCount-1 [#_"int" nodeCount]
        (>> (dec (+ nodeCount Long/SIZE)) NodeBitMap'SHIFT)
    )

    (§ final #_"Graph" :graph nil)
    (§ mutable #_"long[]" :bits nil)
    (§ mutable #_"int" :nodeCount 0)
    (§ mutable #_"int" :counter 0)

    (§ defn #_"NodeBitMap" NodeBitMap'new-1 [#_"Graph" graph]
        (let [
            #_"NodeBitMap" this (Object.)
            this (assoc this :graph graph)
            this (assoc this :nodeCount (:nodesSize graph))
            this (assoc this :bits (long-array (NodeBitMap'sizeForNodeCount-1 (:nodeCount this))))
        ]
            this
        )
    )

    (§ defn- #_"NodeBitMap" NodeBitMap'new-1 [#_"NodeBitMap" other]
        (let [
            #_"NodeBitMap" this (Object.)
            this (assoc this :graph (:graph other))
            this (assoc this :bits (#_"Object" .clone (:bits other)))
            this (assoc this :nodeCount (:nodeCount other))
        ]
            this
        )
    )

    (§ method! #_"NodeBitMap" NodeBitMap''copy-1 [#_"NodeBitMap" this]
        (NodeBitMap'new-1 this)
    )

    (§ method! #_"boolean" NodeBitMap''isNew-2 [#_"NodeBitMap" this, #_"Node" node]
        (<= (:nodeCount this) (:id node))
    )

    (§ method! #_"boolean" NodeBitMap''checkAndMarkInc-2 [#_"NodeBitMap" this, #_"Node" node]
        (and (not (NodeBitMap''isMarked-2 this, node))
            (do
                (§ ass! this (update this :counter inc))
                (NodeBitMap''mark-2 this, node)
                true
            )
        )
    )

    (§ method- #_"NodeBitMap" NodeBitMap''checkGrow-2 [#_"NodeBitMap" this, #_"int" id]
        (when (<= (:nodeCount this) id) => this
            (if (<= (count (:bits this)) (>> id NodeBitMap'SHIFT))
                (NodeBitMap''grow-1 this)
                (assoc this :nodeCount (inc id))
            )
        )
    )

    (§ method! #_"boolean" NodeBitMap''isMarked-2 [#_"NodeBitMap" this, #_"int" id]
        (not (zero? (& (nth (:bits this) (>> id NodeBitMap'SHIFT)) (<< 1 id))))
    )

    (§ method! #_"boolean" NodeBitMap''isMarked-2 [#_"NodeBitMap" this, #_"Node" node]
        (NodeBitMap''isMarked-2 this, (:id node))
    )

    (§ method! #_"boolean" NodeBitMap''isMarkedAndGrow-2 [#_"NodeBitMap" this, #_"Node" node]
        (§ ass! this (NodeBitMap''checkGrow-2 this, (:id node)))
        (NodeBitMap''isMarked-2 this, (:id node))
    )

    (§ method! #_"void" NodeBitMap''mark-2 [#_"NodeBitMap" this, #_"Node" node]
        (aswap (:bits this) (>> (:id node) NodeBitMap'SHIFT) | (<< 1 (:id node)))
        nil
    )

    (§ method! #_"NodeBitMap" NodeBitMap''markAndGrow-2 [#_"NodeBitMap" this, #_"Node" node]
        (let [
            this (NodeBitMap''checkGrow-2 this, (:id node))
        ]
            (NodeBitMap''mark-2 this, node)
            this
        )
    )

    (§ method! #_"void" NodeBitMap''clear-2 [#_"NodeBitMap" this, #_"Node" node]
        (aswap (:bits this) (>> (:id node) NodeBitMap'SHIFT) & (bit-not (<< 1 (:id node))))
        nil
    )

    (§ method! #_"NodeBitMap" NodeBitMap''clearAndGrow-2 [#_"NodeBitMap" this, #_"Node" node]
        (let [
            this (NodeBitMap''checkGrow-2 this, (:id node))
        ]
            (NodeBitMap''clear-2 this, node)
            this
        )
    )

    (§ method! #_"void" NodeBitMap''clearAll-1 [#_"NodeBitMap" this]
        (Arrays/fill (:bits this), 0)
        nil
    )

    #_unused
    (§ method! #_"void" NodeBitMap''intersect-2 [#_"NodeBitMap" this, #_"NodeBitMap" other]
        (let [
            #_"int" n (min (count (:bits this)) (count (:bits other)))
        ]
            (loop-when-recur [#_"int" i n] (< i (count (:bits this))) [(inc i)]
                (aset (:bits this) i 0)
            )
            (dotimes [#_"int" i n]
                (aswap (:bits this) i & (nth (:bits other) i))
            )
        )
        nil
    )

    #_unused
    (§ method! #_"void" NodeBitMap''subtract-2 [#_"NodeBitMap" this, #_"NodeBitMap" other]
        (let [
            #_"int" n (min (count (:bits this)) (count (:bits other)))
        ]
            (dotimes [#_"int" i n]
                (aswap (:bits this) i & (bit-not (nth (:bits other) i)))
            )
        )
        nil
    )

    #_unused
    (§ method! #_"NodeBitMap" NodeBitMap''union-2 [#_"NodeBitMap" this, #_"NodeBitMap" other]
        (let [
            this (NodeBitMap''grow-1 this)
            this
                (when (< (count (:bits this)) (count (:bits other))) => this
                    (assoc this :bits (Arrays/copyOf (:bits this), (count (:bits other))))
                )
        ]
            (dotimes [#_"int" i (min (count (:bits this)) (count (:bits other)))]
                (aswap (:bits this) i | (nth (:bits other) i))
            )
            this
        )
    )

    (§ method! #_"void" NodeBitMap''invert-1 [#_"NodeBitMap" this]
        (dotimes [#_"int" i (count (:bits this))]
            (aswap (:bits this) i bit-not)
        )
        nil
    )

    (§ method! #_"NodeBitMap" NodeBitMap''grow-1 [#_"NodeBitMap" this]
        (let [
            this (assoc this :nodeCount (max (:nodeCount this) (:nodesSize (:graph this))))
            #_"int" n (NodeBitMap'sizeForNodeCount-1 (:nodeCount this))
        ]
            (when (< (count (:bits this)) n) => this
                (assoc this :bits (Arrays/copyOf (:bits this), (max n (inc (quot (* (count (:bits this)) 3) 2)))))
            )
        )
    )

    (§ method! #_"<T extends Node> void" NodeBitMap''markAll-2 [#_"NodeBitMap" this, #_"Iterable<T>" nodes]
        (doseq [#_"Node" node nodes]
            (NodeBitMap''mark-2 this, node)
        )
        nil
    )

    (§ method! #_"Node" NodeBitMap''nextMarkedNode-2 [#_"NodeBitMap" this, #_"int" fromNodeId]
        (let [
            #_"int" i (>> fromNodeId NodeBitMap'SHIFT)
            #_"int" n (count (:bits this))
        ]
            (when (< i n)
                (loop [i i #_"long" word (NodeBitMap'getPartOfWord-2 (nth (:bits this) i), fromNodeId)]
                    (or
                        (loop-when word (not (zero? word))
                            (let [
                                #_"int" bitIndex (Long/numberOfTrailingZeros word)
                                #_"int" nodeId (+ (* i Long/SIZE) bitIndex)
                            ]
                                (or (nth (:nodes (:graph this)) nodeId)
                                    (do
                                        ;; node was deleted -> clear the bit and continue searching
                                        (aswap (:bits this) i & (bit-not (<< 1 bitIndex)))
                                        (let [
                                            nodeId (inc nodeId)
                                        ]
                                            (when-not (zero? (& nodeId (dec Long/SIZE))) ;; => we reached the end of this word
                                                (recur (NodeBitMap'getPartOfWord-2 word, nodeId))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (let [
                            i (inc i)
                        ]
                            (when (< i n)
                                (recur i (nth (:bits this) i))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"long" NodeBitMap'getPartOfWord-2 [#_"long" word, #_"int" firstNodeIdToInclude]
        (& word (<< 0xffffffffffffffff firstNodeIdToInclude))
    )

    (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"NodeBitMap" this]
        (MarkedNodeIterator'new-1 this)
    )

    (§ override! #_"int" NodeBitMap''count-1 [#_"NodeBitMap" this]
        (loop-when-recur [#_"int" n 0 #_"ISeq" s (seq (:bits this))] (some? s) [(+ n (Long/bitCount (first s))) (next s)] => n)
    )

    (§ override! #_"boolean" NodeBitMap''contains-2 [#_"NodeBitMap" this, #_"Node" node]
        (NodeBitMap''isMarked-2 this, node)
    )
)

;;;
 ; This iterator only returns nodes that are marked in the NodeBitMap and are alive
 ; in the corresponding Graph.
 ;
 ; @anno NodeBitMap.MarkedNodeIterator
 ;;
(final-ns MarkedNodeIterator (§ implements Iterator #_"<Node>")
    (§ final #_"NodeBitMap" :bitMap nil)

    (§ mutable #_"int" :currentNodeId 0)
    (§ mutable #_"Node" :currentNode nil)

    (§ defn #_"MarkedNodeIterator" MarkedNodeIterator'new-1 [#_"NodeBitMap" bitMap]
        (let [
            #_"MarkedNodeIterator" this (Object.)
            this (assoc this :bitMap bitMap)
            this (assoc this :currentNodeId -1)
        ]
            (§ ass! this (MarkedNodeIterator''forward-1 this))
            this
        )
    )

    (§ method- #_"MarkedNodeIterator" MarkedNodeIterator''forward-1 [#_"MarkedNodeIterator" this]
        (let [
            this (assoc this :currentNode (NodeBitMap''nextMarkedNode-2 (:bitMap this), (inc (:currentNodeId this))))
        ]
            (assoc this :currentNodeId (if (some? (:currentNode this)) (:id (:currentNode this)) -1))
        )
    )

    (§ override! #_"boolean" MarkedNodeIterator''hasNext-1 [#_"MarkedNodeIterator" this]
        (when (and (nil? (:currentNode this)) (<= 0 (:currentNodeId this)))
            (§ ass! this (MarkedNodeIterator''forward-1 this))
        )
        (<= 0 (:currentNodeId this))
    )

    #_unused
    (§ override! #_"Node" MarkedNodeIterator''next-1 [#_"MarkedNodeIterator" this]
        (when-not (MarkedNodeIterator''hasNext-1 this)
            (throw (NoSuchElementException.))
        )
        (when-not (Node''isAlive-1 (:currentNode this))
            (throw (ConcurrentModificationException. "NodeBitMap was modified between the calls to hasNext() and next()"))
        )

        (let [
            #_"Node" result (:currentNode this)
        ]
            (§ ass! this (assoc this :currentNode nil))
            result
        )
    )
)

;;;
 ; Metadata for every Node type. The metadata includes:
 ;
 ; (1) The offsets of fields annotated with Input and Successor as well as methods for iterating over such fields.
 ; (2) The identifier for an IterableNodeType class.
 ;;
(final-ns NodeClass #_"<T>" (§ extends FieldIntrospection #_"<T>")
    (def #_"long" NodeClass'MAX_EDGES 8)
    (def #_"long" NodeClass'MAX_LIST_EDGES 6)
    (def #_"long" NodeClass'OFFSET_MASK 0xfc)
    (def #_"long" NodeClass'LIST_MASK 0x01)
    (def #_"long" NodeClass'NEXT_EDGE 0x08)

    (§ defn- #_"<T> NodeClass<T>" NodeClass'get-1 [#_"Class<T>" clazz]
        (let [
            #_"Field" field (#_"Class" .getDeclaredField clazz, "TYPE")
            _ (#_"Field" .setAccessible field, true)
            #_"NodeClass<T>" result (#_"Field" .get field, nil)
        ]
            (when (or (some? result) (= clazz Node)) => (throw! (str "TYPE field not initialized for class " (#_"Class" .getTypeName clazz)))
                result
            )
        )
    )

    ;;;
     ; Gets the NodeClass associated with a given Class.
     ;;
    (§ defn #_"<T> NodeClass<T>" NodeClass'create-1 [#_"Class<T>" c]
        (let [
            #_"Class<? super T>" superclass (#_"Class" .getSuperclass c)
        ]
            (NodeClass'new-2 c, (when-not (= superclass Node) (NodeClass'get-1 superclass)))
        )
    )

    (§ def- #_"AtomicInteger" NodeClass'nextIterableId (AtomicInteger.))

    (§ final #_"InputEdges" :inputs nil)
    (§ final #_"SuccessorEdges" :successors nil)
    (§ final #_"NodeClass<? super T>" :superNodeClass nil)

    (§ final #_"int" :iterableId 0)
    (§ final #_"EnumSet<InputType>" :allowedUsageTypes nil)
    (§ mutable #_"int[]" :iterableIds nil)
    (§ final #_"long" :inputsIteration 0)
    (§ final #_"long" :successorIteration 0)

    (§ final #_"boolean" :canonicalizable? false)
    (§ final #_"boolean" :commutative? false)
    (§ final #_"boolean" :simplifiable? false)

    ;;;
     ; Determines if the node has no inputs, nor successors.
     ;;
    (§ final #_"boolean" :isLeafNode false)

    (§ defn #_"NodeClass" NodeClass'new-2 [#_"Class<T>" clazz, #_"NodeClass<? super T>" superNodeClass]
        (let [
            #_"NodeClass" this (FieldIntrospection'new-1 clazz)
            this (assoc this :superNodeClass superNodeClass)
            this (assoc this :canonicalizable? (#_"Class" .isAssignableFrom Canonicalizable, clazz))
            this (assoc this :commutative? (#_"Class" .isAssignableFrom BinaryCommutative, clazz))
            this (assoc this :simplifiable? (#_"Class" .isAssignableFrom Simplifiable, clazz))
            #_"NodeFieldsScanner" fs (NodeFieldsScanner'new-1 superNodeClass)
            _ (FieldsScanner''scan-4 fs, clazz, (#_"Class" .getSuperclass clazz), false)
            this (assoc this :successors (SuccessorEdges'new-2 (:directSuccessors fs), (:successors fs)))
            this (assoc this :successorIteration (NodeClass'computeIterationMask-3 (Fields''type-1 (:successors this)), (:directCount (:successors this)), (:offsets (:successors this))))
            this (assoc this :inputs (InputEdges'new-2 (:directInputs fs), (:inputs fs)))
            this (assoc this :inputsIteration (NodeClass'computeIterationMask-3 (Fields''type-1 (:inputs this)), (:directCount (:inputs this)), (:offsets (:inputs this))))
            this (assoc this :data (Fields'new-1 (:data fs)))
            this (assoc this :isLeafNode (zero? (+ (count (:offsets (:inputs this))) (count (:offsets (:successors this))))))
            this (assoc this :allowedUsageTypes (if (nil? superNodeClass) (EnumSet/noneOf InputType) (#_"Object" .clone (:allowedUsageTypes superNodeClass))))
        ]
            (if (#_"Class" .isAssignableFrom IterableNodeType, clazz)
                (do
                    (§ ass this (assoc this :iterableId (#_"AtomicInteger" .getAndIncrement NodeClass'nextIterableId)))

                    (loop-when-recur [#_"NodeClass" snc superNodeClass] (and (some? snc) (#_"Class" .isAssignableFrom IterableNodeType, (:class snc))) [(:superNodeClass snc)]
                        (§ ass! snc (NodeClass''addIterableId-2 snc, (:iterableId this)))
                    )

                    (§ ass this (assoc this :iterableIds (int-array [ (:iterableId this) ])))
                )
                (do
                    (§ ass this (assoc this :iterableId Node'NOT_ITERABLE))
                    (§ ass this (assoc this :iterableIds nil))
                )
            )
            this
        )
    )

    (§ defn #_"long" NodeClass'computeIterationMask-3 [#_"EdgesType" type, #_"int" directCount, #_"long[]" offsets]
        (when (< NodeClass'MAX_EDGES (count offsets))
            (throw! (str "Exceeded maximum of " NodeClass'MAX_EDGES " edges (" type ")"))
        )
        (when (< NodeClass'MAX_LIST_EDGES (- (count offsets) directCount))
            (throw! (str "Exceeded maximum of " NodeClass'MAX_LIST_EDGES " list edges (" type ")"))
        )

        (loop-when [#_"long" mask 0 #_"int" i (dec (count offsets))] (<= 0 i) => mask
            (let [
                mask (| (<< mask NodeClass'NEXT_EDGE) (nth offsets i))
                mask (if (<= directCount i) (| mask 0x3) mask)
            ]
                (recur mask (dec i))
            )
        )
    )

    (§ method- #_"NodeClass<T>" NodeClass''addIterableId-2 [#_"NodeClass<T>" this, #_"int" newIterableId]
        (locking this
            (let [
                #_"int[]" copy (Arrays/copyOf (:iterableIds this), (inc (count (:iterableIds this))))
            ]
                (aset copy (count (:iterableIds this)) newIterableId)
                (assoc this :iterableIds copy)
            )
        )
    )

    #_unused
    (§ defn- #_"boolean" NodeClass'containsId-2 [#_"int" iterableId, #_"int[]" iterableIds]
        (loop [#_"ISeq" s (seq iterableIds)] (and (some? s) (or (= (first s) iterableId) (recur (next s)))))
    )

    (§ mutable #_"String" :shortName nil)

    #_unused
    (§ method! #_"String" NodeClass''shortName-1 [#_"NodeClass<T>" this]
        (when (nil? (:shortName this))
            (let [
                #_"String" localShortName (#_"Class" .getSimpleName (:class this))
            ]
                (if (and (#_"String" .endsWith localShortName, "Node") (not (= localShortName "StartNode")) (not (= localShortName "EndNode")))
                    (§ ass! this (assoc this :shortName (#_"String" .substring localShortName, 0, (- (count localShortName) 4))))
                    (§ ass! this (assoc this :shortName localShortName))
                )
            )
        )
        (:shortName this)
    )

    #_unused
    (§ override! #_"Fields[]" NodeClass''getAllFields-1 [#_"NodeClass<T>" this]
        (into-array Fields [ (:data this), (:inputs this), (:successors this) ])
    )

    #_unused
    (§ defn #_"int" NodeClass'allocatedNodeIterabledIds-0 []
        (#_"AtomicInteger" .get NodeClass'nextIterableId)
    )

    (§ defn- #_"boolean" NodeClass'deepEquals0-2 [#_"Object" e1, #_"Object" e2]
        (or (= e1 e2)
            (and (some? e1) (some? e2)
                (when (and (#_"Class" .isArray (#_"Object" .getClass e1)) (= (#_"Object" .getClass e1) (#_"Object" .getClass e2))) => (= e1 e2)
                    (if (and (instance? Object*'class e1) (instance? Object*'class e2))
                        (NodeClass'deepEquals-2 (§ cast #_"Object[]" e1), (§ cast #_"Object[]" e2))
                        (condp instance? e1
                            int*'class     (Arrays/equals (§ cast #_"int[]" e1), (§ cast #_"int[]" e2))
                            long*'class    (Arrays/equals (§ cast #_"long[]" e1), (§ cast #_"long[]" e2))
                            byte*'class    (Arrays/equals (§ cast #_"byte[]" e1), (§ cast #_"byte[]" e2))
                            char*'class    (Arrays/equals (§ cast #_"char[]" e1), (§ cast #_"char[]" e2))
                            short*'class   (Arrays/equals (§ cast #_"short[]" e1), (§ cast #_"short[]" e2))
                            float*'class   (Arrays/equals (§ cast #_"float[]" e1), (§ cast #_"float[]" e2))
                            double*'class  (Arrays/equals (§ cast #_"double[]" e1), (§ cast #_"double[]" e2))
                            boolean*'class (Arrays/equals (§ cast #_"boolean[]" e1), (§ cast #_"boolean[]" e2))
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"boolean" NodeClass'deepEquals-2 [#_"Object[]" a1, #_"Object[]" a2]
        (let [
            #_"int" n (count a1)
        ]
            (and (= (count a2) n)
                (loop-when [#_"int" i 0] (< i n) => true
                    (and (NodeClass'deepEquals0-2 (nth a1 i), (nth a2 i))
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (§ method! #_"boolean" NodeClass''dataEquals-3 [#_"NodeClass<T>" this, #_"Node" a, #_"Node" b]
        (loop-when [#_"int" i 0] (< i (count (:offsets (:data this)))) => true
            (let [
                #_"Class" type (Fields''getType-2 (:data this), i)
            ]
                (and
                    (if (#_"Class" .isPrimitive type)
                        (condp = type
                            int'class     (= (Fields''getInt-3     (:data this), a, i) (Fields''getInt-3     (:data this), b, i))
                            boolean'class (= (Fields''getBoolean-3 (:data this), a, i) (Fields''getBoolean-3 (:data this), b, i))
                            long'class    (= (Fields''getLong-3    (:data this), a, i) (Fields''getLong-3    (:data this), b, i))
                            short'class   (= (Fields''getShort-3   (:data this), a, i) (Fields''getShort-3   (:data this), b, i))
                            char'class    (= (Fields''getChar-3    (:data this), a, i) (Fields''getChar-3    (:data this), b, i))
                            byte'class    (= (Fields''getByte-3    (:data this), a, i) (Fields''getByte-3    (:data this), b, i))
                        )
                        (let [
                            #_"Object" objectA (Fields''getObject-3 (:data this), a, i)
                            #_"Object" objectB (Fields''getObject-3 (:data this), b, i)
                        ]
                            (or (= objectA objectB) (and (some? objectA) (some? objectB) (NodeClass'deepEquals0-2 objectA, objectB)))
                        )
                    )
                    (recur (inc i))
                )
            )
        )
    )

    (§ method! #_"boolean" NodeClass''isValid-4 [#_"NodeClass<T>" this, #_"Position" pos, #_"NodeClass" from, #_"Edges" fromEdges]
        (or (= this from)
            (let [
                #_"Edges" toEdges (NodeClass''getEdges-2 this, (:type fromEdges))
            ]
                (and (< (:index pos) (count (:offsets toEdges)))
                     (< (:index pos) (count (:offsets fromEdges)))
                     (Fields''isSame-3 toEdges, fromEdges, (:index pos))
                )
            )
        )
    )

    (§ defn #_"void" NodeClass'updateEdgesInPlace-3 [#_"Node" node, #_"InplaceUpdateClosure" duplicationReplacement, #_"Edges" edges]
        (let [
            #_"EdgesType" type (:type edges)
            #_"long[]" offsets (:offsets edges)
            #_"int" i
                (loop-when-recur [i 0] (< i (:directCount edges)) [(inc i)] => i
                    (let [
                        #_"Node" edge (Edges'getNode-3 node, offsets, i)
                    ]
                        (when (some? edge)
                            (let [
                                #_"Node" newEdge (InplaceUpdateClosure''replacement-3 duplicationReplacement, edge, type)
                            ]
                                (if (= type EdgesType'Inputs)
                                    (Node''updateUsages-3 node, nil, newEdge)
                                    (Node''updatePredecessor-3 node, nil, newEdge)
                                )
                                (Edges''initializeNode-4 edges, node, i, newEdge)
                            )
                        )
                    )
                )
        ]
            (loop-when-recur i (< i (count (:offsets edges))) (inc i)
                (let [
                    #_"NodeList<Node>" list (Edges'getNodeList-3 node, offsets, i)
                ]
                    (when (some? list)
                        (Edges''initializeList-4 edges, node, i, (NodeClass'updateEdgeListCopy-4 node, list, duplicationReplacement, type))
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" NodeClass''updateInputSuccInPlace-3 [#_"NodeClass<T>" this, #_"Node" node, #_"InplaceUpdateClosure" duplicationReplacement]
        (NodeClass'updateEdgesInPlace-3 node, duplicationReplacement, (:inputs this))
        (NodeClass'updateEdgesInPlace-3 node, duplicationReplacement, (:successors this))
        nil
    )

    (§ defn- #_"NodeList<Node>" NodeClass'updateEdgeListCopy-4 [#_"Node" node, #_"NodeList<Node>" list, #_"InplaceUpdateClosure" duplicationReplacement, #_"EdgesType" type]
        (let [
            #_"NodeList<Node>" result (if (= type EdgesType'Inputs) (NodeInputList'new-2 node, (count list)) (NodeSuccessorList'new-2 node, (count list)))
        ]
            (dotimes [#_"int" i (count list)]
                (let [
                    #_"Node" oldNode (nth list i)
                ]
                    (when (some? oldNode)
                        (NodeList''set-3 result, i, (InplaceUpdateClosure''replacement-3 duplicationReplacement, oldNode, type))
                    )
                )
            )
            result
        )
    )

    ;;;
     ; Gets the input or successor edges defined by this node class.
     ;;
    (§ method! #_"Edges" NodeClass''getEdges-2 [#_"NodeClass<T>" this, #_"EdgesType" type]
        (if (= type EdgesType'Inputs) (:inputs this) (:successors this))
    )

    (§ defn #_"EconomicMap<Node, Node>" NodeClass'addGraphDuplicate-5 [#_"Graph" graph, #_"Graph" oldGraph, #_"int" estimatedNodeCount, #_"Iterable<? extends Node>" nodes, #_"DuplicationReplacement" replacements]
        (let [
            #_"int" denseThreshold (+ (Graph''getNodeCount-1 oldGraph) (>> (:nodesDeleted oldGraph) 4))
            #_"EconomicMap<Node, Node>" newNodes
                (if (< denseThreshold estimatedNodeCount)
                    (NodeMap'new-1 oldGraph)                    ;; use dense map
                    (EconomicMap/create Equivalence/IDENTITY) ;; use sparse map
                )
        ]
            (NodeClass'createNodeDuplicates-4 graph, nodes, replacements, newNodes)

            (let [
                #_"InplaceUpdateClosure" replacementClosure
                    (§ reify #_"InplaceUpdateClosure" (InplaceUpdateClosure'reify-0)
                        (§ override! #_"Node" InplaceUpdateClosure''replacement-3 [#_"InplaceUpdateClosure" this, #_"Node" node, #_"EdgesType" type]
                            (or (get newNodes node)
                                (let [
                                    #_"Node" replacement (if (some? replacements) (DuplicationReplacement''replacement-2 replacements, node) node)
                                ]
                                    (cond
                                        (not= replacement node)                                 replacement
                                        (and (= (:graph node) graph) (= type EdgesType'Inputs)) node ;; patch to the outer world
                                    )
                                )
                            )
                        )
                    )
            ]
                ;; re-wire inputs
                (doseq [#_"Node" oldNode nodes]
                    (let [
                        #_"Node" node (get newNodes oldNode)
                        #_"NodeClass" nodeClass (:nodeClass node)
                    ]
                        (if (or (nil? replacements) (= (DuplicationReplacement''replacement-2 replacements, oldNode) oldNode))
                            (NodeClass''updateInputSuccInPlace-3 nodeClass, node, replacementClosure)
                            (NodeClass'transferEdgesDifferentNodeClass-5 graph, replacements, newNodes, oldNode, node)
                        )
                    )
                )

                newNodes
            )
        )
    )

    (§ defn- #_"void" NodeClass'createNodeDuplicates-4 [#_"Graph" graph, #_"Iterable<? extends Node>" nodes, #_"DuplicationReplacement" replacements, #_"EconomicMap<Node, Node>" newNodes]
        (doseq [#_"Node" node nodes]
            (when (some? node)
                (let [
                    #_"Node" replacement (if (some? replacements) (DuplicationReplacement''replacement-2 replacements, node) node)
                ]
                    (#_"EconomicMap" .put newNodes, node, (if (not= replacement node) replacement (Node''clone-3 node, graph, Node'WithAllEdges)))
                )
            )
        )
        nil
    )

    (§ defn- #_"void" NodeClass'transferEdgesDifferentNodeClass-5 [#_"Graph" graph, #_"DuplicationReplacement" replacements, #_"EconomicMap<Node, Node>" newNodes, #_"Node" oldNode, #_"Node" node]
        (NodeClass'transferEdges-6 graph, replacements, newNodes, oldNode, node, EdgesType'Inputs)
        (NodeClass'transferEdges-6 graph, replacements, newNodes, oldNode, node, EdgesType'Successors)
        nil
    )

    (§ defn- #_"void" NodeClass'transferEdges-6 [#_"Graph" graph, #_"DuplicationReplacement" replacements, #_"EconomicMap<Node, Node>" newNodes, #_"Node" oldNode, #_"Node" node, #_"EdgesType" type]
        (let [
            #_"NodeClass" nodeClass (:nodeClass node)
            #_"NodeClass" oldNodeClass (:nodeClass oldNode)
            #_"Edges" oldEdges (NodeClass''getEdges-2 oldNodeClass, type)
        ]
            (doseq [#_"Position" pos (Edges''getPositionsIterable-2 oldEdges, oldNode)]
                (when (NodeClass''isValid-4 nodeClass, pos, oldNodeClass, oldEdges)
                    (let [
                        #_"Node" oldEdge (Position''get-2 pos, oldNode)
                    ]
                        (when (some? oldEdge)
                            (let [
                                #_"Node" target
                                    (or (get newNodes oldEdge)
                                        (let [
                                            #_"Node" replacement (if (some? replacements) (DuplicationReplacement''replacement-2 replacements, oldEdge) oldEdge)
                                        ]
                                            (cond
                                                (not= replacement oldEdge)                                 replacement
                                                (and (= (:graph oldEdge) graph) (= type EdgesType'Inputs)) oldEdge ;; patch to the outer world
                                            )
                                        )
                                    )
                            ]
                                (Position''set-3 pos, node, target)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"NodeIterable<Node>" NodeClass''getSuccessorIterable-2 [#_"NodeClass<T>" this, #_"Node" node]
        (let [
            #_"long" mask (:successorIteration this)
        ]
            (§ reify #_"NodeIterable<Node>" (NodeIterable'reify-0)
                (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"NodeIterable<Node>" this]
                    (RawEdgesIterator'new-2 node, mask)
                )
            )
        )
    )

    (§ method! #_"NodeIterable<Node>" NodeClass''getInputIterable-2 [#_"NodeClass<T>" this, #_"Node" node]
        (let [
            #_"long" mask (:inputsIteration this)
        ]
            (§ reify #_"NodeIterable<Node>" (NodeIterable'reify-0)
                (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"NodeIterable<Node>" this]
                    (RawEdgesIterator'new-2 node, mask)
                )
            )
        )
    )

    #_unused
    (§ method! #_"boolean" NodeClass''equalSuccessors-3 [#_"NodeClass<T>" this, #_"Node" node, #_"Node" other]
        (NodeClass''equalEdges-4 this, node, other, (:successorIteration this))
    )

    (§ method! #_"boolean" NodeClass''equalInputs-3 [#_"NodeClass<T>" this, #_"Node" node, #_"Node" other]
        (NodeClass''equalEdges-4 this, node, other, (:inputsIteration this))
    )

    (§ method- #_"boolean" NodeClass''equalEdges-4 [#_"NodeClass<T>" this, #_"Node" node, #_"Node" other, #_"long" mask]
        (loop [mask mask]
            (or (zero? mask)
                (let [
                    #_"long" offset (& mask NodeClass'OFFSET_MASK)
                ]
                    (if (zero? (& mask NodeClass'LIST_MASK))
                        (let [
                            #_"Object" v1 (Edges'getNodeUnsafe-2 node, offset)
                            #_"Object" v2 (Edges'getNodeUnsafe-2 other, offset)
                        ]
                            (and (= v1 v2) (recur (>>> mask NodeClass'NEXT_EDGE)))
                        )
                        (let [
                            #_"Object" v1 (Edges'getNodeListUnsafe-2 node, offset)
                            #_"Object" v2 (Edges'getNodeListUnsafe-2 other, offset)
                        ]
                            (and (= v1 v2) (recur (>>> mask NodeClass'NEXT_EDGE)))
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"void" NodeClass''pushInputs-3 [#_"NodeClass<T>" this, #_"Node" node, #_"NodeStack" stack]
        (loop-when-recur [#_"long" mask (:inputsIteration this)] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (§ ass! stack (NodeStack''push-2 stack, n))
                        )
                    )
                    (let [
                        #_"NodeList<Node>" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (§ ass! stack (NodeStack''push-2 stack, n))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" NodeClass''applySuccessors-3 [#_"NodeClass<T>" this, #_"Node" node, #_"EdgeVisitor" consumer]
        (NodeClass'applyEdges-3 node, consumer, (:successorIteration this))
        nil
    )

    (§ method! #_"void" NodeClass''applyInputs-3 [#_"NodeClass<T>" this, #_"Node" node, #_"EdgeVisitor" consumer]
        (NodeClass'applyEdges-3 node, consumer, (:inputsIteration this))
        nil
    )

    (§ defn- #_"void" NodeClass'applyEdges-3 [#_"Node" node, #_"EdgeVisitor" consumer, #_"long" mask]
        (loop-when-recur [mask mask] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (let [
                                #_"Node" newNode (EdgeVisitor''apply-3 consumer, node, n)
                            ]
                                (when-not (= newNode n)
                                    (Edges'putNodeUnsafe-3 node, offset, newNode)
                                )
                            )
                        )
                    )
                    (let [
                        #_"NodeList<Node>" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (let [
                                            #_"Node" newNode (EdgeVisitor''apply-3 consumer, node, n)
                                        ]
                                            (when-not (= newNode n)
                                                (NodeList''initialize-3 list, i, newNode)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" NodeClass''unregisterAtSuccessorsAsPredecessor-2 [#_"NodeClass<T>" this, #_"Node" node]
        (loop-when-recur [#_"long" mask (:successorIteration this)] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (Node''updatePredecessor-3 node, n, nil)
                            (Edges'putNodeUnsafe-3 node, offset, nil)
                        )
                    )
                    (let [
                        #_"NodeList<Node>" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (Node''updatePredecessor-3 node, n, nil)
                                    )
                                )
                            )
                            (§ ass! list (NodeList''clearWithoutUpdate-1 list))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" NodeClass''registerAtSuccessorsAsPredecessor-2 [#_"NodeClass<T>" this, #_"Node" node]
        (loop-when-recur [#_"long" mask (:successorIteration this)] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (Node''updatePredecessor-3 node, nil, n)
                        )
                    )
                    (let [
                        #_"NodeList<Node>" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (Node''updatePredecessor-3 node, nil, n)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"boolean" NodeClass''replaceFirstInput-4 [#_"NodeClass<T>" this, #_"Node" node, #_"Node" key, #_"Node" replacement]
        (NodeClass'replaceFirstEdge-4 node, key, replacement, (:inputsIteration this))
    )

    (§ method! #_"boolean" NodeClass''replaceFirstSuccessor-4 [#_"NodeClass<T>" this, #_"Node" node, #_"Node" key, #_"Node" replacement]
        (NodeClass'replaceFirstEdge-4 node, key, replacement, (:successorIteration this))
    )

    (§ defn #_"boolean" NodeClass'replaceFirstEdge-4 [#_"Node" node, #_"Node" key, #_"Node" replacement, #_"long" mask]
        (loop [mask mask]
            (and (not (zero? mask))
                (or
                    (if (zero? (& mask NodeClass'LIST_MASK))
                        (let [
                            #_"long" offset (& mask NodeClass'OFFSET_MASK)
                        ]
                            (when (= (Edges'getNodeUnsafe-2 node, offset) key)
                                (Edges'putNodeUnsafe-3 node, offset, replacement)
                                true
                            )
                        )
                        (let [
                            #_"NodeList<Node>" list (Edges'getNodeListUnsafe-2 node, (& mask NodeClass'OFFSET_MASK))
                        ]
                            (when (and (some? list) (NodeList''replaceFirst-3 list, key, replacement))
                                true
                            )
                        )
                    )
                    (recur (>>> mask NodeClass'NEXT_EDGE))
                )
            )
        )
    )

    (§ method! #_"void" NodeClass''registerAtInputsAsUsage-2 [#_"NodeClass<T>" this, #_"Node" node]
        (loop-when-recur [#_"long" mask (:inputsIteration this)] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (Node''addUsage-2 n, node)
                        )
                    )
                    (let [
                        #_"NodeList<Node>" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (Node''addUsage-2 n, node)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" NodeClass''unregisterAtInputsAsUsage-2 [#_"NodeClass<T>" this, #_"Node" node]
        (loop-when-recur [#_"long" mask (:inputsIteration this)] (not (zero? mask)) [(>>> mask NodeClass'NEXT_EDGE)]
            (let [
                #_"long" offset (& mask NodeClass'OFFSET_MASK)
            ]
                (if (zero? (& mask NodeClass'LIST_MASK))
                    (let [
                        #_"Node" n (Edges'getNodeUnsafe-2 node, offset)
                    ]
                        (when (some? n)
                            (Node''removeThisFromUsages-2 node, n)
                            (when (Node''hasNoUsages-1 n)
                                (Node''maybeNotifyZeroUsages-2 node, n)
                            )
                            (Edges'putNodeUnsafe-3 node, offset, nil)
                        )
                    )
                    (let [
                        #_"NodeList<Node>" list (Edges'getNodeListUnsafe-2 node, offset)
                    ]
                        (when (some? list)
                            (dotimes [#_"int" i (count list)]
                                (let [
                                    #_"Node" n (nth list i)
                                ]
                                    (when (some? n)
                                        (Node''removeThisFromUsages-2 node, n)
                                        (when (Node''hasNoUsages-1 n)
                                            (Node''maybeNotifyZeroUsages-2 node, n)
                                        )
                                    )
                                )
                            )
                            (§ ass! list (NodeList''clearWithoutUpdate-1 list))
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; Describes a field representing an input or successor edge in a node.
 ;
 ; @anno NodeClass.EdgeInfo
 ;;
(class-ns EdgeInfo (§ extends FieldInfo)
    (§ defn #_"EdgeInfo" EdgeInfo'new-4 [#_"long" offset, #_"String" name, #_"Class" type, #_"Class" declaringClass]
        (FieldInfo'new-4 offset, name, type, declaringClass)
    )

    ;;;
     ; Sorts non-list edges before list edges.
     ;;
    #_unused
    (§ override #_"int" EdgeInfo''compareTo-2 [#_"EdgeInfo" this, #_"FieldInfo" o]
        (if (#_"Class" .isAssignableFrom NodeList, (:type o))
            (when-not (#_"Class" .isAssignableFrom NodeList, (:type this))
                (§ return -1)
            )
            (when (#_"Class" .isAssignableFrom NodeList, (:type this))
                (§ return 1)
            )
        )
        (FieldInfo''compareTo-2 (§ super ), o)
    )
)

;;;
 ; Describes a field representing an {@linkplain EdgesType#Inputs input} edge in a node.
 ;
 ; @anno NodeClass.InputInfo
 ;;
(final-ns InputInfo (§ extends EdgeInfo)
    (§ final #_"InputType" :inputType nil)
    (§ final #_"boolean" :optional false)

    (§ defn #_"InputInfo" InputInfo'new-6 [#_"long" offset, #_"String" name, #_"Class" type, #_"Class" declaringClass, #_"InputType" inputType, #_"boolean" optional]
        (let [
            #_"InputInfo" this (EdgeInfo'new-4 offset, name, type, declaringClass)
            this (assoc this :inputType inputType)
            this (assoc this :optional optional)
        ]
            this
        )
    )
)

;;;
 ; @anno NodeClass.NodeFieldsScanner
 ;;
(final-ns NodeFieldsScanner (§ extends FieldsScanner)
    (§ final #_"ArrayList<InputInfo>" :inputs (ArrayList.))
    (§ final #_"ArrayList<EdgeInfo>" :successors (ArrayList.))
    (§ mutable #_"int" :directInputs 0)
    (§ mutable #_"int" :directSuccessors 0)

    (§ defn #_"NodeFieldsScanner" NodeFieldsScanner'new-1 [#_"NodeClass" superNodeClass]
        (let [
            #_"NodeFieldsScanner" this (FieldsScanner'new-0)
        ]
            (when (some? superNodeClass)
                (InputEdges'translateInto-2 (:inputs superNodeClass), (:inputs this))
                (Edges'translateInto-2 (:successors superNodeClass), (:successors this))
                (Fields'translateInto-2 (:data superNodeClass), (:data this))
                (§ ass this (assoc this :directInputs (:directCount (:inputs superNodeClass))))
                (§ ass this (assoc this :directSuccessors (:directCount (:successors superNodeClass))))
            )
            this
        )
    )

    #_unused
    (§ override! #_"void" NodeFieldsScanner''scanField-3 [#_"NodeFieldsScanner" this, #_"Field" field, #_"long" offset]
        (let [
            #_"Input" inputAnnotation (#_"AnnotatedElement" .getAnnotation field, Input)
            #_"OptionalInput" optionalInputAnnotation (#_"AnnotatedElement" .getAnnotation field, OptionalInput)
            #_"Successor" successorAnnotation (#_"AnnotatedElement" .getAnnotation field, Successor)
            #_"Class" type (#_"Field" .getType field)
            #_"int" modifiers (#_"Field" .getModifiers field)
        ]
            (cond
                (or (some? inputAnnotation) (some? optionalInputAnnotation))
                (do
                    (if (#_"Class" .isAssignableFrom NodeInputList, type)
                        (do
                            ;; NodeInputList fields should not be final, since they are written (via Unsafe) in clearInputs()
                            (when (Modifier/isFinal modifiers)
                                (throw! (str "NodeInputList input field " field " should not be final"))
                            )
                            (when (Modifier/isPublic modifiers)
                                (throw! (str "NodeInputList input field " field " should not be public"))
                            )
                        )
                        (do
                            (when-not (or (#_"Class" .isAssignableFrom Node, type) (#_"Class" .isInterface type))
                                (throw! (str "invalid input type: " type))
                            )
                            (when (Modifier/isFinal modifiers)
                                (throw! (str "Node input field " field " should not be final"))
                            )
                            (§ ass! this (update this :directInputs inc))
                        )
                    )
                    (let [
                        #_"InputType" inputType (if (some? inputAnnotation) (#_"Input" .value inputAnnotation) (#_"OptionalInput" .value optionalInputAnnotation))
                    ]
                        (#_"ArrayList" .add (:inputs this), (InputInfo'new-6 offset, (#_"Field" .getName field), type, (#_"Field" .getDeclaringClass field), inputType, (#_"Field" .isAnnotationPresent field, OptionalInput)))
                    )
                )
                (some? successorAnnotation)
                (do
                    (if (#_"Class" .isAssignableFrom NodeSuccessorList, type)
                        (do
                            ;; NodeSuccessorList fields should not be final, since they are written (via Unsafe) in clearSuccessors()
                            (when (Modifier/isFinal modifiers)
                                (throw! (str "NodeSuccessorList successor field " field "should not be final"))
                            )
                            (when (Modifier/isPublic modifiers)
                                (throw! (str "NodeSuccessorList successor field " field " should not be public"))
                            )
                        )
                        (do
                            (when-not (#_"Class" .isAssignableFrom Node, type)
                                (throw! (str "invalid successor type: " type))
                            )
                            (when (Modifier/isFinal modifiers)
                                (throw! (str "Node successor field " field " should not be final"))
                            )
                            (§ ass! this (update this :directSuccessors inc))
                        )
                    )
                    (#_"ArrayList" .add (:successors this), (EdgeInfo'new-4 offset, (#_"Field" .getName field), type, (#_"Field" .getDeclaringClass field)))
                )
                :else
                (do
                    (when (and (#_"Class" .isAssignableFrom Node, type) (not (= (#_"Field" .getName field) "Null")))
                        (throw! (str "suspicious node field: " field))
                    )
                    (when (#_"Class" .isAssignableFrom NodeInputList, type)
                        (throw! (str "suspicious node input list field: " field))
                    )
                    (when (#_"Class" .isAssignableFrom NodeSuccessorList, type)
                        (throw! (str "suspicious node successor list field: " field))
                    )
                    (FieldsScanner''scanField-3 (§ super ), field, offset)
                )
            )
        )
        nil
    )
)

;;;
 ; @anno NodeClass.InplaceUpdateClosure
 ;;
(§ interface InplaceUpdateClosure
    (§ abstract #_"Node" InplaceUpdateClosure''replacement-3 [#_"InplaceUpdateClosure" this, #_"Node" node, #_"EdgesType" type])
)

;;;
 ; An iterator that will iterate over edges.
 ;
 ; An iterator of this type will not return nil values, unless edges are modified concurrently.
 ;
 ; @anno NodeClass.RawEdgesIterator
 ;;
(final-ns RawEdgesIterator (§ implements Iterator #_"<Node>")
    (§ final #_"Node" :node nil)
    (§ mutable #_"long" :mask 0)
    (§ mutable #_"Node" :nextValue nil)

    (§ defn #_"RawEdgesIterator" RawEdgesIterator'new-2 [#_"Node" node, #_"long" mask]
        (let [
            #_"RawEdgesIterator" this (Object.)
            this (assoc this :node node)
            this (assoc this :mask mask)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" RawEdgesIterator''hasNext-1 [#_"RawEdgesIterator" this]
        (let [
            #_"Node" next (:nextValue this)
        ]
            (or (some? next)
                (do
                    (§ ass! this (assoc this :nextValue (RawEdgesIterator''forward-1 this)))
                    (some? (:nextValue this))
                )
            )
        )
    )

    (§ method- #_"Node" RawEdgesIterator''forward-1 [#_"RawEdgesIterator" this]
        (loop-when [] (not (zero? (:mask this)))
            (let [
                #_"Node" next (RawEdgesIterator''getInput-1 this)
            ]
                (§ ass! this (assoc this :mask (RawEdgesIterator''advanceInput-1 this)))
                (or next (recur))
            )
        )
    )

    #_unused
    (§ override! #_"Node" RawEdgesIterator''next-1 [#_"RawEdgesIterator" this]
        (let [
            #_"Node" next (:nextValue this)
        ]
            (when (some? next) => (or (RawEdgesIterator''forward-1 this) (throw (NoSuchElementException.)))
                (§ ass! this (assoc this :nextValue nil))
                next
            )
        )
    )

    (§ method! #_"long" RawEdgesIterator''advanceInput-1 [#_"RawEdgesIterator" this]
        (let [
            #_"int" state (& (int (:mask this)) 0x03)
        ]
            (case state
                0   ;; Skip normal field.
                    (>>> (:mask this) NodeClass'NEXT_EDGE)
                1   ;; We are iterating a node list.
                    (if (zero? (& (:mask this) 0xffff00))
                        ;; Node list is finished => go to next input.
                        (>>> (:mask this) 24)
                        ;; Node list count is non-zero, decrease by 1.
                        (- (:mask this) 0x100)
                    )
                ;; Need to expand node list.
                (let [
                    #_"NodeList" nodeList (Edges'getNodeListUnsafe-2 (:node this), (& (:mask this) 0xfc))
                ]
                    (when (some? nodeList)
                        (let [
                            #_"int" size (count nodeList)
                        ]
                            (when-not (zero? size)
                                ;; Set pointer to upper most index of node list.
                                (§ return (| (<< (>>> (:mask this) NodeClass'NEXT_EDGE) 24) (& (:mask this) 0xfd) (<< (dec size) NodeClass'NEXT_EDGE)))
                            )
                        )
                    )
                    ;; Node list is empty or nil => skip.
                    (>>> (:mask this) NodeClass'NEXT_EDGE)
                )
            )
        )
    )

    (§ method! #_"Node" RawEdgesIterator''getInput-1 [#_"RawEdgesIterator" this]
        (let [
            #_"int" state (int (& (:mask this) 0x03))
        ]
            (case state
                0   (Edges'getNodeUnsafe-2 (:node this), (& (:mask this) 0xfc))
                1   ;; We are iterating a node list.
                    (let [
                        #_"NodeList" nodeList (Edges'getNodeListUnsafe-2 (:node this), (& (:mask this) 0xfc))
                    ]
                        (nth (:nodes nodeList) (- (count nodeList) 1 (int (& (>>> (:mask this) NodeClass'NEXT_EDGE) 0xffff))))
                    )
                ;; Node list needs to expand first.
                nil
            )
        )
    )

    #_unused
    (§ method! #_"Position" RawEdgesIterator''nextPosition-1 [#_"RawEdgesIterator" this]
        nil
    )
)

(final-ns NodeFlood (§ implements Iterable #_"<Node>")
    (§ final #_"NodeBitMap" :visited nil)
    (§ final #_"Queue<Node>" :worklist (ArrayDeque.))
    (§ mutable #_"int" :totalMarkedCount 0)

    (§ defn #_"NodeFlood" NodeFlood'new-1 [#_"Graph" graph]
        (let [
            #_"NodeFlood" this (Object.)
            this (assoc this :visited (NodeBitMap'new-1 graph))
        ]
            this
        )
    )

    (§ method! #_"NodeFlood" NodeFlood''add-2 [#_"NodeFlood" this, #_"Node" node]
        (when (and (some? node) (not (NodeBitMap''isMarked-2 (:visited this), node))) => this
            (NodeBitMap''mark-2 (:visited this), node)
            (#_"Queue" .add (:worklist this), node)
            (update this :totalMarkedCount inc)
        )
    )

    #_unused
    (§ method! #_"NodeFlood" NodeFlood''addAll-2 [#_"NodeFlood" this, #_"Iterable<? extends Node>" nodes]
        (reduce NodeFlood''add-2 this nodes)
    )

    (§ method! #_"boolean" NodeFlood''isMarked-2 [#_"NodeFlood" this, #_"Node" node]
        (NodeBitMap''isMarked-2 (:visited this), node)
    )

    #_unused
    (§ method! #_"boolean" NodeFlood''isNew-2 [#_"NodeFlood" this, #_"Node" node]
        (NodeBitMap''isNew-2 (:visited this), node)
    )

    (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"NodeFlood" this]
        (let [
            #_"NodeFlood" flood this
        ]
            (§ reify #_"Iterator<Node>" (Iterator.)
                (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<Node>" this]
                    (not (#_"Queue" .isEmpty (:worklist flood)))
                )

                (§ override! #_"Node" #_"Iterator" .next [#_"Iterator<Node>" this]
                    (#_"Queue" .remove (:worklist flood))
                )
            )
        )
    )

    #_unused
    (§ method! #_"Iterable<Node>" NodeFlood''unmarkedNodes-1 [#_"NodeFlood" this]
        (let [
            #_"NodeFlood" flood this
        ]
            (§ reify #_"Iterable<Node>" (Iterable.)
                (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"Iterable<Node>" this]
                    (UnmarkedNodeIterator'new-2 (:visited flood), (#_"Iterable" .iterator (Graph''getNodes-1 (:graph (:visited flood)))))
                )
            )
        )
    )
)

;;;
 ; @anno NodeFlood.UnmarkedNodeIterator
 ;;
(final-ns UnmarkedNodeIterator (§ implements Iterator #_"<Node>")
    (§ final #_"NodeBitMap" :visited nil)
    (§ mutable #_"Iterator<Node>" :nodes nil)
    (§ mutable #_"Node" :nextNode nil)

    (§ defn #_"UnmarkedNodeIterator" UnmarkedNodeIterator'new-2 [#_"NodeBitMap" visited, #_"Iterator<Node>" nodes]
        (let [
            #_"UnmarkedNodeIterator" this (Object.)
            this (assoc this :visited visited)
            this (assoc this :nodes nodes)
        ]
            (§ ass! this (UnmarkedNodeIterator''forward-1 this))
            this
        )
    )

    (§ method- #_"UnmarkedNodeIterator" UnmarkedNodeIterator''forward-1 [#_"UnmarkedNodeIterator" this]
        (loop [this this]
            (when (#_"Iterator" .hasNext (:nodes this)) => (assoc this :nextNode nil)
                (let [
                    this (assoc this :nextNode (#_"Iterator" .next (:nodes this)))
                ]
                    (recur-if (NodeBitMap''isMarked-2 (:visited this), (:nextNode this)) [this] => this)
                )
            )
        )
    )

    #_unused
    (§ override! #_"boolean" UnmarkedNodeIterator''hasNext-1 [#_"UnmarkedNodeIterator" this]
        (some? (:nextNode this))
    )

    #_unused
    (§ override! #_"Node" UnmarkedNodeIterator''next-1 [#_"UnmarkedNodeIterator" this]
        (try
            (:nextNode this)
            (finally
                (§ ass! this (UnmarkedNodeIterator''forward-1 this))
            )
        )
    )
)

(final-ns NodeInputList #_"<T extends Node>" (§ extends NodeList #_"<T>")
    (§ defn #_"NodeInputList" NodeInputList'new-1 [#_"Node" self]
        (NodeList'new-1 self)
    )

    (§ defn #_"NodeInputList" NodeInputList'new-2 [#_"Node" self, #_"int" initialSize]
        (NodeList'new-2 self, initialSize)
    )

    (§ defn #_"NodeInputList" NodeInputList'new-2 [#_"Node" self, #_"T[]" elements]
        (NodeList'new-2 self, elements)
    )

    (§ defn #_"NodeInputList" NodeInputList'new-2 [#_"Node" self, #_"List<? extends T>" elements]
        (NodeList'new-2 self, elements)
    )

    #_unused
    (§ override! #_"void" NodeInputList''update-3 [#_"NodeInputList<T extends Node>" this, #_"T" oldNode, #_"T" newNode]
        (Node''updateUsages-3 (:self this), oldNode, newNode)
        nil
    )
)

(final-ns NodeSuccessorList #_"<T extends Node>" (§ extends NodeList #_"<T>")
    #_unused
    (§ defn #_"NodeSuccessorList" NodeSuccessorList'new-1 [#_"Node" self]
        (NodeList'new-1 self)
    )

    (§ defn #_"NodeSuccessorList" NodeSuccessorList'new-2 [#_"Node" self, #_"int" initialSize]
        (NodeList'new-2 self, initialSize)
    )

    (§ defn #_"NodeSuccessorList" NodeSuccessorList'new-2 [#_"Node" self, #_"T[]" elements]
        (NodeList'new-2 self, elements)
    )

    (§ defn #_"NodeSuccessorList" NodeSuccessorList'new-2 [#_"Node" self, #_"List<? extends T>" elements]
        (NodeList'new-2 self, elements)
    )

    #_unused
    (§ override! #_"void" NodeSuccessorList''update-3 [#_"NodeSuccessorList<T extends Node>" this, #_"T" oldNode, #_"T" newNode]
        (Node''updatePredecessor-3 (:self this), oldNode, newNode)
        nil
    )
)

(class-ns NodeList #_"<T extends Node>" (§ extends AbstractList #_"<T>") (§ implements NodeIterable #_"<T>")
    (§ def #_"Node[]" NodeList'EMPTY_NODE_ARRAY (make-array Node 0))

    (§ final #_"Node" :self nil)
    (§ mutable #_"Node[]" :nodes nil)
    (§ mutable #_"int" :size 0)
    (§ final #_"int" :initialSize 0)

    (§ defn #_"NodeList" NodeList'new-1 [#_"Node" self]
        (let [
            #_"NodeList" this (AbstractList.)
            this (assoc this :self self)
            this (assoc this :nodes NodeList'EMPTY_NODE_ARRAY)
            this (assoc this :initialSize 0)
        ]
            this
        )
    )

    (§ defn #_"NodeList" NodeList'new-2 [#_"Node" self, #_"int" initialSize]
        (let [
            #_"NodeList" this (AbstractList.)
            this (assoc this :self self)
            this (assoc this :size initialSize)
            this (assoc this :initialSize initialSize)
            this (assoc this :nodes (make-array Node initialSize))
        ]
            this
        )
    )

    (§ defn #_"NodeList" NodeList'new-2 [#_"Node" self, #_"T[]" elements]
        (let [
            #_"NodeList" this (AbstractList.)
            this (assoc this :self self)
        ]
            (if (or (nil? elements) (empty? elements))
                (do
                    (§ ass this (assoc this :size 0))
                    (§ ass this (assoc this :nodes NodeList'EMPTY_NODE_ARRAY))
                    (§ ass this (assoc this :initialSize 0))
                )
                (do
                    (§ ass this (assoc this :size (count elements)))
                    (§ ass this (assoc this :initialSize (count elements)))
                    (§ ass this (assoc this :nodes (make-array Node (count elements))))
                    (dotimes [#_"int" i (count elements)]
                        (aset (:nodes this) i (nth elements i))
                    )
                )
            )
            this
        )
    )

    (§ defn #_"NodeList" NodeList'new-2 [#_"Node" self, #_"List<? extends T>" elements]
        (let [
            #_"NodeList" this (AbstractList.)
            this (assoc this :self self)
        ]
            (if (or (nil? elements) (empty? elements))
                (do
                    (§ ass this (assoc this :size 0))
                    (§ ass this (assoc this :nodes NodeList'EMPTY_NODE_ARRAY))
                    (§ ass this (assoc this :initialSize 0))
                )
                (do
                    (§ ass this (assoc this :size (count elements)))
                    (§ ass this (assoc this :initialSize (count elements)))
                    (§ ass this (assoc this :nodes (make-array Node (count elements))))
                    (dotimes [#_"int" i (count elements)]
                        (aset (:nodes this) i (nth elements i))
                    )
                )
            )
            this
        )
    )

    (§ abstract #_"void" NodeList''update-3 [#_"NodeList<T extends Node>" this, #_"T" oldNode, #_"T" newNode])

    (§ override #_"boolean" NodeList''add-2 [#_"NodeList<T extends Node>" this, #_"Node" node]
        (let [
            #_"int" length (count (:nodes this))
        ]
            (cond
                (zero? length)
                    (§ ass! this (assoc this :nodes (make-array Node 2)))
                (= (:size this) length)
                (let [
                    #_"Node[]" newNodes (make-array Node (inc (* (count (:nodes this)) 2)))
                ]
                    (System/arraycopy (:nodes this), 0, newNodes, 0, length)
                    (§ ass! this (assoc this :nodes newNodes))
                )
            )
            (aset (:nodes this) (:size this) node)
            (§ ass! this (update this :size inc))
            (NodeList''update-3 this, nil, (§ cast #_"T" node))
            true
        )
    )

    (§ override #_"T" NodeList''set-3 [#_"NodeList<T extends Node>" this, #_"int" index, #_"Node" node]
        (let [
            #_"T" oldValue (nth (:nodes this) index)
        ]
            (NodeList''update-3 this, (§ cast #_"T" (nth (:nodes this) index)), (§ cast #_"T" node))
            (aset (:nodes this) index node)
            oldValue
        )
    )

    (§ method #_"void" NodeList''initialize-3 [#_"NodeList<T extends Node>" this, #_"int" index, #_"Node" node]
        (aset (:nodes this) index node)
        nil
    )

    (§ method #_"void" NodeList''copy-2 [#_"NodeList<T extends Node>" this, #_"NodeList<? extends Node>" other]
        (let [
            #_"Node[]" newNodes (make-array Node (:size other))
        ]
            (System/arraycopy (:nodes other), 0, newNodes, 0, (count newNodes))
            (§ ass! this (assoc this :nodes newNodes))
            (§ ass! this (assoc this :size (:size other)))
        )
        nil
    )

    (§ override #_"void" NodeList''clear-1 [#_"NodeList<T extends Node>" this]
        (dotimes [#_"int" i (:size this)]
            (NodeList''update-3 this, (§ cast #_"T" (nth (:nodes this) i)), nil)
        )
        (§ ass! this (NodeList''clearWithoutUpdate-1 this))
        nil
    )

    (§ method! #_"NodeList<T extends Node>" NodeList''clearWithoutUpdate-1 [#_"NodeList<T extends Node>" this]
        (let [
            this (assoc this :nodes NodeList'EMPTY_NODE_ARRAY)
            this (assoc this :size 0)
        ]
            this
        )
    )

    (§ override #_"boolean" NodeList''remove-2 [#_"NodeList<T extends Node>" this, #_"Object" node]
        (let [
            #_"int" i (loop-when-recur [i 0] (and (< i (:size this)) (not= (nth (:nodes this) i) node)) [(inc i)] => i)
        ]
            (and (< i (:size this))
                (let [
                    #_"T" oldValue (nth (:nodes this) i)
                ]
                    (loop-when-recur [i (inc i)] (< i (:size this)) [(inc i)]
                        (aset (:nodes this) (dec i) (nth (:nodes this) i))
                    )
                    (§ ass! this (update this :size dec))
                    (aset (:nodes this) (:size this) nil)
                    (NodeList''update-3 this, oldValue, nil)
                    true
                )
            )
        )
    )

    (§ override #_"T" NodeList''remove-2 [#_"NodeList<T extends Node>" this, #_"int" index]
        (let [
            #_"T" oldValue (nth (:nodes this) index)
        ]
            (loop-when-recur [#_"int" i (inc index)] (< i (:size this)) [(inc i)]
                (aset (:nodes this) (dec i) (nth (:nodes this) i))
            )
            (§ ass! this (update this :size dec))
            (aset (:nodes this) (:size this) nil)
            (NodeList''update-3 this, oldValue, nil)
            oldValue
        )
    )

    (§ method! #_"boolean" NodeList''replaceFirst-3 [#_"NodeList<T extends Node>" this, #_"Node" node, #_"Node" other]
        (loop-when [#_"int" i 0] (< i (:size this)) => false
            (when (= (nth (:nodes this) i) node) => (recur (inc i))
                (aset (:nodes this) i other)
                true
            )
        )
    )

    (§ override #_"Iterator<T>" #_"Iterable" .iterator [#_"NodeList<T extends Node>" this]
        (NodeListIterator'new-2 this, 0)
    )

    (§ override #_"boolean" NodeList''contains-2 [#_"NodeList<T extends Node>" this, #_"T" other]
        (loop [#_"int" i 0] (and (< i (:size this)) (or (= (nth (:nodes this) i) other) (recur (inc i)))))
    )

    (§ override #_"List<T>" NodeList''snapshot-1 [#_"NodeList<T extends Node>" this]
        (Arrays/asList (Arrays/copyOf (:nodes this), (:size this)))
    )

    (§ override #_"<A> A[]" NodeList''toArray-2 [#_"NodeList<T extends Node>" this, #_"A[]" a]
        (when (<= (:size this) (count a)) => (Arrays/copyOf (:nodes this), (:size this), (#_"Object" .getClass a))
            (System/arraycopy (:nodes this), 0, a, 0, (:size this))
            a
        )
    )

    #_unused
    (§ method #_"void" NodeList''replace-3 [#_"NodeList<T extends Node>" this, #_"T" node, #_"T" other]
        (dotimes [#_"int" i (count this)]
            (when (= (nth (:nodes this) i) node)
                (aset (:nodes this) i other)
                (NodeList''update-3 this, node, other)
            )
        )
        nil
    )

    (§ override #_"int" NodeList''indexOf-2 [#_"NodeList<T extends Node>" this, #_"Object" node]
        (loop-when [#_"int" i 0] (< i (:size this)) => -1
            (if (= (nth (:nodes this) i) node)
                i
                (recur (inc i))
            )
        )
    )

    (§ override #_"boolean" NodeList''contains-2 [#_"NodeList<T extends Node>" this, #_"Object" o]
        (not= (NodeList''indexOf-2 this, o) -1)
    )

    (§ override #_"boolean" NodeList''addAll-2 [#_"NodeList<T extends Node>" this, #_"Collection<? extends T>" c]
        (doseq [#_"T" e c]
            (NodeList''add-2 this, e)
        )
        true
    )

    (§ method #_"boolean" NodeList''addAll-2 [#_"NodeList<T extends Node>" this, #_"T[]" c]
        (doseq [#_"T" e c]
            (NodeList''add-2 this, e)
        )
        true
    )
)

;;;
 ; @anno NodeList.NodeListIterator
 ;;
(final-ns NodeListIterator #_"<R extends Node>" (§ implements Iterator #_"<R>")
    (§ final #_"NodeList<R>" :list nil)
    (§ mutable #_"int" :index 0)

    (§ defn #_"NodeListIterator" NodeListIterator'new-2 [#_"NodeList<R>" list, #_"int" startIndex]
        (let [
            #_"NodeListIterator" this (Object.)
            this (assoc this :list list)
            this (assoc this :index startIndex)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" NodeListIterator''hasNext-1 [#_"NodeListIterator<R extends Node>" this]
        (< (:index this) (:size (:list this)))
    )

    #_unused
    (§ override! #_"R" NodeListIterator''next-1 [#_"NodeListIterator<R extends Node>" this]
        (let [
            _ (§ cast #_"R" (nth (:nodes (:list this)) (:index this)))
        ]
            (§ ass! this (update this :index inc))
            _
        )
    )
)

(final-ns NodeMap #_"<T>" (§ implements EconomicMap #_"<Node, T>")
    (def- #_"int" NodeMap'MIN_REALLOC_SIZE 16)

    (§ final #_"Graph" :graph nil)
    (§ mutable #_"Object[]" :values nil)

    (§ defn #_"NodeMap" NodeMap'new-1 [#_"Graph" graph]
        (let [
            #_"NodeMap" this (Object.)
            this (assoc this :graph graph)
            this (assoc this :values (make-array Object (:nodesSize graph)))
        ]
            this
        )
    )

    (§ defn #_"NodeMap" NodeMap'new-1 [#_"NodeMap<T>" copyFrom]
        (let [
            #_"NodeMap" this (Object.)
            this (assoc this :graph (:graph copyFrom))
            this (assoc this :values (Arrays/copyOf (:values copyFrom), (count (:values copyFrom))))
        ]
            this
        )
    )

    (§ override! #_"T" NodeMap''get-2 [#_"NodeMap<T>" this, #_"Node" node]
        (§ cast #_"T" (nth (:values this) (:id node)))
    )

    (§ method! #_"T" NodeMap''getAndGrow-2 [#_"NodeMap<T>" this, #_"Node" node]
        (§ ass! this (NodeMap''checkAndGrow-2 this, node))
        (§ cast #_"T" (nth (:values this) (:id node)))
    )

    (§ method- #_"NodeMap<T>" NodeMap''checkAndGrow-2 [#_"NodeMap<T>" this, #_"Node" node]
        (when (NodeMap''isNew-2 this, node) => this
            (assoc this :values (Arrays/copyOf (:values this), (max NodeMap'MIN_REALLOC_SIZE (quot (* (:nodesSize (:graph this)) 3) 2))))
        )
    )

    (§ override! #_"boolean" NodeMap''containsKey-2 [#_"NodeMap<T>" this, #_"Node" node]
        (and (= (:graph node) (:graph this)) (some? (NodeMap''get-2 this, node)))
    )

    #_unused
    (§ method! #_"boolean" NodeMap''containsValue-2 [#_"NodeMap<T>" this, #_"Object" value]
        (loop [#_"ISeq" s (seq (:values this))] (and (some? s) (or (= (first s) value) (recur (next s)))))
    )

    (§ method! #_"void" NodeMap''set-3 [#_"NodeMap<T>" this, #_"Node" node, #_"T" value]
        (aset (:values this) (:id node) value)
        nil
    )

    (§ method! #_"NodeMap<T>" NodeMap''setAndGrow-3 [#_"NodeMap<T>" this, #_"Node" node, #_"T" value]
        (let [
            this (NodeMap''checkAndGrow-2 this, node)
        ]
            (NodeMap''set-3 this, node, value)
            this
        )
    )

    ;;;
     ; @return the key for the entry at index {@code i}
     ;;
    (§ method! #_"Node" NodeMap''getKey-2 [#_"NodeMap<T>" this, #_"int" i]
        (nth (:nodes (:graph this)) i)
    )

    (§ method! #_"int" NodeMap''capacity-1 [#_"NodeMap<T>" this]
        (count (:values this))
    )

    (§ method! #_"boolean" NodeMap''isNew-2 [#_"NodeMap<T>" this, #_"Node" node]
        (<= (NodeMap''capacity-1 this) (:id node))
    )

    #_unused
    (§ override! #_"void" NodeMap''clear-1 [#_"NodeMap<T>" this]
        (Arrays/fill (:values this), nil)
        nil
    )

    (§ override! #_"Iterable<Node>" NodeMap''getKeys-1 [#_"NodeMap<T>" this]
        (let [
            #_"NodeMap" nodeMap this
        ]
            (§ reify #_"Iterable<Node>" (Iterable.)
                (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"Iterable<Node>" this]
                    (§ reify #_"Iterator<Node>" (Iterator.)
                        (let [
                            #_"int" i 0
                        ]
                            (§ method- #_"void" Iterator''forward-1 [#_"Iterator<Node>" this]
                                (while (and (< i (count (:values nodeMap))) (or (nil? (NodeMap''getKey-2 nodeMap, i)) (nil? (nth (:values nodeMap) i))))
                                    (§ ass i (inc i))
                                )
                                nil
                            )

                            (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<Node>" this]
                                (Iterator''forward-1 this)
                                (< i (count (:values nodeMap)))
                            )

                            (§ override! #_"Node" #_"Iterator" .next [#_"Iterator<Node>" this]
                                (let [
                                    #_"Node" key (NodeMap''getKey-2 nodeMap, i)
                                ]
                                    (§ ass i (inc i))
                                    (Iterator''forward-1 this)
                                    key
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"MapCursor<Node, T>" NodeMap''getEntries-1 [#_"NodeMap<T>" this]
        (let [
            #_"NodeMap" nodeMap this
        ]
            (§ reify #_"MapCursor<Node, T>" (MapCursor.)
                (let [
                    #_"int" i -1
                ]
                    (§ override! #_"boolean" #_"MapCursor" .advance [#_"MapCursor<Node, T>" this]
                        (§ ass i (inc i))
                        (while (and (< i (count (:values nodeMap))) (or (nil? (nth (:values nodeMap) i)) (nil? (NodeMap''getKey-2 nodeMap, i))))
                            (§ ass i (inc i))
                        )
                        (< i (count (:values nodeMap)))
                    )

                    (§ override! #_"Node" #_"MapCursor" .getKey [#_"MapCursor<Node, T>" this]
                        (NodeMap''getKey-2 nodeMap, i)
                    )

                    (§ override! #_"T" #_"MapCursor" .getValue [#_"MapCursor<Node, T>" this]
                        (§ cast #_"T" (nth (:values nodeMap) i))
                    )

                    (§ override! #_"void" #_"MapCursor" .remove [#_"MapCursor<Node, T>" this]
                        (aset (:values nodeMap) i nil)
                        nil
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"Iterable<T>" NodeMap''getValues-1 [#_"NodeMap<T>" this]
        (let [
            #_"NodeMap" nodeMap this
        ]
            (§ reify #_"Iterable<T>" (Iterable.)
                (§ override! #_"Iterator<T>" #_"Iterable" .iterator [#_"Iterable<T>" this]
                    (§ reify #_"Iterator<T>" (Iterator.)
                        (let [
                            #_"int" i 0
                        ]
                            (§ method- #_"void" Iterator''forward-1 [#_"Iterator<T>" this]
                                (while (and (< i (count (:values nodeMap))) (or (nil? (NodeMap''getKey-2 nodeMap, i)) (nil? (nth (:values nodeMap) i))))
                                    (§ ass i (inc i))
                                )
                                nil
                            )

                            (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<T>" this]
                                (Iterator''forward-1 this)
                                (< i (count (:values nodeMap)))
                            )

                            (§ override! #_"T" #_"Iterator" .next [#_"Iterator<T>" this]
                                (let [
                                    #_"T" value (nth (:values nodeMap) i)
                                ]
                                    (§ ass i (inc i))
                                    (Iterator''forward-1 this)
                                    value
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ override! #_"T" NodeMap''put-3 [#_"NodeMap<T>" this, #_"Node" key, #_"T" value]
        (let [
            #_"T" result (NodeMap''get-2 this, key)
        ]
            (NodeMap''set-3 this, key, value)
            result
        )
    )

    #_unused
    (§ override! #_"T" NodeMap''removeKey-2 [#_"NodeMap<T>" this, #_"Node" key]
        (NodeMap''put-3 this, key, nil)
    )

    #_unused
    (§ override! #_"void" NodeMap''replaceAll-2 [#_"NodeMap<T>" this, #_"BiFunction<? super Node, ? super T, ? extends T>" function]
        (doseq [#_"Node" n (NodeMap''getKeys-1 this)]
            (NodeMap''put-3 this, n, (#_"BiFunction" .apply function, n, (NodeMap''get-2 this, n)))
        )
        nil
    )
)

(final-ns NodeStack
    (def- #_"int" NodeStack'DEFAULT_INITIAL_SIZE 8)

    (§ mutable #_"Node[]" :values nil)
    (§ mutable #_"int" :tos 0)

    (§ defn #_"NodeStack" NodeStack'new-0 []
        (NodeStack'new-1 NodeStack'DEFAULT_INITIAL_SIZE)
    )

    (§ defn #_"NodeStack" NodeStack'new-1 [#_"int" initialSize]
        (let [
            #_"NodeStack" this (Object.)
            this (assoc this :values (make-array Node initialSize))
        ]
            this
        )
    )

    (§ method! #_"NodeStack" NodeStack''push-2 [#_"NodeStack" this, #_"Node" node]
        (let [
            #_"int" i (:tos this)
            _ (§ ass! (:tos this) (inc (:tos this)))
            this
                (when (<= (count (:values this)) i) => this
                    (NodeStack''grow-1 this)
                )
        ]
            (aset (:values this) i node)
            this
        )
    )

    (§ method- #_"NodeStack" NodeStack''grow-1 [#_"NodeStack" this]
        (let [
            #_"int" n (count (:values this))
            #_"Node[]" a (make-array Node (<< n 1))
        ]
            (System/arraycopy (:values this), 0, a, 0, n)
            (assoc this :values a)
        )
    )

    (§ method! #_"Node" NodeStack''get-2 [#_"NodeStack" this, #_"int" index]
        (nth (:values this) index)
    )

    (§ method! #_"Node" NodeStack''pop-1 [#_"NodeStack" this]
        (§ ass! this (update this :tos dec))
        (nth (:values this) (:tos this))
    )

    (§ method! #_"Node" NodeStack''peek-1 [#_"NodeStack" this]
        (nth (:values this) (dec (:tos this)))
    )

    (§ method! #_"boolean" NodeStack''isEmpty-1 [#_"NodeStack" this]
        (zero? (:tos this))
    )

    (§ method! #_"NodeStack" NodeStack''clear-1 [#_"NodeStack" this]
        (assoc this :tos 0)
    )
)

(final-ns NodeUsageIterable (§ implements NodeIterable #_"<Node>")
    (§ final #_"Node" :node nil)

    (§ defn #_"NodeUsageIterable" NodeUsageIterable'new-1 [#_"Node" node]
        (let [
            #_"NodeUsageIterable" this (Object.)
            this (assoc this :node node)
        ]
            this
        )
    )

    (§ override! #_"NodeUsageIterator" #_"Iterable" .iterator [#_"NodeUsageIterable" this]
        (NodeUsageIterator'new-1 (:node this))
    )

    #_unused
    (§ override! #_"Node" NodeUsageIterable''first-1 [#_"NodeUsageIterable" this]
        (:usage0 (:node this))
    )

    #_unused
    (§ override! #_"boolean" NodeUsageIterable''isEmpty-1 [#_"NodeUsageIterable" this]
        (nil? (:usage0 (:node this)))
    )

    #_unused
    (§ override! #_"boolean" NodeUsageIterable''isNotEmpty-1 [#_"NodeUsageIterable" this]
        (some? (:usage0 (:node this)))
    )

    #_unused
    (§ override! #_"int" NodeUsageIterable''count-1 [#_"NodeUsageIterable" this]
        (Node''getUsageCount-1 (:node this))
    )
)

(final-ns NodeUsageIterator (§ implements Iterator #_"<Node>")
    (§ final #_"Node" :node nil)
    (§ mutable #_"int" :index -1)
    (§ mutable #_"Node" :current nil)

    (§ method! #_"NodeUsageIterator" NodeUsageIterator''advance-1 [#_"NodeUsageIterator" this]
        (let [
            this (assoc this :current nil)
            this (update this :index inc)
        ]
            (condp = (:index this)
                0 (assoc this :current (:usage0 (:node this)))
                1 (assoc this :current (:usage1 (:node this)))
                (let [
                    #_"int" i (- (:index this) Node'INLINE_USAGE_COUNT)
                ]
                    (when (< i (:extraUsagesCount (:node this))) => this
                        (assoc this :current (nth (:extraUsages (:node this)) i))
                    )
                )
            )
        )
    )

    (§ defn #_"NodeUsageIterator" NodeUsageIterator'new-1 [#_"Node" node]
        (let [
            #_"NodeUsageIterator" this (Object.)
            this (assoc this :node node)
        ]
            (§ ass! this (NodeUsageIterator''advance-1 this))
            this
        )
    )

    #_unused
    (§ override! #_"boolean" NodeUsageIterator''hasNext-1 [#_"NodeUsageIterator" this]
        (some? (:current this))
    )

    #_unused
    (§ override! #_"Node" NodeUsageIterator''next-1 [#_"NodeUsageIterator" this]
        (let [
            #_"Node" result (:current this)
        ]
            (when (nil? result)
                (throw (NoSuchElementException.))
            )
            (§ ass! this (NodeUsageIterator''advance-1 this))
            result
        )
    )
)

(class-ns NodeWorkList (§ implements Iterable #_"<Node>")
    (§ final #_"Queue<Node>" :worklist (ArrayDeque.))

    (§ defn #_"NodeWorkList" NodeWorkList'new-2 [#_"Graph" graph, #_"boolean" fill]
        (let [
            #_"NodeWorkList" this (Object.)
        ]
            (when fill
                (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                    (#_"Queue" .add (:worklist this), node)
                )
            )
            this
        )
    )

    (§ method #_"void" NodeWorkList''addAll-2 [#_"NodeWorkList" this, #_"Iterable<? extends Node>" nodes]
        (doseq [#_"Node" node nodes]
            (when (Node''isAlive-1 node)
                (NodeWorkList''add-2 this, node)
            )
        )
        nil
    )

    (§ abstract #_"void" NodeWorkList''add-2 [#_"NodeWorkList" this, #_"Node" node])

    #_unused
    (§ abstract #_"boolean" NodeWorkList''contains-2 [#_"NodeWorkList" this, #_"Node" node])
)

;;;
 ; Describes an edge slot for a NodeClass.
 ;;
(final-ns Position
    ;;;
     ; The edges in which this position lies.
     ;;
    (§ final #_"Edges" :edges nil)
    ;;;
     ; Index of the Node or NodeList field denoted by this position.
     ;;
    (§ final #_"int" :index 0)
    ;;;
     ; Index within a NodeList if #index denotes a NodeList field otherwise Node#NOT_ITERABLE.
     ;;
    (§ final #_"int" :subIndex 0)

    (§ defn #_"Position" Position'new-3 [#_"Edges" edges, #_"int" index, #_"int" subIndex]
        (let [
            #_"Position" this (Object.)
            this (assoc this :edges edges)
            this (assoc this :index index)
            this (assoc this :subIndex subIndex)
        ]
            this
        )
    )

    (§ method! #_"Node" Position''get-2 [#_"Position" this, #_"Node" node]
        (if (< (:index this) (:directCount (:edges this)))
            (Edges'getNode-3 node, (:offsets (:edges this)), (:index this))
            (nth (Edges'getNodeList-3 node, (:offsets (:edges this)), (:index this)) (:subIndex this))
        )
    )

    (§ method! #_"InputType" Position''getInputType-1 [#_"Position" this]
        (InputEdges''getInputType-2 (:edges this), (:index this))
    )

    #_unused
    (§ method! #_"boolean" Position''isInputOptional-1 [#_"Position" this]
        (InputEdges''isOptional-2 (:edges this), (:index this))
    )

    (§ method! #_"void" Position''set-3 [#_"Position" this, #_"Node" node, #_"Node" value]
        (if (< (:index this) (:directCount (:edges this)))
            (Edges''setNode-4 (:edges this), node, (:index this), value)
            (NodeList''set-3 (Edges'getNodeList-3 node, (:offsets (:edges this)), (:index this)), (:subIndex this), value)
        )
        nil
    )

    (§ method! #_"void" Position''initialize-3 [#_"Position" this, #_"Node" node, #_"Node" value]
        (if (< (:index this) (:directCount (:edges this)))
            (Edges''initializeNode-4 (:edges this), node, (:index this), value)
            (NodeList''initialize-3 (Edges'getNodeList-3 node, (:offsets (:edges this)), (:index this)), (:subIndex this), value)
        )
        nil
    )
)

(final-ns SingletonNodeWorkList (§ extends NodeWorkList)
    (§ final #_"NodeBitMap" :visited nil)

    (§ defn #_"SingletonNodeWorkList" SingletonNodeWorkList'new-1 [#_"Graph" graph]
        (let [
            #_"SingletonNodeWorkList" this (NodeWorkList'new-2 graph, false)
            this (assoc this :visited (NodeBitMap'new-1 graph))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" SingletonNodeWorkList''add-2 [#_"SingletonNodeWorkList" this, #_"Node" node]
        (when (some? node)
            (when-not (NodeBitMap''isMarkedAndGrow-2 (:visited this), node)
                (NodeBitMap''mark-2 (:visited this), node)
                (#_"Queue" .add (:worklist this), node)
            )
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" SingletonNodeWorkList''contains-2 [#_"SingletonNodeWorkList" this, #_"Node" node]
        (NodeBitMap''isMarked-2 (:visited this), node)
    )

    (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"SingletonNodeWorkList" this]
        (let [
            #_"SingletonNodeWorkList" owner this
        ]
            (§ reify #_"Iterator<Node>" (Iterator.)
                (§ method- #_"void" Iterator''dropDeleted-1 [#_"Iterator<Node>" this]
                    (while (and (not (#_"Queue" .isEmpty (:worklist owner))) (Node''isDeleted-1 (#_"Queue" .peek (:worklist owner))))
                        (#_"Queue" .remove (:worklist owner))
                    )
                    nil
                )

                (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<Node>" this]
                    (Iterator''dropDeleted-1 this)
                    (not (#_"Queue" .isEmpty (:worklist owner)))
                )

                (§ override! #_"Node" #_"Iterator" .next [#_"Iterator<Node>" this]
                    (Iterator''dropDeleted-1 this)
                    (#_"Queue" .remove (:worklist owner))
                )
            )
        )
    )
)

;;;
 ; Nodes can implement Canonicalizable or one of the two sub-interfaces Unary and
 ; Binary to provide local optimizations like constant folding and strength reduction.
 ; Implementations should return a replacement that is always semantically correct for the given
 ; inputs, or "this" if they do not see an opportunity for improvement.
 ;
 ; <b>Implementations of Canonicalizable#canonical(CanonicalizerTool) or the equivalent
 ; methods of the two sub-interfaces must not have any side effects.</b>
 ; They are not allowed to change inputs, successors or properties of any node (including the
 ; current one) and they also cannot add new nodes to the graph.
 ;
 ; In addition to pre-existing nodes they can return newly created nodes, which will be added to the
 ; graph automatically if (and only if) the effects of the canonicalization are committed.
 ; Non-cyclic graphs (DAGs) of newly created nodes (i.e. one newly created node with an input to
 ; another newly created node) will be handled correctly.
 ;;
(§ interface Canonicalizable
    ;;;
     ; Implementations of this method can provide local optimizations like constant folding and
     ; strength reduction. Implementations should look at the properties and inputs of the current
     ; node and determine if there is a more optimal and always semantically correct replacement.
     ;
     ; The return value determines the effect that the canonicalization will have:
     ;
     ; (1) Returning an pre-existing node will replace the current node with the given one.
     ; (2) Returning a newly created node (that was not yet added to the graph) will replace the
     ; current node with the given one, after adding it to the graph. If both the replacement and
     ; the replacee are anchored in control flow (fixed nodes), the replacement will be added to the
     ; control flow. It is invalid to replace a non-fixed node with a newly created fixed node
     ; (because its placement in the control flow cannot be determined without scheduling).
     ; (3) Returning nil will delete the current node and replace it with nil at
     ; all usages. Note that it is not necessary to delete floating nodes that have no more usages
     ; this way - they will be deleted automatically.
     ;
     ; @param tool provides access to runtime interfaces like MetaAccessProvider
     ;;
    (§ abstract #_"Node" Canonicalizable''canonical-2 [#_"Canonicalizable" this, #_"CanonicalizerTool" tool])
)

;;;
 ; This sub-interface of Canonicalizable is intended for nodes that have exactly one
 ; input. It has an additional #canonical(CanonicalizerTool, Node) method that looks at
 ; the given input instead of the current input of the node - which can be used to ask "what if
 ; this input is changed to this node" - questions.
 ;
 ; @param <T> the common supertype of all inputs of this node
 ;
 ; @anno Canonicalizable.Unary
 ;;
(§ interface Unary #_"<T extends Node>" (§ extends Canonicalizable)
    ;;;
     ; Similar to Canonicalizable#canonical(CanonicalizerTool), except that
     ; implementations should act as if the current input of the node was the given one, i.e.
     ; they should never look at the inputs via the this pointer.
     ;;
    (§ abstract #_"Node" Unary''canonical-3 [#_"Unary<T extends Node>" this, #_"CanonicalizerTool" tool, #_"T" forValue])

    ;;;
     ; Gets the current value of the input, so that calling
     ; #canonical(CanonicalizerTool, Node) with the value returned from this method
     ; should behave exactly like Canonicalizable#canonical(CanonicalizerTool).
     ;;
    (§ abstract #_"T" Unary''getValue-1 [#_"Unary<T extends Node>" this])

    #_unused
    (§ default #_"T" Unary''canonical-2 [#_"Unary<T extends Node>" this, #_"CanonicalizerTool" tool]
        (Unary''canonical-3 this, tool, (Unary''getValue-1 this))
    )
)

;;;
 ; This sub-interface of Canonicalizable is intended for nodes that have exactly two
 ; inputs. It has an additional #canonical(CanonicalizerTool, Node, Node) method that
 ; looks at the given inputs instead of the current inputs of the node - which can be used to
 ; ask "what if this input is changed to this node" - questions.
 ;
 ; @param <T> the common supertype of all inputs of this node
 ;
 ; @anno Canonicalizable.Binary
 ;;
(§ interface Binary #_"<T extends Node>" (§ extends Canonicalizable)
    ;;;
     ; Similar to Canonicalizable#canonical(CanonicalizerTool), except that
     ; implementations should act as if the current input of the node was the given one, i.e.
     ; they should never look at the inputs via the this pointer.
     ;;
    (§ abstract #_"Node" Binary''canonical-4 [#_"Binary<T extends Node>" this, #_"CanonicalizerTool" tool, #_"T" forX, #_"T" forY])

    #_unused
    (§ default #_"T" Binary''canonical-2 [#_"Binary<T extends Node>" this, #_"CanonicalizerTool" tool]
        (Binary''canonical-4 this, tool, (:x this), (:y this))
    )
)

;;;
 ; This sub-interface of Binary is for nodes with two inputs where the operation is commutative.
 ; It is used to improve GVN by trying to merge nodes with the same inputs in different order.
 ;
 ; @anno Canonicalizable.BinaryCommutative
 ;;
(§ interface BinaryCommutative #_"<T extends Node>" (§ extends Binary #_"<T>")
    ;;;
     ; Ensure a canonical ordering of inputs for commutative nodes to improve GVN results.
     ; Order the inputs by increasing Node#id and call Graph#findDuplicate(Node) on the node
     ; if it's currently in a graph. It's assumed that if there was a constant on the left,
     ; it's been moved to the right by other code and that ordering is left alone.
     ;
     ; @return the original node or another node with the same input ordering
     ;;
    (§ abstract #_"Node" BinaryCommutative''maybeCommuteInputs-1 [#_"BinaryCommutative<T extends Node>" this])
)

(§ interface CanonicalizerTool
    (§ abstract #_"boolean" CanonicalizerTool''canonicalizeReads-1 [#_"CanonicalizerTool" this])

    ;;;
     ; If this method returns false, not all {@link Node#usages() usages of a node} are yet available.
     ; So a node must not be canonicalized base on, e.g. information returned from Node#hasNoUsages().
     ;;
    (§ abstract #_"boolean" CanonicalizerTool''allUsagesAvailable-1 [#_"CanonicalizerTool" this])

    ;;;
     ; Indicates the smallest width for comparing an integer value on the target platform.
     ; If this method returns nil, then there is no known smallest compare width.
     ;;
    (§ abstract #_"Integer" CanonicalizerTool''smallestCompareWidth-1 [#_"CanonicalizerTool" this])
)

;;;
 ; This interface allows nodes to perform more complicated simplifications, in contrast to
 ; Canonicalizable, which supports only replacing the current node.
 ;
 ; Implementors of this interface need to be aware that they need to call
 ; SimplifierTool#addToWorkList(Node) for each node that might be influenced
 ; (in terms of simplification and canonicalization) by the actions performed in simplify.
 ;;
(§ interface Simplifiable
    #_unused
    (§ abstract #_"void" Simplifiable''simplify-2 [#_"Simplifiable" this, #_"SimplifierTool" tool])
)

(§ interface SimplifierTool (§ extends CanonicalizerTool)
    (§ abstract #_"void" SimplifierTool''deleteBranch-2 [#_"SimplifierTool" this, #_"Node" branch])

    ;;;
     ; Adds a node to the worklist independent of whether it has already been on the worklist.
     ;;
    (§ abstract #_"void" SimplifierTool''addToWorkList-2 [#_"SimplifierTool" this, #_"Node" node])

    (§ abstract #_"void" SimplifierTool''addToWorkList-2 [#_"SimplifierTool" this, #_"Iterable<? extends Node>" nodes])

    (§ abstract #_"void" SimplifierTool''removeIfUnused-2 [#_"SimplifierTool" this, #_"Node" node])
)

(final-ns SuccessorEdges (§ extends Edges)
    (§ defn #_"SuccessorEdges" SuccessorEdges'new-2 [#_"int" directCount, #_"ArrayList<EdgeInfo>" edges]
        (Edges'new-3 EdgesType'Successors, directCount, edges)
    )

    #_unused
    (§ override! #_"void" SuccessorEdges''update-4 [#_"SuccessorEdges" this, #_"Node" node, #_"Node" oldValue, #_"Node" newValue]
        (Node''updatePredecessor-3 node, oldValue, newValue)
        nil
    )
)

(final-ns TypedGraphNodeIterator #_"<T extends IterableNodeType>" (§ implements Iterator #_"<T>")
    (§ final #_"Graph" :graph nil)
    (§ final #_"int[]" :ids nil)
    (§ final #_"Node[]" :current nil)

    (§ mutable #_"int" :currentIdIndex 0)
    (§ mutable #_"boolean" :needsForward false)

    (§ defn #_"TypedGraphNodeIterator" TypedGraphNodeIterator'new-2 [#_"NodeClass" clazz, #_"Graph" graph]
        (let [
            #_"TypedGraphNodeIterator" this (Object.)
            this (assoc this :graph graph)
            this (assoc this :ids (:iterableIds clazz))
            this (assoc this :currentIdIndex 0)
            this (assoc this :current (make-array Node (count (:ids this))))
            this (assoc this :needsForward true)
        ]
            this
        )
    )

    (§ method- #_"Node" TypedGraphNodeIterator''findNext-1 [#_"TypedGraphNodeIterator<T extends IterableNodeType>" this]
        (if (:needsForward this)
            (§ ass! this (TypedGraphNodeIterator''forward-1 this))
            (let [
                #_"Node" c (TypedGraphNodeIterator''current-1 this)
                #_"Node" afterDeleted (Graph''getIterableNodeNext-2 (:graph this), c)
            ]
                (cond
                    (nil? afterDeleted)
                        (§ ass! this (assoc this :needsForward true))
                    (not= c afterDeleted)
                        (TypedGraphNodeIterator''setCurrent-2 this, afterDeleted)
                )
            )
        )
        (when-not (:needsForward this)
            (TypedGraphNodeIterator''current-1 this)
        )
    )

    (§ method- #_"TypedGraphNodeIterator<T extends IterableNodeType>" TypedGraphNodeIterator''forward-1 [#_"TypedGraphNodeIterator<T extends IterableNodeType>" this]
        (let [
            this (assoc this :needsForward false)
            #_"int" startIdx (:currentIdIndex this)
        ]
            (loop [this this]
                (let [
                    #_"Node" next
                        (if (nil? (TypedGraphNodeIterator''current-1 this))
                            (Graph''getIterableNodeStart-2 (:graph this), (nth (:ids this) (:currentIdIndex this)))
                            (Graph''getIterableNodeNext-2 (:graph this), (:typeCacheNext (TypedGraphNodeIterator''current-1 this)))
                        )
                ]
                    (if (some? next)
                        (do
                            (TypedGraphNodeIterator''setCurrent-2 this, next)
                            this
                        )
                        (let [
                            this (update this :currentIdIndex inc)
                            this
                                (when (<= (count (:ids this)) (:currentIdIndex this)) => this
                                    (assoc this :currentIdIndex 0)
                                )
                        ]
                            (when (= (:currentIdIndex this) startIdx) => (recur this)
                                (assoc this :needsForward true)
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method- #_"Node" TypedGraphNodeIterator''current-1 [#_"TypedGraphNodeIterator<T extends IterableNodeType>" this]
        (nth (:current this) (:currentIdIndex this))
    )

    (§ method- #_"void" TypedGraphNodeIterator''setCurrent-2 [#_"TypedGraphNodeIterator<T extends IterableNodeType>" this, #_"Node" n]
        (aset (:current this) (:currentIdIndex this) n)
        nil
    )

    #_unused
    (§ override! #_"boolean" TypedGraphNodeIterator''hasNext-1 [#_"TypedGraphNodeIterator<T extends IterableNodeType>" this]
        (some? (TypedGraphNodeIterator''findNext-1 this))
    )

    #_unused
    (§ override! #_"T" TypedGraphNodeIterator''next-1 [#_"TypedGraphNodeIterator<T extends IterableNodeType>" this]
        (let [
            #_"Node" result (TypedGraphNodeIterator''findNext-1 this)
        ]
            (when (some? result) => (throw (NoSuchElementException.))
                (§ ass! this (assoc this :needsForward true))
                (§ cast #_"T" result)
            )
        )
    )
)

; @LIROpcode
(final-ns AMD64DeoptimizeOp (§ extends LIRInstruction) (§ implements BlockEndOp)
    (§ def #_"LIRInstructionClass<AMD64DeoptimizeOp>" AMD64DeoptimizeOp'TYPE (LIRInstructionClass'new-1 AMD64DeoptimizeOp))

    (§ defn #_"AMD64DeoptimizeOp" AMD64DeoptimizeOp'new-0 []
        (LIRInstruction'new-1 AMD64DeoptimizeOp'TYPE)
    )

    #_unused
    (§ override! #_"void" AMD64DeoptimizeOp''emitCode-2 [#_"AMD64DeoptimizeOp" this, #_"Assembler" asm]
        (AMD64Call'directCall-4 asm, (ForeignCalls''lookupForeignCall-2 HotSpot'foreignCalls, ForeignCallDescriptor'UNCOMMON_TRAP_HANDLER), nil, false)
        nil
    )
)

; @LIROpcode
(final-ns CRuntimeCallEpilogueOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<CRuntimeCallEpilogueOp>" CRuntimeCallEpilogueOp'TYPE (LIRInstructionClass'new-1 CRuntimeCallEpilogueOp))

    (§ final #_"int" :threadLastJavaSpOffset 0)
    (§ final #_"int" :threadLastJavaFpOffset 0)
    (§ final #_"int" :threadLastJavaPcOffset 0)
    (§ final #_"Register" :thread nil)

    (§ defn #_"CRuntimeCallEpilogueOp" CRuntimeCallEpilogueOp'new-4 [#_"int" threadLastJavaSpOffset, #_"int" threadLastJavaFpOffset, #_"int" threadLastJavaPcOffset, #_"Register" thread]
        (let [
            #_"CRuntimeCallEpilogueOp" this (LIRInstruction'new-1 CRuntimeCallEpilogueOp'TYPE)
            this (assoc this :threadLastJavaSpOffset threadLastJavaSpOffset)
            this (assoc this :threadLastJavaFpOffset threadLastJavaFpOffset)
            this (assoc this :threadLastJavaPcOffset threadLastJavaPcOffset)
            this (assoc this :thread thread)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" CRuntimeCallEpilogueOp''emitCode-2 [#_"CRuntimeCallEpilogueOp" this, #_"Assembler" asm]
        ;; reset last Java frame
        (Assembler''movslq-3 asm, (AMD64Address'new-2 (:thread this), (:threadLastJavaSpOffset this)), 0)
        (Assembler''movslq-3 asm, (AMD64Address'new-2 (:thread this), (:threadLastJavaFpOffset this)), 0)
        (Assembler''movslq-3 asm, (AMD64Address'new-2 (:thread this), (:threadLastJavaPcOffset this)), 0)
        nil
    )
)

; @LIROpcode
(final-ns CRuntimeCallPrologueOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<CRuntimeCallPrologueOp>" CRuntimeCallPrologueOp'TYPE (LIRInstructionClass'new-1 CRuntimeCallPrologueOp))

    (§ final #_"int" :threadLastJavaSpOffset 0)
    (§ final #_"Register" :thread nil)

    (§ defn #_"CRuntimeCallPrologueOp" CRuntimeCallPrologueOp'new-2 [#_"int" threadLastJavaSpOffset, #_"Register" thread]
        (let [
            #_"CRuntimeCallPrologueOp" this (LIRInstruction'new-1 CRuntimeCallPrologueOp'TYPE)
            this (assoc this :threadLastJavaSpOffset threadLastJavaSpOffset)
            this (assoc this :thread thread)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" CRuntimeCallPrologueOp''emitCode-2 [#_"CRuntimeCallPrologueOp" this, #_"Assembler" asm]
        ;; save last Java frame
        (Assembler''movq-3 asm, (AMD64Address'new-2 (:thread this), (:threadLastJavaSpOffset this)), AMD64/rsp)
        nil
    )
)

;;;
 ; Removes the current frame and tail calls the uncommon trap routine.
 ;;
; @LIROpcode
(final-ns DeoptimizeCallerOp (§ extends EpilogueBlockEndOp)
    (§ def #_"LIRInstructionClass<DeoptimizeCallerOp>" DeoptimizeCallerOp'TYPE (LIRInstructionClass'new-1 DeoptimizeCallerOp))

    (§ defn #_"DeoptimizeCallerOp" DeoptimizeCallerOp'new-0 []
        (EpilogueBlockEndOp'new-1 DeoptimizeCallerOp'TYPE)
    )

    #_unused
    (§ override! #_"void" DeoptimizeCallerOp''emitCode-2 [#_"DeoptimizeCallerOp" this, #_"Assembler" asm]
        (EpilogueBlockEndOp''leaveFrameAndRestoreRbp-2 this, asm)
        (AMD64Call'directJmp-2 asm, (ForeignCalls''lookupForeignCall-2 HotSpot'foreignCalls, ForeignCallDescriptor'UNCOMMON_TRAP_HANDLER))
        nil
    )
)

;;;
 ; A direct call that complies with the conventions for such calls in HotSpot. It doesn't use an
 ; inline cache so it's just a patchable call site.
 ;;
; @LIROpcode
(final-ns DirectStaticCallOp (§ extends DirectCallOp)
    (§ def #_"LIRInstructionClass<DirectStaticCallOp>" DirectStaticCallOp'TYPE (LIRInstructionClass'new-1 DirectStaticCallOp))

    (§ final #_"InvokeKind" :invokeKind nil)

    (§ defn #_"DirectStaticCallOp" DirectStaticCallOp'new-5 [#_"ResolvedJavaMethod" target, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps, #_"InvokeKind" invokeKind]
        (let [
            #_"DirectStaticCallOp" this (DirectCallOp'new-5 DirectStaticCallOp'TYPE, target, result, parameters, temps)
            this (assoc this :invokeKind invokeKind)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" DirectStaticCallOp''emitCode-2 [#_"DirectStaticCallOp" this, #_"Assembler" asm]
        (Assembler''recordMark-2 asm, (if (= (:invokeKind this) InvokeKind'Static) HotSpot'invokestaticMark HotSpot'invokespecialMark))
        (DirectCallOp''emitCode-2 (§ super ), asm)
        nil
    )
)

;;;
 ; A direct call that complies with the conventions for such calls in HotSpot. In particular, for
 ; calls using an inline cache, a MOVE instruction is emitted just prior to the aligned direct call.
 ;;
; @LIROpcode
(final-ns DirectVirtualCallOp (§ extends DirectCallOp)
    (§ def #_"LIRInstructionClass<DirectVirtualCallOp>" DirectVirtualCallOp'TYPE (LIRInstructionClass'new-1 DirectVirtualCallOp))

    (§ final #_"InvokeKind" :invokeKind nil)

    (§ defn #_"DirectVirtualCallOp" DirectVirtualCallOp'new-5 [#_"ResolvedJavaMethod" target, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps, #_"InvokeKind" invokeKind]
        (let [
            #_"DirectVirtualCallOp" this (DirectCallOp'new-5 DirectVirtualCallOp'TYPE, target, result, parameters, temps)
            this (assoc this :invokeKind invokeKind)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" DirectVirtualCallOp''emitCode-2 [#_"DirectVirtualCallOp" this, #_"Assembler" asm]
        ;; The mark for an invocation that uses an inline cache must be placed
        ;; at the instruction that loads the Klass from the inline cache.
        (Assembler''recordMark-2 asm, (if (= (:invokeKind this) InvokeKind'Virtual) HotSpot'invokevirtualMark HotSpot'invokeinterfaceMark))
        ;; This must be emitted exactly like this to ensure, it's patchable.
        (Assembler''movq-3 asm, AMD64/rax, HotSpot'nonOopBits)
        (DirectCallOp''emitCall-2 (§ super ), asm)
        nil
    )
)

(class-ns EpilogueBlockEndOp (§ extends LIRInstruction) (§ implements AMD64HotSpotRestoreRbpOp, BlockEndOp)
    (§ defn #_"EpilogueBlockEndOp" EpilogueBlockEndOp'new-1 [#_"LIRInstructionClass<? extends EpilogueBlockEndOp>" c]
        (LIRInstruction'new-1 c)
    )

    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :savedRbp AMD64HotSpotRestoreRbpOp'PLACEHOLDER)

    (§ method #_"void" EpilogueBlockEndOp''leaveFrameAndRestoreRbp-2 [#_"EpilogueBlockEndOp" this, #_"Assembler" asm]
        (EpilogueOp'leaveFrameAndRestoreRbp-2 (:savedRbp this), asm)
        nil
    )

    #_unused
    (§ override #_"void" EpilogueBlockEndOp''setSavedRbp-2 [#_"EpilogueBlockEndOp" this, #_"AllocatableValue" value]
        (§ ass! this (assoc this :savedRbp value))
        nil
    )
)

;;;
 ; Superclass for operations that use the value of RBP saved in a method's prologue.
 ;;
(class-ns EpilogueOp (§ extends LIRInstruction) (§ implements AMD64HotSpotRestoreRbpOp)
    #_unused
    (§ defn #_"EpilogueOp" EpilogueOp'new-1 [#_"LIRInstructionClass<? extends EpilogueOp>" c]
        (LIRInstruction'new-1 c)
    )

    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :savedRbp AMD64HotSpotRestoreRbpOp'PLACEHOLDER)

    #_unused
    (§ method #_"void" EpilogueOp''leaveFrameAndRestoreRbp-2 [#_"EpilogueOp" this, #_"Assembler" asm]
        (EpilogueOp'leaveFrameAndRestoreRbp-2 (:savedRbp this), asm)
        nil
    )

    (§ defn #_"void" EpilogueOp'leaveFrameAndRestoreRbp-2 [#_"AllocatableValue" savedRbp, #_"Assembler" asm]
        (if (instance? StackSlot savedRbp)
            (do
                ;; restoring RBP from the stack must be done before the frame is removed
                (Assembler''movq-3 asm, AMD64/rbp, (Assembler''asAddress-2 asm, savedRbp))
            )
            (let [
                #_"Register" framePointer (#_"RegisterValue" .getRegister savedRbp)
            ]
                (when-not (= framePointer AMD64/rbp)
                    (Assembler''movq-3 asm, AMD64/rbp, framePointer)
                )
            )
        )
        (FrameContext''leave-2 (:frameContext asm), asm)
        nil
    )

    #_unused
    (§ override #_"void" EpilogueOp''setSavedRbp-2 [#_"EpilogueOp" this, #_"AllocatableValue" value]
        (§ ass! this (assoc this :savedRbp value))
        nil
    )
)

;;;
 ; Utility for emitting the instruction to save RBP.
 ;
 ; @anno LIRGenerator.SaveRbp
 ;;
(final-ns SaveRbp
    (§ final #_"LIRGenerator" :gen nil)
    (§ final #_"NoOp" :placeholder nil)
    ;;;
     ; The slot reserved for saving RBP.
     ;;
    (§ final #_"StackSlot" :reservedSlot nil)

    (§ defn #_"SaveRbp" SaveRbp'new-2 [#_"LIRGenerator" gen, #_"NoOp" placeholder]
        (let [
            #_"SaveRbp" this (Object.)
            this (assoc this :gen gen)
            this (assoc this :placeholder placeholder)
            this (assoc this :reservedSlot (AMD64FrameMapBuilder''allocateRBPSpillSlot-1 (:frameMapBuilder (:res (:gen this)))))
        ]
            this
        )
    )

    ;;;
     ; Replaces this operation with the appropriate move for saving rbp.
     ;
     ; @param useStack specifies if rbp must be saved to the stack
     ;;
    (§ method! #_"AllocatableValue" SaveRbp''finalize-2 [#_"SaveRbp" this, #_"boolean" useStack]
        (let [
            #_"AllocatableValue" dst
                (if useStack
                    (:reservedSlot this)
                    (do
                        (AMD64FrameMapBuilder''freeRBPSpillSlot-1 (:frameMapBuilder (:res (:gen this))))
                        (LIRGenerator''newVariable-2 (:gen this), (LIRKind'value-1 AMD64Kind/QWORD))
                    )
                )
        ]
            (NoOp''replace-3 (:placeholder this), (:lir (:res (:gen this))), (MoveFromRegOp'new-3 AMD64Kind/QWORD, dst, (#_"Register" .asValue AMD64/rbp, (LIRKind'value-1 AMD64Kind/QWORD))))
            dst
        )
    )
)

(final-ns LoadConfigValueOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<LoadConfigValueOp>" LoadConfigValueOp'TYPE (LIRInstructionClass'new-1 LoadConfigValueOp))

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :result nil)

    (§ final #_"int" :markId 0)

    (§ defn #_"LoadConfigValueOp" LoadConfigValueOp'new-2 [#_"int" markId, #_"AllocatableValue" result]
        (let [
            #_"LoadConfigValueOp" this (LIRInstruction'new-1 LoadConfigValueOp'TYPE)
            this (assoc this :result result)
            this (assoc this :markId markId)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" LoadConfigValueOp''emitCode-2 [#_"LoadConfigValueOp" this, #_"Assembler" asm]
        (throw! "unimplemented")
    )
)

(value-ns AMD64HotSpotMove
    #_unused
    (§ defn #_"void" AMD64HotSpotMove'decodeKlassPointer-4 [#_"Assembler" asm, #_"Register" register, #_"Register" scratch, #_"AMD64Address" address]
        (let [
            #_"CompressEncoding" encoding HotSpot'klassEncoding
        ]
            (Assembler''movl-3 asm, register, address)
            (when-not (zero? (:shift encoding))
                (Assembler''shlq-3 asm, register, (:shift encoding))
            )
            (when (CompressEncoding''hasBase-1 encoding)
                (Assembler''movq-3 asm, scratch, (:base encoding))
                (Assembler''addq-3 asm, register, scratch)
            )
        )
        nil
    )
)

;;;
 ; @anno AMD64HotSpotMove.HotSpotLoadObjectConstantOp
 ;;
(final-ns HotSpotLoadObjectConstantOp (§ extends LIRInstruction) (§ implements LoadConstantOp)
    (§ def #_"LIRInstructionClass<HotSpotLoadObjectConstantOp>" HotSpotLoadObjectConstantOp'TYPE (LIRInstructionClass'new-1 HotSpotLoadObjectConstantOp))

    ; @Def({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :result nil)

    (§ final #_"HotSpotObjectConstant" :input nil)

    (§ defn #_"HotSpotLoadObjectConstantOp" HotSpotLoadObjectConstantOp'new-2 [#_"AllocatableValue" result, #_"HotSpotObjectConstant" input]
        (let [
            #_"HotSpotLoadObjectConstantOp" this (LIRInstruction'new-1 HotSpotLoadObjectConstantOp'TYPE)
            this (assoc this :result result)
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" HotSpotLoadObjectConstantOp''emitCode-2 [#_"HotSpotLoadObjectConstantOp" this, #_"Assembler" asm]
        (let [
            #_"boolean" compressed? (#_"HotSpotObjectConstant" .isCompressed (:input this))
        ]
            (if (.inlineObjects HotSpot'target)
                (do
                    (Assembler''recordInlineDataInCode-2 asm, (:input this))
                    (if (instance? RegisterValue (:result this))
                        (if compressed?
                            (Assembler''movl-3 asm, (#_"RegisterValue" .getRegister (:result this)), 0xdeaddead)
                            (Assembler''movq-3 asm, (#_"RegisterValue" .getRegister (:result this)), 0xdeaddeaddeaddead)
                        )
                        (if compressed?
                            (Assembler''movl-3 asm, (Assembler''asAddress-2 asm, (:result this)), 0xdeaddead)
                            (throw! "cannot store 64-bit constants to memory")
                        )
                    )
                )
                (when (instance? RegisterValue (:result this)) => (throw! "cannot directly store data patch to memory")
                    (let [
                        #_"AMD64Address" address (Assembler''recordDataReferenceInCode-3 asm, (:input this), (if compressed? 4 8))
                    ]
                        (if compressed?
                            (Assembler''movl-3 asm, (#_"RegisterValue" .getRegister (:result this)), address)
                            (Assembler''movq-3 asm, (#_"RegisterValue" .getRegister (:result this)), address)
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"Constant" HotSpotLoadObjectConstantOp''getConstant-1 [#_"HotSpotLoadObjectConstantOp" this]
        (:input this)
    )

    #_unused
    (§ override! #_"AllocatableValue" HotSpotLoadObjectConstantOp''getResult-1 [#_"HotSpotLoadObjectConstantOp" this]
        (:result this)
    )
)

;;;
 ; @anno AMD64HotSpotMove.BaseMove
 ;;
(final-ns BaseMove (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<BaseMove>" BaseMove'TYPE (LIRInstructionClass'new-1 BaseMove))

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)

    #_unused
    (§ defn #_"BaseMove" BaseMove'new-1 [#_"AllocatableValue" result]
        (let [
            #_"BaseMove" this (LIRInstruction'new-1 BaseMove'TYPE)
            this (assoc this :result result)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" BaseMove''emitCode-2 [#_"BaseMove" this, #_"Assembler" asm]
        (Assembler''movq-3 asm, (#_"RegisterValue" .getRegister (:result this)), (Assembler'createPlaceholder-1 -1))
        (Assembler''recordMark-2 asm, HotSpot'narrowKlassBaseAddressMark)
        nil
    )
)

;;;
 ; @anno AMD64HotSpotMove.HotSpotLoadMetaspaceConstantOp
 ;;
(final-ns HotSpotLoadMetaspaceConstantOp (§ extends LIRInstruction) (§ implements LoadConstantOp)
    (§ def #_"LIRInstructionClass<HotSpotLoadMetaspaceConstantOp>" HotSpotLoadMetaspaceConstantOp'TYPE (LIRInstructionClass'new-1 HotSpotLoadMetaspaceConstantOp))

    ; @Def({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :result nil)

    (§ final #_"HotSpotMetaspaceConstant" :input nil)

    (§ defn #_"HotSpotLoadMetaspaceConstantOp" HotSpotLoadMetaspaceConstantOp'new-2 [#_"AllocatableValue" result, #_"HotSpotMetaspaceConstant" input]
        (let [
            #_"HotSpotLoadMetaspaceConstantOp" this (LIRInstruction'new-1 HotSpotLoadMetaspaceConstantOp'TYPE)
            this (assoc this :result result)
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" HotSpotLoadMetaspaceConstantOp''emitCode-2 [#_"HotSpotLoadMetaspaceConstantOp" this, #_"Assembler" asm]
        (let [
            #_"boolean" compressed? (#_"HotSpotMetaspaceConstant" .isCompressed (:input this))
        ]
            (if (instance? RegisterValue (:result this))
                (if compressed?
                    (do
                        (Assembler''recordInlineDataInCode-2 asm, (:input this))
                        (Assembler''movl-3 asm, (#_"RegisterValue" .getRegister (:result this)), 0xdeaddead)
                    )
                    (do
                        (Assembler''recordInlineDataInCode-2 asm, (:input this))
                        (Assembler''movq-3 asm, (#_"RegisterValue" .getRegister (:result this)), 0xdeaddeaddeaddead)
                    )
                )
                (when compressed? => (throw! "cannot store 64-bit constants to memory")
                    (do
                        (Assembler''recordInlineDataInCode-2 asm, (:input this))
                        (Assembler''movl-3 asm, (Assembler''asAddress-2 asm, (:result this)), 0xdeaddead)
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"Constant" HotSpotLoadMetaspaceConstantOp''getConstant-1 [#_"HotSpotLoadMetaspaceConstantOp" this]
        (:input this)
    )

    #_unused
    (§ override! #_"AllocatableValue" HotSpotLoadMetaspaceConstantOp''getResult-1 [#_"HotSpotLoadMetaspaceConstantOp" this]
        (:result this)
    )
)

(final-ns LIRBuilder
    (§ final #_"LIRGenerator" :gen nil)

    (§ final #_"NodeMap<Value>" :nodeOperands nil)
    (§ final #_"LockStackHolder" :lockStackHolder nil)

    (§ mutable #_"ValueNode" :currentInstruction nil)

    (§ defn #_"LIRBuilder" LIRBuilder'new-2 [#_"Graph" graph, #_"LIRGenerator" gen]
        (let [
            #_"LIRBuilder" this (Object.)
            this (assoc this :gen gen)
            this (assoc this :nodeOperands (NodeMap'new-1 graph))
            this (assoc this :lockStackHolder (LockStackHolder'new-1 (LockStack'new-2 (:frameMapBuilder (:res gen)), (LIRKind'value-1 AMD64Kind/QWORD))))
            (§ ass! gen (LIRGenerator''setLockStackHolder-2 gen, (:lockStackHolder this)))
        ]
            this
        )
    )

    ;;;
     ; Associates {@code operand} with the {@code node} in the current block.
     ;
     ; @return {@code operand}
     ;;
    (§ method! #_"Value" LIRBuilder''setResult-3 [#_"LIRBuilder" this, #_"ValueNode" node, #_"Value" operand]
        (NodeMap''set-3 (:nodeOperands this), node, operand)
        operand
    )

    (§ method- #_"Value" LIRBuilder''getOperand-2 [#_"LIRBuilder" this, #_"Node" node]
        (when (some? (:nodeOperands this)) (NodeMap''get-2 (:nodeOperands this), node))
    )

    ;;;
     ; Returns the operand that has been previously initialized by #setResult(ValueNode, Value) with the result of
     ; an instruction. It's a code generation error to ask for the operand of ValueNode that doesn't have one yet.
     ;
     ; @param node A node that produces a result value.
     ;;
    (§ method! #_"Value" LIRBuilder''operand-2 [#_"LIRBuilder" this, #_"Node" node]
        (LIRBuilder''getOperand-2 this, node)
    )

    ;;;
     ; Returns true if there is an {@link Value operand} associated with the {@code node} in the current block.
     ;;
    (§ method! #_"boolean" LIRBuilder''hasOperand-2 [#_"LIRBuilder" this, #_"Node" node]
        (some? (LIRBuilder''getOperand-2 this, node))
    )

    (§ method! #_"LabelRef" LIRBuilder''getLIRBlock-2 [#_"LIRBuilder" this, #_"FixedNode" node]
        (let [
            #_"Block" block (ControlFlowGraph''blockFor-2 (:cfg (:lir (:res (:gen this)))), node)
        ]
            (loop-when [#_"int" i 0 #_"ISeq" s (seq (:successors (:currentBlock (:gen this))))] (some? s) => (throw! "Block not in successor list of current block")
                (if (= (first s) block)
                    (LabelRef'forSuccessor-3 (:lir (:res (:gen this))), (:currentBlock (:gen this)), i)
                    (recur (inc i) (next s))
                )
            )
        )
    )

    (§ method! #_"LIRKind" LIRBuilder''getExactPhiKind-2 [#_"LIRBuilder" this, #_"PhiNode" phi]
        ;; collect reference information
        (loop-when [#_"LIRKind" derivedKind (LIRGenerator''toRegisterKind-2 (:gen this), (Stamp''getLIRKind-1 (:stamp phi))) #_"int" i 0] (and (< i (PhiNode''valueCount-1 phi)) (not (LIRKind''isUnknownReference-1 derivedKind))) => derivedKind
            (let [
                #_"ValueNode" node (PhiNode''valueAt-2 phi, i)
                #_"Value" value (LIRBuilder''getOperand-2 this, node)
                ;; get ValueKind for input
                #_"LIRKind" valueKind
                    (if (some? value)
                        (#_"Value" .getValueKind value, LIRKind)
                        (LIRGenerator''toRegisterKind-2 (:gen this), (Stamp''getLIRKind-1 (:stamp node)))
                    )
            ]
                ;; merge the reference information of the derived kind and the input
                (recur (LIRKind'mergeReferenceInformation-2 derivedKind, valueKind) (inc i))
            )
        )
    )

    #_unused
    (§ defn- #_"boolean" LIRBuilder'isPhiInputFromBackedge-2 [#_"PhiNode" phi, #_"int" index]
        (let [
            #_"AbstractMergeNode" merge (PhiNode''merge-1 phi)
            #_"AbstractEndNode" end (AbstractMergeNode''phiPredecessorAt-2 merge, index)
        ]
            (and (instance? LoopEndNode end) (= (:loopBegin end) merge))
        )
    )

    (§ method- #_"Value[]" LIRBuilder''createPhiIn-2 [#_"LIRBuilder" this, #_"AbstractMergeNode" merge]
        (let [
            #_"List<Value>" values (ArrayList.)
        ]
            (doseq [#_"ValuePhiNode" phi (AbstractMergeNode''valuePhis-1 merge)]
                (let [
                    #_"Variable" value (LIRGenerator''newVariable-2 (:gen this), (LIRBuilder''getExactPhiKind-2 this, phi))
                ]
                    (#_"List" .add values, value)
                    (LIRBuilder''setResult-3 this, phi, value)
                )
            )
            (#_"List" .toArray values, (make-array Value (count values)))
        )
    )

    ;;;
     ; @return true if object constant to stack moves are supported
     ;;
    (§ method! #_"boolean" LIRBuilder''allowObjectConstantToStackMove-1 [#_"LIRBuilder" this]
        true
    )

    (§ method- #_"Value[]" LIRBuilder''createPhiOut-3 [#_"LIRBuilder" this, #_"AbstractMergeNode" merge, #_"AbstractEndNode" pred]
        (let [
            #_"List<Value>" values (ArrayList.)
        ]
            (doseq [#_"PhiNode" phi (AbstractMergeNode''valuePhis-1 merge)]
                (let [
                    #_"ValueNode" node (PhiNode''valueAt-2 phi, pred)
                    #_"Value" value (LIRBuilder''operand-2 this, node)
                ]
                    (cond
                        (instance? RegisterValue value)
                            ;; Fixed register intervals are not allowed at block boundaries so we introduce a new Variable.
                            (§ ass value (LIRGenerator''emitMove-2 (:gen this), value))
                        (and (not (LIRBuilder''allowObjectConstantToStackMove-1 this)) (instance? ConstantNode node) (not (LIRKind'isValue-1 value)))
                            ;; Some constants are not allowed as inputs for PHIs in certain backends. Explicitly create
                            ;; a copy of this value to force it into a register. The new variable is only used in the PHI.
                            (let [
                                #_"Variable" result (LIRGenerator''newVariable-2 (:gen this), (#_"Value" .getValueKind value))
                            ]
                                (LIRGenerator''emitMove-3 (:gen this), result, value)
                                (§ ass value result)
                            )
                    )
                    (#_"List" .add values, value)
                )
            )
            (#_"List" .toArray values, (make-array Value (count values)))
        )
    )

    (§ method! #_"boolean" LIRBuilder''peephole-2 [#_"LIRBuilder" this, #_"ValueNode" valueNode]
        (and (instance? IntegerDivRemNode valueNode)
            (let [
                #_"IntegerDivRemNode" divRem valueNode
            ]
                (loop [#_"FixedNode" node (:next divRem)]
                    (let [
                        node
                            (condp instance? node
                                IfNode
                                    (case (:trueSuccessorProbability node)
                                        1.0 (:trueSuccessor node)
                                        0.0 (:falseSuccessor node)
                                        nil
                                    )
                                FixedWithNextNode
                                    node
                                nil
                            )
                    ]
                        (and (some? node)
                            (let [
                                #_"boolean" found?
                                    (and (instance? IntegerDivRemNode node)
                                         (not= (IntegerDivRemNode''getOp-1 divRem) (IntegerDivRemNode''getOp-1 node))
                                         (= (IntegerDivRemNode''getType-1 divRem) (IntegerDivRemNode''getType-1 node))
                                         (= (:x node) (:x divRem)) (= (:y node) (:y divRem)) (not (LIRBuilder''hasOperand-2 this, node))
                                    )
                            ]
                                (when found? => (recur (:next node))
                                    (let [
                                        #_"Value[]" pair
                                            (condp = (IntegerDivRemNode''getType-1 divRem)
                                                Signedness'SIGNED
                                                    (LIRGenerator''emitSignedDivRem-3 (:gen this), (LIRBuilder''operand-2 this, (:x divRem)), (LIRBuilder''operand-2 this, (:y divRem)))
                                                Signedness'UNSIGNED
                                                    (LIRGenerator''emitUnsignedDivRem-3 (:gen this), (LIRBuilder''operand-2 this, (:x divRem)), (LIRBuilder''operand-2 this, (:y divRem)))
                                            )
                                    ]
                                        (condp = (IntegerDivRemNode''getOp-1 divRem)
                                            DivRemOp'DIV
                                            (do
                                                (LIRBuilder''setResult-3 this, divRem, (nth pair 0))
                                                (LIRBuilder''setResult-3 this, node, (nth pair 1))
                                            )
                                            DivRemOp'REM
                                            (do
                                                (LIRBuilder''setResult-3 this, divRem, (nth pair 1))
                                                (LIRBuilder''setResult-3 this, node, (nth pair 0))
                                            )
                                        )
                                        true
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"void" LIRBuilder''doBlockPrologue-2 [#_"LIRBuilder" this, #_"Block" block]
        (when GraalOptions'mitigateSpeculativeExecutionAttacks
            (let [
                #_"boolean" hasControlSplitPredecessor
                    (loop-when [#_"ISeq" s (seq (:predecessors block))] (some? s) => false
                        (or (< 1 (count (:successors (first s))))
                            (recur (next s))
                        )
                    )
            ]
                (when (or hasControlSplitPredecessor (empty? (:predecessors block)))
                    (LIRGenerator''emitLFence-1 (:gen this))
                )
            )
        )
        nil
    )

    ; @SuppressWarnings("try")
    (§ method! #_"LIRBuilder" LIRBuilder''doBlock-4 [#_"LIRBuilder" this, #_"Block" block, #_"Graph" graph, #_"BlockMap<List<Node>>" blockMap]
        (try (§ with [#_"BlockScope" _ (LIRGenerator''getBlockScope-2 (:gen this), block)])
            (if (= block (ControlFlowGraph''getStartBlock-1 (:cfg (:lir (:res (:gen this))))))
                (LIRBuilder''emitPrologue-2 this, graph)
                ;; create phi-in value array
                (when (instance? AbstractMergeNode (:beginNode block))
                    (let [
                        #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:res (:gen this))), block)
                    ]
                        (§ ass! (nth ops 0) (LabelOp''setPhiValues-2 (nth ops 0), (LIRBuilder''createPhiIn-2 this, (:beginNode block))))
                    )
                )
            )
            (LIRBuilder''doBlockPrologue-2 this, block)
            (let [
                #_"List<Node>" nodes (BlockMap''get-2 blockMap, block)
            ]
                (doseq [#_"Node" node nodes]
                    ;; => there can be cases in which the result of an instruction is already set before by other instructions
                    (when (and (instance? ValueNode node) (nil? (LIRBuilder''getOperand-2 this, node)) (not (LIRBuilder''peephole-2 this, node)))
                        (§ ass! this (assoc this :currentInstruction node))
                        (LIRBuilder''emitNode-2 this, node)
                    )
                )
                (when-not (LIRGenerator''hasBlockEnd-2 (:gen this), block)
                    (let [
                        #_"NodeIterable<Node>" successors (Node''successors-1 (:endNode block))
                    ]
                        ;; If we have more than one successor, we cannot just use the first one.
                        ;; Since successors are unordered, this would be a random choice.
                        (when (= (count (:successors block)) 1) => (throw! (str "Block without BlockEndOp: " (:endNode block)))
                            (LIRGenerator''emitJump-2 (:gen this), (LIRBuilder''getLIRBlock-2 this, (NodeIterable''first-1 successors)))
                        )
                    )
                )
                this
            )
        )
    )

    (§ method! #_"void" LIRBuilder''emitNode-2 [#_"LIRBuilder" this, #_"ValueNode" node]
        (when (instance? LIRLowerable node) => (throw! (str "node is not LIRLowerable: " node))
            (LIRLowerable''generate-2 node, this)
        )
        nil
    )

    (§ method! #_"void" LIRBuilder''emitPrologue-2 [#_"LIRBuilder" this, #_"Graph" graph]
        (let [
            #_"CallingConvention" args (:callingConvention (:res (:gen this)))
            #_"Value[]" params (make-array Value (inc (#_"CallingConvention" .getArgumentCount args)))
        ]
            (dotimes [#_"int" i (dec (count params))]
                (let [
                    #_"AllocatableValue" arg (#_"CallingConvention" .getArgument args, i)
                ]
                    (aset params i arg)
                    (when (and (instance? StackSlot arg) (#_"StackSlot" .isInCallerFrame arg) (not (:hasArgInCallerFrame (:lir (:res (:gen this))))))
                        (§ ass! (:lir (:res (:gen this))) (LIR''setHasArgInCallerFrame-1 (:lir (:res (:gen this)))))
                    )
                )
            )
            (aset params (dec (count params)) (#_"Register" .asValue AMD64/rbp, (LIRKind'value-1 AMD64Kind/QWORD)))

            (LIRGenerator''emitIncomingValues-2 (:gen this), params)
            (§ ass! (:gen this) (LIRGenerator''emitSaveRbp-1 (:gen this)))
            (LIRGenerator''append-2 (:gen this), (:lockStack (:lockStackHolder this)))
            (doseq [#_"ParameterNode" param (Graph''getNodes-2 graph, ParameterNode'TYPE)]
                (LIRBuilder''setResult-3 this, param, (LIRGenerator''emitMove-2 (:gen this), (nth params (AbstractLocalNode''index-1 param))))
            )
        )
        nil
    )

    (§ method! #_"void" LIRBuilder''visitMerge-2 [#_"LIRBuilder" this, #_"AbstractMergeNode" node]
        nil
    )

    (§ method! #_"void" LIRBuilder''visitEndNode-2 [#_"LIRBuilder" this, #_"AbstractEndNode" node]
        (let [
            #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 node)
            #_"JumpOp" jump (LIRBuilder''newJumpOp-2 this, (LIRBuilder''getLIRBlock-2 this, merge))
        ]
            (§ ass! jump (JumpOp''setPhiValues-2 jump, (LIRBuilder''createPhiOut-3 this, merge, node)))
            (LIRGenerator''append-2 (:gen this), jump)
        )
        nil
    )

    ;;;
     ; Runtime specific classes can override this to insert a safepoint at the end of a loop.
     ;;
    (§ method! #_"void" LIRBuilder''visitLoopEnd-2 [#_"LIRBuilder" this, #_"LoopEndNode" node]
        nil
    )

    (§ method! #_"void" LIRBuilder''visitSafepointNode-2 [#_"LIRBuilder" this, #_"SafepointNode" node]
        (LIRGenerator''append-2 (:gen this), (SafepointOp'new-2 this, HotSpot'threadRegister))
        nil
    )

    (§ method! #_"JumpOp" LIRBuilder''newJumpOp-2 [#_"LIRBuilder" this, #_"LabelRef" ref]
        (JumpOp'new-1 ref)
    )

    #_unused
    (§ method! #_"LIRKind" LIRBuilder''getPhiKind-2 [#_"LIRBuilder" this, #_"PhiNode" phi]
        (Stamp''getLIRKind-1 (:stamp phi))
    )

    (§ method! #_"void" LIRBuilder''emitBranch-5 [#_"LIRBuilder" this, #_"LogicNode" node, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor, #_"double" trueSuccessorProbability]
        (condp instance? node
            IsNullNode        (LIRBuilder''emitNullCheckBranch-5 this, node, trueSuccessor, falseSuccessor, trueSuccessorProbability)
            CompareNode       (LIRBuilder''emitCompareBranch-5 this, node, trueSuccessor, falseSuccessor, trueSuccessorProbability)
            LogicConstantNode (LIRBuilder''emitConstantBranch-4 this, (:value node), trueSuccessor, falseSuccessor)
            IntegerTestNode   (LIRBuilder''emitIntegerTestBranch-5 this, node, trueSuccessor, falseSuccessor, trueSuccessorProbability)
        )
        nil
    )

    (§ method! #_"void" LIRBuilder''emitIf-2 [#_"LIRBuilder" this, #_"IfNode" node]
        (LIRBuilder''emitBranch-5 this, (:condition node), (LIRBuilder''getLIRBlock-2 this, (:trueSuccessor node)), (LIRBuilder''getLIRBlock-2 this, (:falseSuccessor node)), (IfNode''probability-2 node, (:trueSuccessor node)))
        nil
    )

    (§ method- #_"void" LIRBuilder''emitNullCheckBranch-5 [#_"LIRBuilder" this, #_"IsNullNode" node, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor, #_"double" trueSuccessorProbability]
        (let [
            #_"LIRKind" kind (Stamp''getLIRKind-1 (:stamp (UnaryOpLogicNode''getValue-1 node)))
            #_"Value" nullValue (LIRGenerator''emitConstant-3 (:gen this), kind, JavaConstant/NULL_POINTER)
        ]
            (LIRGenerator''emitCompareBranch-8 (:gen this), (#_"ValueKind" .getPlatformKind kind), (LIRBuilder''operand-2 this, (UnaryOpLogicNode''getValue-1 node)), nullValue, Condition'EQ, trueSuccessor, falseSuccessor, trueSuccessorProbability)
        )
        nil
    )

    (§ method! #_"void" LIRBuilder''emitCompareBranch-5 [#_"LIRBuilder" this, #_"CompareNode" compare, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor, #_"double" trueSuccessorProbability]
        (let [
            #_"PlatformKind" kind (#_"ValueKind" .getPlatformKind (Stamp''getLIRKind-1 (:stamp (:x compare))))
        ]
            (LIRGenerator''emitCompareBranch-8 (:gen this), kind, (LIRBuilder''operand-2 this, (:x compare)), (LIRBuilder''operand-2 this, (:y compare)), (:condition (CompareNode''condition-1 compare)), trueSuccessor, falseSuccessor, trueSuccessorProbability)
        )
        nil
    )

    (§ method! #_"void" LIRBuilder''emitIntegerTestBranch-5 [#_"LIRBuilder" this, #_"IntegerTestNode" test, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor, #_"double" trueSuccessorProbability]
        (LIRGenerator''emitIntegerTestBranch-6 (:gen this), (LIRBuilder''operand-2 this, (:x test)), (LIRBuilder''operand-2 this, (:y test)), trueSuccessor, falseSuccessor, trueSuccessorProbability)
        nil
    )

    (§ method! #_"void" LIRBuilder''emitConstantBranch-4 [#_"LIRBuilder" this, #_"boolean" value?, #_"LabelRef" trueSuccessor, #_"LabelRef" falseSuccessor]
        (LIRGenerator''emitJump-2 (:gen this), (if value? trueSuccessor falseSuccessor))
        nil
    )

    (§ method! #_"Variable" LIRBuilder''emitConditional-4 [#_"LIRBuilder" this, #_"LogicNode" node, #_"Value" trueValue, #_"Value" falseValue]
        (condp instance? node
            IsNullNode
                (let [
                    #_"LIRKind" kind (Stamp''getLIRKind-1 (:stamp (UnaryOpLogicNode''getValue-1 node)))
                    #_"Value" nullValue (LIRGenerator''emitConstant-3 (:gen this), kind, JavaConstant/NULL_POINTER)
                ]
                    (LIRGenerator''emitConditionalMove-7 (:gen this), (#_"ValueKind" .getPlatformKind kind), (LIRBuilder''operand-2 this, (UnaryOpLogicNode''getValue-1 node)), nullValue, Condition'EQ, trueValue, falseValue)
                )
            CompareNode
                (let [
                    #_"PlatformKind" kind (#_"ValueKind" .getPlatformKind (Stamp''getLIRKind-1 (:stamp (:x node))))
                ]
                    (LIRGenerator''emitConditionalMove-7 (:gen this), kind, (LIRBuilder''operand-2 this, (:x node)), (LIRBuilder''operand-2 this, (:y node)), (:condition (CompareNode''condition-1 node)), trueValue, falseValue)
                )
            LogicConstantNode
                (LIRGenerator''emitMove-2 (:gen this), (if (:value node) trueValue falseValue))
            IntegerTestNode
                (LIRGenerator''emitIntegerTestMove-5 (:gen this), (LIRBuilder''operand-2 this, (:x node)), (LIRBuilder''operand-2 this, (:y node)), trueValue, falseValue)
        )
    )

    (§ method! #_"void" LIRBuilder''emitConditional-2 [#_"LIRBuilder" this, #_"ConditionalNode" conditional]
        (let [
            #_"Value" trueValue (LIRBuilder''operand-2 this, (:trueValue conditional))
            #_"Value" falseValue (LIRBuilder''operand-2 this, (:falseValue conditional))
        ]
            (LIRBuilder''setResult-3 this, conditional, (LIRBuilder''emitConditional-4 this, (:condition conditional), trueValue, falseValue))
        )
        nil
    )

    (§ method! #_"void" LIRBuilder''emitOverflowCheckBranch-5 [#_"LIRBuilder" this, #_"AbstractBeginNode" overflowSuccessor, #_"AbstractBeginNode" next, #_"Stamp" stamp, #_"double" probability]
        (LIRGenerator''emitOverflowCheckBranch-5 (:gen this), (LIRBuilder''getLIRBlock-2 this, overflowSuccessor), (LIRBuilder''getLIRBlock-2 this, next), (Stamp''getLIRKind-1 stamp), probability)
        nil
    )

    ;;;
     ; This method tries to create a switch implementation that is optimal for the given switch. It
     ; will either generate a sequential if/then/else cascade, a set of range tests or a table switch.
     ;
     ; If the given switch does not contain int keys, it will always create a sequential implementation.
     ;;
    (§ method! #_"void" LIRBuilder''emitSwitch-2 [#_"LIRBuilder" this, #_"SwitchNode" node]
        (let [
            #_"LabelRef" defaultTarget (LIRBuilder''getLIRBlock-2 this, (SwitchNode''defaultSuccessor-1 node))
            #_"int" keyCount (count (:keys node))
        ]
            (if (zero? keyCount)
                (LIRGenerator''emitJump-2 (:gen this), defaultTarget)
                (let [
                    #_"Variable" value (LIRGenerator''load-2 (:gen this), (LIRBuilder''operand-2 this, (SwitchNode''value-1 node)))
                ]
                    (cond
                        (= keyCount 1)
                            (let [
                                #_"double" probability (SwitchNode''probability-2 node, (SwitchNode''keySuccessor-2 node, 0))
                                #_"LIRKind" kind (Stamp''getLIRKind-1 (:stamp (SwitchNode''value-1 node)))
                                #_"Value" key (LIRGenerator''emitConstant-3 (:gen this), kind, (SwitchNode''keyAt-2 node, 0))
                            ]
                                (LIRGenerator''emitCompareBranch-8 (:gen this), (#_"ValueKind" .getPlatformKind kind), (LIRGenerator''load-2 (:gen this), (LIRBuilder''operand-2 this, (SwitchNode''value-1 node))), key, Condition'EQ, (LIRBuilder''getLIRBlock-2 this, (SwitchNode''keySuccessor-2 node, 0)), defaultTarget, probability)
                            )
                        (and (instance? IntegerSwitchNode node) (SwitchNode''isSorted-1 node))
                            (let [
                                #_"LabelRef[]" keyTargets (make-array LabelRef keyCount)
                                #_"JavaConstant[]" keyConstants (make-array JavaConstant keyCount)
                                #_"double[]" keyProbabilities (double-array keyCount)
                                #_"JavaKind" keyKind (#_"JavaConstant" .getJavaKind (IntegerSwitchNode''keyAt-2 node, 0))
                            ]
                                (dotimes [#_"int" i keyCount]
                                    (aset keyTargets i (LIRBuilder''getLIRBlock-2 this, (SwitchNode''keySuccessor-2 node, i)))
                                    (aset keyConstants i (IntegerSwitchNode''keyAt-2 node, i))
                                    (aset keyProbabilities i (SwitchNode''keyProbability-2 node, i))
                                )
                                (LIRGenerator''emitStrategySwitch-6 (:gen this), keyConstants, keyProbabilities, keyTargets, defaultTarget, value)
                            )
                        :else
                            ;; keyKind != JavaKind.Int || !node.isSorted()
                            (let [
                                #_"LabelRef[]" keyTargets (make-array LabelRef keyCount)
                                #_"Constant[]" keyConstants (make-array Constant keyCount)
                                #_"double[]" keyProbabilities (double-array keyCount)
                            ]
                                (dotimes [#_"int" i keyCount]
                                    (aset keyTargets i (LIRBuilder''getLIRBlock-2 this, (SwitchNode''keySuccessor-2 node, i)))
                                    (aset keyConstants i (SwitchNode''keyAt-2 node, i))
                                    (aset keyProbabilities i (SwitchNode''keyProbability-2 node, i))
                                )

                                ;; hopefully only a few entries
                                (LIRGenerator''emitStrategySwitch-5 (:gen this), (SequentialStrategy'new-2 keyProbabilities, keyConstants), value, keyTargets, defaultTarget)
                            )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"Value[]" LIRBuilder''visitInvokeArguments-3 [#_"LIRBuilder" this, #_"CallingConvention" invokeCc, #_"Collection<ValueNode>" arguments]
        ;; for each argument, load it into the correct location
        (let [
            #_"Value[]" args (make-array Value (count arguments))
        ]
            (loop-when [#_"int" j 0 #_"ISeq" s (seq arguments)] (some? s)
                (let [
                    #_"ValueNode" arg (first s)
                ]
                    (when (some? arg) => (throw! "I thought we no longer have nil entries for two-slot types...")
                        (let [
                            #_"AllocatableValue" operand (#_"CallingConvention" .getArgument invokeCc, j)
                        ]
                            (LIRGenerator''emitMove-3 (:gen this), operand, (LIRBuilder''operand-2 this, arg))
                            (aset args j operand)
                            (recur (inc j) (next s))
                        )
                    )
                )
            )
            args
        )
    )

    (§ method- #_"void" LIRBuilder''emitDirectCall-5 [#_"LIRBuilder" this, #_"DirectCallTargetNode" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (let [
            #_"InvokeKind" invokeKind (CallTargetNode''invokeKind-1 callTarget)
        ]
            (if (InvokeKind''isIndirect-1 invokeKind)
                (LIRGenerator''append-2 (:gen this), (DirectVirtualCallOp'new-5 (CallTargetNode''targetMethod-1 callTarget), result, parameters, temps, invokeKind))
                (let [
                    #_"HotSpotResolvedJavaMethod" resolvedMethod (CallTargetNode''targetMethod-1 callTarget)
                ]
                    (LIRGenerator''append-2 (:gen this), (DirectStaticCallOp'new-5 (CallTargetNode''targetMethod-1 callTarget), result, parameters, temps, invokeKind))
                )
            )
        )
        nil
    )

    (§ method- #_"void" LIRBuilder''emitIndirectCall-5 [#_"LIRBuilder" this, #_"IndirectCallTargetNode" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (if (instance? HotSpotIndirectCallTargetNode callTarget)
            (let [
                #_"Value" metaspaceMethodSrc (LIRBuilder''operand-2 this, (:metaspaceMethod callTarget))
                #_"Value" targetAddressSrc (LIRBuilder''operand-2 this, (:computedAddress callTarget))
                #_"AllocatableValue" metaspaceMethodDst (#_"Register" .asValue AMD64/rbx, (#_"Value" .getValueKind metaspaceMethodSrc))
                #_"AllocatableValue" targetAddressDst (#_"Register" .asValue AMD64/rax, (#_"Value" .getValueKind targetAddressSrc))
            ]
                (LIRGenerator''emitMove-3 (:gen this), metaspaceMethodDst, metaspaceMethodSrc)
                (LIRGenerator''emitMove-3 (:gen this), targetAddressDst, targetAddressSrc)
                (LIRGenerator''append-2 (:gen this), (AMD64IndirectCallOp'new-6 (CallTargetNode''targetMethod-1 callTarget), result, parameters, temps, metaspaceMethodDst, targetAddressDst))
            )
            (let [
                #_"Value" targetAddressSrc (LIRBuilder''operand-2 this, (:computedAddress callTarget))
                #_"AllocatableValue" targetAddress (#_"Register" .asValue AMD64/rax, (#_"Value" .getValueKind targetAddressSrc))
            ]
                (LIRGenerator''emitMove-3 (:gen this), targetAddress, targetAddressSrc)
                (LIRGenerator''append-2 (:gen this), (IndirectCallOp'new-5 (CallTargetNode''targetMethod-1 callTarget), result, parameters, temps, targetAddress))
            )
        )
        nil
    )

    (§ method! #_"void" LIRBuilder''emitInvoke-2 [#_"LIRBuilder" this, #_"InvokeNode" invoke]
        (let [
            #_"LoweredCallTargetNode" callTarget (:callTarget invoke)
            #_"FrameMapBuilder" frameMapBuilder (:frameMapBuilder (:res (:gen this)))
            #_"CallingConvention" invokeCc (#_"RegisterConfig" .getCallingConvention HotSpot'registerConfig, (LoweredCallTargetNode''callType-1 callTarget), (Stamp''javaType-1 (:stamp invoke)), (LoweredCallTargetNode''signature-1 callTarget), HotSpot'valueKindFactory)
        ]
            (FrameMapBuilder''callsMethod-2 frameMapBuilder, invokeCc)

            (let [
                #_"Value[]" parameters (LIRBuilder''visitInvokeArguments-3 this, invokeCc, (CallTargetNode''arguments-1 callTarget))
                #_"Value" result (#_"CallingConvention" .getReturn invokeCc)
            ]
                (condp instance? callTarget
                    DirectCallTargetNode   (LIRBuilder''emitDirectCall-5 this, callTarget, result, parameters, AllocatableValue/NONE)
                    IndirectCallTargetNode (LIRBuilder''emitIndirectCall-5 this, callTarget, result, parameters, AllocatableValue/NONE)
                )

                (when-not (= result Value/ILLEGAL)
                    (LIRBuilder''setResult-3 this, invoke, (LIRGenerator''emitMove-2 (:gen this), result))
                )
            )
        )
        nil
    )
)

;;;
 ; Pushes an interpreter frame to the stack.
 ;;
; @LIROpcode
(final-ns PushInterpreterFrameOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<PushInterpreterFrameOp>" PushInterpreterFrameOp'TYPE (LIRInstructionClass'new-1 PushInterpreterFrameOp))

    ; @Alive(OperandFlag'REG)
    (§ mutable #_"AllocatableValue" :frameSize nil)
    ; @Alive(OperandFlag'REG)
    (§ mutable #_"AllocatableValue" :framePc nil)
    ; @Alive(OperandFlag'REG)
    (§ mutable #_"AllocatableValue" :senderSp nil)
    ; @Alive(OperandFlag'REG)
    (§ mutable #_"AllocatableValue" :initialInfo nil)

    #_unused
    (§ defn #_"PushInterpreterFrameOp" PushInterpreterFrameOp'new-4 [#_"AllocatableValue" frameSize, #_"AllocatableValue" framePc, #_"AllocatableValue" senderSp, #_"AllocatableValue" initialInfo]
        (let [
            #_"PushInterpreterFrameOp" this (LIRInstruction'new-1 PushInterpreterFrameOp'TYPE)
            this (assoc this :frameSize frameSize)
            this (assoc this :framePc framePc)
            this (assoc this :senderSp senderSp)
            this (assoc this :initialInfo initialInfo)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" PushInterpreterFrameOp''emitCode-2 [#_"PushInterpreterFrameOp" this, #_"Assembler" asm]
        (let [
            #_"Register" frameSizeRegister (#_"RegisterValue" .getRegister (:frameSize this))
            #_"Register" framePcRegister (#_"RegisterValue" .getRegister (:framePc this))
            #_"Register" senderSpRegister (#_"RegisterValue" .getRegister (:senderSp this))
            #_"Register" initialInfoRegister (#_"RegisterValue" .getRegister (:initialInfo this))
            #_"int" wordSize 8
        ]
            ;; we'll push PC and BP by hand
            (Assembler''subq-3 asm, frameSizeRegister, (* 2 wordSize))

            ;; push return address
            (Assembler''push-2 asm, framePcRegister)

            ;; prolog
            (Assembler''push-2 asm, initialInfoRegister)
            (Assembler''movq-3 asm, initialInfoRegister, AMD64/rsp)
            (Assembler''subq-3 asm, AMD64/rsp, frameSizeRegister)

            ;; this value is corrected by layout_activation_impl
            (Assembler''movptr-3 asm, (AMD64Address'new-2 initialInfoRegister, (* HotSpot'frameInterpreterFrameLastSpOffset wordSize)), 0)

            ;; make the frame walkable
            (Assembler''movq-3 asm, (AMD64Address'new-2 initialInfoRegister, (* HotSpot'frameInterpreterFrameSenderSpOffset wordSize)), senderSpRegister)
        )
        nil
    )
)

(final-ns AMD64HotSpotRegisterAllocationConfig (§ extends RegisterAllocationConfig)
    ;;;
     ; Specify priority of register selection within phases of register allocation. Highest priority
     ; is first. A useful heuristic is to give registers a low priority when they are required by
     ; machine instructions, like EAX and EDX on I486, and choose no-save registers before save-on-call
     ; and save-on-call before save-on-entry. Registers which participate in fixed calling sequences
     ; should come last. Registers which are used as pairs must fall on an even boundary.
     ;
     ; Adopted from x86_64.ad.
     ;;
    (§ def #_"Register[]" AMD64HotSpotRegisterAllocationConfig'registerAllocationOrder)
    (§ array
        AMD64/r10, AMD64/r11, AMD64/r8, AMD64/r9, AMD64/r12,
        AMD64/rcx, AMD64/rbx, AMD64/rdi, AMD64/rdx, AMD64/rsi, AMD64/rax, AMD64/rbp,
        AMD64/r13, AMD64/r14
        ;; AMD64.r15, AMD64.rsp
    )

    (§ defn #_"AMD64HotSpotRegisterAllocationConfig" AMD64HotSpotRegisterAllocationConfig'new-0 []
        (RegisterAllocationConfig'new-0)
    )

    #_unused
    (§ override! #_"RegisterArray" AMD64HotSpotRegisterAllocationConfig''initAllocatable-2 [#_"AMD64HotSpotRegisterAllocationConfig" this, #_"RegisterArray" registers]
        (let [
            #_"BitSet" regMap (BitSet. (#_"RegisterArray" .size (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig)))
        ]
            (doseq [#_"Register" reg registers]
                (#_"BitSet" .set regMap, (.number reg))
            )

            (let [
                #_"ArrayList<Register>" allocatableRegisters (ArrayList.)
            ]
                (doseq [#_"Register" reg AMD64HotSpotRegisterAllocationConfig'registerAllocationOrder]
                    (when (#_"BitSet" .get regMap, (.number reg))
                        (#_"ArrayList" .add allocatableRegisters, reg)
                    )
                )

                (RegisterAllocationConfig''initAllocatable-2 (§ super ), (RegisterArray. allocatableRegisters))
            )
        )
    )
)

(§ interface AMD64HotSpotRestoreRbpOp
    ;;;
     ; The type of location (i.e. stack or register) in which RBP is saved is not known until initial LIR generation
     ; is finished. Until then, we use a placeholder variable so that LIR verification is successful.
     ;;
    (§ def #_"Variable" AMD64HotSpotRestoreRbpOp'PLACEHOLDER (Variable'new-2 (LIRKind'value-1 AMD64Kind/QWORD), Integer/MAX_VALUE))

    (§ abstract #_"void" AMD64HotSpotRestoreRbpOp''setSavedRbp-2 [#_"AMD64HotSpotRestoreRbpOp" this, #_"AllocatableValue" value])
)

;;;
 ; Returns from a function.
 ;;
; @LIROpcode
(final-ns AMD64HotSpotReturnOp (§ extends EpilogueBlockEndOp)
    (§ def #_"LIRInstructionClass<AMD64HotSpotReturnOp>" AMD64HotSpotReturnOp'TYPE (LIRInstructionClass'new-1 AMD64HotSpotReturnOp))

    ; @Use({OperandFlag'REG, OperandFlag'ILLEGAL})
    (§ mutable #_"Value" :value nil)

    (§ final #_"boolean" :isStub false)
    (§ final #_"Register" :thread nil)
    (§ final #_"Register" :scratchForSafepointOnReturn nil)

    (§ defn #_"AMD64HotSpotReturnOp" AMD64HotSpotReturnOp'new-4 [#_"Value" value, #_"boolean" isStub, #_"Register" thread, #_"Register" scratchForSafepointOnReturn]
        (let [
            #_"AMD64HotSpotReturnOp" this (EpilogueBlockEndOp'new-1 AMD64HotSpotReturnOp'TYPE)
            this (assoc this :value value)
            this (assoc this :isStub isStub)
            this (assoc this :thread thread)
            this (assoc this :scratchForSafepointOnReturn scratchForSafepointOnReturn)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64HotSpotReturnOp''emitCode-2 [#_"AMD64HotSpotReturnOp" this, #_"Assembler" asm]
        (EpilogueBlockEndOp''leaveFrameAndRestoreRbp-2 this, asm)
        (when-not (:isStub this)
            ;; Every non-stub compile method must have a poll before the return.
            (SafepointOp'emitCode-4 asm, true, (:thread this), (:scratchForSafepointOnReturn this))
        )
        (Assembler''ret-2 asm, 0)
        nil
    )
)

;;;
 ; Emits a safepoint poll.
 ;;
; @LIROpcode
(final-ns SafepointOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<SafepointOp>" SafepointOp'TYPE (LIRInstructionClass'new-1 SafepointOp))

    ;;;
     ; Tests if the polling page address can be reached from the code cache with 32-bit displacements.
     ;;
    (§ defn- #_"boolean" SafepointOp'isPollingPageFar-0 []
        (let [
            #_"long" pollingPageAddress HotSpot'safepointPollingAddress
        ]
            (or (not (NumUtil'isInt-1 (- pollingPageAddress HotSpot'codeCacheLowBound))) (not (NumUtil'isInt-1 (- pollingPageAddress HotSpot'codeCacheHighBound))))
        )
    )

    ; @Temp({OperandFlag'REG, OperandFlag'ILLEGAL})
    (§ mutable #_"AllocatableValue" :temp nil)

    (§ final #_"Register" :thread nil)

    (§ defn #_"SafepointOp" SafepointOp'new-2 [#_"LIRBuilder" builder, #_"Register" thread]
        (let [
            #_"SafepointOp" this (LIRInstruction'new-1 SafepointOp'TYPE)
            this (assoc this :thread thread)
            this (assoc this :temp (if (or HotSpot'threadLocalHandshakes (SafepointOp'isPollingPageFar-0)) (LIRGenerator''newVariable-2 (:gen builder), (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target)))) Value/ILLEGAL)) ;; => don't waste a register if it's unneeded
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" SafepointOp''emitCode-2 [#_"SafepointOp" this, #_"Assembler" asm]
        (SafepointOp'emitCode-4 asm, false, (:thread this), (when (instance? RegisterValue (:temp this)) (#_"RegisterValue" .getRegister (:temp this))))
        nil
    )

    (§ defn- #_"void" SafepointOp'emitThreadLocalPoll-4 [#_"Assembler" asm, #_"boolean" atReturn, #_"Register" thread, #_"Register" scratch]
        (Assembler''movptr-3 asm, scratch, (AMD64Address'new-2 thread, HotSpot'threadPollingPageOffset))
        (Assembler''recordMark-2 asm, (if atReturn HotSpot'pollReturnFarMark HotSpot'pollFarMark))
        (Assembler''testl-3 asm, AMD64/rax, (AMD64Address'new-1 scratch))
        nil
    )

    (§ defn- #_"void" SafepointOp'emitGlobalPoll-3 [#_"Assembler" asm, #_"boolean" atReturn, #_"Register" scratch]
        (if (SafepointOp'isPollingPageFar-0)
            (do
                (Assembler''movq-3 asm, scratch, HotSpot'safepointPollingAddress)
                (Assembler''recordMark-2 asm, (if atReturn HotSpot'pollReturnFarMark HotSpot'pollFarMark))
                (Assembler''testl-3 asm, AMD64/rax, (AMD64Address'new-1 scratch))
            )
            (do
                (Assembler''recordMark-2 asm, (if atReturn HotSpot'pollReturnNearMark HotSpot'pollNearMark))
                ;; The C++ code transforms the polling page offset into an RIP displacement
                ;; to the real address at that offset in the polling page.
                (Assembler''testl-3 asm, AMD64/rax, (AMD64Address'new-2 AMD64/rip, 0))
            )
        )
        nil
    )

    (§ defn #_"void" SafepointOp'emitCode-4 [#_"Assembler" asm, #_"boolean" atReturn, #_"Register" thread, #_"Register" scratch]
        (if HotSpot'threadLocalHandshakes
            (SafepointOp'emitThreadLocalPoll-4 asm, atReturn, thread, scratch)
            (SafepointOp'emitGlobalPoll-3 asm, atReturn, scratch)
        )
        nil
    )
)

(final-ns AMD64HotSpotStrategySwitchOp (§ extends StrategySwitchOp)
    (§ def #_"LIRInstructionClass<AMD64HotSpotStrategySwitchOp>" AMD64HotSpotStrategySwitchOp'TYPE (LIRInstructionClass'new-1 AMD64HotSpotStrategySwitchOp))

    (§ defn #_"AMD64HotSpotStrategySwitchOp" AMD64HotSpotStrategySwitchOp'new-5 [#_"SwitchStrategy" strategy, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget, #_"Value" key, #_"Value" scratch]
        (StrategySwitchOp'new-6 AMD64HotSpotStrategySwitchOp'TYPE, strategy, keyTargets, defaultTarget, key, scratch)
    )

    #_unused
    (§ override! #_"void" AMD64HotSpotStrategySwitchOp''emitCode-2 [#_"AMD64HotSpotStrategySwitchOp" this, #_"Assembler" asm]
        (SwitchStrategy''run-2 (:strategy this), (HotSpotSwitchClosure'new-3 this, (#_"RegisterValue" .getRegister (:key this)), asm))
        nil
    )
)

;;;
 ; @anno AMD64HotSpotStrategySwitchOp.HotSpotSwitchClosure
 ;;
(final-ns HotSpotSwitchClosure (§ extends AMD64SwitchClosure)
    (§ defn #_"HotSpotSwitchClosure" HotSpotSwitchClosure'new-3 [#_"AMD64HotSpotStrategySwitchOp" op, #_"Register" keyRegister, #_"Assembler" asm]
        (AMD64SwitchClosure'new-3 op, keyRegister, asm)
    )

    #_unused
    (§ override! #_"void" HotSpotSwitchClosure''emitComparison-2 [#_"HotSpotSwitchClosure" this, #_"Constant" constant]
        (when (instance? HotSpotMetaspaceConstant constant) => (AMD64SwitchClosure''emitComparison-2 (§ super ), constant)
            (if (#_"HotSpotMetaspaceConstant" .isCompressed constant)
                (do
                    (Assembler''recordInlineDataInCode-2 (:asm this), constant)
                    (Assembler''cmpl-3 (:asm this), (:keyRegister this), 0xdeaddead)
                )
                (let [
                    #_"AMD64Address" addr (Assembler''recordDataReferenceInCode-3 (:asm this), constant, 8)
                ]
                    (Assembler''cmpq-3 (:asm this), (:keyRegister this), addr)
                )
            )
        )
        nil
    )
)

;;;
 ; A register indirect call that complies with the extra conventions for such calls in HotSpot. In
 ; particular, the metaspace Method of the callee must be in RBX for the case where a vtable entry's
 ; _from_compiled_entry is the address of an C2I adapter. Such adapters expect the target method to
 ; be in RBX.
 ;;
; @LIROpcode
(final-ns AMD64IndirectCallOp (§ extends IndirectCallOp)
    (§ def #_"LIRInstructionClass<AMD64IndirectCallOp>" AMD64IndirectCallOp'TYPE (LIRInstructionClass'new-1 AMD64IndirectCallOp))

    ;;;
     ; Vtable stubs expect the metaspace Method in RBX.
     ;;
    (§ def #_"Register" AMD64IndirectCallOp'METHOD AMD64/rbx)

    ; @Use({OperandFlag'REG})
    (§ mutable #_"Value" :metaspaceMethod nil)

    (§ defn #_"AMD64IndirectCallOp" AMD64IndirectCallOp'new-6 [#_"ResolvedJavaMethod" targetMethod, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps, #_"Value" metaspaceMethod, #_"Value" targetAddress]
        (let [
            #_"AMD64IndirectCallOp" this (IndirectCallOp'new-6 AMD64IndirectCallOp'TYPE, targetMethod, result, parameters, temps, targetAddress)
            this (assoc this :metaspaceMethod metaspaceMethod)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64IndirectCallOp''emitCode-2 [#_"AMD64IndirectCallOp" this, #_"Assembler" asm]
        (Assembler''recordMark-2 asm, HotSpot'inlineInvokeMark)
        (AMD64Call'indirectCall-3 asm, (#_"RegisterValue" .getRegister (:targetAddress this)), (:callTarget this))
        nil
    )
)

;;;
 ; Performs a hard-coded tail call to the specified target, which normally should be an InstalledCode instance.
 ;;
; @LIROpcode
(final-ns AMD64TailcallOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64TailcallOp>" AMD64TailcallOp'TYPE (LIRInstructionClass'new-1 AMD64TailcallOp))

    ; @Use
    (§ mutable #_"Value" :target nil)
    ; @Alive
    (§ mutable #_"Value[]" :parameters nil)

    (§ defn #_"AMD64TailcallOp" AMD64TailcallOp'new-2 [#_"Value[]" parameters, #_"Value" target]
        (let [
            #_"AMD64TailcallOp" this (LIRInstruction'new-1 AMD64TailcallOp'TYPE)
            this (assoc this :target target)
            this (assoc this :parameters parameters)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64TailcallOp''emitCode-2 [#_"AMD64TailcallOp" this, #_"Assembler" asm]
        ;; destroy the current frame (now the return address is the top of stack)
        (Assembler''leave-1 asm)

        ;; jump to the target method
        (Assembler''jmp-2 asm, (#_"RegisterValue" .getRegister (:target this)))
        (Assembler''ensureUniquePC-1 asm)
        nil
    )
)

(final-ns LockStackHolder
    (§ final #_"LockStack" :lockStack nil)

    (§ defn #_"LockStackHolder" LockStackHolder'new-1 [#_"LockStack" lockStack]
        (let [
            #_"LockStackHolder" this (Object.)
            this (assoc this :lockStack lockStack)
        ]
            this
        )
    )
)

;;;
 ; Constants for specifying whether a foreign call destroys or preserves registers. A foreign
 ; call will always destroy {@link ForeignCallLinkage#getOutgoingCallingConvention() its}
 ; {@linkplain ForeignCallLinkage#getTemporaries() temporary} registers.
 ;
 ; @anno ForeignCallLinkage.RegisterEffect
 ;;
(value-ns RegisterEffect
    (§ enum RegisterEffect'DESTROYS_REGISTERS)
    (§ enum RegisterEffect'PRESERVES_REGISTERS)
)

;;;
 ; Constants for specifying whether a call is a leaf or not and whether a JavaFrameAnchor prologue
 ; and epilogue is required around the call. A leaf function does not lock, GC or throw exceptions.
 ;
 ; @anno ForeignCallLinkage.Transition
 ;;
(value-ns Transition
    ;;;
     ; A call to a leaf function that is guaranteed to not use floating point registers and will never have
     ; its caller stack inspected by the VM. That is, JavaFrameAnchor management around the call can be omitted.
     ;;
    (§ enum Transition'LEAF_NOFP)
    ;;;
     ; A call to a leaf function that might use floating point registers but will never have its
     ; caller stack inspected. That is, JavaFrameAnchor management around the call can be omitted.
     ;;
    (§ enum Transition'LEAF)
    ;;;
     ; A call to a leaf function that might use floating point registers and may have its caller
     ; stack inspected. That is, JavaFrameAnchor management code around the call is required.
     ;;
    (§ enum Transition'STACK_INSPECTABLE_LEAF)
    ;;;
     ; A function that may lock, GC or raise an exception and thus requires debug info to be associated
     ; with a call site to the function. The execution stack may be inspected while in the called function.
     ; That is, JavaFrameAnchor management code around the call is required.
     ;;
    (§ enum Transition'SAFEPOINT)
)

;;;
 ; The runtime specific details of a foreign call.
 ;;
(final-ns ForeignCallLinkage (§ implements InvokeTarget)
    ;;;
     ; The descriptor of the call.
     ;;
    (§ final #_"ForeignCallDescriptor" :descriptor nil)

    (§ mutable #_"long" :address 0)

    (§ final #_"RegisterEffect" :effect nil)
    (§ final #_"Transition" :transition nil)
    ;;;
     ; The calling convention for this call.
     ; The details of where parameters are passed and value(s) are returned from the caller's perspective.
     ;;
    (§ final #_"CallingConvention" :outgoingCallingConvention nil)
    ;;;
     ; The calling convention for incoming arguments to the stub, iff this call uses a compiled stub.
     ; The details of where parameters are passed and value(s) are returned from the callee's perspective.
     ;;
    (§ final #_"CallingConvention" :incomingCallingConvention nil)

    (§ final #_"boolean" :reexecutable false)
    ;;;
     ; The memory locations killed by the call.
     ;;
    (§ final #_"LocationIdentity[]" :killedLocations nil)

    ;;;
     ; The registers and stack slots defined/killed by the call.
     ;;
    (§ mutable #_"Value[]" :temporaries AllocatableValue/NONE)
    ;;;
     ; Non-null (eventually) iff this is a call to a compiled stub.
     ;;
    (§ mutable #_"Stub" :stub nil)

    (§ defn #_"ForeignCallLinkage" ForeignCallLinkage'new-8* [#_"ForeignCallDescriptor" descriptor, #_"long" address, #_"RegisterEffect" effect, #_"Transition" transition, #_"CallingConvention" outgoingCallingConvention, #_"CallingConvention" incomingCallingConvention, #_"boolean" reexecutable, #_"LocationIdentity..." killedLocations]
        (let [
            #_"ForeignCallLinkage" this (Object.)
            this (assoc this :descriptor descriptor)
            this (assoc this :address address)
            this (assoc this :effect effect)
            this (assoc this :transition transition)
            this (assoc this :outgoingCallingConvention outgoingCallingConvention)
            this (assoc this :incomingCallingConvention (or incomingCallingConvention outgoingCallingConvention))
            this (assoc this :reexecutable reexecutable)
            this (assoc this :killedLocations killedLocations)
        ]
            this
        )
    )

    ;;;
     ; Creates a ForeignCallLinkage.
     ;
     ; @param descriptor the descriptor of the call
     ; @param address the address of the code to call
     ; @param effect specifies if the call destroys or preserves all registers (apart from temporaries which are always destroyed)
     ; @param outgoingCcType outgoing (caller) calling convention type
     ; @param incomingCcType incoming (callee) calling convention type (can be nil)
     ; @param transition specifies if this is a {@linkplain #needsDebugInfo() leaf} call
     ; @param reexecutable specifies if the call can be re-executed without (meaningful) side effects.
     ;            Deoptimization will not return to a point before a call that cannot be re-executed.
     ; @param killedLocations the memory locations killed by the call
     ;;
    (§ defn #_"ForeignCallLinkage" ForeignCallLinkage'create-8* [#_"ForeignCallDescriptor" descriptor, #_"long" address, #_"RegisterEffect" effect, #_"CallingConvention$Type" outgoingCcType, #_"CallingConvention$Type" incomingCcType, #_"Transition" transition, #_"boolean" reexecutable, #_"LocationIdentity..." killedLocations]
        (let [
            #_"CallingConvention" outgoingCc (ForeignCallLinkage'createCallingConvention-2 descriptor, outgoingCcType)
            #_"CallingConvention" incomingCc (when (some? incomingCcType) (ForeignCallLinkage'createCallingConvention-2 descriptor, incomingCcType))
            #_"ForeignCallLinkage" linkage (ForeignCallLinkage'new-8* descriptor, address, effect, transition, outgoingCc, incomingCc, reexecutable, killedLocations)
        ]
            (when (= outgoingCcType HotSpotCallingConventionType/NativeCall) => linkage
                (assoc linkage :temporaries ForeignCalls'nativeABICallerSaveRegisters)
            )
        )
    )

    ;;;
     ; Gets a calling convention for a given descriptor and call type.
     ;;
    (§ defn #_"CallingConvention" ForeignCallLinkage'createCallingConvention-2 [#_"ForeignCallDescriptor" descriptor, #_"CallingConvention$Type" ccType]
        (let [
            #_"Class[]" argumentTypes (#_"Object" .clone (:argumentTypes descriptor))
            #_"JavaType[]" parameterTypes (make-array JavaType (count argumentTypes))
        ]
            (dotimes [#_"int" i (count parameterTypes)]
                (aset parameterTypes i (ForeignCallLinkage'asJavaType-1 (nth argumentTypes i)))
            )
            (let [
                #_"JavaType" returnType (ForeignCallLinkage'asJavaType-1 (:resultType descriptor))
            ]
                (#_"RegisterConfig" .getCallingConvention HotSpot'registerConfig, ccType, returnType, parameterTypes, HotSpot'valueKindFactory)
            )
        )
    )

    (§ defn- #_"JavaType" ForeignCallLinkage'asJavaType-1 [#_"Class" type]
        (let [
            #_"ResolvedJavaType" javaType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, type)
        ]
            (when (WordTypes'isWord-1 javaType) => javaType
                (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (#_"JavaKind" .toJavaClass WordTypes'wordKind))
            )
        )
    )

    ;;;
     ; Identifies foreign calls which are guaranteed to include a safepoint check.
     ;;
    (§ method! #_"boolean" ForeignCallLinkage''isGuaranteedSafepoint-1 [#_"ForeignCallLinkage" this]
        (= (:transition this) Transition'SAFEPOINT)
    )

    ;;;
     ; Gets the values used/killed by this foreign call.
     ;;
    (§ method! #_"Value[]" ForeignCallLinkage''getTemporaries-1 [#_"ForeignCallLinkage" this]
        (if (empty? (:temporaries this)) (:temporaries this) (#_"Object" .clone (:temporaries this)))
    )

    ;;;
     ; Returns the maximum absolute offset of a PC relative call to this stub from any position in the code cache
     ; or -1 when not applicable. Intended for determining the required size of address/offset fields.
     ;;
    (§ method! #_"long" ForeignCallLinkage''getMaxCallTargetOffset-1 [#_"ForeignCallLinkage" this]
        (#_"CodeCacheProvider" .getMaxCallTargetOffset HotSpot'codeCache, (:address this))
    )

    (§ method! #_"ForeignCallLinkage" ForeignCallLinkage''setCompiledStub-2 [#_"ForeignCallLinkage" this, #_"Stub" stub]
        (assoc this :stub stub)
    )

    (§ method! #_"ForeignCallLinkage" ForeignCallLinkage''finalizeAddress-1 [#_"ForeignCallLinkage" this]
        (when (zero? (:address this)) => this
            (assoc this :address (#_"InstalledCode" .getStart (Stub''getCode-1 (:stub this))))
        )
    )

    ;;;
     ; Determines if the foreign call target destroys all registers.
     ;
     ; @return true if the register allocator must save all live registers around a call to this target
     ;;
    (§ method! #_"boolean" ForeignCallLinkage''destroysRegisters-1 [#_"ForeignCallLinkage" this]
        (= (:effect this) RegisterEffect'DESTROYS_REGISTERS)
    )

    ;;;
     ; Determines if a JavaFrameAnchor needs to be set up and torn down around this call.
     ;;
    (§ method! #_"boolean" ForeignCallLinkage''needsJavaFrameAnchor-1 [#_"ForeignCallLinkage" this]
        (and (any = (:transition this) Transition'SAFEPOINT Transition'STACK_INSPECTABLE_LEAF)
            (nil? (:stub this)) ;; the stub will do the JavaFrameAnchor management around the runtime call(s) it makes
        )
    )
)

;;;
 ; Manages allocation and re-use of lock slots in a scoped manner. The slots are used in HotSpot's
 ; lightweight locking mechanism to store the mark word of an object being locked.
 ;;
(final-ns LockStack (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<LockStack>" LockStack'TYPE (LIRInstructionClass'new-1 LockStack))

    (§ def- #_"AllocatableValue[]" LockStack'EMPTY (make-array AllocatableValue 0))

    ; @Def({OperandFlag'STACK})
    (§ mutable #_"AllocatableValue[]" :locks nil)

    (§ final #_"FrameMapBuilder" :frameMapBuilder nil)
    (§ final #_"LIRKind" :slotKind nil)

    (§ defn #_"LockStack" LockStack'new-2 [#_"FrameMapBuilder" frameMapBuilder, #_"LIRKind" slotKind]
        (let [
            #_"LockStack" this (LIRInstruction'new-1 LockStack'TYPE)
            this (assoc this :frameMapBuilder frameMapBuilder)
            this (assoc this :slotKind slotKind)
            this (assoc this :locks LockStack'EMPTY)
        ]
            this
        )
    )

    ;;;
     ; Gets a stack slot for a lock at a given lock nesting depth, allocating it first if necessary.
     ;;
    (§ method! #_"VirtualStackSlot" LockStack''makeLockSlot-2 [#_"LockStack" this, #_"int" lockDepth]
        (cond
            (= (:locks this) LockStack'EMPTY)
                (§ ass! this (assoc this :locks (make-array AllocatableValue (inc lockDepth))))
            (< (count (:locks this)) (inc lockDepth))
                (§ ass! this (assoc this :locks (Arrays/copyOf (:locks this), (inc lockDepth))))
        )
        (when (nil? (nth (:locks this) lockDepth))
            (aset (:locks this) lockDepth (FrameMapBuilder''allocateSpillSlot-2 (:frameMapBuilder this), (:slotKind this)))
        )
        (nth (:locks this) lockDepth)
    )

    #_unused
    (§ override! #_"void" LockStack''emitCode-2 [#_"LockStack" this, #_"Assembler" asm]
        ;; do nothing
        nil
    )
)

;;;
 ; The name and signature of a foreign call. A foreign call differs from a normal compiled Java call
 ; in at least one of these aspects:
 ;
 ; (1) The call is to C/C++/assembler code.
 ; (2) The call uses different conventions for passing parameters or returning values.
 ; (3) The callee has different register saving semantics. For example, the callee may save all
 ; registers (apart from some specified temporaries) in which case the register allocator doesn't
 ; not need to spill all live registers around the call site.
 ; (4) The call does not occur at an INVOKE* bytecode. Such a call could be transformed into a
 ; standard Java call if the foreign routine is a normal Java method and the runtime supports
 ; linking Java calls at arbitrary bytecodes.
 ;;
(final-ns ForeignCallDescriptor
    (§ final #_"String" :name nil)
    (§ final #_"Class" :resultType nil)
    (§ final #_"Class[]" :argumentTypes nil)

    (§ defn #_"ForeignCallDescriptor" ForeignCallDescriptor'new-3* [#_"String" name, #_"Class" resultType, #_"Class..." argumentTypes]
        (let [
            #_"ForeignCallDescriptor" this (Object.)
            this (assoc this :name name)
            this (assoc this :resultType resultType)
            this (assoc this :argumentTypes argumentTypes)
        ]
            this
        )
    )

    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'DEOPTIMIZATION_HANDLER (ForeignCallDescriptor'new-3* "deoptHandler", void'class))
    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'UNCOMMON_TRAP_HANDLER  (ForeignCallDescriptor'new-3* "uncommonTrapHandler", void'class))

    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'NEW_ARRAY            (ForeignCallDescriptor'new-3* "new_array", Object, KlassPointer, int'class, boolean'class))
    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'NEW_INSTANCE         (ForeignCallDescriptor'new-3* "new_instance", Object, KlassPointer))
    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'NEW_ARRAY_C          (ForeignCallDescriptor'new-3* "newArrayC", void'class, Word, KlassPointer, int'class))
    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'NEW_INSTANCE_C       (ForeignCallDescriptor'new-3* "newInstanceC", void'class, Word, KlassPointer))
    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'DYNAMIC_NEW_ARRAY    (ForeignCallDescriptor'new-3* "dynamic_new_array", Object, Class, int'class))
    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'DYNAMIC_NEW_INSTANCE (ForeignCallDescriptor'new-3* "dynamic_new_instance", Object, Class))

    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'MONITORENTER (ForeignCallDescriptor'new-3* "monitorenter", void'class, Object, Word))
    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'MONITOREXIT  (ForeignCallDescriptor'new-3* "monitorexit", void'class, Object, Word))

    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'G1WBPRECALL  (ForeignCallDescriptor'new-3* "write_barrier_pre", void'class, Object))
    (§ def #_"ForeignCallDescriptor" ForeignCallDescriptor'G1WBPOSTCALL (ForeignCallDescriptor'new-3* "write_barrier_post", void'class, Word))
)

;;;
 ; Details about a set of supported {@link ForeignCallDescriptor foreign calls}.
 ;;
(final-ns ForeignCalls
    ;;;
     ; System V Application Binary Interface, AMD64 Architecture Processor Supplement, Draft Version 0.96, 3.2.1
     ;
     ; http://www.uclibc.org/docs/psABI-x86_64.pdf
     ;
     ; "This subsection discusses usage of each register. Registers %rbp, %rbx and %r12 through %r15 "belong" to the calling
     ; function and the called function is required to preserve their values. In other words, a called function must preserve
     ; these registers' values for its caller. Remaining registers "belong" to the called function. If a calling function
     ; wants to preserve such a register value across a function call, it must save the value in its local stack frame."
     ;;
    (§ defn- #_"Value[]" ForeignCalls'createNativeABICallerSaveRegisters-0 []
        (let [
            #_"List<Register>" registers (#_"RegisterArray" .asList (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig))
        ]
            (into-array Value (map #(#_"Register" .asValue %) (remove #{ AMD64/rbp, AMD64/rbx, AMD64/r12, AMD64/r13, AMD64/r14, AMD64/r15 } registers)))
        )
    )

    ;;;
     ; Registers that must be saved across a foreign call into the runtime.
     ;;
    (§ def #_"Value[]" ForeignCalls'nativeABICallerSaveRegisters (ForeignCalls'createNativeABICallerSaveRegisters-0))

    (§ final #_"EconomicMap<ForeignCallDescriptor, ForeignCallLinkage>" :foreignCalls (EconomicMap/create))

    (§ defn #_"ForeignCalls" ForeignCalls'new-0 []
        (let [
            #_"ForeignCalls" this (Object.)
        ]
            (ForeignCalls''initialize-1 this)
            this
        )
    )

    ;;;
     ; Registers the linkage for a foreign call.
     ;;
    (§ method! #_"void" ForeignCalls''register-2 [#_"ForeignCalls" this, #_"ForeignCallLinkage" linkage]
        (#_"EconomicMap" .put (:foreignCalls this), (:descriptor linkage), linkage)
        nil
    )

    ;;;
     ; Creates and registers the details for linking a foreign call to a Stub.
     ;
     ; @param descriptor the signature of the call to the stub
     ; @param reexecutable specifies if the stub call can be re-executed without (meaningful) side effects.
     ;            Deoptimization will not return to a point before a stub call that cannot be re-executed.
     ; @param transition specifies if this is a {@linkplain Transition#LEAF leaf} call
     ; @param killedLocations the memory locations killed by the stub call
     ;;
    (§ method! #_"void" ForeignCalls''registerStubCall-5* [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor, #_"boolean" reexecutable, #_"Transition" transition, #_"LocationIdentity..." killedLocations]
        (let [
            #_"ForeignCallLinkage" linkage (ForeignCallLinkage'create-8* descriptor, 0, RegisterEffect'PRESERVES_REGISTERS, HotSpotCallingConventionType/JavaCall, HotSpotCallingConventionType/JavaCallee, transition, reexecutable, killedLocations)
        ]
            (ForeignCalls''register-2 this, linkage)
        )
        nil
    )

    ;;;
     ; Creates and registers the linkage for a foreign call.
     ;
     ; @param descriptor the signature of the foreign call
     ; @param address the address of the code to call
     ; @param outgoingCcType outgoing (caller) calling convention type
     ; @param effect specifies if the call destroys or preserves all registers (apart from temporaries which are always destroyed)
     ; @param transition specifies if this is a {@linkplain Transition#LEAF leaf} call
     ; @param reexecutable specifies if the foreign call can be re-executed without (meaningful) side effects.
     ;            Deoptimization will not return to a point before a foreign call that cannot be re-executed.
     ; @param killedLocations the memory locations killed by the foreign call
     ;;
    (§ method! #_"void" ForeignCalls''registerForeignCall-8* [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor, #_"long" address, #_"CallingConvention$Type" outgoingCcType, #_"RegisterEffect" effect, #_"Transition" transition, #_"boolean" reexecutable, #_"LocationIdentity..." killedLocations]
        (let [
            #_"ForeignCallLinkage" linkage (ForeignCallLinkage'create-8* descriptor, address, effect, outgoingCcType, nil, transition, reexecutable, killedLocations)
        ]
            (ForeignCalls''register-2 this, linkage)
        )
        nil
    )

    ;;;
     ; Creates a stub for a foreign call.
     ;
     ; @param descriptor the signature of the call to the stub
     ; @param address the address of the foreign code to call
     ; @param prependThread true if the JavaThread value for the current thread is to be prepended
     ;            to the arguments for the call to {@code address}
     ; @param transition specifies if this is a {@linkplain Transition#LEAF leaf} call
     ; @param reexecutable specifies if the foreign call can be re-executed without (meaningful) side effects.
     ;            Deoptimization will not return to a point before a foreign call that cannot be re-executed.
     ; @param killedLocations the memory locations killed by the foreign call
     ;;
    (§ method! #_"void" ForeignCalls''linkForeignCall-7* [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor, #_"long" address, #_"boolean" prependThread, #_"Transition" transition, #_"boolean" reexecutable, #_"LocationIdentity..." killedLocations]
        (let [
            #_"ForeignCallStub" stub (ForeignCallStub'new-6* address, descriptor, prependThread, transition, reexecutable, killedLocations)
        ]
            (§ ass! (:linkage stub) (ForeignCallLinkage''setCompiledStub-2 (:linkage stub), stub))
            (ForeignCalls''register-2 this, (:linkage stub))
            (ForeignCalls''register-2 this, (:target stub))
        )
        nil
    )

    (def #_"boolean" ForeignCalls'PREPEND_THREAD true)
    (def #_"boolean" ForeignCalls'DONT_PREPEND_THREAD (not ForeignCalls'PREPEND_THREAD))

    (def #_"boolean" ForeignCalls'REEXECUTABLE true)
    (def #_"boolean" ForeignCalls'NOT_REEXECUTABLE (not ForeignCalls'REEXECUTABLE))

    (§ def #_"LocationIdentity[]" ForeignCalls'NO_LOCATIONS (make-array LocationIdentity 0))

    ;;;
     ; Gets the linkage for a foreign call.
     ;;
    (§ method! #_"ForeignCallLinkage" ForeignCalls''lookupForeignCall-2 [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor]
        (let [
            #_"ForeignCallLinkage" callTarget (get (:foreignCalls this) descriptor)
        ]
            (§ ass! callTarget (ForeignCallLinkage''finalizeAddress-1 callTarget))
            callTarget
        )
    )

    ;;;
     ; Determines if a given foreign call is side-effect free. Deoptimization cannot return
     ; execution to a point before a foreign call that has a side effect.
     ;;
    (§ method! #_"boolean" ForeignCalls''isReexecutable-2 [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor]
        (:reexecutable (get (:foreignCalls this) descriptor))
    )

    ;;;
     ; Identifies foreign calls which are guaranteed to include a safepoint check.
     ;;
    (§ method! #_"boolean" ForeignCalls''isGuaranteedSafepoint-2 [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor]
        (ForeignCallLinkage''isGuaranteedSafepoint-1 (get (:foreignCalls this) descriptor))
    )

    ;;;
     ; Gets the set of memory locations killed by a given foreign call. Returning the special
     ; value LocationIdentity#any() denotes that the call kills all memory locations.
     ; Returning any empty array denotes that the call does not kill any memory locations.
     ;;
    (§ method! #_"LocationIdentity[]" ForeignCalls''getKilledLocations-2 [#_"ForeignCalls" this, #_"ForeignCallDescriptor" descriptor]
        (:killedLocations (get (:foreignCalls this) descriptor))
    )

    (§ defn #_"void" ForeignCalls'link-1 [#_"Stub" stub]
        (§ ass! (:linkage stub) (ForeignCallLinkage''setCompiledStub-2 (:linkage stub), stub))
        nil
    )

    (§ method- #_"void" ForeignCalls''initialize-1 [#_"ForeignCalls" this]
        (ForeignCalls''registerForeignCall-8* this, ForeignCallDescriptor'DEOPTIMIZATION_HANDLER, HotSpot'handleDeoptStub, HotSpotCallingConventionType/NativeCall, RegisterEffect'PRESERVES_REGISTERS, Transition'LEAF_NOFP, ForeignCalls'REEXECUTABLE, ForeignCalls'NO_LOCATIONS)
        (ForeignCalls''registerForeignCall-8* this, ForeignCallDescriptor'UNCOMMON_TRAP_HANDLER, HotSpot'uncommonTrapStub, HotSpotCallingConventionType/NativeCall, RegisterEffect'PRESERVES_REGISTERS, Transition'LEAF_NOFP, ForeignCalls'REEXECUTABLE, ForeignCalls'NO_LOCATIONS)

        (ForeignCalls'link-1 (NewArrayStub'new-1 (ForeignCalls''registerStubCall-5* this, ForeignCallDescriptor'NEW_ARRAY, ForeignCalls'REEXECUTABLE, Transition'SAFEPOINT, HotSpotReplacementsUtil'TLAB_TOP_LOCATION, HotSpotReplacementsUtil'TLAB_END_LOCATION)))
        (ForeignCalls'link-1 (NewInstanceStub'new-1 (ForeignCalls''registerStubCall-5* this, ForeignCallDescriptor'NEW_INSTANCE, ForeignCalls'REEXECUTABLE, Transition'SAFEPOINT, HotSpotReplacementsUtil'TLAB_TOP_LOCATION, HotSpotReplacementsUtil'TLAB_END_LOCATION)))
        (ForeignCalls''registerForeignCall-8* this, ForeignCallDescriptor'NEW_ARRAY_C, HotSpot'newArrayAddress, HotSpotCallingConventionType/NativeCall, RegisterEffect'DESTROYS_REGISTERS, Transition'SAFEPOINT, ForeignCalls'REEXECUTABLE, (LocationIdentity/any))
        (ForeignCalls''registerForeignCall-8* this, ForeignCallDescriptor'NEW_INSTANCE_C, HotSpot'newInstanceAddress, HotSpotCallingConventionType/NativeCall, RegisterEffect'DESTROYS_REGISTERS, Transition'SAFEPOINT, ForeignCalls'REEXECUTABLE, (LocationIdentity/any))
        (ForeignCalls''linkForeignCall-7* this, ForeignCallDescriptor'DYNAMIC_NEW_ARRAY, HotSpot'dynamicNewArrayAddress, ForeignCalls'PREPEND_THREAD, Transition'SAFEPOINT, ForeignCalls'REEXECUTABLE)
        (ForeignCalls''linkForeignCall-7* this, ForeignCallDescriptor'DYNAMIC_NEW_INSTANCE, HotSpot'dynamicNewInstanceAddress, ForeignCalls'PREPEND_THREAD, Transition'SAFEPOINT, ForeignCalls'REEXECUTABLE)

        (ForeignCalls''linkForeignCall-7* this, ForeignCallDescriptor'MONITORENTER, HotSpot'monitorenterAddress, ForeignCalls'PREPEND_THREAD, Transition'SAFEPOINT, ForeignCalls'NOT_REEXECUTABLE, (LocationIdentity/any))
        (ForeignCalls''linkForeignCall-7* this, ForeignCallDescriptor'MONITOREXIT, HotSpot'monitorexitAddress, ForeignCalls'PREPEND_THREAD, Transition'STACK_INSPECTABLE_LEAF, ForeignCalls'NOT_REEXECUTABLE, (LocationIdentity/any))

        (ForeignCalls''linkForeignCall-7* this, ForeignCallDescriptor'G1WBPRECALL, HotSpot'writeBarrierPreAddress, ForeignCalls'PREPEND_THREAD, Transition'LEAF_NOFP, ForeignCalls'REEXECUTABLE, ForeignCalls'NO_LOCATIONS)
        (ForeignCalls''linkForeignCall-7* this, ForeignCallDescriptor'G1WBPOSTCALL, HotSpot'writeBarrierPostAddress, ForeignCalls'PREPEND_THREAD, Transition'LEAF_NOFP, ForeignCalls'REEXECUTABLE, ForeignCalls'NO_LOCATIONS)
        nil
    )
)

;;;
 ; Implements the logic that decides whether a field read should be constant folded.
 ;;
(value-ns ConstantFields
    (§ def- #_"ResolvedJavaField" ConstantFields'stringValueField (#_"MetaAccessProvider" .lookupJavaField HotSpot'metaAccess, (#_"Class" .getDeclaredField String, "value")))
    (§ def- #_"ResolvedJavaField" ConstantFields'stringHashField  (#_"MetaAccessProvider" .lookupJavaField HotSpot'metaAccess, (#_"Class" .getDeclaredField String, "hash")))

    (§ def- #_"ResolvedJavaType" ConstantFields'hotSpotType   (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, HotSpot))
    (§ def- #_"ResolvedJavaType" ConstantFields'nodeClassType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, NodeClass))

    (§ defn #_"boolean" ConstantFields'isStaticFieldConstant-1 [#_"ResolvedJavaField" field]
        (let [
            #_"ResolvedJavaType" declaringClass (#_"ResolvedJavaField" .getDeclaringClass field)
        ]
            (and (#_"ResolvedJavaType" .isInitialized declaringClass) (not (= (#_"ResolvedJavaType" .getName declaringClass) "Ljava/lang/System;")))
        )
    )

    (§ defn #_"boolean" ConstantFields'isStableField-1 [#_"ResolvedJavaField" field]
        (and HotSpot'foldStableValues
             (or (not (#_"ResolvedJavaField" .isStatic field))
                 (ConstantFields'isStaticFieldConstant-1 field)
             )
             (or (#_"HotSpotResolvedJavaField" .isStable field)
                 (any = field ConstantFields'stringValueField ConstantFields'stringHashField)
             )
        )
    )

    (§ defn #_"boolean" ConstantFields'isStableFieldValueConstant-3 [#_"ResolvedJavaField" field, #_"JavaConstant" value, #_"JavaConstant" receiver]
        (or (not (#_"JavaConstant" .isDefaultForKind value))
            (and (not (#_"ResolvedJavaField" .isStatic field))
                (#_"ResolvedJavaType" .isInstance ConstantFields'hotSpotType, receiver)
            )
        )
    )

    (§ defn #_"boolean" ConstantFields'isFinalField-1 [#_"ResolvedJavaField" field]
        (and (#_"ResolvedJavaField" .isFinal field)
            (or (not (#_"ResolvedJavaField" .isStatic field)) (ConstantFields'isStaticFieldConstant-1 field))
        )
    )

    (§ defn #_"boolean" ConstantFields'isFinalFieldValueConstant-3 [#_"ResolvedJavaField" field, #_"JavaConstant" value, #_"JavaConstant" receiver]
        (or GraalOptions'trustFinalDefaultFields (not (#_"JavaConstant" .isDefaultForKind value))
            (and (not (#_"ResolvedJavaField" .isStatic field))
                (#_"ResolvedJavaType" .isInstance ConstantFields'nodeClassType, receiver)
            )
        )
    )

    (§ defn- #_"int" ConstantFields'getArrayDimension-1 [#_"JavaType" type]
        (loop-when-recur [#_"int" n 0 type (#_"JavaType" .getComponentType type)] (some? type) [(inc n) (#_"JavaType" .getComponentType type)] => n)
    )

    ;;;
     ; Decide whether a read from the {@code field} should be constant folded.
     ;;
    (§ defn #_"ConstantNode" ConstantFields'readConstantField-2 [#_"ResolvedJavaField" field, #_"JavaConstant" receiver]
        (when (ConstantFields'isStableField-1 field)
            (let [
                #_"JavaConstant" value (#_"ConstantReflectionProvider" .readFieldValue HotSpot'constantReflection, field, receiver)
            ]
                (when (and (some? value) (ConstantFields'isStableFieldValueConstant-3 field, value, receiver))
                    (§ return (ConstantNode'forConstant-3 value, (ConstantFields'getArrayDimension-1 (#_"ResolvedJavaField" .getType field)), false))
                )
            )
        )
        (when (ConstantFields'isFinalField-1 field)
            (let [
                #_"JavaConstant" value (#_"ConstantReflectionProvider" .readFieldValue HotSpot'constantReflection, field, receiver)
            ]
                (when (and (some? value) (ConstantFields'isFinalFieldValueConstant-3 field, value, receiver))
                    (§ return (ConstantNode'forConstant-1 value))
                )
            )
        )
        nil
    )

    (§ defn #_"ConstantNode" ConstantFields'tryConstantFold-2 [#_"ResolvedJavaField" field, #_"JavaConstant" receiver]
        (when (or (#_"ResolvedJavaField" .isStatic field) (and (some? receiver) (not (#_"JavaConstant" .isNull receiver))))
            (ConstantFields'readConstantField-2 field, receiver)
        )
    )
)

;;;
 ; This plugin handles the HotSpot-specific customizations of bytecode parsing:
 ;
 ; Word-type rewriting for {@link BytecodeParser#parsingIntrinsic intrinsic} functions
 ; (snippets and method substitutions), by forwarding to the WordOperationPlugin. Note that
 ; we forward the NodePlugin and TypePlugin methods, but not the
 ; InlineInvokePlugin methods implemented by WordOperationPlugin. The latter is not
 ; necessary because HotSpot only uses the Word type in methods that are force-inlined,
 ; i.e. there are never non-inlined invokes that involve the Word type.
 ;
 ; Constant folding of field loads.
 ;;
(final-ns HotSpotNodePlugin (§ implements NodePlugin, TypePlugin)
    (§ final #_"WordOperationPlugin" :wordOperationPlugin nil)

    (§ defn #_"HotSpotNodePlugin" HotSpotNodePlugin'new-1 [#_"WordOperationPlugin" wordOperationPlugin]
        (let [
            #_"HotSpotNodePlugin" this (Object.)
            this (assoc this :wordOperationPlugin wordOperationPlugin)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"StampPair" HotSpotNodePlugin''interceptType-4 [#_"HotSpotNodePlugin" this, #_"GraphBuilderTool" b, #_"JavaType" declaredType, #_"boolean" never-nil?]
        (when (GraphBuilderTool''parsingIntrinsic-1 b)
            (WordOperationPlugin''interceptType-4 (:wordOperationPlugin this), b, declaredType, never-nil?)
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotNodePlugin''handleInvoke-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
        (and (BytecodeParser''parsingIntrinsic-1 parser)
            (WordOperationPlugin''handleInvoke-4 (:wordOperationPlugin this), parser, method, args)
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotNodePlugin''handleLoadField-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field]
        (or (and (instance? ConstantNode object)
                (HotSpotNodePlugin'tryReadField-3 parser, field, (ValueNode''asJavaConstant-1 object))
            )
            (and (BytecodeParser''parsingIntrinsic-1 parser)
                (WordOperationPlugin''handleLoadField-4 (:wordOperationPlugin this), parser, object, field)
            )
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotNodePlugin''handleLoadStaticField-3 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field]
        (or (HotSpotNodePlugin'tryReadField-3 parser, field, nil)
            (and (BytecodeParser''parsingIntrinsic-1 parser)
                (WordOperationPlugin''handleLoadStaticField-3 (:wordOperationPlugin this), parser, field)
            )
        )
    )

    (§ defn- #_"boolean" HotSpotNodePlugin'tryReadField-3 [#_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"JavaConstant" object]
        (HotSpotNodePlugin'tryConstantFold-3 parser, field, object)
    )

    (§ defn- #_"boolean" HotSpotNodePlugin'tryConstantFold-3 [#_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"JavaConstant" object]
        (let [
            #_"ConstantNode" constant (ConstantFields'tryConstantFold-2 field, object)
        ]
            (and (some? constant)
                (do
                    (BytecodeParser''push-3 parser, (#_"ResolvedJavaField" .getJavaKind field), (Graph''add-2 (:graph parser), constant))
                    true
                )
            )
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotNodePlugin''handleStoreField-5 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value]
        (and (BytecodeParser''parsingIntrinsic-1 parser)
            (WordOperationPlugin''handleStoreField-5 (:wordOperationPlugin this), parser, object, field, value)
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotNodePlugin''handleStoreStaticField-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"ValueNode" value]
        (and (BytecodeParser''parsingIntrinsic-1 parser)
            (WordOperationPlugin''handleStoreStaticField-4 (:wordOperationPlugin this), parser, field, value)
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotNodePlugin''handleLoadIndexed-5 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (and (BytecodeParser''parsingIntrinsic-1 parser)
            (WordOperationPlugin''handleLoadIndexed-5 (:wordOperationPlugin this), parser, array, index, elementKind)
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotNodePlugin''handleStoreIndexed-6 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind, #_"ValueNode" value]
        (and (BytecodeParser''parsingIntrinsic-1 parser)
            (WordOperationPlugin''handleStoreIndexed-6 (:wordOperationPlugin this), parser, array, index, elementKind, value)
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotNodePlugin''handleCheckCast-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
        (and (BytecodeParser''parsingIntrinsic-1 parser)
            (WordOperationPlugin''handleCheckCast-4 (:wordOperationPlugin this), parser, object, type)
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotNodePlugin''handleInstanceOf-4 [#_"HotSpotNodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
        (and (BytecodeParser''parsingIntrinsic-1 parser)
            (WordOperationPlugin''handleInstanceOf-4 (:wordOperationPlugin this), parser, object, type)
        )
    )
)

;;;
 ; Reflection operations on values represented as constants for the
 ; processing of snippets. Snippets need a direct access to the value of object constants, which is
 ; not allowed in other parts of Graal to enforce compiler-VM separation.
 ;
 ; This interface must not be used in Graal code that is not related to snippet processing.
 ;;
(value-ns SnippetReflection
    ;;;
     ; Creates a boxed {@link JavaKind#Object object} constant.
     ;
     ; @param object the object value to box
     ; @return a constant containing {@code object}
     ;;
    (§ defn #_"JavaConstant" SnippetReflection'forObject-1 [#_"Object" object]
        (#_"HotSpotConstantReflectionProvider" .forObject HotSpot'constantReflection, object)
    )

    ;;;
     ; Gets the object reference a given constant represents if it is of a given type. The constant
     ; must have kind JavaKind#Object.
     ;
     ; @param type the expected type of the object represented by {@code constant}. If the object is required
     ;            to be of this type, then wrap the call to this method in Objects#requireNonNull(Object).
     ; @param constant an object constant
     ; @return the object value represented by {@code constant} if it is an
     ;         {@link ResolvedJavaType#isInstance(JavaConstant) instance of} {@code type} otherwise nil
     ;;
    (§ defn #_"Object" SnippetReflection'asObject-2 [#_"ResolvedJavaType" type, #_"JavaConstant" constant]
        (when-not (#_"JavaConstant" .isNull constant)
            (#_"HotSpotObjectConstant" .asObject constant, type)
        )
    )

    ;;;
     ; Gets the object reference a given constant represents if it is of a given type. The constant
     ; must have kind JavaKind#Object.
     ;
     ; @param type the expected type of the object represented by {@code constant}. If the object is required
     ;            to be of this type, then wrap the call to this method in Objects#requireNonNull(Object).
     ; @param constant an object constant
     ; @return the object value represented by {@code constant} cast to {@code type} if it is an
     ;         {@link Class#isInstance(Object) instance of} {@code type} otherwise nil
     ;;
    (§ defn #_"<T> T" SnippetReflection'asObject-2 [#_"Class<T>" type, #_"JavaConstant" constant]
        (when-not (#_"JavaConstant" .isNull constant)
            (#_"HotSpotObjectConstant" .asObject constant, type)
        )
    )

    ;;;
     ; Creates a boxed constant for the given kind from an Object. The object needs to be of the
     ; Java boxed type corresponding to the kind.
     ;
     ; @param kind the kind of the constant to create
     ; @param value the Java boxed value: a Byte instance for JavaKind#Byte, etc.
     ; @return the boxed copy of {@code value}
     ;;
    (§ defn #_"JavaConstant" SnippetReflection'forBoxed-2 [#_"JavaKind" kind, #_"Object" value]
        (if (= kind JavaKind/Object)
            (SnippetReflection'forObject-1 value)
            (JavaConstant/forBoxedPrimitive value)
        )
    )
)

;;;
 ; Extends WordOperationPlugin to handle HotSpot word operations.
 ;;
(final-ns HotSpotWordOperationPlugin (§ extends WordOperationPlugin)
    (§ defn #_"HotSpotWordOperationPlugin" HotSpotWordOperationPlugin'new-0 []
        (WordOperationPlugin'new-0)
    )

    #_unused
    (§ override! #_"LoadIndexedNode" HotSpotWordOperationPlugin''createLoadIndexedNode-3 [#_"HotSpotWordOperationPlugin" this, #_"ValueNode" array, #_"ValueNode" index]
        (let [
            #_"ResolvedJavaType" arrayType (StampTool'typeOrNull-1 (:stamp array))
            #_"Stamp" componentStamp (WordTypes'getWordStamp-1 (#_"ResolvedJavaType" .getComponentType arrayType))
        ]
            (if (instance? MetaspacePointerStamp componentStamp)
                (LoadIndexedPointerNode'new-3 componentStamp, array, index)
                (WordOperationPlugin''createLoadIndexedNode-3 (§ super ), array, index)
            )
        )
    )

    #_unused
    (§ override! #_"boolean" HotSpotWordOperationPlugin''handleInvoke-4 [#_"HotSpotWordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
        (and (WordTypes'isWordOperation-1 method)
            (let [
                #_"HotSpotOperation" operation (BridgeMethodUtils'getAnnotation-2 HotSpotOperation, method)
            ]
                (if (some? operation)
                    (HotSpotWordOperationPlugin''processHotSpotWordOperation-5 this, parser, method, args, operation)
                    (WordOperationPlugin''processWordOperation-4 this, parser, args, (WordTypes'getWordOperation-2 method, (#_"ResolvedJavaMethod" .getDeclaringClass (BytecodeParser''getMethod-1 parser))))
                )
                true
            )
        )
    )

    (§ method! #_"void" HotSpotWordOperationPlugin''processHotSpotWordOperation-5 [#_"HotSpotWordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args, #_"HotSpotOperation" operation]
        (let [
            #_"JavaKind" returnKind (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature method))
        ]
            (condp =? (HotSpotOperation''opcode-1 operation)
               [HotspotOpcode'POINTER_EQ HotspotOpcode'POINTER_NE]
                    (let [
                        #_"HotspotOpcode" opcode (HotSpotOperation''opcode-1 operation)
                        #_"ValueNode" left (nth args 0)
                        #_"ValueNode" right (nth args 1)
                        #_"PointerEqualsNode" comparison (BytecodeParser''add-2 parser, (PointerEqualsNode'new-2 left, right))
                        #_"ValueNode" eqValue (BytecodeParser''add-2 parser, (ConstantNode'forBoolean-1 (= opcode HotspotOpcode'POINTER_EQ)))
                        #_"ValueNode" neValue (BytecodeParser''add-2 parser, (ConstantNode'forBoolean-1 (= opcode HotspotOpcode'POINTER_NE)))
                    ]
                        (BytecodeParser''addPush-3 parser, returnKind, (ConditionalNode'create-3 comparison, eqValue, neValue))
                    )
                HotspotOpcode'IS_NULL
                    (let [
                        #_"ValueNode" pointer (nth args 0)
                        #_"LogicNode" isNull (BytecodeParser''add-2 parser, (IsNullNode'create-1 pointer))
                    ]
                        (BytecodeParser''addPush-3 parser, returnKind, (ConditionalNode'create-3 isNull, (BytecodeParser''add-2 parser, (ConstantNode'forBoolean-1 true)), (BytecodeParser''add-2 parser, (ConstantNode'forBoolean-1 false))))
                    )
                HotspotOpcode'FROM_POINTER
                    (BytecodeParser''addPush-3 parser, returnKind, (PointerCastNode'new-2 (StampFactory'forKind-1 WordTypes'wordKind), (nth args 0)))
                HotspotOpcode'TO_KLASS_POINTER
                    (BytecodeParser''addPush-3 parser, returnKind, (PointerCastNode'new-2 KlassPointerStamp'KLASS, (nth args 0)))
                HotspotOpcode'TO_METHOD_POINTER
                    (BytecodeParser''addPush-3 parser, returnKind, (PointerCastNode'new-2 MethodPointerStamp'METHOD, (nth args 0)))
                HotspotOpcode'READ_KLASS_POINTER
                    (let [
                        #_"Stamp" readStamp KlassPointerStamp'KLASS
                        #_"AddressNode" address (WordOperationPlugin''makeAddress-4 this, parser, (nth args 0), (nth args 1))
                        #_"LocationIdentity" location
                            (if (= (count args) 2)
                                (LocationIdentity/any)
                                (SnippetReflection'asObject-2 LocationIdentity, (ValueNode''asJavaConstant-1 (nth args 2)))
                            )
                        #_"ReadNode" read (BytecodeParser''add-2 parser, (ReadNode'new-4 address, location, readStamp, BarrierType'NONE))
                    ]
                        (BytecodeParser''push-3 parser, returnKind, read)
                    )
            )
        )
        nil
    )
)

;;;
 ; Marks the control flow path where an object acquired a lightweight lock based on an atomic
 ; compare-and-swap (CAS) of the mark word in the object's header.
 ;;
(final-ns AcquiredCASLockNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<AcquiredCASLockNode>" AcquiredCASLockNode'TYPE (NodeClass'create-1 AcquiredCASLockNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)

    #_unused
    (§ defn #_"AcquiredCASLockNode" AcquiredCASLockNode'new-1 [#_"ValueNode" object]
        (let [
            #_"AcquiredCASLockNode" this (FixedWithNextNode'new-2 AcquiredCASLockNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :object object)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AcquiredCASLockNode''generate-2 [#_"AcquiredCASLockNode" this, #_"LIRBuilder" builder]
        ;; this is just a marker node, so it generates nothing
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"void" AcquiredCASLockNode'mark-1 [#_"Object" object])
)

;;;
 ; Reserves a block of memory in the stack frame of a method. The block is reserved in the frame for
 ; the entire execution of the associated method.
 ;;
(final-ns AllocaNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<AllocaNode>" AllocaNode'TYPE (NodeClass'create-1 AllocaNode))

    ;;;
     ; The number of slots in block.
     ;;
    (§ final #_"int" :slots 0)

    ;;;
     ; The indexes of the object pointer slots in the block. Each such object pointer slot must be
     ; initialized before any safepoint in the method otherwise the garbage collector will see
     ; garbage values when processing these slots.
     ;;
    (§ final #_"BitSet" :objects nil)

    #_unused
    (§ defn #_"AllocaNode" AllocaNode'new-1 [#_"int" slots]
        (AllocaNode'new-3 slots, WordTypes'wordKind, (BitSet.))
    )

    (§ defn #_"AllocaNode" AllocaNode'new-3 [#_"int" slots, #_"JavaKind" wordKind, #_"BitSet" objects]
        (let [
            #_"AllocaNode" this (FixedWithNextNode'new-2 AllocaNode'TYPE, (StampFactory'forKind-1 wordKind))
            this (assoc this :slots slots)
            this (assoc this :objects objects)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AllocaNode''generate-2 [#_"AllocaNode" this, #_"LIRBuilder" builder]
        (let [
            #_"VirtualStackSlot" array (FrameMapBuilder''allocateStackSlots-4 (:frameMapBuilder (:res (:gen builder))), (:slots this), (:objects this), nil)
            #_"Value" result (LIRGenerator''emitAddress-2 (:gen builder), array)
        ]
            (LIRBuilder''setResult-3 builder, this, result)
        )
        nil
    )

    ; @NodeIntrinsic
    #_unused
    (§ native #_"Word" AllocaNode'alloca-1 [#_@ConstantNodeParameter #_"int" slots])
)

(class-ns ArrayRangeWriteBarrier (§ extends WriteBarrier) (§ implements Lowerable)
    (§ def #_"NodeClass<ArrayRangeWriteBarrier>" ArrayRangeWriteBarrier'TYPE (NodeClass'create-1 ArrayRangeWriteBarrier))

    ; @Input(InputType'Association)
    (§ mutable #_"AddressNode" :address nil)
    ; @Input
    (§ mutable #_"ValueNode" :length nil)

    (§ final #_"int" :elementStride 0)

    (§ defn #_"ArrayRangeWriteBarrier" ArrayRangeWriteBarrier'new-4 [#_"NodeClass<? extends ArrayRangeWriteBarrier>" c, #_"AddressNode" address, #_"ValueNode" length, #_"int" elementStride]
        (let [
            #_"ArrayRangeWriteBarrier" this (WriteBarrier'new-1 c)
            this (assoc this :address address)
            this (assoc this :length length)
            this (assoc this :elementStride elementStride)
        ]
            this
        )
    )

    (§ method #_"AddressNode" ArrayRangeWriteBarrier''getAddress-1 [#_"ArrayRangeWriteBarrier" this]
        (:address this)
    )

    (§ method #_"ValueNode" ArrayRangeWriteBarrier''getLength-1 [#_"ArrayRangeWriteBarrier" this]
        (:length this)
    )

    (§ method #_"int" ArrayRangeWriteBarrier''getElementStride-1 [#_"ArrayRangeWriteBarrier" this]
        (:elementStride this)
    )
)

;;;
 ; Intrinsic for opening a scope binding a stack-based lock with an object. A lock scope must be
 ; closed with an EndLockScopeNode. The frame state after this node denotes that the object
 ; is locked (ensuring the GC sees and updates the object) so it must come after any nil pointer
 ; check on the object.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns BeginLockScopeNode (§ extends AbstractMemoryCheckpoint) (§ implements LIRLowerable, MonitorEnter, Single)
    (§ def #_"NodeClass<BeginLockScopeNode>" BeginLockScopeNode'TYPE (NodeClass'create-1 BeginLockScopeNode))

    (§ mutable #_"int" :lockDepth 0)

    #_unused
    (§ defn #_"BeginLockScopeNode" BeginLockScopeNode'new-1 [#_"int" lockDepth]
        (let [
            #_"BeginLockScopeNode" this (AbstractMemoryCheckpoint'new-2 BeginLockScopeNode'TYPE, (StampFactory'forKind-1 WordTypes'wordKind))
            this (assoc this :lockDepth lockDepth)
        ]
            this
        )
    )

    #_unused
    (§ defn #_"BeginLockScopeNode" BeginLockScopeNode'new-2 [#_"JavaKind" kind, #_"int" lockDepth]
        (let [
            #_"BeginLockScopeNode" this (AbstractMemoryCheckpoint'new-2 BeginLockScopeNode'TYPE, (StampFactory'forKind-1 kind))
            this (assoc this :lockDepth lockDepth)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" BeginLockScopeNode''hasSideEffect-1 [#_"BeginLockScopeNode" this]
        false
    )

    #_unused
    (§ override! #_"LocationIdentity" BeginLockScopeNode''getLocationIdentity-1 [#_"BeginLockScopeNode" this]
        (LocationIdentity/any)
    )

    #_unused
    (§ override! #_"void" BeginLockScopeNode''generate-2 [#_"BeginLockScopeNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAddress-2 (:gen builder), (LIRGenerator''getLockSlot-2 (:gen builder), (:lockDepth this))))
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"Word" BeginLockScopeNode'beginLockScope-1 [#_@ConstantNodeParameter #_"int" lockDepth])
)

;;;
 ; A high-level intrinsic for getting an address inside of an object. During lowering it will be
 ; moved next to any uses to avoid creating a derived pointer that is live across a safepoint.
 ;;
(final-ns ComputeObjectAddressNode (§ extends FixedWithNextNode) (§ implements Lowerable, ControlFlowAnchored)
    (§ def #_"NodeClass<ComputeObjectAddressNode>" ComputeObjectAddressNode'TYPE (NodeClass'create-1 ComputeObjectAddressNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)
    ; @Input
    (§ mutable #_"ValueNode" :offset nil)

    #_unused
    (§ defn #_"ComputeObjectAddressNode" ComputeObjectAddressNode'new-2 [#_"ValueNode" obj, #_"ValueNode" offset]
        (let [
            #_"ComputeObjectAddressNode" this (FixedWithNextNode'new-2 ComputeObjectAddressNode'TYPE, (StampFactory'forKind-1 JavaKind/Long))
            this (assoc this :object obj)
            this (assoc this :offset offset)
        ]
            this
        )
    )

    ; @NodeIntrinsic
    (§ native #_"long" ComputeObjectAddressNode'get-2 [#_"Object" array, #_"long" offset])

    #_unused
    (§ override! #_"void" ComputeObjectAddressNode''lower-2 [#_"ComputeObjectAddressNode" this, #_"LoweringTool" lowerer]
        (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
            (Lowerer'lowerComputeObjectAddressNode-1 this)
        )
        nil
    )
)

;;;
 ; Gets the address of the C++ JavaThread object for the current thread.
 ;;
(final-ns CurrentJavaThreadNode (§ extends FloatingNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<CurrentJavaThreadNode>" CurrentJavaThreadNode'TYPE (NodeClass'create-1 CurrentJavaThreadNode))

    #_unused
    (§ defn #_"CurrentJavaThreadNode" CurrentJavaThreadNode'new-0 []
        (CurrentJavaThreadNode'new-1 WordTypes'wordKind)
    )

    (§ defn #_"CurrentJavaThreadNode" CurrentJavaThreadNode'new-1 [#_"JavaKind" wordKind]
        (FloatingNode'new-2 CurrentJavaThreadNode'TYPE, (StampFactory'forKind-1 wordKind))
    )

    #_unused
    (§ override! #_"void" CurrentJavaThreadNode''generate-2 [#_"CurrentJavaThreadNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (#_"Register" .asValue HotSpot'threadRegister, (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target)))))
        nil
    )

    ; @NodeIntrinsic
    #_unused
    (§ native #_"Word" CurrentJavaThreadNode'get-0 [])
)

;;;
 ; Intrinsic for getting the lock in the current lock scope.
 ;;
(final-ns CurrentLockNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<CurrentLockNode>" CurrentLockNode'TYPE (NodeClass'create-1 CurrentLockNode))

    (§ mutable #_"int" :lockDepth 0)

    #_unused
    (§ defn #_"CurrentLockNode" CurrentLockNode'new-1 [#_"int" lockDepth]
        (let [
            #_"CurrentLockNode" this (FixedWithNextNode'new-2 CurrentLockNode'TYPE, (StampFactory'forKind-1 WordTypes'wordKind))
            this (assoc this :lockDepth lockDepth)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" CurrentLockNode''generate-2 [#_"CurrentLockNode" this, #_"LIRBuilder" builder]
        ;; the register allocator cannot handle stack -> register moves, so we use an LEA here
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAddress-2 (:gen builder), (LIRGenerator''getLockSlot-2 (:gen builder), (:lockDepth this))))
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"Word" CurrentLockNode'currentLock-1 [#_@ConstantNodeParameter #_"int" lockDepth])
)

;;;
 ; Removes the current frame and tail calls the uncommon trap routine.
 ;;
(final-ns DeoptimizeCallerNode (§ extends ControlSinkNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<DeoptimizeCallerNode>" DeoptimizeCallerNode'TYPE (NodeClass'create-1 DeoptimizeCallerNode))

    (§ final #_"DeoptimizationAction" :action nil)
    (§ final #_"DeoptimizationReason" :reason nil)

    #_unused
    (§ defn #_"DeoptimizeCallerNode" DeoptimizeCallerNode'new-2 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason]
        (let [
            #_"DeoptimizeCallerNode" this (ControlSinkNode'new-2 DeoptimizeCallerNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :action action)
            this (assoc this :reason reason)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" DeoptimizeCallerNode''generate-2 [#_"DeoptimizeCallerNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''emitDeoptimizeCaller-3 (:gen builder), (:action this), (:reason this))
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"void" DeoptimizeCallerNode'deopt-2 [#_@ConstantNodeParameter #_"DeoptimizationAction" action, #_@ConstantNodeParameter #_"DeoptimizationReason" reason])
)

;;;
 ; Intrinsic for closing a scope binding a stack-based lock with an object.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns EndLockScopeNode (§ extends AbstractMemoryCheckpoint) (§ implements LIRLowerable, MonitorExit, Single)
    (§ def #_"NodeClass<EndLockScopeNode>" EndLockScopeNode'TYPE (NodeClass'create-1 EndLockScopeNode))

    #_unused
    (§ defn #_"EndLockScopeNode" EndLockScopeNode'new-0 []
        (AbstractMemoryCheckpoint'new-2 EndLockScopeNode'TYPE, (StampFactory'forVoid-0))
    )

    #_unused
    (§ override! #_"boolean" EndLockScopeNode''hasSideEffect-1 [#_"EndLockScopeNode" this]
        false
    )

    #_unused
    (§ override! #_"LocationIdentity" EndLockScopeNode''getLocationIdentity-1 [#_"EndLockScopeNode" this]
        (LocationIdentity/any)
    )

    #_unused
    (§ override! #_"void" EndLockScopeNode''generate-2 [#_"EndLockScopeNode" this, #_"LIRBuilder" builder]
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"void" EndLockScopeNode'endLockScope-0 [])
)

;;;
 ; Marks the control flow path where an object acquired a biased lock because the lock was already
 ; biased to the object on the current thread.
 ;;
(final-ns FastAcquireBiasedLockNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<FastAcquireBiasedLockNode>" FastAcquireBiasedLockNode'TYPE (NodeClass'create-1 FastAcquireBiasedLockNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)

    #_unused
    (§ defn #_"FastAcquireBiasedLockNode" FastAcquireBiasedLockNode'new-1 [#_"ValueNode" object]
        (let [
            #_"FastAcquireBiasedLockNode" this (FixedWithNextNode'new-2 FastAcquireBiasedLockNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :object object)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" FastAcquireBiasedLockNode''generate-2 [#_"FastAcquireBiasedLockNode" this, #_"LIRBuilder" builder]
        ;; this is just a marker node, so it generates nothing
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"void" FastAcquireBiasedLockNode'mark-1 [#_"Object" object])
)

(final-ns G1ArrayRangePostWriteBarrier (§ extends ArrayRangeWriteBarrier)
    (§ def #_"NodeClass<G1ArrayRangePostWriteBarrier>" G1ArrayRangePostWriteBarrier'TYPE (NodeClass'create-1 G1ArrayRangePostWriteBarrier))

    (§ defn #_"G1ArrayRangePostWriteBarrier" G1ArrayRangePostWriteBarrier'new-3 [#_"AddressNode" address, #_"ValueNode" length, #_"int" elementStride]
        (ArrayRangeWriteBarrier'new-4 G1ArrayRangePostWriteBarrier'TYPE, address, length, elementStride)
    )
)

(final-ns G1ArrayRangePreWriteBarrier (§ extends ArrayRangeWriteBarrier)
    (§ def #_"NodeClass<G1ArrayRangePreWriteBarrier>" G1ArrayRangePreWriteBarrier'TYPE (NodeClass'create-1 G1ArrayRangePreWriteBarrier))

    (§ defn #_"G1ArrayRangePreWriteBarrier" G1ArrayRangePreWriteBarrier'new-3 [#_"AddressNode" address, #_"ValueNode" length, #_"int" elementStride]
        (ArrayRangeWriteBarrier'new-4 G1ArrayRangePreWriteBarrier'TYPE, address, length, elementStride)
    )
)

(final-ns G1PostWriteBarrier (§ extends ObjectWriteBarrier)
    (§ def #_"NodeClass<G1PostWriteBarrier>" G1PostWriteBarrier'TYPE (NodeClass'create-1 G1PostWriteBarrier))

    (§ final #_"boolean" :always-nil? false)

    (§ defn #_"G1PostWriteBarrier" G1PostWriteBarrier'new-4 [#_"AddressNode" address, #_"ValueNode" value, #_"boolean" precise?, #_"boolean" always-nil?]
        (G1PostWriteBarrier'new-5 G1PostWriteBarrier'TYPE, address, value, precise?, always-nil?)
    )

    (§ defn #_"G1PostWriteBarrier" G1PostWriteBarrier'new-5 [#_"NodeClass<? extends G1PostWriteBarrier>" c, #_"AddressNode" address, #_"ValueNode" value, #_"boolean" precise?, #_"boolean" always-nil?]
        (let [
            #_"G1PostWriteBarrier" this (ObjectWriteBarrier'new-4 c, address, value, precise?)
            this (assoc this :always-nil? always-nil?)
        ]
            this
        )
    )
)

(final-ns G1PreWriteBarrier (§ extends ObjectWriteBarrier) (§ implements DeoptBefore)
    (§ def #_"NodeClass<G1PreWriteBarrier>" G1PreWriteBarrier'TYPE (NodeClass'create-1 G1PreWriteBarrier))

    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateBefore nil)

    (§ final #_"boolean" :nullCheck false)
    (§ final #_"boolean" :doLoad false)

    (§ defn #_"G1PreWriteBarrier" G1PreWriteBarrier'new-4 [#_"AddressNode" address, #_"ValueNode" expectedObject, #_"boolean" doLoad, #_"boolean" nullCheck]
        (let [
            #_"G1PreWriteBarrier" this (ObjectWriteBarrier'new-4 G1PreWriteBarrier'TYPE, address, expectedObject, true)
            this (assoc this :doLoad doLoad)
            this (assoc this :nullCheck nullCheck)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" G1PreWriteBarrier''canDeoptimize-1 [#_"G1PreWriteBarrier" this]
        (:nullCheck this)
    )

    #_unused
    (§ override! #_"FrameState" G1PreWriteBarrier''stateBefore-1 [#_"G1PreWriteBarrier" this]
        (:stateBefore this)
    )

    (§ override! #_"void" G1PreWriteBarrier''setStateBefore-2 [#_"G1PreWriteBarrier" this, #_"FrameState" state]
        (Node''updateUsages-3 this, (:stateBefore this), state)
        (§ ass! this (assoc this :stateBefore state))
        nil
    )
)

;;;
 ; The G1ReferentFieldReadBarrier is added when a read access is performed to the referent
 ; field of a {@link java.lang.ref.Reference} object (through a LoadFieldNode or an
 ; UnsafeLoadNode). The return value of the read is passed to the snippet implementing the
 ; read barrier and consequently is added to the SATB queue if the concurrent marker is enabled.
 ;;
(final-ns G1ReferentFieldReadBarrier (§ extends ObjectWriteBarrier)
    (§ def #_"NodeClass<G1ReferentFieldReadBarrier>" G1ReferentFieldReadBarrier'TYPE (NodeClass'create-1 G1ReferentFieldReadBarrier))

    (§ final #_"boolean" :doLoad false)

    (§ defn #_"G1ReferentFieldReadBarrier" G1ReferentFieldReadBarrier'new-3 [#_"AddressNode" address, #_"ValueNode" expectedObject, #_"boolean" doLoad]
        (let [
            #_"G1ReferentFieldReadBarrier" this (ObjectWriteBarrier'new-4 G1ReferentFieldReadBarrier'TYPE, address, expectedObject, true)
            this (assoc this :doLoad doLoad)
        ]
            this
        )
    )

    (§ method! #_"ValueNode" G1ReferentFieldReadBarrier''getExpectedObject-1 [#_"G1ReferentFieldReadBarrier" this]
        (:value this)
    )
)

;;;
 ; Intrinsification for getting the address of an object. The code path(s) between a call to
 ; #get(Object) and all uses of the returned value must not contain safepoints. This can
 ; only be guaranteed if used in a snippet that is instantiated after frame state assignment.
 ; ComputeObjectAddressNode should generally be used in preference to this node.
 ;;
(final-ns GetObjectAddressNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<GetObjectAddressNode>" GetObjectAddressNode'TYPE (NodeClass'create-1 GetObjectAddressNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)

    (§ defn #_"GetObjectAddressNode" GetObjectAddressNode'new-1 [#_"ValueNode" obj]
        (let [
            #_"GetObjectAddressNode" this (FixedWithNextNode'new-2 GetObjectAddressNode'TYPE, (StampFactory'forKind-1 JavaKind/Long))
            this (assoc this :object obj)
        ]
            this
        )
    )

    ; @NodeIntrinsic
    #_unused
    (§ native #_"long" GetObjectAddressNode'get-1 [#_"Object" array])

    #_unused
    (§ override! #_"void" GetObjectAddressNode''generate-2 [#_"GetObjectAddressNode" this, #_"LIRBuilder" builder]
        (let [
            #_"AllocatableValue" obj (LIRGenerator''newVariable-2 (:gen builder), (LIRKind'unknownReference-1 (#_"Architecture" .getWordKind (.arch HotSpot'target))))
        ]
            (LIRGenerator''emitMove-3 (:gen builder), obj, (LIRBuilder''operand-2 builder, (:object this)))
            (LIRBuilder''setResult-3 builder, this, obj)
        )
        nil
    )
)

;;;
 ; Represents HotSpot values that may change after compilation.
 ;;
(final-ns GraalHotSpotVMConfigNode (§ extends FloatingNode) (§ implements LIRLowerable, Canonicalizable)
    (§ def #_"NodeClass<GraalHotSpotVMConfigNode>" GraalHotSpotVMConfigNode'TYPE (NodeClass'create-1 GraalHotSpotVMConfigNode))

    (§ final #_"int" :markId 0)

    ;;;
     ; Constructor for #areConfigValuesConstant().
     ;;
    #_unused
    (§ defn #_"GraalHotSpotVMConfigNode" GraalHotSpotVMConfigNode'new-0 []
        (let [
            #_"GraalHotSpotVMConfigNode" this (FloatingNode'new-2 GraalHotSpotVMConfigNode'TYPE, (StampFactory'forKind-1 JavaKind/Boolean))
            this (assoc this :markId 0)
        ]
            this
        )
    )

    ;;;
     ; Constructor for node intrinsics below.
     ;
     ; @param markId id of the config value
     ;;
    #_unused
    (§ defn #_"GraalHotSpotVMConfigNode" GraalHotSpotVMConfigNode'new-2 [#_@InjectedNodeParameter #_"Stamp" stamp, #_"int" markId]
        (let [
            #_"GraalHotSpotVMConfigNode" this (FloatingNode'new-2 GraalHotSpotVMConfigNode'TYPE, stamp)
            this (assoc this :markId markId)
        ]
            this
        )
    )

    ;;;
     ; Constructor with explicit type specification.
     ;
     ; @param markId id of the config value
     ; @param kind explicit type of the node
     ;;
    #_unused
    (§ defn #_"GraalHotSpotVMConfigNode" GraalHotSpotVMConfigNode'new-2 [#_"int" markId, #_"JavaKind" kind]
        (let [
            #_"GraalHotSpotVMConfigNode" this (FloatingNode'new-2 GraalHotSpotVMConfigNode'TYPE, (StampFactory'forKind-1 kind))
            this (assoc this :markId markId)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" GraalHotSpotVMConfigNode''generate-2 [#_"GraalHotSpotVMConfigNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitLoadConfigValue-3 (:gen builder), (:markId this), (Stamp''getLIRKind-1 (:stamp this))))
        nil
    )

    ; @NodeIntrinsic
    (§ native- #_"boolean" GraalHotSpotVMConfigNode'areConfigValuesConstant-0 [])

    ; @NodeIntrinsic
    (§ native- #_"long" GraalHotSpotVMConfigNode'loadLongConfigValue-1 [#_@ConstantNodeParameter #_"int" markId])

    ; @NodeIntrinsic
    (§ native- #_"int" GraalHotSpotVMConfigNode'loadIntConfigValue-1 [#_@ConstantNodeParameter #_"int" markId])

    ; @NodeIntrinsic
    (§ native- #_"byte" GraalHotSpotVMConfigNode'loadByteConfigValue-1 [#_@ConstantNodeParameter #_"int" markId])

    (§ defn #_"long" GraalHotSpotVMConfigNode'cardTableAddress-0 []
        (GraalHotSpotVMConfigNode'loadLongConfigValue-1 HotSpot'cardTableAddressMark)
    )

    (§ defn #_"boolean" GraalHotSpotVMConfigNode'isCardTableAddressConstant-0 []
        (GraalHotSpotVMConfigNode'areConfigValuesConstant-0)
    )

    (§ defn #_"long" GraalHotSpotVMConfigNode'heapTopAddress-0 []
        (GraalHotSpotVMConfigNode'loadLongConfigValue-1 HotSpot'heapTopAddressMark)
    )

    (§ defn #_"long" GraalHotSpotVMConfigNode'heapEndAddress-0 []
        (GraalHotSpotVMConfigNode'loadLongConfigValue-1 HotSpot'heapEndAddressMark)
    )

    (§ defn #_"int" GraalHotSpotVMConfigNode'logOfHeapRegionGrainBytes-0 []
        (GraalHotSpotVMConfigNode'loadIntConfigValue-1 HotSpot'logOfHeapRegionGrainBytesMark)
    )

    (§ defn #_"boolean" GraalHotSpotVMConfigNode'inlineContiguousAllocationSupported-0 []
        (not (zero? (GraalHotSpotVMConfigNode'loadByteConfigValue-1 HotSpot'inlineContiguousAllocationSupportedMark)))
    )

    #_unused
    (§ override! #_"Node" GraalHotSpotVMConfigNode''canonical-2 [#_"GraalHotSpotVMConfigNode" this, #_"CanonicalizerTool" tool]
        (condp = (:markId this)
            0                                               (ConstantNode'forBoolean-1 true)
            HotSpot'cardTableAddressMark                    (ConstantNode'forLong-1 HotSpot'cardTableAddress)
            HotSpot'heapTopAddressMark                      (ConstantNode'forLong-1 HotSpot'heapTopAddress)
            HotSpot'heapEndAddressMark                      (ConstantNode'forLong-1 HotSpot'heapEndAddress)
            HotSpot'logOfHeapRegionGrainBytesMark           (ConstantNode'forInt-1 HotSpot'logOfHeapRegionGrainBytes)
            HotSpot'inlineContiguousAllocationSupportedMark (ConstantNode'forBoolean-1 HotSpot'inlineContiguousAllocationSupported)
            this
        )
    )
)

(final-ns HotSpotCompressionNode (§ extends CompressionNode)
    (§ def #_"NodeClass<HotSpotCompressionNode>" HotSpotCompressionNode'TYPE (NodeClass'create-1 HotSpotCompressionNode))

    (§ defn #_"HotSpotCompressionNode" HotSpotCompressionNode'new-3 [#_"CompressionOp" op, #_"ValueNode" input, #_"CompressEncoding" encoding]
        (CompressionNode'new-5 HotSpotCompressionNode'TYPE, op, input, (HotSpotNarrowOopStamp'mkStamp-3 op, (:stamp input), encoding), encoding)
    )

    (§ defn #_"HotSpotCompressionNode" HotSpotCompressionNode'compress-2 [#_"ValueNode" input, #_"CompressEncoding" encoding]
        (Graph''add-2 (:graph input), (HotSpotCompressionNode'new-3 CompressionOp'Compress, input, encoding))
    )

    (§ defn #_"CompressionNode" HotSpotCompressionNode'uncompress-2 [#_"ValueNode" input, #_"CompressEncoding" encoding]
        (Graph''add-2 (:graph input), (HotSpotCompressionNode'new-3 CompressionOp'Uncompress, input, encoding))
    )

    #_unused
    (§ override! #_"Constant" HotSpotCompressionNode''compress-2 [#_"HotSpotCompressionNode" this, #_"Constant" constant]
        (if (= constant JavaConstant/NULL_POINTER)
            HotSpotCompressedNullConstant/COMPRESSED_NULL
            (condp instance? constant
                HotSpotConstant (#_"HotSpotConstant" .compress constant)
            )
        )
    )

    #_unused
    (§ override! #_"Constant" HotSpotCompressionNode''uncompress-2 [#_"HotSpotCompressionNode" this, #_"Constant" constant]
        (condp instance? constant
            HotSpotConstant (#_"HotSpotConstant" .uncompress constant)
        )
    )

    #_unused
    (§ override! #_"Stamp" HotSpotCompressionNode''mkStamp-2 [#_"HotSpotCompressionNode" this, #_"Stamp" input]
        (HotSpotNarrowOopStamp'mkStamp-3 (:op this), input, (:encoding this))
    )
)

(final-ns HotSpotDirectCallTargetNode (§ extends DirectCallTargetNode)
    (§ def #_"NodeClass<HotSpotDirectCallTargetNode>" HotSpotDirectCallTargetNode'TYPE (NodeClass'create-1 HotSpotDirectCallTargetNode))

    (§ defn #_"HotSpotDirectCallTargetNode" HotSpotDirectCallTargetNode'new-6 [#_"ValueNode[]" arguments, #_"StampPair" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (DirectCallTargetNode'new-7 HotSpotDirectCallTargetNode'TYPE, arguments, returnStamp, signature, target, callType, invokeKind)
    )
)

(final-ns HotSpotIndirectCallTargetNode (§ extends IndirectCallTargetNode)
    (§ def #_"NodeClass<HotSpotIndirectCallTargetNode>" HotSpotIndirectCallTargetNode'TYPE (NodeClass'create-1 HotSpotIndirectCallTargetNode))

    ; @Input
    (§ mutable #_"ValueNode" :metaspaceMethod nil)

    (§ defn #_"HotSpotIndirectCallTargetNode" HotSpotIndirectCallTargetNode'new-8 [#_"ValueNode" metaspaceMethod, #_"ValueNode" computedAddress, #_"ValueNode[]" arguments, #_"StampPair" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (let [
            #_"HotSpotIndirectCallTargetNode" this (IndirectCallTargetNode'new-8 HotSpotIndirectCallTargetNode'TYPE, computedAddress, arguments, returnStamp, signature, target, callType, invokeKind)
            this (assoc this :metaspaceMethod metaspaceMethod)
        ]
            this
        )
    )
)

(final-ns LoadIndexedPointerNode (§ extends LoadIndexedNode)
    (§ def #_"NodeClass<LoadIndexedPointerNode>" LoadIndexedPointerNode'TYPE (NodeClass'create-1 LoadIndexedPointerNode))

    (§ defn #_"LoadIndexedPointerNode" LoadIndexedPointerNode'new-3 [#_"Stamp" stamp, #_"ValueNode" array, #_"ValueNode" index]
        (LoadIndexedNode'new-5 LoadIndexedPointerNode'TYPE, stamp, array, index, JavaKind/Illegal)
    )

    #_unused
    (§ override! #_"boolean" LoadIndexedPointerNode''inferStamp-1 [#_"LoadIndexedPointerNode" this]
        false
    )
)

(class-ns ObjectWriteBarrier (§ extends WriteBarrier)
    (§ def #_"NodeClass<ObjectWriteBarrier>" ObjectWriteBarrier'TYPE (NodeClass'create-1 ObjectWriteBarrier))

    ; @Input(InputType'Association)
    (§ mutable #_"AddressNode" :address nil)
    ; @OptionalInput
    (§ mutable #_"ValueNode" :value nil)

    (§ final #_"boolean" :precise? false)

    (§ defn #_"ObjectWriteBarrier" ObjectWriteBarrier'new-4 [#_"NodeClass<? extends ObjectWriteBarrier>" c, #_"AddressNode" address, #_"ValueNode" value, #_"boolean" precise?]
        (let [
            #_"ObjectWriteBarrier" this (WriteBarrier'new-1 c)
            this (assoc this :address address)
            this (assoc this :value value)
            this (assoc this :precise? precise?)
        ]
            this
        )
    )
)

(final-ns RandomSeedNode (§ extends FloatingNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<RandomSeedNode>" RandomSeedNode'TYPE (NodeClass'create-1 RandomSeedNode))

    #_unused
    (§ defn #_"RandomSeedNode" RandomSeedNode'new-0 []
        (FloatingNode'new-2 RandomSeedNode'TYPE, (StampFactory'intValue-0))
    )

    #_unused
    (§ override! #_"void" RandomSeedNode''generate-2 [#_"RandomSeedNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitRandomSeed-1 (:gen builder)))
        nil
    )
)

(final-ns SerialArrayRangeWriteBarrier (§ extends ArrayRangeWriteBarrier)
    (§ def #_"NodeClass<SerialArrayRangeWriteBarrier>" SerialArrayRangeWriteBarrier'TYPE (NodeClass'create-1 SerialArrayRangeWriteBarrier))

    (§ defn #_"SerialArrayRangeWriteBarrier" SerialArrayRangeWriteBarrier'new-3 [#_"AddressNode" address, #_"ValueNode" length, #_"int" elementStride]
        (ArrayRangeWriteBarrier'new-4 SerialArrayRangeWriteBarrier'TYPE, address, length, elementStride)
    )
)

(final-ns SerialWriteBarrier (§ extends ObjectWriteBarrier)
    (§ def #_"NodeClass<SerialWriteBarrier>" SerialWriteBarrier'TYPE (NodeClass'create-1 SerialWriteBarrier))

    (§ defn #_"SerialWriteBarrier" SerialWriteBarrier'new-2 [#_"AddressNode" address, #_"boolean" precise?]
        (SerialWriteBarrier'new-3 SerialWriteBarrier'TYPE, address, precise?)
    )

    (§ defn #_"SerialWriteBarrier" SerialWriteBarrier'new-3 [#_"NodeClass<? extends SerialWriteBarrier>" c, #_"AddressNode" address, #_"boolean" precise?]
        (ObjectWriteBarrier'new-4 c, address, nil, precise?)
    )
)

;;;
 ; Node for a foreign call from within a stub.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns StubForeignCallNode (§ extends FixedWithNextNode) (§ implements LIRLowerable, Multi)
    (§ def #_"NodeClass<StubForeignCallNode>" StubForeignCallNode'TYPE (NodeClass'create-1 StubForeignCallNode))

    ; @Input
    (§ mutable #_"NodeInputList<ValueNode>" :arguments nil)

    (§ final #_"ForeignCallDescriptor" :descriptor nil)

    (§ defn #_"StubForeignCallNode" StubForeignCallNode'new-3* [#_@InjectedNodeParameter #_"Stamp" stamp, #_"ForeignCallDescriptor" descriptor, #_"ValueNode..." arguments]
        (let [
            #_"StubForeignCallNode" this (FixedWithNextNode'new-2 StubForeignCallNode'TYPE, stamp)
            this (assoc this :arguments (NodeInputList'new-2 this, arguments))
            this (assoc this :descriptor descriptor)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"LocationIdentity[]" StubForeignCallNode''getLocationIdentities-1 [#_"StubForeignCallNode" this]
        (let [
            #_"LocationIdentity[]" killedLocations (ForeignCalls''getKilledLocations-2 HotSpot'foreignCalls, (:descriptor this))
            killedLocations (Arrays/copyOf killedLocations, (inc (count killedLocations)))
        ]
            (aset killedLocations (dec (count killedLocations)) HotSpotReplacementsUtil'PENDING_EXCEPTION_LOCATION)
            killedLocations
        )
    )

    (§ method! #_"Value[]" StubForeignCallNode''operands-2 [#_"StubForeignCallNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value[]" operands (make-array Value (count (:arguments this)))
        ]
            (dotimes [#_"int" i (count operands)]
                (aset operands i (LIRBuilder''operand-2 builder, (nth (:arguments this) i)))
            )
            operands
        )
    )

    #_unused
    (§ override! #_"void" StubForeignCallNode''generate-2 [#_"StubForeignCallNode" this, #_"LIRBuilder" builder]
        (let [
            #_"ForeignCallLinkage" linkage (ForeignCalls''lookupForeignCall-2 HotSpot'foreignCalls, (:descriptor this))
            #_"Value[]" operands (StubForeignCallNode''operands-2 this, builder)
            #_"Value" result (LIRGenerator''emitForeignCall-3* (:gen builder), linkage, operands)
        ]
            (when (some? result)
                (LIRBuilder''setResult-3 builder, this, result)
            )
        )
        nil
    )
)

;;;
 ; Start node for a Stub's graph.
 ;;
(final-ns StubStartNode (§ extends StartNode)
    (§ def #_"NodeClass<StubStartNode>" StubStartNode'TYPE (NodeClass'create-1 StubStartNode))

    (§ final #_"Stub" :stub nil)

    (§ defn #_"StubStartNode" StubStartNode'new-1 [#_"Stub" stub]
        (let [
            #_"StubStartNode" this (StartNode'new-1 StubStartNode'TYPE)
            this (assoc this :stub stub)
        ]
            this
        )
    )
)

(final-ns HotSpotNarrowOopStamp (§ extends NarrowOopStamp)
    (§ defn- #_"HotSpotNarrowOopStamp" HotSpotNarrowOopStamp'new-5 [#_"ResolvedJavaType" type, #_"boolean" exactType, #_"boolean" never-nil?, #_"boolean" always-nil?, #_"CompressEncoding" encoding]
        (NarrowOopStamp'new-5 type, exactType, never-nil?, always-nil?, encoding)
    )

    #_unused
    (§ override! #_"AbstractObjectStamp" HotSpotNarrowOopStamp''copyWith-5 [#_"HotSpotNarrowOopStamp" this, #_"ResolvedJavaType" type, #_"boolean" exactType, #_"boolean" never-nil?, #_"boolean" always-nil?]
        (HotSpotNarrowOopStamp'new-5 type, exactType, never-nil?, always-nil?, (NarrowOopStamp''getEncoding-1 this))
    )

    (§ defn #_"Stamp" HotSpotNarrowOopStamp'compressed-2 [#_"AbstractObjectStamp" stamp, #_"CompressEncoding" encoding]
        (HotSpotNarrowOopStamp'new-5 (AbstractObjectStamp''type-1 stamp), (AbstractObjectStamp''isExactType-1 stamp), (:never-nil? stamp), (:always-nil? stamp), encoding)
    )

    #_unused
    (§ override! #_"Constant" HotSpotNarrowOopStamp''readConstant-4 [#_"HotSpotNarrowOopStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
        (try
            (#_"HotSpotMemoryAccessProvider" .readNarrowOopConstant provider, base, displacement)
            (catch IllegalArgumentException _
                nil
            )
        )
    )

    #_unused
    (§ override! #_"JavaConstant" HotSpotNarrowOopStamp''asConstant-1 [#_"HotSpotNarrowOopStamp" this]
        (when (:always-nil? this) HotSpotCompressedNullConstant/COMPRESSED_NULL)
    )

    #_unused
    (§ override! #_"boolean" HotSpotNarrowOopStamp''isCompatible-2 [#_"HotSpotNarrowOopStamp" this, #_"Constant" other]
        (if (instance? HotSpotObjectConstant other)
            (#_"HotSpotObjectConstant" .isCompressed other)
            true
        )
    )

    (§ defn #_"Stamp" HotSpotNarrowOopStamp'mkStamp-3 [#_"CompressionOp" op, #_"Stamp" input, #_"CompressEncoding" encoding]
        (condp = op
            CompressionOp'Compress
                (condp instance? input
                    ObjectStamp       (HotSpotNarrowOopStamp'compressed-2 input, encoding) ;; compressed oop
                    KlassPointerStamp (KlassPointerStamp''compressed-2 input, encoding)    ;; compressed klass pointer
                )
            CompressionOp'Uncompress
                (condp instance? input
                    NarrowOopStamp    (NarrowOopStamp''uncompressed-1 input)    ;; oop
                    KlassPointerStamp (KlassPointerStamp''uncompressed-1 input) ;; metaspace pointer
                )
        )
    )
)

(final-ns KlassPointerStamp (§ extends MetaspacePointerStamp)
    (§ def #_"KlassPointerStamp" KlassPointerStamp'KLASS             (KlassPointerStamp'new-2 false, false))
    (§ def #_"KlassPointerStamp" KlassPointerStamp'KLASS_NON_NULL    (KlassPointerStamp'new-2 true, false))
    (§ def #_"KlassPointerStamp" KlassPointerStamp'KLASS_ALWAYS_NULL (KlassPointerStamp'new-2 false, true))

    (§ final #_"CompressEncoding" :encoding nil)

    (§ defn- #_"KlassPointerStamp" KlassPointerStamp'new-2 [#_"boolean" never-nil?, #_"boolean" always-nil?]
        (KlassPointerStamp'new-3 never-nil?, always-nil?, nil)
    )

    (§ defn- #_"KlassPointerStamp" KlassPointerStamp'new-3 [#_"boolean" never-nil?, #_"boolean" always-nil?, #_"CompressEncoding" encoding]
        (let [
            #_"KlassPointerStamp" this (MetaspacePointerStamp'new-2 never-nil?, always-nil?)
            this (assoc this :encoding encoding)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"AbstractPointerStamp" KlassPointerStamp''copyWith-3 [#_"KlassPointerStamp" this, #_"boolean" newNonNull, #_"boolean" newAlwaysNull]
        (KlassPointerStamp'new-3 newNonNull, newAlwaysNull, (:encoding this))
    )

    #_unused
    (§ override! #_"boolean" KlassPointerStamp''isCompatible-2 [#_"KlassPointerStamp" this, #_"Stamp" that]
        (or (= this that)
            (and (instance? KlassPointerStamp that)
                (= (:encoding this) (:encoding that))
            )
        )
    )

    #_unused
    (§ override! #_"boolean" KlassPointerStamp''isCompatible-2 [#_"KlassPointerStamp" this, #_"Constant" constant]
        (if (instance? HotSpotMetaspaceConstant constant)
            (some? (#_"HotSpotMetaspaceConstant" .asResolvedJavaType constant))
            (MetaspacePointerStamp''isCompatible-2 (§ super ), constant)
        )
    )

    #_unused
    (§ override! #_"Stamp" KlassPointerStamp''constant-2 [#_"KlassPointerStamp" this, #_"Constant" constant]
        (if (KlassPointerStamp''isCompressed-1 this)
            (when (= HotSpotCompressedNullConstant/COMPRESSED_NULL constant)
                (§ return (KlassPointerStamp'new-3 false, true, (:encoding this)))
            )
            (when (= JavaConstant/NULL_POINTER constant)
                (§ return KlassPointerStamp'KLASS_ALWAYS_NULL)
            )
        )

        (cond
            (:never-nil? this)                       this
            (KlassPointerStamp''isCompressed-1 this) (KlassPointerStamp'new-3 true, false, (:encoding this))
            :else                                    KlassPointerStamp'KLASS_NON_NULL
        )
    )

    #_unused
    (§ override! #_"Constant" KlassPointerStamp''asConstant-1 [#_"KlassPointerStamp" this]
        (if (and (:always-nil? this) (KlassPointerStamp''isCompressed-1 this))
            HotSpotCompressedNullConstant/COMPRESSED_NULL
            (Stamp''asConstant-1 (§ super ))
        )
    )

    #_unused
    (§ override! #_"LIRKind" KlassPointerStamp''getLIRKind-1 [#_"KlassPointerStamp" this]
        (if (KlassPointerStamp''isCompressed-1 this)
            (LIRKindTool'getNarrowPointerKind-0)
            (MetaspacePointerStamp''getLIRKind-1 (§ super ))
        )
    )

    (§ method! #_"boolean" KlassPointerStamp''isCompressed-1 [#_"KlassPointerStamp" this]
        (some? (:encoding this))
    )

    (§ method! #_"KlassPointerStamp" KlassPointerStamp''compressed-2 [#_"KlassPointerStamp" this, #_"CompressEncoding" newEncoding]
        (KlassPointerStamp'new-3 (:never-nil? this), (:always-nil? this), newEncoding)
    )

    (§ method! #_"KlassPointerStamp" KlassPointerStamp''uncompressed-1 [#_"KlassPointerStamp" this]
        (KlassPointerStamp'new-2 (:never-nil? this), (:always-nil? this))
    )

    #_unused
    (§ override! #_"Constant" KlassPointerStamp''readConstant-4 [#_"KlassPointerStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
        (if (KlassPointerStamp''isCompressed-1 this)
            (#_"HotSpotMemoryAccessProvider" .readNarrowKlassPointerConstant provider, base, displacement)
            (#_"HotSpotMemoryAccessProvider" .readKlassPointerConstant provider, base, displacement)
        )
    )
)

(class-ns MetaspacePointerStamp (§ extends AbstractPointerStamp)
    (§ defn #_"MetaspacePointerStamp" MetaspacePointerStamp'new-2 [#_"boolean" never-nil?, #_"boolean" always-nil?]
        (AbstractPointerStamp'new-2 never-nil?, always-nil?)
    )

    (§ override #_"LIRKind" MetaspacePointerStamp''getLIRKind-1 [#_"MetaspacePointerStamp" this]
        (LIRKindTool'getWordKind-0)
    )

    #_unused
    (§ override #_"Stamp" MetaspacePointerStamp''empty-1 [#_"MetaspacePointerStamp" this]
        ;; there is no empty pointer stamp
        this
    )

    (§ override #_"boolean" MetaspacePointerStamp''isCompatible-2 [#_"MetaspacePointerStamp" this, #_"Constant" constant]
        (#_"Constant" .isDefaultForKind constant)
    )

    #_unused
    (§ override #_"boolean" MetaspacePointerStamp''hasValues-1 [#_"MetaspacePointerStamp" this]
        true
    )

    #_unused
    (§ override #_"Stamp" MetaspacePointerStamp''join-2 [#_"MetaspacePointerStamp" this, #_"Stamp" other]
        (AbstractPointerStamp''defaultPointerJoin-2 this, other)
    )

    #_unused
    (§ override #_"ResolvedJavaType" MetaspacePointerStamp''javaType-1 [#_"MetaspacePointerStamp" this]
        (throw! "metaspace pointer has no Java type")
    )
)

(final-ns MethodPointerStamp (§ extends MetaspacePointerStamp)
    (§ def- #_"MethodPointerStamp" MethodPointerStamp'METHOD             (MethodPointerStamp'new-2 false, false))
    (§ def- #_"MethodPointerStamp" MethodPointerStamp'METHOD_NON_NULL    (MethodPointerStamp'new-2 true, false))
    (§ def- #_"MethodPointerStamp" MethodPointerStamp'METHOD_ALWAYS_NULL (MethodPointerStamp'new-2 false, true))

    (§ defn- #_"MethodPointerStamp" MethodPointerStamp'new-2 [#_"boolean" never-nil?, #_"boolean" always-nil?]
        (MetaspacePointerStamp'new-2 never-nil?, always-nil?)
    )

    #_unused
    (§ override! #_"AbstractPointerStamp" MethodPointerStamp''copyWith-3 [#_"MethodPointerStamp" this, #_"boolean" newNonNull, #_"boolean" newAlwaysNull]
        (cond
            newNonNull    MethodPointerStamp'METHOD_NON_NULL
            newAlwaysNull MethodPointerStamp'METHOD_ALWAYS_NULL
            :else         MethodPointerStamp'METHOD
        )
    )

    #_unused
    (§ override! #_"boolean" MethodPointerStamp''isCompatible-2 [#_"MethodPointerStamp" this, #_"Stamp" otherStamp]
        (or (= this otherStamp) (instance? MethodPointerStamp otherStamp))
    )

    #_unused
    (§ override! #_"boolean" MethodPointerStamp''isCompatible-2 [#_"MethodPointerStamp" this, #_"Constant" constant]
        (if (instance? HotSpotMetaspaceConstant constant)
            (some? (#_"HotSpotMetaspaceConstant" .asResolvedJavaMethod constant))
            (MetaspacePointerStamp''isCompatible-2 (§ super ), constant)
        )
    )

    #_unused
    (§ override! #_"Stamp" MethodPointerStamp''constant-2 [#_"MethodPointerStamp" this, #_"Constant" constant]
        (if (= JavaConstant/NULL_POINTER constant)
            MethodPointerStamp'METHOD_ALWAYS_NULL
            MethodPointerStamp'METHOD_NON_NULL
        )
    )

    #_unused
    (§ override! #_"Constant" MethodPointerStamp''readConstant-4 [#_"MethodPointerStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement]
        (#_"HotSpotMemoryAccessProvider" .readMethodPointerConstant provider, base, displacement)
    )
)

(class-ns WriteBarrier (§ extends FixedWithNextNode) (§ implements Lowerable)
    (§ def #_"NodeClass<WriteBarrier>" WriteBarrier'TYPE (NodeClass'create-1 WriteBarrier))

    (§ defn #_"WriteBarrier" WriteBarrier'new-1 [#_"NodeClass<? extends WriteBarrier>" c]
        (FixedWithNextNode'new-2 c, (StampFactory'forVoid-0))
    )

    #_unused
    (§ override #_"void" WriteBarrier''lower-2 [#_"WriteBarrier" this, #_"LoweringTool" lowerer]
        (WriteBarrierTemplates''lower-3 Lowerer'writeBarrierSnippets, this, lowerer)
        nil
    )
)

(final-ns WriteBarrierAdditionPhase (§ extends Phase)
    (§ defn #_"WriteBarrierAdditionPhase" WriteBarrierAdditionPhase'new-0 []
        (Phase'new-0)
    )

    #_unused
    (§ override! #_"void" WriteBarrierAdditionPhase''run-2 [#_"WriteBarrierAdditionPhase" this, #_"Graph" graph]
        (doseq [#_"Node" node (Graph''getNodes-1 graph)]
            (condp instance? node
                ReadNode                      (WriteBarrierAdditionPhase''addReadNodeBarriers-3 this, node, graph)
                WriteNode                     (WriteBarrierAdditionPhase''addWriteNodeBarriers-3 this, node, graph)
                LoweredAtomicReadAndWriteNode (WriteBarrierAdditionPhase''addAtomicReadWriteNodeBarriers-3 this, node, graph)
                AbstractCompareAndSwapNode    (WriteBarrierAdditionPhase''addCASBarriers-3 this, node, graph)
                ArrayRangeWrite
                    (when (ArrayRangeWrite''writesObjectArray-1 node)
                        (WriteBarrierAdditionPhase''addArrayRangeBarriers-3 this, node, graph)
                    )
                nil
            )
        )
        nil
    )

    (§ method- #_"void" WriteBarrierAdditionPhase''addReadNodeBarriers-3 [#_"WriteBarrierAdditionPhase" this, #_"ReadNode" node, #_"Graph" graph]
        (when (= (FixedAccessNode''getBarrierType-1 node) BarrierType'PRECISE)
            (Graph''addAfterFixed-3 graph, node, (Graph''add-2 graph, (G1ReferentFieldReadBarrier'new-3 (FixedAccessNode''getAddress-1 node), node, false)))
        )
        nil
    )

    (§ defn #_"void" WriteBarrierAdditionPhase'addG1PreWriteBarrier-6 [#_"FixedAccessNode" node, #_"AddressNode" address, #_"ValueNode" value, #_"boolean" doLoad, #_"boolean" nullCheck, #_"Graph" graph]
        (let [
            #_"G1PreWriteBarrier" preBarrier (Graph''add-2 graph, (G1PreWriteBarrier'new-4 address, value, doLoad, nullCheck))
        ]
            (G1PreWriteBarrier''setStateBefore-2 preBarrier, (DeoptimizingFixedWithNextNode''stateBefore-1 node))
            (§ ass! node (FixedAccessNode''setNullCheck-2 node, false))
            (DeoptimizingFixedWithNextNode''setStateBefore-2 node, nil)
            (Graph''addBeforeFixed-3 graph, node, preBarrier)
        )
        nil
    )

    (§ method! #_"void" WriteBarrierAdditionPhase''addG1PostWriteBarrier-6 [#_"WriteBarrierAdditionPhase" this, #_"FixedAccessNode" node, #_"AddressNode" address, #_"ValueNode" value, #_"boolean" precise?, #_"Graph" graph]
        (Graph''addAfterFixed-3 graph, node, (Graph''add-2 graph, (G1PostWriteBarrier'new-4 address, value, precise?, (StampTool'isPointerAlwaysNull-1 (:stamp value)))))
        nil
    )

    (§ method! #_"void" WriteBarrierAdditionPhase''addSerialPostWriteBarrier-6 [#_"WriteBarrierAdditionPhase" this, #_"FixedAccessNode" node, #_"AddressNode" address, #_"ValueNode" value, #_"boolean" precise?, #_"Graph" graph]
        (when-not (StampTool'isPointerAlwaysNull-1 (:stamp value)) ;; serial barrier isn't needed for nil value
            (Graph''addAfterFixed-3 graph, node, (Graph''add-2 graph, (SerialWriteBarrier'new-2 address, precise?)))
        )
        nil
    )

    (§ method- #_"void" WriteBarrierAdditionPhase''addWriteNodeBarriers-3 [#_"WriteBarrierAdditionPhase" this, #_"WriteNode" node, #_"Graph" graph]
        (let [
            #_"BarrierType" barrierType (FixedAccessNode''getBarrierType-1 node)
        ]
            (condp =? barrierType
               [BarrierType'IMPRECISE BarrierType'PRECISE]
                    (let [
                        #_"boolean" precise? (= barrierType BarrierType'PRECISE)
                    ]
                        (if HotSpot'useG1GC
                            (do
                                (when-not (#_"LocationIdentity" .isInit (FixedAccessNode''getLocationIdentity-1 node))
                                    (WriteBarrierAdditionPhase'addG1PreWriteBarrier-6 node, (FixedAccessNode''getAddress-1 node), nil, true, (:nullCheck node), graph)
                                )
                                (WriteBarrierAdditionPhase''addG1PostWriteBarrier-6 this, node, (FixedAccessNode''getAddress-1 node), (AbstractWriteNode''value-1 node), precise?, graph)
                            )
                            (WriteBarrierAdditionPhase''addSerialPostWriteBarrier-6 this, node, (FixedAccessNode''getAddress-1 node), (AbstractWriteNode''value-1 node), precise?, graph)
                        )
                    )
                BarrierType'NONE nil ;; nothing to do
            )
        )
        nil
    )

    (§ method- #_"void" WriteBarrierAdditionPhase''addAtomicReadWriteNodeBarriers-3 [#_"WriteBarrierAdditionPhase" this, #_"LoweredAtomicReadAndWriteNode" node, #_"Graph" graph]
        (let [
            #_"BarrierType" barrierType (FixedAccessNode''getBarrierType-1 node)
        ]
            (condp =? barrierType
               [BarrierType'IMPRECISE BarrierType'PRECISE]
                    (let [
                        #_"boolean" precise? (= barrierType BarrierType'PRECISE)
                    ]
                        (if HotSpot'useG1GC
                            (do
                                (WriteBarrierAdditionPhase'addG1PreWriteBarrier-6 node, (FixedAccessNode''getAddress-1 node), nil, true, (:nullCheck node), graph)
                                (WriteBarrierAdditionPhase''addG1PostWriteBarrier-6 this, node, (FixedAccessNode''getAddress-1 node), (:newValue node), precise?, graph)
                            )
                            (WriteBarrierAdditionPhase''addSerialPostWriteBarrier-6 this, node, (FixedAccessNode''getAddress-1 node), (:newValue node), precise?, graph)
                        )
                    )
                BarrierType'NONE nil ;; nothing to do
            )
        )
        nil
    )

    (§ method- #_"void" WriteBarrierAdditionPhase''addCASBarriers-3 [#_"WriteBarrierAdditionPhase" this, #_"AbstractCompareAndSwapNode" node, #_"Graph" graph]
        (let [
            #_"BarrierType" barrierType (FixedAccessNode''getBarrierType-1 node)
        ]
            (condp =? barrierType
               [BarrierType'IMPRECISE BarrierType'PRECISE]
                    (let [
                        #_"boolean" precise? (= barrierType BarrierType'PRECISE)
                    ]
                        (if HotSpot'useG1GC
                            (do
                                (WriteBarrierAdditionPhase'addG1PreWriteBarrier-6 node, (FixedAccessNode''getAddress-1 node), (:expectedValue node), false, false, graph)
                                (WriteBarrierAdditionPhase''addG1PostWriteBarrier-6 this, node, (FixedAccessNode''getAddress-1 node), (AbstractCompareAndSwapNode''getNewValue-1 node), precise?, graph)
                            )
                            (WriteBarrierAdditionPhase''addSerialPostWriteBarrier-6 this, node, (FixedAccessNode''getAddress-1 node), (AbstractCompareAndSwapNode''getNewValue-1 node), precise?, graph)
                        )
                    )
                BarrierType'NONE nil ;; nothing to do
            )
        )
        nil
    )

    (§ method- #_"void" WriteBarrierAdditionPhase''addArrayRangeBarriers-3 [#_"WriteBarrierAdditionPhase" this, #_"ArrayRangeWrite" write, #_"Graph" graph]
        (if HotSpot'useG1GC
            (do
                (when-not (ArrayRangeWrite''isInitialization-1 write)
                    (let [
                        #_"G1ArrayRangePreWriteBarrier" g1ArrayRangePreWriteBarrier (Graph''add-2 graph, (G1ArrayRangePreWriteBarrier'new-3 (ArrayRangeWrite''getAddress-1 write), (ArrayRangeWrite''getLength-1 write), (ArrayRangeWrite''getElementStride-1 write)))
                    ]
                        (Graph''addBeforeFixed-3 graph, write, g1ArrayRangePreWriteBarrier)
                    )
                )
                (let [
                    #_"G1ArrayRangePostWriteBarrier" g1ArrayRangePostWriteBarrier (Graph''add-2 graph, (G1ArrayRangePostWriteBarrier'new-3 (ArrayRangeWrite''getAddress-1 write), (ArrayRangeWrite''getLength-1 write), (ArrayRangeWrite''getElementStride-1 write)))
                ]
                    (Graph''addAfterFixed-3 graph, write, g1ArrayRangePostWriteBarrier)
                )
            )
            (let [
                #_"SerialArrayRangeWriteBarrier" serialArrayRangeWriteBarrier (Graph''add-2 graph, (SerialArrayRangeWriteBarrier'new-3 (ArrayRangeWrite''getAddress-1 write), (ArrayRangeWrite''getLength-1 write), (ArrayRangeWrite''getElementStride-1 write)))
            ]
                (Graph''addAfterFixed-3 graph, write, serialArrayRangeWriteBarrier)
            )
        )
        nil
    )
)

(final-ns CallSiteTargetNode (§ extends MacroStateSplitNode) (§ implements Canonicalizable, Lowerable)
    (§ def #_"NodeClass<CallSiteTargetNode>" CallSiteTargetNode'TYPE (NodeClass'create-1 CallSiteTargetNode))

    #_unused
    (§ defn #_"CallSiteTargetNode" CallSiteTargetNode'new-5 [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode" receiver]
        (MacroStateSplitNode'new-6* CallSiteTargetNode'TYPE, invokeKind, targetMethod, bci, returnStamp, receiver)
    )

    (§ method- #_"ValueNode" CallSiteTargetNode''getCallSite-1 [#_"CallSiteTargetNode" this]
        (nth (:arguments this) 0)
    )

    (§ defn #_"ConstantNode" CallSiteTargetNode'tryFold-1 [#_"ValueNode" callSite]
        (when (and (some? callSite) (instance? ConstantNode callSite) (not (ValueNode''isNullConstant-1 callSite)))
            (let [
                #_"JavaConstant" target (#_"HotSpotObjectConstant" .getCallSiteTarget (:value callSite), nil)
            ]
                (when (some? target)
                    (ConstantNode'forConstant-1 target)
                )
            )
        )
    )

    #_unused
    (§ override! #_"Node" CallSiteTargetNode''canonical-2 [#_"CallSiteTargetNode" this, #_"CanonicalizerTool" tool]
        (or (CallSiteTargetNode'tryFold-1 (CallSiteTargetNode''getCallSite-1 this))
            this
        )
    )

    #_unused
    (§ override! #_"void" CallSiteTargetNode''lower-2 [#_"CallSiteTargetNode" this, #_"LoweringTool" lowerer]
        (let [
            #_"ConstantNode" target (CallSiteTargetNode'tryFold-1 (CallSiteTargetNode''getCallSite-1 this))
        ]
            (if (some? target)
                (§ ass! (:graph this) (Graph''replaceFixedWithFloating-3 (:graph this), this, target))
                (let [
                    #_"InvokeNode" invoke (MacroNode''createInvoke-1 this)
                ]
                    (§ ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, invoke))
                    (InvokeNode''lower-2 invoke, lowerer)
                )
            )
        )
        nil
    )
)

;;;
 ; Read {@code Class::_klass} to get the hub for a {@link java.lang.Class}. This node mostly exists
 ; to replace {@code _klass._java_mirror._klass} with {@code _klass}. The constant folding could be
 ; handled by
 ; ReadNode#canonicalizeRead(ValueNode, AddressNode, LocationIdentity, CanonicalizerTool).
 ;;
(final-ns ClassGetHubNode (§ extends FloatingNode) (§ implements Lowerable, Canonicalizable, ConvertNode)
    (§ def #_"NodeClass<ClassGetHubNode>" ClassGetHubNode'TYPE (NodeClass'create-1 ClassGetHubNode))

    ; @Input
    (§ mutable #_"ValueNode" :class nil)

    (§ defn #_"ClassGetHubNode" ClassGetHubNode'new-1 [#_"ValueNode" clazz]
        (let [
            #_"ClassGetHubNode" this (FloatingNode'new-2 ClassGetHubNode'TYPE, KlassPointerStamp'KLASS)
            this (assoc this :class clazz)
        ]
            this
        )
    )

    (§ defn #_"ValueNode" ClassGetHubNode'create-2 [#_"ValueNode" clazz, #_"boolean" allUsagesAvailable]
        (ClassGetHubNode'canonical-4 nil, allUsagesAvailable, KlassPointerStamp'KLASS, clazz)
    )

    #_unused
    (§ defn #_"boolean" ClassGetHubNode'intrinsify-3 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode" clazz]
        (BytecodeParser''push-3 parser, JavaKind/Object, (BytecodeParser''append-2 parser, (ClassGetHubNode'create-2 clazz, false)))
        true
    )

    (§ defn #_"ValueNode" ClassGetHubNode'canonical-4 [#_"ClassGetHubNode" node, #_"boolean" allUsagesAvailable, #_"Stamp" stamp, #_"ValueNode" clazz]
        (when-not (and allUsagesAvailable (some? node) (Node''hasNoUsages-1 node))
            (if (and (instance? ConstantNode clazz) (some? HotSpot'metaAccess))
                (let [
                    #_"ResolvedJavaType" exactType (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (ValueNode''asJavaConstant-1 clazz))
                ]
                    (if (#_"ResolvedJavaType" .isPrimitive exactType)
                        (ConstantNode'forConstant-2 stamp, JavaConstant/NULL_POINTER)
                        (ConstantNode'forConstant-2 stamp, (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, exactType))
                    )
                )
                (condp instance? clazz
                    GetClassNode    (LoadHubNode'new-2 KlassPointerStamp'KLASS_NON_NULL, (:object clazz))
                    HubGetClassNode (:hub clazz) ;; replace: _klass._java_mirror._klass -> _klass
                                    (or node (ClassGetHubNode'new-1 clazz))
                )
            )
        )
    )

    #_unused
    (§ override! #_"Node" ClassGetHubNode''canonical-2 [#_"ClassGetHubNode" this, #_"CanonicalizerTool" tool]
        (ClassGetHubNode'canonical-4 this, (CanonicalizerTool''allUsagesAvailable-1 tool), (:stamp this), (:class this))
    )

    #_unused
    (§ override! #_"void" ClassGetHubNode''lower-2 [#_"ClassGetHubNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerClassGetHubNode-2 this, lowerer)
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"KlassPointer" ClassGetHubNode'readClass-1 [#_"Class" clazzNonNull])

    ; @NodeIntrinsic(PiNode.class)
    (§ native #_"KlassPointer" ClassGetHubNode'piCastNonNull-2 [#_"Object" object, #_"GuardingNode" anchor])

    (§ override! #_"ValueNode" ClassGetHubNode''getValue-1 [#_"ClassGetHubNode" this]
        (:class this)
    )

    #_unused
    (§ override! #_"Constant" ClassGetHubNode''convert-2 [#_"ClassGetHubNode" this, #_"Constant" constant]
        (let [
            #_"ResolvedJavaType" exactType (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant)
        ]
            (if (#_"ResolvedJavaType" .isPrimitive exactType)
                JavaConstant/NULL_POINTER
                (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, exactType)
            )
        )
    )

    #_unused
    (§ override! #_"Constant" ClassGetHubNode''reverse-2 [#_"ClassGetHubNode" this, #_"Constant" constant]
        (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant))
    )

    #_unused
    (§ override! #_"boolean" ClassGetHubNode''isLossless-1 [#_"ClassGetHubNode" this]
        false
    )

    ;;;
     ; There is more than one {@link java.lang.Class} value that has a NULL hub.
     ;;
    #_unused
    (§ override! #_"boolean" ClassGetHubNode''mayNullCheckSkipConversion-1 [#_"ClassGetHubNode" this]
        false
    )

    #_unused
    (§ override! #_"boolean" ClassGetHubNode''preservesOrder-3 [#_"ClassGetHubNode" this, #_"CanonicalCondition" op, #_"Constant" value]
        (not (#_"ResolvedJavaType" .isPrimitive (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, value)))
    )
)

;;;
 ; Represents an encoded representation of a constant.
 ;;
(final-ns EncodedSymbolConstant (§ extends DataPointerConstant)
    (§ final #_"Constant" :constant nil)
    (§ mutable #_"byte[]" :bytes nil)

    #_unused
    (§ defn #_"EncodedSymbolConstant" EncodedSymbolConstant'new-1 [#_"Constant" constant]
        (let [
            #_"EncodedSymbolConstant" this (DataPointerConstant'new-1 1)
            this (assoc this :constant constant)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"int" EncodedSymbolConstant''getSerializedSize-1 [#_"EncodedSymbolConstant" this]
        (count (EncodedSymbolConstant''getEncodedConstant-1 this))
    )

    #_unused
    (§ override! #_"void" EncodedSymbolConstant''serialize-2 [#_"EncodedSymbolConstant" this, #_"ByteBuffer" buffer]
        (#_"ByteBuffer" .put buffer, (EncodedSymbolConstant''getEncodedConstant-1 this))
        nil
    )

    ;;;
     ; Converts a string to a byte array with modified UTF-8 encoding. The first two bytes of the
     ; byte array store the length of the string in bytes.
     ;
     ; @param s a java.lang.String in UTF-16
     ;;
    (§ defn- #_"byte[]" EncodedSymbolConstant'toUTF8String-1 [#_"String" s]
        (try (§ with [#_"ByteArrayOutputStream" bytes (ByteArrayOutputStream.)])
            (let [
                #_"DataOutputStream" stream (DataOutputStream. bytes)
            ]
                (#_"DataOutputStream" .writeUTF stream, s)
                (#_"ByteArrayOutputStream" .toByteArray bytes)
            )
        )
    )

    (§ defn- #_"byte[]" EncodedSymbolConstant'encodeConstant-1 [#_"Constant" constant]
        (condp instance? constant
            HotSpotObjectConstant
                (EncodedSymbolConstant'toUTF8String-1 (#_"HotSpotObjectConstant" .asObject constant, String))
            HotSpotMetaspaceConstant
                (let [
                    #_"HotSpotResolvedObjectType" klass (#_"HotSpotMetaspaceConstant" .asResolvedJavaType constant)
                ]
                    (if (some? klass)
                        (EncodedSymbolConstant'toUTF8String-1 (#_"HotSpotResolvedObjectType" .getName klass))
                        (let [
                            #_"HotSpotResolvedJavaMethod" method (#_"HotSpotMetaspaceConstant" .asResolvedJavaMethod constant)
                        ]
                            (when (some? method) => (throw! (str "encoding of constant " constant " failed"))
                                (let [
                                    #_"byte[]" name (EncodedSymbolConstant'toUTF8String-1 (#_"HotSpotResolvedJavaMethod" .getName method))
                                    #_"byte[]" signature (EncodedSymbolConstant'toUTF8String-1 (#_"Signature" .toMethodDescriptor (#_"HotSpotResolvedJavaMethod" .getSignature method)))
                                    #_"byte[]" bytes (byte-array (+ (count name) (count signature)))
                                    #_"int" i 0
                                ]
                                    (System/arraycopy name, 0, bytes, i, (count name))
                                    (§ ass i (+ i (count name)))
                                    (System/arraycopy signature, 0, bytes, i, (count signature))
                                    (§ ass i (+ i (count signature)))
                                    bytes
                                )
                            )
                        )
                    )
                )
        )
    )

    (§ method! #_"byte[]" EncodedSymbolConstant''getEncodedConstant-1 [#_"EncodedSymbolConstant" this]
        (when (nil? (:bytes this))
            (§ ass! this (assoc this :bytes (EncodedSymbolConstant'encodeConstant-1 (:constant this))))
        )
        (:bytes this)
    )

    #_unused
    (§ override! #_"String" EncodedSymbolConstant''toValueString-1 [#_"EncodedSymbolConstant" this]
        (str "encoded symbol\"" (#_"Constant" .toValueString (:constant this)) "\"")
    )
)

;;;
 ; A collection of methods used in HotSpot snippets, substitutions and stubs.
 ;;
(value-ns HotSpotReplacementsUtil
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'TLAB_TOP_LOCATION               (NamedLocationIdentity'mutable-1 "TlabTop"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'TLAB_END_LOCATION               (NamedLocationIdentity'mutable-1 "TlabEnd"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'TLAB_START_LOCATION             (NamedLocationIdentity'mutable-1 "TlabStart"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'PENDING_EXCEPTION_LOCATION      (NamedLocationIdentity'mutable-1 "PendingException"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'PENDING_DEOPTIMIZATION_LOCATION (NamedLocationIdentity'mutable-1 "PendingDeoptimization"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'OBJECT_RESULT_LOCATION          (NamedLocationIdentity'mutable-1 "ObjectResult"))

    (§ defn #_"Word" HotSpotReplacementsUtil'readTlabTop-1 [#_"Word" thread]
        (Word''readWord-3 thread, HotSpot'threadTlabTopOffset, HotSpotReplacementsUtil'TLAB_TOP_LOCATION)
    )

    (§ defn #_"Word" HotSpotReplacementsUtil'readTlabEnd-1 [#_"Word" thread]
        (Word''readWord-3 thread, HotSpot'threadTlabEndOffset, HotSpotReplacementsUtil'TLAB_END_LOCATION)
    )

    (§ defn #_"Word" HotSpotReplacementsUtil'readTlabStart-1 [#_"Word" thread]
        (Word''readWord-3 thread, HotSpot'threadTlabStartOffset, HotSpotReplacementsUtil'TLAB_START_LOCATION)
    )

    (§ defn #_"void" HotSpotReplacementsUtil'writeTlabTop-2 [#_"Word" thread, #_"Word" top]
        (Word''writeWord-4 thread, HotSpot'threadTlabTopOffset, top, HotSpotReplacementsUtil'TLAB_TOP_LOCATION)
        nil
    )

    (§ defn #_"void" HotSpotReplacementsUtil'initializeTlab-3 [#_"Word" thread, #_"Word" start, #_"Word" end]
        (Word''writeWord-4 thread, HotSpot'threadTlabStartOffset, start, HotSpotReplacementsUtil'TLAB_START_LOCATION)
        (Word''writeWord-4 thread, HotSpot'threadTlabTopOffset, start, HotSpotReplacementsUtil'TLAB_TOP_LOCATION)
        (Word''writeWord-4 thread, HotSpot'threadTlabEndOffset, end, HotSpotReplacementsUtil'TLAB_END_LOCATION)
        nil
    )

    ;;;
     ; Clears the pending exception for the given thread.
     ;
     ; @return the pending exception, or nil if there was none
     ;;
    (§ defn #_"Object" HotSpotReplacementsUtil'clearPendingException-1 [#_"Word" thread]
        (let [
            #_"Object" result (Word''readObject-3 thread, HotSpot'pendingExceptionOffset, HotSpotReplacementsUtil'PENDING_EXCEPTION_LOCATION)
        ]
            (Word''writeObject-4 thread, HotSpot'pendingExceptionOffset, nil, HotSpotReplacementsUtil'PENDING_EXCEPTION_LOCATION)
            result
        )
    )

    ;;;
     ; Reads the pending deoptimization value for the given thread.
     ;
     ; @return true if there was a pending deoptimization
     ;;
    #_unused
    (§ defn #_"int" HotSpotReplacementsUtil'readPendingDeoptimization-1 [#_"Word" thread]
        (Word''readInt-3 thread, HotSpot'pendingDeoptimizationOffset, HotSpotReplacementsUtil'PENDING_DEOPTIMIZATION_LOCATION)
    )

    ;;;
     ; Writes the pending deoptimization value for the given thread.
     ;;
    #_unused
    (§ defn #_"void" HotSpotReplacementsUtil'writePendingDeoptimization-2 [#_"Word" thread, #_"int" value]
        (Word''writeInt-4 thread, HotSpot'pendingDeoptimizationOffset, value, HotSpotReplacementsUtil'PENDING_DEOPTIMIZATION_LOCATION)
        nil
    )

    ;;;
     ; Gets and clears the object result from a runtime call stored in a thread local.
     ;
     ; @return the object that was in the thread local
     ;;
    (§ defn #_"Object" HotSpotReplacementsUtil'getAndClearObjectResult-1 [#_"Word" thread]
        (let [
            #_"Object" result (Word''readObject-3 thread, HotSpot'objectResultOffset, HotSpotReplacementsUtil'OBJECT_RESULT_LOCATION)
        ]
            (Word''writeObject-4 thread, HotSpot'objectResultOffset, nil, HotSpotReplacementsUtil'OBJECT_RESULT_LOCATION)
            result
        )
    )

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'PROTOTYPE_MARK_WORD_LOCATION (NamedLocationIdentity'mutable-1 "PrototypeMarkWord"))

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'KLASS_LAYOUT_HELPER_LOCATION
        (§ reify #_"OptimizingLocationIdentity" (OptimizingLocationIdentity'new-1 "Klass::_layout_helper")
            #_unused
            (§ override! #_"ValueNode" OptimizingLocationIdentity''canonicalizeRead-5 [#_"OptimizingLocationIdentity" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object, #_"CanonicalizerTool" tool]
                (let [
                    #_"ValueNode" javaObject (OptimizingLocationIdentity''findReadHub-2 this, object)
                ]
                    (when (and (some? javaObject) (instance? ObjectStamp (:stamp javaObject))) => read
                        (let [
                            #_"HotSpotResolvedObjectType" type (Stamp''javaType-1 (:stamp javaObject))
                        ]
                            (when (and (#_"HotSpotResolvedObjectType" .isArray type) (not (#_"ResolvedJavaType" .isPrimitive (#_"HotSpotResolvedObjectType" .getComponentType type)))) => read
                                (ConstantNode'forInt-1 (#_"HotSpotResolvedObjectType" .layoutHelper type))
                            )
                        )
                    )
                )
            )
        )
    )

    ; @NodeIntrinsic(value = KlassLayoutHelperNode.class)
    (§ native #_"int" HotSpotReplacementsUtil'readLayoutHelper-1 [#_"KlassPointer" object])

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'ARRAY_KLASS_COMPONENT_MIRROR (NamedLocationIdentity'immutable-1 "ArrayKlass::_component_mirror"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'MARK_WORD_LOCATION           (NamedLocationIdentity'mutable-1   "MarkWord"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'HUB_WRITE_LOCATION           (NamedLocationIdentity'mutable-1   "Hub:write"))

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'HUB_LOCATION
        (§ reify #_"OptimizingLocationIdentity" (OptimizingLocationIdentity'new-1 "Hub")
            #_unused
            (§ override! #_"ValueNode" OptimizingLocationIdentity''canonicalizeRead-5 [#_"OptimizingLocationIdentity" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object, #_"CanonicalizerTool" tool]
                (let [
                    #_"TypeReference" constantType (StampTool'typeReferenceOrNull-1 (:stamp object))
                ]
                    (when (and (some? constantType) (:exactReference constantType)) => read
                        (ConstantNode'forConstant-2 (:stamp read), (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, (:type constantType)))
                    )
                )
            )
        )
    )

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'COMPRESSED_HUB_LOCATION
        (§ reify #_"OptimizingLocationIdentity" (OptimizingLocationIdentity'new-1 "CompressedHub")
            #_unused
            (§ override! #_"ValueNode" OptimizingLocationIdentity''canonicalizeRead-5 [#_"OptimizingLocationIdentity" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object, #_"CanonicalizerTool" tool]
                (let [
                    #_"TypeReference" constantType (StampTool'typeReferenceOrNull-1 (:stamp object))
                ]
                    (when (and (some? constantType) (:exactReference constantType)) => read
                        (ConstantNode'forConstant-2 (:stamp read), (#_"HotSpotMetaspaceConstant" .compress (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, (:type constantType))))
                    )
                )
            )
        )
    )

    (§ defn #_"void" HotSpotReplacementsUtil'initializeObjectHeader-3 [#_"Word" memory, #_"Word" markWord, #_"KlassPointer" hub]
        (Word''writeWord-4 memory, HotSpot'markOffset, markWord, HotSpotReplacementsUtil'MARK_WORD_LOCATION)
        (StoreHubNode'write-2 memory, hub)
        nil
    )

    #_unused
    (§ defn #_"Word" HotSpotReplacementsUtil'arrayStart-1 [#_"int[]" a]
        (WordFactory/unsigned (ComputeObjectAddressNode'get-2 a, Unsafe'ARRAY_INT_BASE_OFFSET))
    )

    ;;;
     ; Computes the size of the memory chunk allocated for an array. This size accounts for the array header size,
     ; body size and any padding after the last element to satisfy object alignment requirements.
     ;
     ; @param length the number of elements in the array
     ; @param headerSize the size of the array header
     ; @param log2ElementSize log2 of the size of an element in the array
     ;
     ; @return the size of the memory chunk
     ;;
    (§ defn #_"int" HotSpotReplacementsUtil'arrayAllocationSize-3 [#_"int" length, #_"int" headerSize, #_"int" log2ElementSize]
        (let [
            #_"int" alignment HotSpot'objectAlignment
            #_"int" size (+ (<< length log2ElementSize) headerSize (dec alignment))
            #_"int" mask (bit-not (dec alignment))
        ]
            (& size mask)
        )
    )

    (§ defn #_"int" HotSpotReplacementsUtil'instanceHeaderSize-0 []
        (if HotSpot'useCompressedClassPointers (- (* 2 (.wordSize HotSpot'target)) 4) (* 2 (.wordSize HotSpot'target)))
    )

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'KLASS_SUPER_CHECK_OFFSET_LOCATION  (NamedLocationIdentity'immutable-1 "Klass::_super_check_offset"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'SECONDARY_SUPER_CACHE_LOCATION     (NamedLocationIdentity'mutable-1   "SecondarySuperCache"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'SECONDARY_SUPERS_LOCATION          (NamedLocationIdentity'immutable-1 "SecondarySupers"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'DISPLACED_MARK_WORD_LOCATION       (NamedLocationIdentity'mutable-1   "DisplacedMarkWord"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'OBJECT_MONITOR_OWNER_LOCATION      (NamedLocationIdentity'mutable-1   "ObjectMonitor::_owner"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'OBJECT_MONITOR_RECURSION_LOCATION  (NamedLocationIdentity'mutable-1   "ObjectMonitor::_recursions"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'OBJECT_MONITOR_CXQ_LOCATION        (NamedLocationIdentity'mutable-1   "ObjectMonitor::_cxq"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'OBJECT_MONITOR_ENTRY_LIST_LOCATION (NamedLocationIdentity'mutable-1   "ObjectMonitor::_EntryList"))

    ;;;
     ; Loads the hub of an object (without nil-checking it first).
     ;;
    #_unused
    (§ defn #_"KlassPointer" HotSpotReplacementsUtil'loadHub-1 [#_"Object" object]
        (HotSpotReplacementsUtil'loadHubIntrinsic-1 object)
    )

    (§ defn #_"Word" HotSpotReplacementsUtil'loadWordFromObject-2 [#_"Object" object, #_"int" offset]
        (HotSpotReplacementsUtil'loadWordFromObjectIntrinsic-4 object, offset, (LocationIdentity/any), (.wordJavaKind HotSpot'target))
    )

    #_unused
    (§ defn #_"Word" HotSpotReplacementsUtil'loadWordFromObject-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" identity]
        (HotSpotReplacementsUtil'loadWordFromObjectIntrinsic-4 object, offset, identity, (.wordJavaKind HotSpot'target))
    )

    (§ defn #_"KlassPointer" HotSpotReplacementsUtil'loadKlassFromObject-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" identity]
        (HotSpotReplacementsUtil'loadKlassFromObjectIntrinsic-4 object, offset, identity, (.wordJavaKind HotSpot'target))
    )

    ;;;
     ; Reads the value of a given register.
     ;
     ; @param register a register which must not be available to the register allocator
     ; @return the value of {@code register} as a word
     ;;
    (§ defn #_"Word" HotSpotReplacementsUtil'registerAsWord-1 [#_@ConstantNodeParameter #_"Register" register]
        (HotSpotReplacementsUtil'registerAsWord-3 register, true, false)
    )

    ; @NodeIntrinsic(value = ReadRegisterNode.class)
    (§ native #_"Word" HotSpotReplacementsUtil'registerAsWord-3 [#_@ConstantNodeParameter #_"Register" register, #_@ConstantNodeParameter #_"boolean" directUse, #_@ConstantNodeParameter #_"boolean" incoming])

    ; @NodeIntrinsic(value = WriteRegisterNode.class)
    #_unused
    (§ native #_"void" HotSpotReplacementsUtil'writeRegisterAsWord-2 [#_@ConstantNodeParameter #_"Register" register, #_"Word" value])

    ; @NodeIntrinsic(value = RawLoadNode.class)
    (§ native- #_"Word" HotSpotReplacementsUtil'loadWordFromObjectIntrinsic-4 [#_"Object" object, #_"long" offset, #_@ConstantNodeParameter #_"LocationIdentity" locationIdentity, #_@ConstantNodeParameter #_"JavaKind" wordKind])

    ; @NodeIntrinsic(value = RawLoadNode.class)
    (§ native- #_"KlassPointer" HotSpotReplacementsUtil'loadKlassFromObjectIntrinsic-4 [#_"Object" object, #_"long" offset, #_@ConstantNodeParameter #_"LocationIdentity" locationIdentity, #_@ConstantNodeParameter #_"JavaKind" wordKind])

    ; @NodeIntrinsic(value = LoadHubNode.class)
    (§ native #_"KlassPointer" HotSpotReplacementsUtil'loadHubIntrinsic-1 [#_"Object" object])

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'CLASS_STATE_LOCATION (NamedLocationIdentity'mutable-1 "ClassState"))

    (§ defn- #_"byte" HotSpotReplacementsUtil'readInstanceKlassState-1 [#_"KlassPointer" hub]
        (MetaspacePointer''readByte-3 hub, HotSpot'instanceKlassInitStateOffset, HotSpotReplacementsUtil'CLASS_STATE_LOCATION)
    )

    ;;;
     ; @param hub the hub of an InstanceKlass
     ; @return true is the InstanceKlass represented by hub is fully initialized
     ;;
    (§ defn #_"boolean" HotSpotReplacementsUtil'isInstanceKlassFullyInitialized-1 [#_"KlassPointer" hub]
        (= (HotSpotReplacementsUtil'readInstanceKlassState-1 hub) HotSpot'instanceKlassStateFullyInitialized)
    )

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'CLASS_KLASS_LOCATION
        (§ reify #_"OptimizingLocationIdentity" (OptimizingLocationIdentity'new-1 "Class._klass")
            #_unused
            (§ override! #_"ValueNode" OptimizingLocationIdentity''canonicalizeRead-5 [#_"OptimizingLocationIdentity" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object, #_"CanonicalizerTool" tool]
                (OptimizingLocationIdentity'foldIndirection-3 read, object, HotSpotReplacementsUtil'CLASS_MIRROR_LOCATION)
            )
        )
    )

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'CLASS_ARRAY_KLASS_LOCATION
        (§ reify #_"OptimizingLocationIdentity" (OptimizingLocationIdentity'new-1 "Class._array_klass")
            #_unused
            (§ override! #_"ValueNode" OptimizingLocationIdentity''canonicalizeRead-5 [#_"OptimizingLocationIdentity" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object, #_"CanonicalizerTool" tool]
                (OptimizingLocationIdentity'foldIndirection-3 read, object, HotSpotReplacementsUtil'ARRAY_KLASS_COMPONENT_MIRROR)
            )
        )
    )

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'CLASS_MIRROR_LOCATION                (NamedLocationIdentity'immutable-1 "Klass::_java_mirror"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'CLASS_MIRROR_HANDLE_LOCATION         (NamedLocationIdentity'immutable-1 "Klass::_java_mirror handle"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'HEAP_TOP_LOCATION                    (NamedLocationIdentity'mutable-1   "HeapTop"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'HEAP_END_LOCATION                    (NamedLocationIdentity'mutable-1   "HeapEnd"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'TLAB_SIZE_LOCATION                   (NamedLocationIdentity'mutable-1   "TlabSize"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'TLAB_THREAD_ALLOCATED_BYTES_LOCATION (NamedLocationIdentity'mutable-1   "TlabThreadAllocatedBytes"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'TLAB_REFILL_WASTE_LIMIT_LOCATION     (NamedLocationIdentity'mutable-1   "RefillWasteLimit"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'TLAB_NOF_REFILLS_LOCATION            (NamedLocationIdentity'mutable-1   "TlabNOfRefills"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'TLAB_FAST_REFILL_WASTE_LOCATION      (NamedLocationIdentity'mutable-1   "TlabFastRefillWaste"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'TLAB_SLOW_ALLOCATIONS_LOCATION       (NamedLocationIdentity'mutable-1   "TlabSlowAllocations"))

    ;; @Fold
    (§ defn #_"long" HotSpotReplacementsUtil'referentOffset-0 []
        (.objectFieldOffset HotSpot'unsafe, (#_"Class" .getDeclaredField java.lang.ref.Reference, "referent"))
    )

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION
        (§ reify #_"OptimizingLocationIdentity" (OptimizingLocationIdentity'new-1 "ObjArrayKlass::_element_klass")
            #_unused
            (§ override! #_"ValueNode" OptimizingLocationIdentity''canonicalizeRead-5 [#_"OptimizingLocationIdentity" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object, #_"CanonicalizerTool" tool]
                read
            )
        )
    )

    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'PRIMARY_SUPERS_LOCATION           (NamedLocationIdentity'immutable-1 "PrimarySupers"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'METASPACE_ARRAY_LENGTH_LOCATION   (NamedLocationIdentity'immutable-1 "MetaspaceArrayLength"))
    (§ def #_"LocationIdentity" HotSpotReplacementsUtil'SECONDARY_SUPERS_ELEMENT_LOCATION (NamedLocationIdentity'immutable-1 "SecondarySupersElement"))
)

;;;
 ; @anno HotSpotReplacementsUtil.OptimizingLocationIdentity
 ;;
(class-ns OptimizingLocationIdentity (§ extends NamedLocationIdentity) (§ implements CanonicalizableLocation)
    (§ defn #_"OptimizingLocationIdentity" OptimizingLocationIdentity'new-1 [#_"String" name]
        (NamedLocationIdentity'new-2 name, true)
    )

    #_unused
    (§ abstract #_"ValueNode" OptimizingLocationIdentity''canonicalizeRead-5 [#_"OptimizingLocationIdentity" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object, #_"CanonicalizerTool" tool])

    (§ method! #_"ValueNode" OptimizingLocationIdentity''findReadHub-2 [#_"OptimizingLocationIdentity" this, #_"ValueNode" object]
        (let [
            #_"ValueNode" base (if (instance? CompressionNode object) (UnaryNode''getValue-1 object) object)
        ]
            (condp instance? base
                Access
                    (when (any = (Access''getLocationIdentity-1 base) HotSpotReplacementsUtil'HUB_LOCATION HotSpotReplacementsUtil'COMPRESSED_HUB_LOCATION)
                        (let [
                            #_"AddressNode" address (Access''getAddress-1 base)
                        ]
                            (when (instance? OffsetAddressNode address)
                                (OffsetAddressNode''getBase-1 address)
                            )
                        )
                    )
                LoadHubNode
                    (:value base)
                nil
            )
        )
    )

    ;;;
     ; Fold reads that convert from Class -> Hub -> Class or vice versa.
     ;
     ; @return an earlier read or the original {@code read}
     ;;
    (§ defn #_"ValueNode" OptimizingLocationIdentity'foldIndirection-3 [#_"ValueNode" read, #_"ValueNode" object, #_"LocationIdentity" otherLocation]
        (when (and (instance? Access object) (= (Access''getLocationIdentity-1 object) otherLocation)) => read
            (let [
                #_"AddressNode" address (Access''getAddress-1 object)
            ]
                (when (instance? OffsetAddressNode address) => read
                    (OffsetAddressNode''getBase-1 address)
                )
            )
        )
    )
)

;;;
 ; Read {@code Klass::_java_mirror} and incorporate non-nil type information into stamp. This is
 ; also used by ClassGetHubNode to eliminate chains of {@code klass._java_mirror._klass}.
 ;;
(final-ns HubGetClassNode (§ extends FloatingNode) (§ implements Lowerable, Canonicalizable, ConvertNode)
    (§ def #_"NodeClass<HubGetClassNode>" HubGetClassNode'TYPE (NodeClass'create-1 HubGetClassNode))

    ; @Input
    (§ mutable #_"ValueNode" :hub nil)

    (§ defn #_"HubGetClassNode" HubGetClassNode'new-1 [#_"ValueNode" hub]
        (let [
            #_"HubGetClassNode" this (FloatingNode'new-2 HubGetClassNode'TYPE, (StampFactory'objectNonNull-1 (TypeReference'create-1 (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Class))))
            this (assoc this :hub hub)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Node" HubGetClassNode''canonical-2 [#_"HubGetClassNode" this, #_"CanonicalizerTool" tool]
        (when-not (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
            (when (and (some? HotSpot'metaAccess) (instance? ConstantNode (:hub this))) => this
                (let [
                    #_"ResolvedJavaType" exactType (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (:value (:hub this)))
                ]
                    (when (some? exactType) => this
                        (ConstantNode'forConstant-1 (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, exactType))
                    )
                )
            )
        )
    )

    (§ override! #_"void" HubGetClassNode''lower-2 [#_"HubGetClassNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerHubGetClassNode-2 this, lowerer)
        nil
    )

    ; @NodeIntrinsic
    #_unused
    (§ native #_"Class" HubGetClassNode'readClass-1 [#_"KlassPointer" hub])

    #_unused
    (§ override! #_"ValueNode" HubGetClassNode''getValue-1 [#_"HubGetClassNode" this]
        (:hub this)
    )

    #_unused
    (§ override! #_"Constant" HubGetClassNode''convert-2 [#_"HubGetClassNode" this, #_"Constant" constant]
        (if (= JavaConstant/NULL_POINTER constant)
            constant
            (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant))
        )
    )

    #_unused
    (§ override! #_"Constant" HubGetClassNode''reverse-2 [#_"HubGetClassNode" this, #_"Constant" constant]
        (if (= JavaConstant/NULL_POINTER constant)
            constant
            (let [
                #_"ResolvedJavaType" type (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant)
            ]
                (if (#_"ResolvedJavaType" .isPrimitive type)
                    JavaConstant/NULL_POINTER
                    (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, type)
                )
            )
        )
    )

    ;;;
     ; Any concrete Klass* has a corresponding {@link java.lang.Class}.
     ;;
    #_unused
    (§ override! #_"boolean" HubGetClassNode''isLossless-1 [#_"HubGetClassNode" this]
        true
    )

    #_unused
    (§ override! #_"boolean" HubGetClassNode''mayNullCheckSkipConversion-1 [#_"HubGetClassNode" this]
        true
    )
)

;;;
 ; Snippets used for implementing the type test of an instanceof instruction. Since instanceof is a
 ; floating node, it is lowered separately for each of its usages.
 ;
 ; The type tests implemented are described in the paper
 ; <a href="http://dl.acm.org/citation.cfm?id=583821"> Fast subtype checking in the HotSpot JVM</a>
 ; by Cliff Click and John Rose.
 ;;
(value-ns InstanceOfSnippets (§ implements Snippets)
    ;;;
     ; A test against a final type.
     ;;
    ; @Snippet
    #_unused
    (§ defn #_"Object" InstanceOfSnippets'instanceofExact-4 [#_"Object" object, #_"KlassPointer" exactHub, #_"Object" trueValue, #_"Object" falseValue]
        (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (nil? object))
            falseValue
            (let [
                #_"KlassPointer" objectHub (HotSpotReplacementsUtil'loadHubIntrinsic-1 (PiNode'piCastNonNull-2 object, (SnippetAnchorNode'anchor-0)))
            ]
                (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'LIKELY_PROBABILITY, (KlassPointer''notEqual-2 objectHub, exactHub))
                    falseValue
                    trueValue
                )
            )
        )
    )

    ;;;
     ; A test against a primary type.
     ;;
    ; @Snippet
    #_unused
    (§ defn #_"Object" InstanceOfSnippets'instanceofPrimary-5 [#_"KlassPointer" hub, #_"Object" object, #_@ConstantParameter #_"int" superCheckOffset, #_"Object" trueValue, #_"Object" falseValue]
        (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (nil? object))
            falseValue
            (let [
                #_"KlassPointer" objectHub (HotSpotReplacementsUtil'loadHubIntrinsic-1 (PiNode'piCastNonNull-2 object, (SnippetAnchorNode'anchor-0)))
            ]
                (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_LIKELY_PROBABILITY, (KlassPointer''notEqual-2 (KlassPointer''readKlassPointer-3 objectHub, superCheckOffset, HotSpotReplacementsUtil'PRIMARY_SUPERS_LOCATION), hub))
                    falseValue
                    trueValue
                )
            )
        )
    )

    ;;;
     ; A test against a restricted secondary type type.
     ;;
    ; @Snippet
    #_unused
    (§ defn #_"Object" InstanceOfSnippets'instanceofSecondary-6 [#_"KlassPointer" hub, #_"Object" object, #_@VarargsParameter #_"KlassPointer[]" hints, #_@VarargsParameter #_"boolean[]" hintIsPositive, #_"Object" trueValue, #_"Object" falseValue]
        (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (nil? object))
            falseValue
            (let [
                #_"KlassPointer" objectHub (HotSpotReplacementsUtil'loadHubIntrinsic-1 (PiNode'piCastNonNull-2 object, (SnippetAnchorNode'anchor-0)))
            ]
                ;; if we get an exact match: succeed immediately
                (ExplodeLoopNode'explodeLoop-0)
                (loop-when [#_"int" i 0] (< i (count hints)) => (if (TypeCheckSnippetUtils'checkSecondarySubType-2 hub, objectHub) trueValue falseValue)
                    (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (KlassPointer''equal-2 (nth hints i), objectHub))
                        (if (nth hintIsPositive i) trueValue falseValue)
                        (recur (inc i))
                    )
                )
            )
        )
    )

    ;;;
     ; Type test used when the type being tested against is not known at compile time.
     ;;
    ; @Snippet
    #_unused
    (§ defn #_"Object" InstanceOfSnippets'instanceofDynamic-5 [#_"KlassPointer" hub, #_"Object" object, #_"Object" trueValue, #_"Object" falseValue, #_@ConstantParameter #_"boolean" allowNull]
        (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (nil? object))
            (if allowNull trueValue falseValue)
            (let [
                #_"KlassPointer" nonNullObjectHub (HotSpotReplacementsUtil'loadHubIntrinsic-1 (PiNode'piCastNonNull-2 object, (SnippetAnchorNode'anchor-0)))
            ]
                ;; The hub of a primitive type can be nil => always return false in this case.
                (if (and (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (not (MetaspacePointer''isNull-1 hub))) (TypeCheckSnippetUtils'checkUnknownSubType-2 hub, nonNullObjectHub))
                    trueValue
                    falseValue
                )
            )
        )
    )

    ; @Snippet
    #_unused
    (§ defn #_"Object" InstanceOfSnippets'isAssignableFrom-4 [#_@NonNullParameter #_"Class" thisClassNonNull, #_"Class" otherClass, #_"Object" trueValue, #_"Object" falseValue]
        (if (nil? otherClass)
            (do
                (DeoptimizeNode'deopt-2 DeoptimizationAction/InvalidateReprofile, DeoptimizationReason/NullCheckException)
                false
            )
            (let [
                #_"Class" otherClassNonNull (PiNode'piCastNonNullClass-2 otherClass, (SnippetAnchorNode'anchor-0))
            ]
                (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_LIKELY_PROBABILITY, (= thisClassNonNull otherClassNonNull))
                    trueValue
                    (let [
                        #_"KlassPointer" thisHub (ClassGetHubNode'readClass-1 thisClassNonNull)
                        #_"KlassPointer" otherHub (ClassGetHubNode'readClass-1 otherClassNonNull)
                    ]
                        (if (and (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (not (MetaspacePointer''isNull-1 thisHub)))
                                 (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (not (MetaspacePointer''isNull-1 otherHub)))
                                 (TypeCheckSnippetUtils'checkUnknownSubType-2 thisHub, (ClassGetHubNode'piCastNonNull-2 otherHub, (SnippetAnchorNode'anchor-0)))
                              )
                            trueValue
                            ;; If either hub is nil, one of them is a primitive type and given that the class is not equal, return false.
                            falseValue
                        )
                    )
                )
            )
        )
    )
)

;;;
 ; @anno InstanceOfSnippets.InstanceOfTemplates
 ;;
(final-ns InstanceOfTemplates (§ extends InstanceOfSnippetsTemplates)
    (§ final #_"SnippetInfo" :instanceofExact (AbstractTemplates''snippet-4* this, InstanceOfSnippets, "instanceofExact"))
    (§ final #_"SnippetInfo" :instanceofPrimary (AbstractTemplates''snippet-4* this, InstanceOfSnippets, "instanceofPrimary"))
    (§ final #_"SnippetInfo" :instanceofSecondary (AbstractTemplates''snippet-4* this, InstanceOfSnippets, "instanceofSecondary", HotSpotReplacementsUtil'SECONDARY_SUPER_CACHE_LOCATION))
    (§ final #_"SnippetInfo" :instanceofDynamic (AbstractTemplates''snippet-4* this, InstanceOfSnippets, "instanceofDynamic", HotSpotReplacementsUtil'SECONDARY_SUPER_CACHE_LOCATION))
    (§ final #_"SnippetInfo" :isAssignableFrom (AbstractTemplates''snippet-4* this, InstanceOfSnippets, "isAssignableFrom", HotSpotReplacementsUtil'SECONDARY_SUPER_CACHE_LOCATION))

    (§ defn #_"InstanceOfTemplates" InstanceOfTemplates'new-0 []
        (InstanceOfSnippetsTemplates'new-0)
    )

    #_unused
    (§ override! #_"Arguments" InstanceOfTemplates''makeArguments-3 [#_"InstanceOfTemplates" this, #_"InstanceOfUsageReplacer" replacer, #_"LoweringTool" lowerer]
        (condp instance? (:instanceOf replacer)
            InstanceOfNode
            (let [
                #_"InstanceOfNode" instanceOf (:instanceOf replacer)
                #_"ValueNode" object (UnaryOpLogicNode''getValue-1 instanceOf)
                #_"TypeReference" targetType (InstanceOfNode''type-1 instanceOf)
                #_"HotSpotResolvedObjectType" type (:type targetType)
                ;; If non-nil, then this is the only type that could pass the type check because the target of
                ;; the type check is a final class or has been speculated to be a final class and this value is
                ;; the only concrete subclass of the target type.
                #_"ResolvedJavaType" exact (when (and (some? targetType) (:exactReference targetType)) type)
                #_"ConstantNode" hub (ConstantNode'forConstant-3 KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass type), (:graph instanceOf))
                #_"Graph" graph (:graph instanceOf)
                #_"Arguments" args
                    (cond
                        (some? exact)
                            (let [
                                args (Arguments'new-3 (:instanceofExact this), (:guardsStage graph), (:loweringStage (:phase lowerer)))
                            ]
                                (Arguments''add-3 args, "object", object)
                                ((Arguments''add-3 args, "exactHub", (ConstantNode'forConstant-3 KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass exact), graph)))
                                args
                            )
                        (#_"HotSpotResolvedObjectType" .isPrimaryType type)
                            (let [
                                args (Arguments'new-3 (:instanceofPrimary this), (:guardsStage graph), (:loweringStage (:phase lowerer)))
                            ]
                                (Arguments''add-3 args, "hub", hub)
                                (Arguments''add-3 args, "object", object)
                                (Arguments''addConst-3 args, "superCheckOffset", (#_"HotSpotResolvedObjectType" .superCheckOffset type))
                                args
                            )
                        :else
                            (let [
                                args (Arguments'new-3 (:instanceofSecondary this), (:guardsStage graph), (:loweringStage (:phase lowerer)))
                            ]
                                (Arguments''add-3 args, "hub", hub)
                                (Arguments''add-3 args, "object", object)
                                (Arguments''addVarargs-5 args, "hints", KlassPointer, KlassPointerStamp'KLASS_NON_NULL, (make-array ConstantNode 0))
                                (Arguments''addVarargs-5 args, "hintIsPositive", boolean'class, (StampFactory'forKind-1 JavaKind/Boolean), (boolean-array 0))
                                args
                            )
                    )
            ]
                (Arguments''add-3 args, "trueValue", (:trueValue replacer))
                (Arguments''add-3 args, "falseValue", (:falseValue replacer))
                args
            )
            InstanceOfDynamicNode
            (let [
                #_"InstanceOfDynamicNode" instanceOf (:instanceOf replacer)
                #_"ValueNode" object (:y instanceOf)
                #_"Arguments" args (Arguments'new-3 (:instanceofDynamic this), (:guardsStage (:graph instanceOf)), (:loweringStage (:phase lowerer)))
            ]
                (Arguments''add-3 args, "hub", (:x instanceOf))
                (Arguments''add-3 args, "object", object)
                (Arguments''add-3 args, "trueValue", (:trueValue replacer))
                (Arguments''add-3 args, "falseValue", (:falseValue replacer))
                (Arguments''addConst-3 args, "allowNull", (:allow-nil? instanceOf))
                args
            )
            ClassIsAssignableFromNode
            (let [
                #_"ClassIsAssignableFromNode" isAssignable (:instanceOf replacer)
                #_"Arguments" args (Arguments'new-3 (:isAssignableFrom this), (:guardsStage (:graph isAssignable)), (:loweringStage (:phase lowerer)))
            ]
                (Arguments''add-3 args, "thisClassNonNull", (:x isAssignable))
                (Arguments''add-3 args, "otherClass", (:y isAssignable))
                (Arguments''add-3 args, "trueValue", (:trueValue replacer))
                (Arguments''add-3 args, "falseValue", (:falseValue replacer))
                args
            )
        )
    )
)

;;;
 ; Read {@code Klass::_layout_helper} and incorporate any useful stamp information based on any type
 ; information in {@code klass}.
 ;;
(final-ns KlassLayoutHelperNode (§ extends FloatingNode) (§ implements Canonicalizable, Lowerable)
    (§ def #_"NodeClass<KlassLayoutHelperNode>" KlassLayoutHelperNode'TYPE (NodeClass'create-1 KlassLayoutHelperNode))

    ; @Input
    (§ mutable #_"ValueNode" :klass nil)

    (§ defn #_"KlassLayoutHelperNode" KlassLayoutHelperNode'new-1 [#_"ValueNode" klass]
        (let [
            #_"KlassLayoutHelperNode" this (FloatingNode'new-2 KlassLayoutHelperNode'TYPE, (StampFactory'forKind-1 JavaKind/Int))
            this (assoc this :klass klass)
        ]
            this
        )
    )

    (§ defn #_"ValueNode" KlassLayoutHelperNode'create-1 [#_"ValueNode" klass]
        (KlassLayoutHelperNode'canonical-3 nil, klass, (StampFactory'forKind-1 JavaKind/Int))
    )

    #_unused
    (§ defn #_"boolean" KlassLayoutHelperNode'intrinsify-3 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode" klass]
        (BytecodeParser''push-3 parser, JavaKind/Int, (BytecodeParser''append-2 parser, (KlassLayoutHelperNode'create-1 klass)))
        true
    )

    #_unused
    (§ override! #_"boolean" KlassLayoutHelperNode''inferStamp-1 [#_"KlassLayoutHelperNode" this]
        (and (instance? LoadHubNode (:klass this))
            (let [
                #_"Stamp" stamp (:stamp (:value (:klass this)))
            ]
                (and (instance? ObjectStamp stamp)
                    (let [
                        #_"ResolvedJavaType" type (AbstractObjectStamp''type-1 stamp)
                    ]
                        (and (some? type) (not (#_"ResolvedJavaType" .isJavaLangObject type))
                            (if (and (not (#_"ResolvedJavaType" .isArray type)) (not (#_"ResolvedJavaType" .isInterface type)))
                                ;; Definitely some form of instance type.
                                (ValueNode''updateStamp-2 this, (StampFactory'forInteger-3 JavaKind/Int, HotSpot'klassLayoutHelperNeutralValue, Integer/MAX_VALUE))
                                (and (#_"ResolvedJavaType" .isArray type)
                                    (ValueNode''updateStamp-2 this, (StampFactory'forInteger-3 JavaKind/Int, Integer/MIN_VALUE, (dec HotSpot'klassLayoutHelperNeutralValue)))
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"Node" KlassLayoutHelperNode''canonical-2 [#_"KlassLayoutHelperNode" this, #_"CanonicalizerTool" tool]
        (when-not (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
            (KlassLayoutHelperNode'canonical-3 this, (:klass this), (:stamp this))
        )
    )

    (§ defn- #_"ValueNode" KlassLayoutHelperNode'canonical-3 [#_"KlassLayoutHelperNode" node, #_"ValueNode" klass, #_"Stamp" stamp]
        (when (and (instance? ConstantNode klass) (not (#_"Constant" .isDefaultForKind (:value klass))))
            (§ return (ConstantNode'forConstant-2 stamp, (Stamp''readConstant-4 stamp, (#_"ConstantReflectionProvider" .getMemoryAccessProvider HotSpot'constantReflection), (:value klass), HotSpot'klassLayoutHelperOffset)))
        )
        (when (instance? LoadHubNode klass)
            (let [
                #_"Stamp" hubStamp (:stamp (:value klass))
            ]
                (when (instance? ObjectStamp hubStamp)
                    (let [
                        #_"HotSpotResolvedObjectType" type (AbstractObjectStamp''type-1 hubStamp)
                    ]
                        (when (and (some? type) (#_"HotSpotResolvedObjectType" .isArray type) (not (#_"ResolvedJavaType" .isPrimitive (#_"HotSpotResolvedObjectType" .getComponentType type))))
                            ;; The layout for all object arrays is the same.
                            (§ return (ConstantNode'forConstant-2 stamp, (Stamp''readConstant-4 stamp, (#_"ConstantReflectionProvider" .getMemoryAccessProvider HotSpot'constantReflection), (#_"HotSpotResolvedObjectType" .klass type), HotSpot'klassLayoutHelperOffset)))
                        )
                    )
                )
            )
        )
        (or node (KlassLayoutHelperNode'new-1 klass))
    )

    #_unused
    (§ override! #_"void" KlassLayoutHelperNode''lower-2 [#_"KlassLayoutHelperNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerKlassLayoutHelperNode-2 this, lowerer)
        nil
    )
)

;;;
 ; Snippets used for implementing the monitorenter and monitorexit instructions.
 ;
 ; The locking algorithm used is described in the paper
 ; <a href="http://dl.acm.org/citation.cfm?id=1167515.1167496"> Eliminating synchronization-related
 ; atomic operations with biased locking and bulk rebiasing</a> by Kenneth Russell and David Detlefs.
 ;
 ; Comment below is reproduced from {@code markOop.hpp} for convenience:
 ;
 ;  Bit-format of an object header (most significant first, big endian layout below):
 ;  32 bits:
 ;  --------
 ;             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)
 ;             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
 ;             size:32 ------------------------------------------>| (CMS free block)
 ;             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)
 ;
 ;  64 bits:
 ;  --------
 ;  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)
 ;  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
 ;  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)
 ;  size:64 ----------------------------------------------------->| (CMS free block)
 ;
 ;  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)
 ;  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)
 ;  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)
 ;  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)
 ;
 ;  - hash contains the identity hash value: largest value is
 ;    31 bits, see os::random().  Also, 64-bit vm's require
 ;    a hash value no bigger than 32 bits because they will not
 ;    properly generate a mask larger than that: see library_call.cpp
 ;    and c1_CodePatterns_sparc.cpp.
 ;
 ;  - the biased lock pattern is used to bias a lock toward a given
 ;    thread. When this pattern is set in the low three bits, the lock
 ;    is either biased toward a given thread or "anonymously" biased,
 ;    indicating that it is possible for it to be biased. When the
 ;    lock is biased toward a given thread, locking and unlocking can
 ;    be performed by that thread without using atomic operations.
 ;    When a lock's bias is revoked, it reverts back to the normal
 ;    locking scheme described below.
 ;
 ;    Note that we are overloading the meaning of the "unlocked" state
 ;    of the header. Because we steal a bit from the age we can
 ;    guarantee that the bias pattern will never be seen for a truly
 ;    unlocked object.
 ;
 ;    Note also that the biased state contains the age bits normally
 ;    contained in the object header. Large increases in scavenge
 ;    times were seen when these bits were absent and an arbitrary age
 ;    assigned to all biased objects, because they tended to consume a
 ;    significant fraction of the eden semispaces and were not
 ;    promoted promptly, causing an increase in the amount of copying
 ;    performed. The runtime system aligns all JavaThread* pointers to
 ;    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))
 ;    to make room for the age bits & the epoch bits (used in support of
 ;    biased locking), and for the CMS "freeness" bit in the 64bVM (+COOPs).
 ;
 ;    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread
 ;    [0           | epoch | age | 1 | 01]       lock is anonymously biased
 ;
 ;  - the two lock bits are used to describe three states: locked/unlocked and monitor.
 ;
 ;    [ptr             | 00]  locked             ptr points to real header on stack
 ;    [header      | 0 | 01]  unlocked           regular object header
 ;    [ptr             | 10]  monitor            inflated lock (header is wapped out)
 ;    [ptr             | 11]  marked             used by markSweep to mark an object
 ;                                               not valid at any other time
 ;
 ;    We assume that stack/thread pointers have the lowest two bits cleared.
 ;
 ; Note that {@code Thread::allocate} enforces JavaThread objects to be aligned
 ; appropriately to comply with the layouts above.
 ;;
(value-ns MonitorSnippets (§ implements Snippets)
    ; @Snippet
    #_unused
    (§ defn #_"void" MonitorSnippets'monitorenter-5 [#_"Object" object, #_"KlassPointer" hub, #_@ConstantParameter #_"int" lockDepth, #_@ConstantParameter #_"Register" threadRegister, #_@ConstantParameter #_"Register" stackPointerRegister]
        ;; load the mark word - this includes a nil-check on object
        (let [
            #_"Word" mark (HotSpotReplacementsUtil'loadWordFromObject-2 object, HotSpot'markOffset)
            #_"Word" lock (BeginLockScopeNode'beginLockScope-1 lockDepth)
            #_"Pointer" objectPointer (Word'objectToTrackedPointer-1 object)
        ]
            (when (and HotSpot'useBiasedLocking (MonitorSnippets'tryEnterBiased-5 object, hub, lock, mark, threadRegister))
                (§ return )
                ;; not biased, fall-through
            )
            (if (and (MonitorSnippets'inlineFastLockSupported-0) (BranchProbabilityNode'probability-2 BranchProbabilityNode'SLOW_PATH_PROBABILITY, (Word''notEqual-2 (Word''and-2 mark, HotSpot'monitorMask), 0)))
                ;; inflated case
                (when (MonitorSnippets'tryEnterInflated-4 object, lock, mark, threadRegister)
                    (§ return )
                )
                ;; create the unlocked mark word pattern
                (let [
                    #_"Word" unlockedMark (Word''or-2 mark, HotSpot'unlockedMask)
                ]
                    ;; copy this unlocked mark word into the lock slot on the stack
                    (Word''writeWord-4 lock, HotSpot'lockDisplacedMarkOffset, unlockedMark, HotSpotReplacementsUtil'DISPLACED_MARK_WORD_LOCATION)

                    ;; make sure previous store does not float below compareAndSwap
                    (MembarNode'memoryBarrier-1 MemoryBarriers/STORE_STORE)

                    ;; Test if the object's mark word is unlocked, and if so, store the (address of) the lock slot into the object's mark word.
                    (let [
                        #_"Word" currentMark (#_"Pointer" .compareAndSwapWord objectPointer, HotSpot'markOffset, unlockedMark, lock, HotSpotReplacementsUtil'MARK_WORD_LOCATION)
                    ]
                        (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (Word''equal-2 currentMark, unlockedMark))
                            (do
                                (AcquiredCASLockNode'mark-1 object)
                                (§ return )
                            )
                            ;; The mark word in the object header was not the same.
                            ;; Either the object is locked by another thread or is already locked
                            ;; by the current thread. The latter is true if the mark word
                            ;; is a stack pointer into the current thread's stack, i.e.:
                            ;;
                            ;; 1. (currentMark & aligned_mask) == 0
                            ;; 2. rsp <= currentMark
                            ;; 3. currentMark <= rsp + page_size
                            ;;
                            ;; These 3 tests can be done by evaluating the following expression:
                            ;;
                            ;; (currentMark - rsp) & (aligned_mask - page_size)
                            ;;
                            ;; assuming both the stack pointer and page_size have their least
                            ;; significant 2 bits cleared and page_size is a power of 2
                            (let [
                                #_"Word" alignedMask (WordFactory/unsigned (dec (.wordSize HotSpot'target)))
                                #_"Word" stackPointer (Word''add-2 (HotSpotReplacementsUtil'registerAsWord-1 stackPointerRegister), HotSpot'stackBias)
                            ]
                                (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (Word''equal-2 (Word''and-2 (Word''subtract-2 currentMark, stackPointer), (Word''subtract-2 alignedMask, (.pageSize HotSpot'unsafe))), 0))
                                    ;; recursively locked => write 0 to the lock slot
                                    (Word''writeWord-4 lock, HotSpot'lockDisplacedMarkOffset, (WordFactory/zero), HotSpotReplacementsUtil'DISPLACED_MARK_WORD_LOCATION)
                                    (§ return )
                                )
                            )
                        )
                    )
                )
            )
            ;; slow-path runtime-call
            (MonitorSnippets'monitorenterStubC-3 ForeignCallDescriptor'MONITORENTER, object, lock)
        )
        nil
    )

    (§ defn- #_"boolean" MonitorSnippets'tryEnterBiased-5 [#_"Object" object, #_"KlassPointer" hub, #_"Word" lock, #_"Word" mark, #_"Register" threadRegister]
        ;; See whether the lock is currently biased toward our thread and whether the epoch is still valid.
        ;; Note that the runtime guarantees sufficient alignment of JavaThread pointers to allow age to be placed into low bits.
        (let [
            #_"Word" biasableLockBits (Word''and-2 mark, HotSpot'biasedLockMaskInPlace)
            ;; Check whether the bias pattern is present in the object's mark word and the bias owner and the epoch are both still current.
            #_"Word" prototypeMarkWord (MetaspacePointer''readWord-3 hub, HotSpot'prototypeMarkWordOffset, HotSpotReplacementsUtil'PROTOTYPE_MARK_WORD_LOCATION)
            #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
            #_"Word" tmp (Word''and-2 (Word''xor-2 (Word''or-2 prototypeMarkWord, thread), mark), (bit-not HotSpot'ageMaskInPlace))
        ]
            (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (Word''equal-2 tmp, 0))
                ;; object is already biased to current thread -> done
                (FastAcquireBiasedLockNode'mark-1 object)
                (§ return true)
            )

            ;; now check to see whether biasing is enabled for this object
            (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (Word''equal-2 biasableLockBits, (WordFactory/unsigned HotSpot'biasedLockPattern)))
                (let [
                    #_"Pointer" objectPointer (Word'objectToTrackedPointer-1 object)
                ]
                    ;; At this point we know that the mark word has the bias pattern and that we are not the bias owner in the
                    ;; current epoch. We need to figure out more details about the state of the mark word in order to know what
                    ;; operations can be legally performed on the object's mark word.

                    ;; If the low three bits in the xor result aren't clear, that means the prototype header is no longer biasable
                    ;; and we have to revoke the bias on this object.
                    (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (Word''equal-2 (Word''and-2 tmp, HotSpot'biasedLockMaskInPlace), 0))
                        (do
                            ;; Biasing is still enabled for object's type. See whether the epoch of the current bias is still valid,
                            ;; meaning that the epoch bits of the mark word are equal to the epoch bits of the prototype mark word.
                            ;; (Note that the prototype mark word's epoch bits only change at a safepoint.) If not, attempt to rebias
                            ;; the object toward the current thread. Note that we must be absolutely sure that the current epoch is
                            ;; invalid in order to do this, because otherwise the manipulations it performs on the mark word are illegal.
                            (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (Word''equal-2 (Word''and-2 tmp, HotSpot'epochMaskInPlace), 0))
                                ;; The epoch of the current bias is still valid but we know nothing about the owner, it might be
                                ;; set or it might be clear. Try to acquire the bias of the object using an atomic operation. If
                                ;; this fails we will go in to the runtime to revoke the object's bias. Note that we first construct
                                ;; the presumed unbiased header so we don't accidentally blow away another thread's valid bias.
                                (let [
                                    #_"Word" unbiasedMark (Word''and-2 mark, (| HotSpot'biasedLockMaskInPlace HotSpot'ageMaskInPlace HotSpot'epochMaskInPlace))
                                    #_"Word" biasedMark (Word''or-2 unbiasedMark, thread)
                                ]
                                    (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'VERY_FAST_PATH_PROBABILITY, (#_"Pointer" .logicCompareAndSwapWord objectPointer, HotSpot'markOffset, unbiasedMark, biasedMark, HotSpotReplacementsUtil'MARK_WORD_LOCATION))
                                        ;; object is now biased to current thread -> done
                                        (§ return true)
                                    )
                                    ;; If the biasing toward our thread failed, this means that another thread owns the bias
                                    ;; and we need to revoke that bias. The revocation will occur in the interpreter runtime.
                                )
                                ;; At this point we know the epoch has expired, meaning that the current bias owner, if any, is
                                ;; actually invalid. Under these circumstances *only*, are we allowed to use the current mark word
                                ;; value as the comparison value when doing the CAS to acquire the bias in the current epoch. In
                                ;; other words, we allow transfer of the bias from one thread to another directly in this situation.
                                (let [
                                    #_"Word" biasedMark (Word''or-2 prototypeMarkWord, thread)
                                ]
                                    (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'VERY_FAST_PATH_PROBABILITY, (#_"Pointer" .logicCompareAndSwapWord objectPointer, HotSpot'markOffset, mark, biasedMark, HotSpotReplacementsUtil'MARK_WORD_LOCATION))
                                        ;; object is now biased to current thread -> done
                                        (§ return true)
                                    )
                                    ;; If the biasing toward our thread failed, then another thread succeeded in biasing it toward itself
                                    ;; and we need to revoke that bias. The revocation will occur in the runtime in the slow case.
                                )
                            )
                            ;; slow-path runtime-call
                            (MonitorSnippets'monitorenterStubC-3 ForeignCallDescriptor'MONITORENTER, object, lock)
                            (§ return true)
                        )
                        ;; The prototype mark word doesn't have the bias bit set any more, indicating that objects of this
                        ;; data type are not supposed to be biased any more. We are going to try to reset the mark of this
                        ;; object to the prototype value and fall through to the CAS-based locking scheme. Note that if our
                        ;; CAS fails, it means that another thread raced us for the privilege of revoking the bias of this
                        ;; particular object, so it's okay to continue in the normal locking code.
                        (let [
                            #_"Word" result (#_"Pointer" .compareAndSwapWord objectPointer, HotSpot'markOffset, mark, prototypeMarkWord, HotSpotReplacementsUtil'MARK_WORD_LOCATION)
                        ]
                            ;; Fall through to the normal CAS-based lock, because no matter what the result of the above CAS,
                            ;; some thread must have succeeded in removing the bias bit from the object's header.
                            (§ return false)
                        )
                    )
                )
                (do
                    ;; biasing not enabled -> fall through to lightweight locking
                    (§ return false)
                )
            )
        )
    )

    (§ defn- #_"boolean" MonitorSnippets'inlineFastLockSupported-0 []
        (and GraalOptions'simpleFastInflatedLocking (<= 0 HotSpot'monitorMask) (<= 0 HotSpot'objectMonitorOwnerOffset))
    )

    (§ defn- #_"boolean" MonitorSnippets'tryEnterInflated-4 [#_"Object" object, #_"Word" lock, #_"Word" mark, #_"Register" threadRegister]
        ;; write non-zero value to lock slot
        (Word''writeWord-4 lock, HotSpot'lockDisplacedMarkOffset, lock, HotSpotReplacementsUtil'DISPLACED_MARK_WORD_LOCATION)
        ;; mark is a pointer to the ObjectMonitor + monitorMask
        (let [
            #_"Word" monitor (Word''subtract-2 mark, HotSpot'monitorMask)
            #_"Word" owner (Word''readWord-3 monitor, HotSpot'objectMonitorOwnerOffset, HotSpotReplacementsUtil'OBJECT_MONITOR_OWNER_LOCATION)
        ]
            ;; appears being unlocked when owner is 0
            (and (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (Word''equal-2 owner, 0))
                 (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (Word''logicCompareAndSwapWord-5 monitor, HotSpot'objectMonitorOwnerOffset, owner, (HotSpotReplacementsUtil'registerAsWord-1 threadRegister), HotSpotReplacementsUtil'OBJECT_MONITOR_OWNER_LOCATION))
            )
        )
    )

    ;;;
     ; Calls straight out to the monitorenter stub.
     ;;
    ; @Snippet
    #_unused
    (§ defn #_"void" MonitorSnippets'monitorenterStub-2 [#_"Object" object, #_@ConstantParameter #_"int" lockDepth]
        (when (nil? object)
            (DeoptimizeNode'deopt-2 DeoptimizationAction/InvalidateReprofile, DeoptimizationReason/NullCheckException)
        )
        ;; BeginLockScope nodes do not read from object, so a use of object cannot float about the nil-check above.
        (MonitorSnippets'monitorenterStubC-3 ForeignCallDescriptor'MONITORENTER, object, (BeginLockScopeNode'beginLockScope-1 lockDepth))
        nil
    )

    ; @Snippet
    #_unused
    (§ defn #_"void" MonitorSnippets'monitorexit-3 [#_"Object" object, #_@ConstantParameter #_"int" lockDepth, #_@ConstantParameter #_"Register" threadRegister]
        (let [
            #_"Word" mark (HotSpotReplacementsUtil'loadWordFromObject-2 object, HotSpot'markOffset)
        ]
            (when HotSpot'useBiasedLocking
                ;; Check for biased locking unlock case, which is a no-op.
                ;; Note: we do not have to check the thread ID for two reasons.
                ;; First, the interpreter checks for IllegalMonitorStateException at a higher level.
                ;; Second, if the bias was revoked while we held the lock, the object could not be
                ;; rebiased toward another thread, so the bias bit would be clear.
                (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (Word''equal-2 (Word''and-2 mark, HotSpot'biasedLockMaskInPlace), (WordFactory/unsigned HotSpot'biasedLockPattern)))
                    (EndLockScopeNode'endLockScope-0)
                    (§ return )
                )
            )

            (let [
                #_"Word" lock (CurrentLockNode'currentLock-1 lockDepth)
                ;; load displaced mark
                #_"Word" displacedMark (Word''readWord-3 lock, HotSpot'lockDisplacedMarkOffset, HotSpotReplacementsUtil'DISPLACED_MARK_WORD_LOCATION)
            ]
                (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_LIKELY_PROBABILITY, (Word''equal-2 displacedMark, 0))
                    nil ;; recursive locking => done
                    (when-not (MonitorSnippets'tryExitInflated-4 object, mark, lock, threadRegister)
                        ;; Test if object's mark word is pointing to the displaced mark word, and if so,
                        ;; restore the displaced mark in the object - if the object's mark word is not
                        ;; pointing to the displaced mark word, do unlocking via runtime call.
                        (let [
                            #_"Pointer" objectPointer (Word'objectToTrackedPointer-1 object)
                        ]
                            (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'VERY_FAST_PATH_PROBABILITY, (#_"Pointer" .logicCompareAndSwapWord objectPointer, HotSpot'markOffset, lock, displacedMark, HotSpotReplacementsUtil'MARK_WORD_LOCATION))
                                nil ;; ...
                                (do
                                    ;; the object's mark word was not pointing to the displaced header
                                    (MonitorSnippets'monitorexitStubC-3 ForeignCallDescriptor'MONITOREXIT, object, lock)
                                )
                            )
                        )
                    )
                )
                (EndLockScopeNode'endLockScope-0)
            )
        )
        nil
    )

    (§ defn- #_"boolean" MonitorSnippets'inlineFastUnlockSupported-0 []
        (and GraalOptions'simpleFastInflatedLocking
            (<= 0 HotSpot'objectMonitorEntryListOffset)
            (<= 0 HotSpot'objectMonitorCxqOffset)
            (<= 0 HotSpot'monitorMask)
            (<= 0 HotSpot'objectMonitorOwnerOffset)
            (<= 0 HotSpot'objectMonitorRecursionsOffset)
        )
    )

    (§ defn- #_"boolean" MonitorSnippets'tryExitInflated-4 [#_"Object" object, #_"Word" mark, #_"Word" lock, #_"Register" threadRegister]
        (and (MonitorSnippets'inlineFastUnlockSupported-0)
             (BranchProbabilityNode'probability-2 BranchProbabilityNode'SLOW_PATH_PROBABILITY, (Word''notEqual-2 (Word''and-2 mark, HotSpot'monitorMask), 0))
            ;; inflated case
            ;; mark is a pointer to the ObjectMonitor + monitorMask
            (let [
                #_"Word" monitor (Word''subtract-2 mark, HotSpot'monitorMask)
                #_"int" ownerOffset HotSpot'objectMonitorOwnerOffset
                #_"Word" owner (Word''readWord-3 monitor, ownerOffset, HotSpotReplacementsUtil'OBJECT_MONITOR_OWNER_LOCATION)
                #_"int" recursionsOffset HotSpot'objectMonitorRecursionsOffset
                #_"Word" recursions (Word''readWord-3 monitor, recursionsOffset, HotSpotReplacementsUtil'OBJECT_MONITOR_RECURSION_LOCATION)
                #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
            ]
                (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (Word''equal-2 (Word''or-2 (Word''xor-2 owner, thread), recursions), 0))
                    ;; owner == thread && recursions == 0
                    (let [
                        #_"int" cxqOffset HotSpot'objectMonitorCxqOffset
                        #_"Word" cxq (Word''readWord-3 monitor, cxqOffset, HotSpotReplacementsUtil'OBJECT_MONITOR_CXQ_LOCATION)
                        #_"int" entryListOffset HotSpot'objectMonitorEntryListOffset
                        #_"Word" entryList (Word''readWord-3 monitor, entryListOffset, HotSpotReplacementsUtil'OBJECT_MONITOR_ENTRY_LIST_LOCATION)
                    ]
                        (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (Word''equal-2 (Word''or-2 cxq, entryList), 0))
                            ;; cxq == 0 && entryList == 0
                            ;; nobody is waiting, success
                            (MembarNode'memoryBarrier-1 (| MemoryBarriers/LOAD_STORE MemoryBarriers/STORE_STORE))
                            (Word''writeWord-3 monitor, ownerOffset, (WordFactory/zero))
                            (§ return true)
                        )
                    )
                )
                (MonitorSnippets'monitorexitStubC-3 ForeignCallDescriptor'MONITOREXIT, object, lock)
                true
            )
        )
    )

    ;;;
     ; Calls straight out to the monitorexit stub.
     ;;
    ; @Snippet
    #_unused
    (§ defn #_"void" MonitorSnippets'monitorexitStub-2 [#_"Object" object, #_@ConstantParameter #_"int" lockDepth]
        (let [
            #_"Word" lock (CurrentLockNode'currentLock-1 lockDepth)
        ]
            (MonitorSnippets'monitorexitStubC-3 ForeignCallDescriptor'MONITOREXIT, object, lock)
            (EndLockScopeNode'endLockScope-0)
        )
        nil
    )

    ; @NodeIntrinsic(ForeignCallNode.class)
    (§ native #_"void" MonitorSnippets'monitorenterStubC-3 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" descriptor, #_"Object" object, #_"Word" lock])

    ; @NodeIntrinsic(ForeignCallNode.class)
    (§ native #_"void" MonitorSnippets'monitorexitStubC-3 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" descriptor, #_"Object" object, #_"Word" lock])
)

;;;
 ; @anno MonitorSnippets.MonitorTemplates
 ;;
(final-ns MonitorTemplates (§ extends AbstractTemplates)
    (§ final #_"SnippetInfo" :monitorenter (AbstractTemplates''snippet-4* this, MonitorSnippets, "monitorenter"))
    (§ final #_"SnippetInfo" :monitorexit (AbstractTemplates''snippet-4* this, MonitorSnippets, "monitorexit"))
    (§ final #_"SnippetInfo" :monitorenterStub (AbstractTemplates''snippet-4* this, MonitorSnippets, "monitorenterStub"))
    (§ final #_"SnippetInfo" :monitorexitStub (AbstractTemplates''snippet-4* this, MonitorSnippets, "monitorexitStub"))

    (§ final #_"boolean" :useFastLocking false)

    (§ defn #_"MonitorTemplates" MonitorTemplates'new-1 [#_"boolean" useFastLocking]
        (let [
            #_"MonitorTemplates" this (AbstractTemplates'new-0)
            this (assoc this :useFastLocking useFastLocking)
        ]
            this
        )
    )

    (§ method! #_"void" MonitorTemplates''lower-3 [#_"MonitorTemplates" this, #_"RawMonitorEnterNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args
                (if (:useFastLocking this)
                    (let [
                        args (Arguments'new-3 (:monitorenter this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
                    ]
                        (Arguments''add-3 args, "object", (:object node))
                        (Arguments''add-3 args, "hub", (:hub node))
                        (Arguments''addConst-3 args, "lockDepth", (:lockDepth (:monitorId node)))
                        (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
                        (Arguments''addConst-3 args, "stackPointerRegister", HotSpot'stackPointerRegister)
                        args
                    )
                    (let [
                        args (Arguments'new-3 (:monitorenterStub this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
                    ]
                        (Arguments''add-3 args, "object", (:object node))
                        (Arguments''addConst-3 args, "lockDepth", (:lockDepth (:monitorId node)))
                        args
                    )
                )
        ]
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )

    (§ method! #_"void" MonitorTemplates''lower-3 [#_"MonitorTemplates" this, #_"MonitorExitNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args
                (if (:useFastLocking this)
                    (Arguments'new-3 (:monitorexit this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
                    (Arguments'new-3 (:monitorexitStub this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
                )
        ]
            (Arguments''add-3 args, "object", (:object node))
            (Arguments''addConst-3 args, "lockDepth", (:lockDepth (:monitorId node)))
            (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )
)

;;;
 ; Snippets used for implementing NEW, ANEWARRAY and NEWARRAY.
 ;;
(value-ns NewObjectSnippets (§ implements Snippets)
    (§ defn #_"void" NewObjectSnippets'emitPrefetchAllocate-2 [#_"Word" address, #_"boolean" isArray]
        (when (pos? HotSpot'allocatePrefetchStyle)
            ;; Insert a prefetch for each allocation only on the fast-path.
            ;; Generate several prefetch instructions.
            (let [
                #_"int" lines (if isArray HotSpot'allocatePrefetchLines HotSpot'allocateInstancePrefetchLines)
                #_"int" stepSize HotSpot'allocatePrefetchStepSize
                #_"int" distance HotSpot'allocatePrefetchDistance
            ]
                (ExplodeLoopNode'explodeLoop-0)
                (loop-when-recur [distance distance #_"int" i 0] (< i lines) [(+ distance stepSize) (inc i)]
                    (PrefetchAllocateNode'prefetch-1 (OffsetAddressNode'address-2 address, distance))
                )
            )
        )
        nil
    )

    ; @Snippet
    #_unused
    (§ defn #_"Object" NewObjectSnippets'allocateInstance-6 [#_@ConstantParameter #_"int" size, #_"KlassPointer" hub, #_"Word" prototypeMarkWord, #_@ConstantParameter #_"boolean" fillContents, #_@ConstantParameter #_"Register" threadRegister, #_@ConstantParameter #_"boolean" constantSize]
        (PiNode'piCastToSnippetReplaceeStamp-1 (NewObjectSnippets'allocateInstanceHelper-6 size, hub, prototypeMarkWord, fillContents, threadRegister, constantSize))
    )

    (§ defn #_"Object" NewObjectSnippets'allocateInstanceHelper-6 [#_"int" size, #_"KlassPointer" hub, #_"Word" prototypeMarkWord, #_"boolean" fillContents, #_"Register" threadRegister, #_"boolean" constantSize]
        (let [
            #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
            #_"Word" top (HotSpotReplacementsUtil'readTlabTop-1 thread)
            #_"Word" end (HotSpotReplacementsUtil'readTlabEnd-1 thread)
            #_"Word" newTop (Word''add-2 top, size)
        ]
            (if (and HotSpot'useTLAB (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (Word''belowOrEqual-2 newTop, end)))
                (do
                    (HotSpotReplacementsUtil'writeTlabTop-2 thread, newTop)
                    (NewObjectSnippets'emitPrefetchAllocate-2 newTop, false)
                    (NewObjectSnippets'formatObject-6 hub, size, top, prototypeMarkWord, fillContents, constantSize)
                )
                (NewObjectSnippets'newInstance-2 ForeignCallDescriptor'NEW_INSTANCE, hub)
            )
        )
    )

    ; @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
    (§ native #_"Object" NewObjectSnippets'newInstance-2 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" descriptor, #_"KlassPointer" hub])

    ; @Snippet
    #_unused
    (§ defn #_"Object" NewObjectSnippets'allocateInstanceDynamic-4 [#_"Class" type, #_"Class" classClass, #_@ConstantParameter #_"boolean" fillContents, #_@ConstantParameter #_"Register" threadRegister]
        (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'SLOW_PATH_PROBABILITY, (nil? type))
            (DeoptimizeNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
        )
        (let [
            #_"Class" nonNullType (PiNode'piCastNonNullClass-2 type, (SnippetAnchorNode'anchor-0))
        ]
            (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'SLOW_PATH_PROBABILITY, (DynamicNewInstanceNode'throwsInstantiationException-2 type, classClass))
                (DeoptimizeNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
            )

            (PiNode'piCastToSnippetReplaceeStamp-1 (NewObjectSnippets'allocateInstanceDynamicHelper-4 type, fillContents, threadRegister, nonNullType))
        )
    )

    (§ defn- #_"Object" NewObjectSnippets'allocateInstanceDynamicHelper-4 [#_"Class" type, #_"boolean" fillContents, #_"Register" threadRegister, #_"Class" nonNullType]
        (let [
            #_"KlassPointer" hub (ClassGetHubNode'readClass-1 nonNullType)
        ]
            (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (not (MetaspacePointer''isNull-1 hub)))
                (let [
                    #_"KlassPointer" nonNullHub (ClassGetHubNode'piCastNonNull-2 hub, (SnippetAnchorNode'anchor-0))
                ]
                    (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (HotSpotReplacementsUtil'isInstanceKlassFullyInitialized-1 nonNullHub))
                        (let [
                            #_"int" layoutHelper (HotSpotReplacementsUtil'readLayoutHelper-1 nonNullHub)
                        ]
                            ;; src/share/vm/oops/klass.hpp: For instances, layout helper is a positive number, the instance size.
                            ;; This size is already passed through align_object_size and scaled to bytes. The low order bit is set
                            ;; if instances of this class cannot be allocated using the fastpath.
                            (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (zero? (& layoutHelper 1)))
                                (let [
                                    #_"Word" prototypeMarkWord (MetaspacePointer''readWord-3 nonNullHub, HotSpot'prototypeMarkWordOffset, HotSpotReplacementsUtil'PROTOTYPE_MARK_WORD_LOCATION)
                                ]
                                    (§ return (NewObjectSnippets'allocateInstanceHelper-6 layoutHelper, nonNullHub, prototypeMarkWord, fillContents, threadRegister, false))
                                )
                            )
                        )
                    )
                )
            )
            (NewObjectSnippets'dynamicNewInstanceStub-1 type)
        )
    )

    ;;;
     ; Maximum array length for which fast path allocation is used.
     ;;
    (def #_"int" NewObjectSnippets'MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH 0x00ffffff)

    ; @Snippet
    #_unused
    (§ defn #_"Object" NewObjectSnippets'allocateArray-8 [#_"KlassPointer" hub, #_"int" length, #_"Word" prototypeMarkWord, #_@ConstantParameter #_"int" headerSize, #_@ConstantParameter #_"int" log2ElementSize, #_@ConstantParameter #_"boolean" fillContents, #_@ConstantParameter #_"Register" threadRegister, #_@ConstantParameter #_"boolean" maybeUnroll]
        (let [
            #_"Object" result (NewObjectSnippets'allocateArrayImpl-9 hub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents, threadRegister, maybeUnroll, false)
        ]
            (PiArrayNode'piArrayCastToSnippetReplaceeStamp-2 result, length)
        )
    )

    (§ defn- #_"Object" NewObjectSnippets'allocateArrayImpl-9 [#_"KlassPointer" hub, #_"int" length, #_"Word" prototypeMarkWord, #_"int" headerSize, #_"int" log2ElementSize, #_"boolean" fillContents, #_"Register" threadRegister, #_"boolean" maybeUnroll, #_"boolean" skipNegativeCheck]
        (let [
            #_"int" allocationSize (HotSpotReplacementsUtil'arrayAllocationSize-3 length, headerSize, log2ElementSize)
            #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
            #_"Word" top (HotSpotReplacementsUtil'readTlabTop-1 thread)
            #_"Word" end (HotSpotReplacementsUtil'readTlabEnd-1 thread)
            #_"Word" newTop (Word''add-2 top, allocationSize)
        ]
            (if (and (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (or skipNegativeCheck (UnsignedMath'belowThan-2 length, NewObjectSnippets'MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH))) HotSpot'useTLAB (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (Word''belowOrEqual-2 newTop, end)))
                (do
                    (HotSpotReplacementsUtil'writeTlabTop-2 thread, newTop)
                    (NewObjectSnippets'emitPrefetchAllocate-2 newTop, true)
                    (NewObjectSnippets'formatArray-8 hub, allocationSize, length, headerSize, top, prototypeMarkWord, fillContents, maybeUnroll)
                )
                (NewObjectSnippets'newArray-4 ForeignCallDescriptor'NEW_ARRAY, hub, length, fillContents)
            )
        )
    )

    ; @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
    (§ native #_"Object" NewObjectSnippets'newArray-4 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" descriptor, #_"KlassPointer" hub, #_"int" length, #_"boolean" fillContents])

    ; @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
    #_unused
    (§ native #_"Object" NewObjectSnippets'dynamicNewArrayStub-3 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" descriptor, #_"Class" elementType, #_"int" length])

    (§ defn #_"Object" NewObjectSnippets'dynamicNewInstanceStub-1 [#_"Class" elementType]
        (NewObjectSnippets'dynamicNewInstanceStubCall-2 ForeignCallDescriptor'DYNAMIC_NEW_INSTANCE, elementType)
    )

    ; @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
    (§ native #_"Object" NewObjectSnippets'dynamicNewInstanceStubCall-2 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" descriptor, #_"Class" elementType])

    ; @Snippet
    #_unused
    (§ defn #_"Object" NewObjectSnippets'allocateArrayDynamic-8 [#_"Class" elementType, #_"Class" voidClass, #_"int" length, #_@ConstantParameter #_"boolean" fillContents, #_@ConstantParameter #_"Register" threadRegister, #_@ConstantParameter #_"JavaKind" knownElementKind, #_@ConstantParameter #_"int" knownLayoutHelper, #_"Word" prototypeMarkWord]
        (NewObjectSnippets'allocateArrayDynamicImpl-8 elementType, voidClass, length, fillContents, threadRegister, knownElementKind, knownLayoutHelper, prototypeMarkWord)
    )

    (§ defn- #_"Object" NewObjectSnippets'allocateArrayDynamicImpl-8 [#_"Class" elementType, #_"Class" voidClass, #_"int" length, #_"boolean" fillContents, #_"Register" threadRegister, #_"JavaKind" knownElementKind, #_"int" knownLayoutHelper, #_"Word" prototypeMarkWord]
        ;; We only need the dynamic check for void when we have no static information from knownElementKind.
        (when (and (= knownElementKind JavaKind/Illegal) (BranchProbabilityNode'probability-2 BranchProbabilityNode'SLOW_PATH_PROBABILITY, (or (nil? elementType) (DynamicNewArrayNode'throwsIllegalArgumentException-2 elementType, voidClass))))
            (DeoptimizeNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
        )

        (let [
            #_"KlassPointer" klass (HotSpotReplacementsUtil'loadKlassFromObject-3 elementType, HotSpot'arrayKlassOffset, HotSpotReplacementsUtil'CLASS_ARRAY_KLASS_LOCATION)
        ]
            (when (MetaspacePointer''isNull-1 klass)
                (DeoptimizeNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
            )
            (let [
                #_"KlassPointer" nonNullKlass (ClassGetHubNode'piCastNonNull-2 klass, (SnippetAnchorNode'anchor-0))
            ]
                (when (neg? length)
                    (DeoptimizeNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
                )
                (let [
                    #_"int" layoutHelper (if (= knownElementKind JavaKind/Illegal) (HotSpotReplacementsUtil'readLayoutHelper-1 nonNullKlass) knownLayoutHelper)
                    ;; For arrays, layout helper is a negative number, containing four distinct bytes,
                    ;; as follows:
                    ;;    MSB:[tag, hsz, ebt, log2(esz)]:LSB
                    ;; where:
                    ;;    tag is 0x80 if the elements are oops, 0xc0 if non-oops
                    ;;    hsz is array header size in bytes (i.e. offset of first element)
                    ;;    ebt is the BasicType of the elements
                    ;;    esz is the element size in bytes
                    #_"int" headerSize (& (>> layoutHelper HotSpot'layoutHelperHeaderSizeShift) HotSpot'layoutHelperHeaderSizeMask)
                    #_"int" log2ElementSize (& (>> layoutHelper HotSpot'layoutHelperLog2ElementSizeShift) HotSpot'layoutHelperLog2ElementSizeMask)
                    #_"Object" result (NewObjectSnippets'allocateArrayImpl-9 nonNullKlass, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents, threadRegister, false, true)
                ]
                    (PiArrayNode'piArrayCastToSnippetReplaceeStamp-2 result, length)
                )
            )
        )
    )

    ; @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
    #_unused
    (§ native #_"Object" NewObjectSnippets'newArrayCall-4 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" descriptor, #_"KlassPointer" hub, #_"int" rank, #_"Word" dims])

    ;;;
     ; Maximum number of long stores to emit when zeroing an object with a constant size.
     ; Larger objects have their bodies initialized in a loop.
     ;;
    (def- #_"int" NewObjectSnippets'MAX_UNROLLED_OBJECT_ZEROING_STORES 8)

    ;;;
     ; Zero uninitialized memory in a newly allocated object, unrolling as necessary and
     ; ensuring that stores are aligned.
     ;
     ; @param size number of bytes to zero
     ; @param memory beginning of object which is being zeroed
     ; @param constantSize is {@code size} known to be constant in the snippet
     ; @param startOffset offset to begin zeroing. May not be word aligned.
     ; @param manualUnroll maximally unroll zeroing
     ;;
    (§ defn- #_"void" NewObjectSnippets'zeroMemory-5 [#_"int" size, #_"Word" memory, #_"boolean" constantSize, #_"int" startOffset, #_"boolean" manualUnroll]
        (NewObjectSnippets'fillMemory-6 0, size, memory, constantSize, startOffset, manualUnroll)
        nil
    )

    (§ defn- #_"void" NewObjectSnippets'fillMemory-6 [#_"long" value, #_"int" size, #_"Word" memory, #_"boolean" constantSize, #_"int" offset, #_"boolean" manualUnroll]
        (let [
            offset
                (when-not (zero? (& offset 0x7)) => offset
                    (Word''writeInt-4 memory, offset, (int value), (LocationIdentity/init))
                    (+ offset 4)
                )
        ]
            (if (and manualUnroll (<= (quot (- size offset) 8) NewObjectSnippets'MAX_UNROLLED_OBJECT_ZEROING_STORES))
                (do
                    ;; This case handles arrays of constant length. Instead of having a snippet variant
                    ;; for each length, generate a chain of stores of maximum length. Once it's inlined
                    ;; the break statement will trim excess stores.
                    (ExplodeLoopNode'explodeLoop-0)
                    (loop-when-recur [#_"int" i offset #_"int" n 0] (and (< i size) (< n NewObjectSnippets'MAX_UNROLLED_OBJECT_ZEROING_STORES)) [(+ i 8) (inc n)]
                        (Word''initializeLong-4 memory, i, value, (LocationIdentity/init))
                    )
                )
                ;; Use Word instead of int to avoid extension to long in generated code.
                (do
                    (when (and constantSize (<= (quot (- size offset) 8) NewObjectSnippets'MAX_UNROLLED_OBJECT_ZEROING_STORES))
                        (ExplodeLoopNode'explodeLoop-0)
                    )
                    (loop-when-recur [#_"Word" i (WordFactory/signed offset)] (< (Word''rawValue-1 i) size) [(Word''add-2 i, 8)]
                        (Word''initializeLong-4 memory, i, value, (LocationIdentity/init))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Formats some allocated memory with an object header and zeroes out the rest.
     ; Disables asserts since they can't be compiled in stubs.
     ;;
    (§ defn #_"Object" NewObjectSnippets'formatObjectForStub-4 [#_"KlassPointer" hub, #_"int" size, #_"Word" memory, #_"Word" compileTimePrototypeMarkWord]
        (NewObjectSnippets'formatObject-6 hub, size, memory, compileTimePrototypeMarkWord, true, false)
    )

    ;;;
     ; Formats some allocated memory with an object header and zeroes out the rest.
     ;;
    (§ defn #_"Object" NewObjectSnippets'formatObject-6 [#_"KlassPointer" hub, #_"int" size, #_"Word" memory, #_"Word" compileTimePrototypeMarkWord, #_"boolean" fillContents, #_"boolean" constantSize]
        (let [
            #_"Word" prototypeMarkWord (if HotSpot'useBiasedLocking (MetaspacePointer''readWord-3 hub, HotSpot'prototypeMarkWordOffset, HotSpotReplacementsUtil'PROTOTYPE_MARK_WORD_LOCATION) compileTimePrototypeMarkWord)
        ]
            (HotSpotReplacementsUtil'initializeObjectHeader-3 memory, prototypeMarkWord, hub)
            (when fillContents
                (NewObjectSnippets'zeroMemory-5 size, memory, constantSize, (HotSpotReplacementsUtil'instanceHeaderSize-0), false)
            )
            (MembarNode'memoryBarrier-2 MemoryBarriers/STORE_STORE, (LocationIdentity/init))
            (Word''toObjectNonNull-1 memory)
        )
    )

    ;;;
     ; Formats some allocated memory with an object header and zeroes out the rest.
     ;;
    (§ defn #_"Object" NewObjectSnippets'formatArray-8 [#_"KlassPointer" hub, #_"int" allocationSize, #_"int" length, #_"int" headerSize, #_"Word" memory, #_"Word" prototypeMarkWord, #_"boolean" fillContents, #_"boolean" maybeUnroll]
        (Word''writeInt-4 memory, HotSpot'arrayLengthOffset, length, (LocationIdentity/init))
        ;; store hub last as the concurrent garbage collectors assume length is valid if hub field is not nil
        (HotSpotReplacementsUtil'initializeObjectHeader-3 memory, prototypeMarkWord, hub)
        (when fillContents
            (NewObjectSnippets'zeroMemory-5 allocationSize, memory, false, headerSize, maybeUnroll)
        )
        (MembarNode'memoryBarrier-2 MemoryBarriers/STORE_STORE, (LocationIdentity/init))
        (Word''toObjectNonNull-1 memory)
    )
)

;;;
 ; @anno NewObjectSnippets.ProfileContext
 ;;
(value-ns ProfileContext
    (§ enum ProfileContext'AllocatingMethod)
    (§ enum ProfileContext'InstanceOrArray)
    (§ enum ProfileContext'AllocatedType)
    (§ enum ProfileContext'AllocatedTypesInMethod)
    (§ enum ProfileContext'Total)
)

;;;
 ; @anno NewObjectSnippets.NewObjectTemplates
 ;;
(final-ns NewObjectTemplates (§ extends AbstractTemplates)
    (§ final #_"SnippetInfo" :allocateInstance (AbstractTemplates''snippet-4* this, NewObjectSnippets, "allocateInstance", HotSpotReplacementsUtil'MARK_WORD_LOCATION, HotSpotReplacementsUtil'HUB_WRITE_LOCATION, HotSpotReplacementsUtil'TLAB_TOP_LOCATION, HotSpotReplacementsUtil'TLAB_END_LOCATION))
    (§ final #_"SnippetInfo" :allocateArray (AbstractTemplates''snippet-4* this, NewObjectSnippets, "allocateArray", HotSpotReplacementsUtil'MARK_WORD_LOCATION, HotSpotReplacementsUtil'HUB_WRITE_LOCATION, HotSpotReplacementsUtil'TLAB_TOP_LOCATION, HotSpotReplacementsUtil'TLAB_END_LOCATION))
    (§ final #_"SnippetInfo" :allocateArrayDynamic (AbstractTemplates''snippet-4* this, NewObjectSnippets, "allocateArrayDynamic", HotSpotReplacementsUtil'MARK_WORD_LOCATION, HotSpotReplacementsUtil'HUB_WRITE_LOCATION, HotSpotReplacementsUtil'TLAB_TOP_LOCATION, HotSpotReplacementsUtil'TLAB_END_LOCATION))
    (§ final #_"SnippetInfo" :allocateInstanceDynamic (AbstractTemplates''snippet-4* this, NewObjectSnippets, "allocateInstanceDynamic", HotSpotReplacementsUtil'MARK_WORD_LOCATION, HotSpotReplacementsUtil'HUB_WRITE_LOCATION, HotSpotReplacementsUtil'TLAB_TOP_LOCATION, HotSpotReplacementsUtil'TLAB_END_LOCATION))

    (§ defn #_"NewObjectTemplates" NewObjectTemplates'new-0 []
        (AbstractTemplates'new-0)
    )

    (§ method! #_"void" NewObjectTemplates''lower-3 [#_"NewObjectTemplates" this, #_"NewInstanceNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"HotSpotResolvedObjectType" type (:instanceClass node)
            #_"Arguments" args (Arguments'new-3 (:allocateInstance this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''addConst-3 args, "size", (#_"HotSpotResolvedObjectType" .instanceSize type))
            (Arguments''add-3 args, "hub", (ConstantNode'forConstant-3 KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass type), (:graph node)))
            (Arguments''add-3 args, "prototypeMarkWord", (#_"HotSpotResolvedObjectType" .prototypeMarkWord type))
            (Arguments''addConst-3 args, "fillContents", (:fillContents node))
            (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
            (Arguments''addConst-3 args, "constantSize", true)
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )

    (§ method! #_"void" NewObjectTemplates''lower-3 [#_"NewObjectTemplates" this, #_"NewArrayNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"HotSpotResolvedObjectType" arrayType (#_"ResolvedJavaType" .getArrayClass (:elementType node))
            #_"JavaKind" elementKind (#_"ResolvedJavaType" .getJavaKind (:elementType node))
            #_"ValueNode" length (AbstractNewArrayNode''length-1 node)
            #_"Arguments" args (Arguments'new-3 (:allocateArray this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "hub", (ConstantNode'forConstant-3 KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass arrayType), (:graph node)))
            (Arguments''add-3 args, "length", (if (Node''isAlive-1 length) length (Graph''addOrUniqueWithInputs-2 (:graph node), length)))
            (Arguments''add-3 args, "prototypeMarkWord", (#_"HotSpotResolvedObjectType" .prototypeMarkWord arrayType))
            (Arguments''addConst-3 args, "headerSize", (HotSpot'arrayBaseOffset-1 elementKind))
            (Arguments''addConst-3 args, "log2ElementSize", (CodeUtil/log2 (HotSpot'arrayIndexScale-1 elementKind)))
            (Arguments''addConst-3 args, "fillContents", (:fillContents node))
            (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
            (Arguments''addConst-3 args, "maybeUnroll", (instance? ConstantNode length))
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )

    (§ method! #_"void" NewObjectTemplates''lower-3 [#_"NewObjectTemplates" this, #_"DynamicNewInstanceNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args (Arguments'new-3 (:allocateInstanceDynamic this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "type", (:class node))
            (Arguments''add-3 args, "classClass", (:classClass node))
            (Arguments''addConst-3 args, "fillContents", (:fillContents node))
            (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )

    (§ defn- #_"HotSpotResolvedObjectType" NewObjectTemplates'lookupArrayClass-2 [#_"LoweringTool" lowerer, #_"JavaKind" kind]
        (#_"ResolvedJavaType" .getArrayClass (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (if (= kind JavaKind/Object) Object (#_"JavaKind" .toJavaClass kind))))
    )

    (§ method! #_"void" NewObjectTemplates''lower-3 [#_"NewObjectTemplates" this, #_"DynamicNewArrayNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" length (AbstractNewArrayNode''length-1 node)
            #_"Arguments" args (Arguments'new-3 (:allocateArrayDynamic this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "elementType", (:elementType node))
            (Arguments''add-3 args, "voidClass", (:voidClass node))
            (Arguments''add-3 args, "length", (if (Node''isAlive-1 length) length (Graph''addOrUniqueWithInputs-2 (:graph node), length)))
            (Arguments''addConst-3 args, "fillContents", (:fillContents node))
            (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
            ;; We use Kind.Illegal as a marker value instead of nil because constant snippet parameters cannot be nil.
            (Arguments''addConst-3 args, "knownElementKind", (if (some? (:knownElementKind node)) (:knownElementKind node) JavaKind/Illegal))
            (Arguments''addConst-3 args, "knownLayoutHelper", (if (some? (:knownElementKind node)) (#_"HotSpotResolvedObjectType" .layoutHelper (NewObjectTemplates'lookupArrayClass-2 lowerer, (:knownElementKind node))) 0))
            (Arguments''add-3 args, "prototypeMarkWord", (#_"HotSpotResolvedObjectType" .prototypeMarkWord (NewObjectTemplates'lookupArrayClass-2 lowerer, JavaKind/Object)))
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )
)

(final-ns ReflectionGetCallerClassNode (§ extends MacroStateSplitNode) (§ implements Canonicalizable, Lowerable)
    (§ def #_"NodeClass<ReflectionGetCallerClassNode>" ReflectionGetCallerClassNode'TYPE (NodeClass'create-1 ReflectionGetCallerClassNode))

    (§ defn #_"ReflectionGetCallerClassNode" ReflectionGetCallerClassNode'new-5* [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode..." arguments]
        (MacroStateSplitNode'new-6* ReflectionGetCallerClassNode'TYPE, invokeKind, targetMethod, bci, returnStamp, arguments)
    )

    #_unused
    (§ override! #_"Node" ReflectionGetCallerClassNode''canonical-2 [#_"ReflectionGetCallerClassNode" this, #_"CanonicalizerTool" tool]
        (or (ReflectionGetCallerClassNode''getCallerClassNode-1 this)
            this
        )
    )

    #_unused
    (§ override! #_"void" ReflectionGetCallerClassNode''lower-2 [#_"ReflectionGetCallerClassNode" this, #_"LoweringTool" lowerer]
        (let [
            #_"ConstantNode" callerClassNode (ReflectionGetCallerClassNode''getCallerClassNode-1 this)
        ]
            (if (some? callerClassNode)
                (§ ass! (:graph this) (Graph''replaceFixedWithFloating-3 (:graph this), this, (Graph''addOrUniqueWithInputs-2 (:graph this), callerClassNode)))
                (let [
                    #_"InvokeNode" invoke (MacroNode''createInvoke-1 this)
                ]
                    (§ ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, invoke))
                    (InvokeNode''lower-2 invoke, lowerer)
                )
            )
        )
        nil
    )

    ;;;
     ; If inlining is deep enough this method returns a ConstantNode of the caller class by walking the stack.
     ;
     ; @return ConstantNode of the caller class, or nil
     ;;
    (§ method- #_"ConstantNode" ReflectionGetCallerClassNode''getCallerClassNode-1 [#_"ReflectionGetCallerClassNode" this]
        ;; Walk back up the frame states to find the caller at the required depth (see JVM_GetCallerClass).
        ;; Start the loop at depth 1, because the current frame state does not include the Reflection.getCallerClass() frame.
        (loop-when [#_"int" n 1 #_"FrameState" state (MacroNode''stateAfter-1 this)] (some? state) => nil ;; let JVM_GetCallerClass do the work
            (let [
                #_"HotSpotResolvedJavaMethod" method (FrameState''getMethod-1 state)
            ]
                (if (< 1 n)
                    (when-not (#_"HotSpotResolvedJavaMethod" .ignoredBySecurityStackWalk method)
                        ;; We have reached the desired frame: return the holder class.
                        (§ return (ConstantNode'forConstant-1 (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"HotSpotResolvedJavaMethod" .getDeclaringClass method))))
                    )
                    ;; Frame 0 and 1 must be caller sensitive (see JVM_GetCallerClass).
                    (when-not (#_"HotSpotResolvedJavaMethod" .isCallerSensitive method)
                        (§ return nil) ;; let JVM_GetCallerClass do the work
                    )
                )
                (recur (inc n) (:outerFrameState state))
            )
        )
    )
)

;;;
 ; The StringToBytesSnippets contains a snippet for lowering StringToBytesNode.
 ;;
(value-ns StringToBytesSnippets (§ implements Snippets)
    (§ def #_"LocationIdentity" StringToBytesSnippets'CSTRING_LOCATION (NamedLocationIdentity'immutable-1 "CString location"))

    ; @Snippet
    #_unused
    (§ defn #_"byte[]" StringToBytesSnippets'transform-1 [#_@ConstantParameter #_"String" compilationTimeString]
        (let [
            #_"int" i (count compilationTimeString)
            #_"byte[]" a (NewArrayNode'newUninitializedArray-2 byte'class, i)
            #_"Word" c (CStringConstant'cstring-1 compilationTimeString)
        ]
            (loop-when-recur [i (dec i)] (<= 0 i) [(dec i)]
                ;; a[i] = c.readByte(i);
                (.putByte HotSpot'unsafe, a, (+ Unsafe'ARRAY_CHAR_BASE_OFFSET i), (Word''readByte-3 c, i, StringToBytesSnippets'CSTRING_LOCATION))
            )
            a
        )
    )
)

;;;
 ; @anno StringToBytesSnippets.StringToBytesTemplates
 ;;
(final-ns StringToBytesTemplates (§ extends AbstractTemplates)
    (§ final #_"SnippetInfo" :create nil)

    (§ defn #_"StringToBytesTemplates" StringToBytesTemplates'new-0 []
        (let [
            #_"StringToBytesTemplates" this (AbstractTemplates'new-0)
            this (assoc this :create (AbstractTemplates''snippet-4* this, StringToBytesSnippets, "transform", (NamedLocationIdentity'getArrayLocation-1 JavaKind/Byte)))
        ]
            this
        )
    )

    (§ method! #_"void" StringToBytesTemplates''lower-3 [#_"StringToBytesTemplates" this, #_"StringToBytesNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args (Arguments'new-3 (:create this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''addConst-3 args, "compilationTimeString", (:value node))
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )
)

;;;
 ; Utilities and common code paths used by the type check snippets.
 ;;
(value-ns TypeCheckSnippetUtils
    (§ defn- #_"KlassPointer" TypeCheckSnippetUtils'loadSecondarySupersElement-2 [#_"Word" metaspaceArray, #_"int" index]
        (KlassPointer'fromWord-1 (Word''readWord-3 metaspaceArray, (+ HotSpot'metaspaceArrayBaseOffset (* index (.wordSize HotSpot'target))), HotSpotReplacementsUtil'SECONDARY_SUPERS_ELEMENT_LOCATION))
    )

    (§ defn- #_"boolean" TypeCheckSnippetUtils'checkSelfAndSupers-2 [#_"KlassPointer" t, #_"KlassPointer" s]
        ;; if (T == S) return true
        (or (KlassPointer''equal-2 s, t)
            ;; if (S.scan_s_s_array(T)) { S.cache = T; return true; }
            (let [
                #_"Word" secondarySupers (MetaspacePointer''readWord-3 s, HotSpot'secondarySupersOffset, HotSpotReplacementsUtil'SECONDARY_SUPERS_LOCATION)
                #_"int" n (Word''readInt-3 secondarySupers, HotSpot'metaspaceArrayLengthOffset, HotSpotReplacementsUtil'METASPACE_ARRAY_LENGTH_LOCATION)
            ]
                (loop-when [#_"int" i 0] (< i n) => false
                    (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_LIKELY_PROBABILITY, (KlassPointer''equal-2 t, (TypeCheckSnippetUtils'loadSecondarySupersElement-2 secondarySupers, i))) => (recur (inc i))
                        (KlassPointer''writeKlassPointer-4 s, HotSpot'secondarySuperCacheOffset, t, HotSpotReplacementsUtil'SECONDARY_SUPER_CACHE_LOCATION)
                        true
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" TypeCheckSnippetUtils'checkSecondarySubType-2 [#_"KlassPointer" t, #_"KlassPointer" sNonNull]
        ;; if (S.cache == T) return true
        (or (KlassPointer''equal-2 (KlassPointer''readKlassPointer-3 sNonNull, HotSpot'secondarySuperCacheOffset, HotSpotReplacementsUtil'SECONDARY_SUPER_CACHE_LOCATION), t)
            (TypeCheckSnippetUtils'checkSelfAndSupers-2 t, sNonNull)
        )
    )

    (§ defn #_"boolean" TypeCheckSnippetUtils'checkUnknownSubType-2 [#_"KlassPointer" t, #_"KlassPointer" sNonNull]
        ;; int off = T.offset
        (let [
            #_"int" superCheckOffset (MetaspacePointer''readInt-3 t, HotSpot'superCheckOffsetOffset, HotSpotReplacementsUtil'KLASS_SUPER_CHECK_OFFSET_LOCATION)
        ]
            ;; if (T = S[off]) return true
            (or (KlassPointer''equal-2 (KlassPointer''readKlassPointer-3 sNonNull, superCheckOffset, HotSpotReplacementsUtil'PRIMARY_SUPERS_LOCATION), t)
                ;; if (off != &cache) return false
                (and (= superCheckOffset HotSpot'secondarySuperCacheOffset)
                    (TypeCheckSnippetUtils'checkSelfAndSupers-2 t, sNonNull)
                )
            )
        )
    )
)

(value-ns UnsafeLoadSnippets (§ implements Snippets)
    ; @Snippet
    #_unused
    (§ defn #_"Object" UnsafeLoadSnippets'lowerUnsafeLoad-2 [#_"Object" object, #_"long" offset]
        (Word''readObject-3 (Word'objectToTrackedPointer-1 (FixedValueAnchorNode'getObject-1 object)), (int offset), (if (and (instance? java.lang.ref.Reference object) (= (HotSpotReplacementsUtil'referentOffset-0) offset)) BarrierType'PRECISE BarrierType'NONE))
    )
)

;;;
 ; @anno UnsafeLoadSnippets.UnsafeLoadTemplates
 ;;
(final-ns UnsafeLoadTemplates (§ extends AbstractTemplates)
    (§ final #_"SnippetInfo" :unsafeLoad (AbstractTemplates''snippet-4* this, UnsafeLoadSnippets, "lowerUnsafeLoad"))

    (§ defn #_"UnsafeLoadTemplates" UnsafeLoadTemplates'new-0 []
        (AbstractTemplates'new-0)
    )

    (§ method! #_"void" UnsafeLoadTemplates''lower-3 [#_"UnsafeLoadTemplates" this, #_"RawLoadNode" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args (Arguments'new-3 (:unsafeLoad this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "object", (:object node))
            (Arguments''add-3 args, "offset", (:offset node))
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )
)

(value-ns WriteBarrierSnippets (§ implements Snippets)
    (§ def #_"LocationIdentity" WriteBarrierSnippets'GC_CARD_LOCATION (NamedLocationIdentity'mutable-1 "GC-Card"))
    (§ def #_"LocationIdentity" WriteBarrierSnippets'GC_LOG_LOCATION (NamedLocationIdentity'mutable-1 "GC-Log"))
    (§ def #_"LocationIdentity" WriteBarrierSnippets'GC_INDEX_LOCATION (NamedLocationIdentity'mutable-1 "GC-Index"))

    (§ defn- #_"void" WriteBarrierSnippets'serialWriteBarrier-1 [#_"Pointer" ptr]
        (let [
            #_"long" startAddress (GraalHotSpotVMConfigNode'cardTableAddress-0)
            #_"Word" base (#_"Pointer" .unsignedShiftRight ptr, HotSpot'cardTableShift)
        ]
            (if (and (= (int startAddress) startAddress) (GraalHotSpotVMConfigNode'isCardTableAddressConstant-0))
                (Word''writeByte-4 base, (int startAddress), (byte 0), WriteBarrierSnippets'GC_CARD_LOCATION)
                (Word''writeByte-4 base, (WordFactory/unsigned startAddress), (byte 0), WriteBarrierSnippets'GC_CARD_LOCATION)
            )
        )
        nil
    )

    ; @Snippet
    #_unused
    (§ defn #_"void" WriteBarrierSnippets'serialImpreciseWriteBarrier-1 [#_"Object" object]
        (WriteBarrierSnippets'serialWriteBarrier-1 (Word'objectToTrackedPointer-1 object))
        nil
    )

    ; @Snippet
    #_unused
    (§ defn #_"void" WriteBarrierSnippets'serialPreciseWriteBarrier-1 [#_"Address" address]
        (WriteBarrierSnippets'serialWriteBarrier-1 (Word'fromAddress-1 address))
        nil
    )

    ; @Snippet
    #_unused
    (§ defn #_"void" WriteBarrierSnippets'serialArrayRangeWriteBarrier-3 [#_"Address" address, #_"int" length, #_@ConstantParameter #_"int" elementStride]
        (when (pos? length)
            (let [
                #_"int" cardShift HotSpot'cardTableShift
                #_"long" cardStart (GraalHotSpotVMConfigNode'cardTableAddress-0)
                #_"long" start (>>> (WriteBarrierSnippets'getPointerToFirstArrayElement-3 address, length, elementStride) cardShift)
                #_"long" end (>>> (WriteBarrierSnippets'getPointerToLastArrayElement-3 address, length, elementStride) cardShift)
            ]
                (loop-when-recur [#_"long" i (- end start)] (<= 0 i) [(dec i)]
                    (DirectStoreNode'storeBoolean-3 (+ start cardStart i), false, JavaKind/Boolean)
                )
            )
        )
        nil
    )

    ; @Snippet
    #_unused
    (§ defn #_"void" WriteBarrierSnippets'g1PreWriteBarrier-6 [#_"Address" address, #_"Object" object, #_"Object" expectedObject, #_@ConstantParameter #_"boolean" doLoad, #_@ConstantParameter #_"boolean" nullCheck, #_@ConstantParameter #_"Register" threadRegister]
        (when nullCheck
            (NullCheckNode'nullCheck-1 address)
        )
        (let [
            #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
            #_"Object" fixedExpectedObject (FixedValueAnchorNode'getObject-1 expectedObject)
            #_"Word" field (Word'fromAddress-1 address)
            #_"Pointer" previousOop (Word'objectToTrackedPointer-1 fixedExpectedObject)
            #_"byte" markingValue (Word''readByte-2 thread, HotSpot'g1SATBQueueMarkingOffset)
            #_"int" gcCycle 0
        ]
            ;; If the concurrent marker is enabled, the barrier is issued.
            (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (not= markingValue (byte 0)))
                ;; If the previous value has to be loaded (before the write), the load is issued.
                ;; The load is always issued except the cases of CAS and referent field.
                (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'LIKELY_PROBABILITY, doLoad)
                    (§ ass previousOop (Word'objectToTrackedPointer-1 (Word''readObject-3 field, 0, BarrierType'NONE)))
                )
                ;; If the previous value is nil the barrier should not be issued.
                (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (#_"Pointer" .notEqual previousOop, 0))
                    ;; If the thread-local SATB buffer is full, issue a native call, which will initialize a new one and add the entry.
                    (let [
                        #_"Word" indexAddress (Word''add-2 thread, HotSpot'g1SATBQueueIndexOffset)
                        #_"Word" indexValue (Word''readWord-2 indexAddress, 0)
                    ]
                        (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (Word''notEqual-2 indexValue, 0))
                            (let [
                                #_"Word" bufferAddress (Word''readWord-2 thread, HotSpot'g1SATBQueueBufferOffset)
                                #_"Word" nextIndex (Word''subtract-2 indexValue, (.wordSize HotSpot'target))
                                #_"Word" logAddress (Word''add-2 bufferAddress, nextIndex)
                            ]
                                ;; Log the object to be marked as well as update the SATB's buffer next index.
                                (Word''writeWord-4 logAddress, 0, previousOop, WriteBarrierSnippets'GC_LOG_LOCATION)
                                (Word''writeWord-4 indexAddress, 0, nextIndex, WriteBarrierSnippets'GC_INDEX_LOCATION)
                            )
                            (WriteBarrierSnippets'g1PreBarrierStub-2 ForeignCallDescriptor'G1WBPRECALL, (#_"Pointer" .toObject previousOop))
                        )
                    )
                )
            )
        )
        nil
    )

    ; @Snippet
    #_unused
    (§ defn #_"void" WriteBarrierSnippets'g1PostWriteBarrier-5 [#_"Address" address, #_"Object" object, #_"Object" value, #_@ConstantParameter #_"boolean" usePrecise, #_@ConstantParameter #_"Register" threadRegister]
        (let [
            #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
            #_"Object" fixedValue (FixedValueAnchorNode'getObject-1 value)
            #_"Pointer" oop (if usePrecise (Word'fromAddress-1 address) (Word'objectToTrackedPointer-1 object))
            #_"int" gcCycle 0
            #_"Pointer" writtenValue (Word'objectToTrackedPointer-1 fixedValue)
            ;; The result of the xor reveals whether the installed pointer crosses heap regions.
            ;; In case it does the write barrier has to be issued.
            #_"UnsignedWord" xorResult (#_"UnsignedWord" .unsignedShiftRight (#_"Pointer" .xor oop, writtenValue), (GraalHotSpotVMConfigNode'logOfHeapRegionGrainBytes-0))
            ;; Calculate the address of the card to be enqueued to the thread local card queue.
            #_"UnsignedWord" cardBase (#_"Pointer" .unsignedShiftRight oop, HotSpot'cardTableShift)
            #_"long" startAddress (GraalHotSpotVMConfigNode'cardTableAddress-0)
            #_"int" displacement 0
        ]
            (if (and (= (int startAddress) startAddress) (GraalHotSpotVMConfigNode'isCardTableAddressConstant-0))
                (§ ass displacement (int startAddress))
                (§ ass cardBase (#_"UnsignedWord" .add cardBase, (WordFactory/unsigned startAddress)))
            )
            (let [
                #_"Word" cardAddress (#_"UnsignedWord" .add cardBase, displacement)
            ]
                (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (#_"UnsignedWord" .notEqual xorResult, 0))
                    ;; If the written value is not nil continue with the barrier addition.
                    (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (#_"Pointer" .notEqual writtenValue, 0))
                        (let [
                            #_"byte" cardByte (Word''readByte-3 cardAddress, 0, WriteBarrierSnippets'GC_CARD_LOCATION)
                        ]
                            ;; If the card is already dirty, (hence already enqueued) skip the insertion.
                            (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (not= cardByte HotSpot'g1YoungCardValue))
                                (MembarNode'memoryBarrier-2 MemoryBarriers/STORE_LOAD, WriteBarrierSnippets'GC_CARD_LOCATION)
                                (let [
                                    #_"byte" cardByteReload (Word''readByte-3 cardAddress, 0, WriteBarrierSnippets'GC_CARD_LOCATION)
                                ]
                                    (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (not= cardByteReload HotSpot'dirtyCardValue))
                                        (Word''writeByte-4 cardAddress, 0, (byte 0), WriteBarrierSnippets'GC_CARD_LOCATION)

                                        ;; If the thread-local card queue is full, issue a native call, which will initialize a new one and add the card entry.
                                        (let [
                                            #_"Word" indexAddress (Word''add-2 thread, HotSpot'g1CardQueueIndexOffset)
                                            #_"Word" indexValue (Word''readWord-2 thread, HotSpot'g1CardQueueIndexOffset)
                                        ]
                                            (if (BranchProbabilityNode'probability-2 BranchProbabilityNode'FREQUENT_PROBABILITY, (Word''notEqual-2 indexValue, 0))
                                                (let [
                                                    #_"Word" bufferAddress (Word''readWord-2 thread, HotSpot'g1CardQueueBufferOffset)
                                                    #_"Word" nextIndex (Word''subtract-2 indexValue, (.wordSize HotSpot'target))
                                                    #_"Word" logAddress (Word''add-2 bufferAddress, nextIndex)
                                                ]
                                                    ;; Log the object to be scanned as well as update the card queue's next index.
                                                    (Word''writeWord-4 logAddress, 0, cardAddress, WriteBarrierSnippets'GC_LOG_LOCATION)
                                                    (Word''writeWord-4 indexAddress, 0, nextIndex, WriteBarrierSnippets'GC_INDEX_LOCATION)
                                                )
                                                (WriteBarrierSnippets'g1PostBarrierStub-2 ForeignCallDescriptor'G1WBPOSTCALL, cardAddress)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ; @Snippet
    #_unused
    (§ defn #_"void" WriteBarrierSnippets'g1ArrayRangePreWriteBarrier-4 [#_"Address" address, #_"int" length, #_@ConstantParameter #_"int" elementStride, #_@ConstantParameter #_"Register" threadRegister]
        (let [
            #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
            #_"byte" markingValue (Word''readByte-2 thread, HotSpot'g1SATBQueueMarkingOffset)
        ]
            ;; return if the concurrent marker is not enabled or the vector length is zero
            (when-not (or (= markingValue (byte 0)) (zero? length))
                (let [
                    #_"Word" bufferAddress (Word''readWord-2 thread, HotSpot'g1SATBQueueBufferOffset)
                    #_"Word" indexAddress (Word''add-2 thread, HotSpot'g1SATBQueueIndexOffset)
                    #_"long" indexValue (#_"WordBase" .rawValue (Word''readWord-2 indexAddress, 0))
                    #_"long" start (WriteBarrierSnippets'getPointerToFirstArrayElement-3 address, length, elementStride)
                    #_"int" scale Unsafe'ARRAY_OBJECT_INDEX_SCALE
                ]
                    (loop-when [indexValue indexValue #_"int" i 0] (< i length)
                        (let [
                            #_"Pointer" oop (Word'objectToTrackedPointer-1 (Word''readObject-3 (WordFactory/pointer (+ start (* i scale))), 0, BarrierType'NONE))
                            indexValue
                                (when (#_"Pointer" .notEqual oop, 0) => indexValue
                                    (if (zero? indexValue)
                                        (do
                                            (WriteBarrierSnippets'g1PreBarrierStub-2 ForeignCallDescriptor'G1WBPRECALL, (#_"Pointer" .toObject oop))
                                            indexValue
                                        )
                                        (let [
                                            indexValue (- indexValue (.wordSize HotSpot'target))
                                            #_"Word" logAddress (Word''add-2 bufferAddress, (WordFactory/unsigned indexValue))
                                        ]
                                            ;; Log the object to be marked as well as update the SATB's buffer next index.
                                            (Word''writeWord-4 logAddress, 0, oop, WriteBarrierSnippets'GC_LOG_LOCATION)
                                            (Word''writeWord-4 indexAddress, 0, (WordFactory/unsigned indexValue), WriteBarrierSnippets'GC_INDEX_LOCATION)
                                            indexValue
                                        )
                                    )
                                )
                        ]
                            (recur indexValue (inc i))
                        )
                    )
                )
            )
        )
        nil
    )

    ; @Snippet
    #_unused
    (§ defn #_"void" WriteBarrierSnippets'g1ArrayRangePostWriteBarrier-4 [#_"Address" address, #_"int" length, #_@ConstantParameter #_"int" elementStride, #_@ConstantParameter #_"Register" threadRegister]
        (when (pos? length)
            (let [
                #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
                #_"Word" bufferAddress (Word''readWord-2 thread, HotSpot'g1CardQueueBufferOffset)
                #_"Word" indexAddress (Word''add-2 thread, HotSpot'g1CardQueueIndexOffset)
                #_"long" indexValue (#_"WordBase" .rawValue (Word''readWord-2 thread, HotSpot'g1CardQueueIndexOffset))
                #_"long" cardStart (GraalHotSpotVMConfigNode'cardTableAddress-0)
                #_"long" start (>>> (WriteBarrierSnippets'getPointerToFirstArrayElement-3 address, length, elementStride) HotSpot'cardTableShift)
                #_"long" end (>>> (WriteBarrierSnippets'getPointerToLastArrayElement-3 address, length, elementStride) HotSpot'cardTableShift)
            ]
                (loop-when [indexValue indexValue #_"long" i (- end start)] (<= 0 i)
                    (let [
                        #_"Word" cardAddress (WordFactory/unsigned (+ start cardStart i))
                        #_"byte" cardByte (Word''readByte-3 cardAddress, 0, WriteBarrierSnippets'GC_CARD_LOCATION)
                        indexValue
                            ;; If the card is already dirty, (hence already enqueued) skip the insertion.
                            (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (not= cardByte HotSpot'g1YoungCardValue)) => indexValue
                                (MembarNode'memoryBarrier-2 MemoryBarriers/STORE_LOAD, WriteBarrierSnippets'GC_CARD_LOCATION)
                                (let [
                                    #_"byte" cardByteReload (Word''readByte-3 cardAddress, 0, WriteBarrierSnippets'GC_CARD_LOCATION)
                                ]
                                    (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'NOT_FREQUENT_PROBABILITY, (not= cardByteReload HotSpot'dirtyCardValue)) => indexValue
                                        (Word''writeByte-4 cardAddress, 0, (byte 0), WriteBarrierSnippets'GC_CARD_LOCATION)
                                        ;; If the thread local card queue is full, issue a native call which will initialize
                                        ;; a new one and add the card entry.
                                        (if (zero? indexValue)
                                            (do
                                                (WriteBarrierSnippets'g1PostBarrierStub-2 ForeignCallDescriptor'G1WBPOSTCALL, cardAddress)
                                                indexValue
                                            )
                                            (let [
                                                indexValue (- indexValue (.wordSize HotSpot'target))
                                                #_"Word" logAddress (Word''add-2 bufferAddress, (WordFactory/unsigned indexValue))
                                            ]
                                                ;; Log the object to be scanned as well as update the card queue's next index.
                                                (Word''writeWord-4 logAddress, 0, cardAddress, WriteBarrierSnippets'GC_LOG_LOCATION)
                                                (Word''writeWord-4 indexAddress, 0, (WordFactory/unsigned indexValue), WriteBarrierSnippets'GC_INDEX_LOCATION)
                                                indexValue
                                            )
                                        )
                                    )
                                )
                            )
                    ]
                        (recur indexValue (dec i))
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"long" WriteBarrierSnippets'getPointerToFirstArrayElement-3 [#_"Address" address, #_"int" length, #_"int" elementStride]
        (let [
            #_"long" result (Word''rawValue-1 (Word'fromAddress-1 address))
        ]
            (if (neg? elementStride) ;; the address points to the place after the last array element
                (+ result (* elementStride length))
                result
            )
        )
    )

    (§ defn- #_"long" WriteBarrierSnippets'getPointerToLastArrayElement-3 [#_"Address" address, #_"int" length, #_"int" elementStride]
        (let [
            #_"long" result (Word''rawValue-1 (Word'fromAddress-1 address))
        ]
            (if (neg? elementStride) ;; the address points to the place after the last array element
                (+ result elementStride)
                (+ result (* (dec length) elementStride))
            )
        )
    )

    ; @NodeIntrinsic(ForeignCallNode.class)
    (§ native- #_"void" WriteBarrierSnippets'g1PreBarrierStub-2 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" descriptor, #_"Object" object])

    ; @NodeIntrinsic(ForeignCallNode.class)
    (§ native #_"void" WriteBarrierSnippets'g1PostBarrierStub-2 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" descriptor, #_"Word" card])
)

;;;
 ; @anno WriteBarrierSnippets.WriteBarrierTemplates
 ;;
(final-ns WriteBarrierTemplates (§ extends AbstractTemplates)
    (§ final #_"SnippetInfo" :serialImpreciseWriteBarrier (AbstractTemplates''snippet-4* this, WriteBarrierSnippets, "serialImpreciseWriteBarrier", WriteBarrierSnippets'GC_CARD_LOCATION))
    (§ final #_"SnippetInfo" :serialPreciseWriteBarrier (AbstractTemplates''snippet-4* this, WriteBarrierSnippets, "serialPreciseWriteBarrier", WriteBarrierSnippets'GC_CARD_LOCATION))
    (§ final #_"SnippetInfo" :serialArrayRangeWriteBarrier (AbstractTemplates''snippet-4* this, WriteBarrierSnippets, "serialArrayRangeWriteBarrier"))
    (§ final #_"SnippetInfo" :g1PreWriteBarrier (AbstractTemplates''snippet-4* this, WriteBarrierSnippets, "g1PreWriteBarrier", WriteBarrierSnippets'GC_INDEX_LOCATION, WriteBarrierSnippets'GC_LOG_LOCATION))
    (§ final #_"SnippetInfo" :g1ReferentReadBarrier (AbstractTemplates''snippet-4* this, WriteBarrierSnippets, "g1PreWriteBarrier", WriteBarrierSnippets'GC_INDEX_LOCATION, WriteBarrierSnippets'GC_LOG_LOCATION))
    (§ final #_"SnippetInfo" :g1PostWriteBarrier (AbstractTemplates''snippet-4* this, WriteBarrierSnippets, "g1PostWriteBarrier", WriteBarrierSnippets'GC_CARD_LOCATION, WriteBarrierSnippets'GC_INDEX_LOCATION, WriteBarrierSnippets'GC_LOG_LOCATION))
    (§ final #_"SnippetInfo" :g1ArrayRangePreWriteBarrier (AbstractTemplates''snippet-4* this, WriteBarrierSnippets, "g1ArrayRangePreWriteBarrier", WriteBarrierSnippets'GC_INDEX_LOCATION, WriteBarrierSnippets'GC_LOG_LOCATION))
    (§ final #_"SnippetInfo" :g1ArrayRangePostWriteBarrier (AbstractTemplates''snippet-4* this, WriteBarrierSnippets, "g1ArrayRangePostWriteBarrier", WriteBarrierSnippets'GC_CARD_LOCATION, WriteBarrierSnippets'GC_INDEX_LOCATION, WriteBarrierSnippets'GC_LOG_LOCATION))

    (§ final #_"CompressEncoding" :oopEncoding nil)

    (§ defn #_"WriteBarrierTemplates" WriteBarrierTemplates'new-1 [#_"CompressEncoding" oopEncoding]
        (let [
            #_"WriteBarrierTemplates" this (AbstractTemplates'new-0)
            this (assoc this :oopEncoding oopEncoding)
        ]
            this
        )
    )

    (§ method! #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"SerialWriteBarrier" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args
                (if (:precise? node)
                    (let [
                        args (Arguments'new-3 (:serialPreciseWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
                    ]
                        (Arguments''add-3 args, "address", (:address node))
                        args
                    )
                    (let [
                        args (Arguments'new-3 (:serialImpreciseWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
                    ]
                        (Arguments''add-3 args, "object", (OffsetAddressNode''getBase-1 (:address node)))
                        args
                    )
                )
        ]
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )

    (§ method! #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"SerialArrayRangeWriteBarrier" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args (Arguments'new-3 (:serialArrayRangeWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "address", (ArrayRangeWriteBarrier''getAddress-1 node))
            (Arguments''add-3 args, "length", (ArrayRangeWriteBarrier''getLength-1 node))
            (Arguments''addConst-3 args, "elementStride", (ArrayRangeWriteBarrier''getElementStride-1 node))
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )

    (§ method! #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"G1PreWriteBarrier" node, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" expected (:value node)
            expected
                (when (and (some? expected) (instance? NarrowOopStamp (:stamp expected))) => expected
                    (HotSpotCompressionNode'uncompress-2 expected, (:oopEncoding this))
                )
            #_"Arguments" args (Arguments'new-3 (:g1PreWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "address", (:address node))
            (Arguments''add-3 args, "object", (when (instance? OffsetAddressNode (:address node)) (OffsetAddressNode''getBase-1 (:address node))))
            (Arguments''add-3 args, "expectedObject", expected)
            (Arguments''addConst-3 args, "doLoad", (:doLoad node))
            (Arguments''addConst-3 args, "nullCheck", (:nullCheck node))
            (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )

    (§ method! #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"G1ReferentFieldReadBarrier" node, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" expected (G1ReferentFieldReadBarrier''getExpectedObject-1 node)
            expected
                (when (and (some? expected) (instance? NarrowOopStamp (:stamp expected))) => expected
                    (HotSpotCompressionNode'uncompress-2 expected, (:oopEncoding this))
                )
            #_"Arguments" args (Arguments'new-3 (:g1ReferentReadBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "address", (:address node))
            (Arguments''add-3 args, "object", (when (instance? OffsetAddressNode (:address node)) (OffsetAddressNode''getBase-1 (:address node))))
            (Arguments''add-3 args, "expectedObject", expected)
            (Arguments''addConst-3 args, "doLoad", (:doLoad node))
            (Arguments''addConst-3 args, "nullCheck", false)
            (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )

    (§ method! #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"G1PostWriteBarrier" node, #_"LoweringTool" lowerer]
        (when-not (:always-nil? node) => (Graph''removeFixed-2 (:graph node), node)
            (let [
                #_"ValueNode" value
                    (when (instance? NarrowOopStamp (:stamp (:value node))) => (:value node)
                        (HotSpotCompressionNode'uncompress-2 (:value node), (:oopEncoding this))
                    )
                #_"Arguments" args (Arguments'new-3 (:g1PostWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
            ]
                (Arguments''add-3 args, "address", (:address node))
                (Arguments''add-3 args, "object", (when (instance? OffsetAddressNode (:address node)) (OffsetAddressNode''getBase-1 (:address node))))
                (Arguments''add-3 args, "value", value)
                (Arguments''addConst-3 args, "usePrecise", (:precise? node))
                (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
                (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
            )
        )
        nil
    )

    (§ method! #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"G1ArrayRangePreWriteBarrier" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args (Arguments'new-3 (:g1ArrayRangePreWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "address", (ArrayRangeWriteBarrier''getAddress-1 node))
            (Arguments''add-3 args, "length", (ArrayRangeWriteBarrier''getLength-1 node))
            (Arguments''addConst-3 args, "elementStride", (ArrayRangeWriteBarrier''getElementStride-1 node))
            (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )

    (§ method! #_"void" WriteBarrierTemplates''lower-3 [#_"WriteBarrierTemplates" this, #_"G1ArrayRangePostWriteBarrier" node, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args (Arguments'new-3 (:g1ArrayRangePostWriteBarrier this), (:guardsStage (:graph node)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "address", (ArrayRangeWriteBarrier''getAddress-1 node))
            (Arguments''add-3 args, "length", (ArrayRangeWriteBarrier''getLength-1 node))
            (Arguments''addConst-3 args, "elementStride", (ArrayRangeWriteBarrier''getElementStride-1 node))
            (Arguments''addConst-3 args, "threadRegister", HotSpot'threadRegister)
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, node), node, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )
)

;;;
 ; A {@linkplain #getGraph generated} stub for a {@link Transition non-leaf} foreign call from compiled code.
 ; A stub is required for such calls as the caller may be scheduled for deoptimization while the call is in progress.
 ; And since these are foreign/runtime calls on slow paths, we don't want to force the register allocator to spill
 ; around the call. As such, this stub saves and restores all allocatable registers.
 ; It also {@linkplain StubUtil#handlePendingException(Word, boolean) handles} any exceptions raised during the foreign call.
 ;;
(final-ns ForeignCallStub (§ extends Stub)
    ;;;
     ; Linkage target for the call from this stub.
     ;;
    (§ final #_"ForeignCallLinkage" :target nil)

    ;;;
     ; Specifies if the JavaThread value for the current thread is to be prepended to the arguments for the call to #target.
     ;;
    (§ final #_"boolean" :prependThread false)

    ;;;
     ; Creates a stub for a call to code at a given address.
     ;
     ; @param address the address of the code to call
     ; @param descriptor the signature of the call to this stub
     ; @param prependThread true if the JavaThread value for the current thread is to be prepended
     ;            to the arguments for the call to {@code address}
     ; @param reexecutable specifies if the stub call can be re-executed without (meaningful) side effects.
     ;            Deoptimization will not return to a point before a stub call that cannot be re-executed.
     ; @param killedLocations the memory locations killed by the stub call
     ;;
    (§ defn #_"ForeignCallStub" ForeignCallStub'new-6* [#_"long" address, #_"ForeignCallDescriptor" descriptor, #_"boolean" prependThread, #_"Transition" transition, #_"boolean" reexecutable, #_"LocationIdentity..." killedLocations]
        (let [
            #_"ForeignCallStub" this (Stub'new-1 (ForeignCallLinkage'create-8* descriptor, 0, RegisterEffect'PRESERVES_REGISTERS, HotSpotCallingConventionType/JavaCall, HotSpotCallingConventionType/JavaCallee, transition, reexecutable, killedLocations))
            this (assoc this :prependThread prependThread)
            #_"Class[]" targetParameterTypes (ForeignCallStub''createTargetParameters-2 this, descriptor)
            #_"ForeignCallDescriptor" targetSig (ForeignCallDescriptor'new-3* (str (:name descriptor) ":C"), (:resultType descriptor), targetParameterTypes)
            this (assoc this :target (ForeignCallLinkage'create-8* targetSig, address, RegisterEffect'DESTROYS_REGISTERS, HotSpotCallingConventionType/NativeCall, HotSpotCallingConventionType/NativeCall, transition, reexecutable, killedLocations))
        ]
            this
        )
    )

    (§ method- #_"Class[]" ForeignCallStub''createTargetParameters-2 [#_"ForeignCallStub" this, #_"ForeignCallDescriptor" descriptor]
        (let [
            #_"Class[]" parameters (#_"Object" .clone (:argumentTypes descriptor))
        ]
            (when (:prependThread this) => parameters
                (let [
                    #_"Class[]" a (make-array Class (inc (count parameters)))
                ]
                    (System/arraycopy parameters, 0, a, 1, (count parameters))
                    (aset a 0 Word)
                    a
                )
            )
        )
    )

    ;;;
     ; Creates a graph for this stub.
     ;
     ; If the stub returns an object, the graph created corresponds to this pseudo code:
     ;
     ;     Object foreignFunctionStub(args...) {
     ;         foreignFunction(currentThread,  args);
     ;         if (clearPendingException(thread())) {
     ;             getAndClearObjectResult(thread());
     ;             DeoptimizeCallerNode.deopt(InvalidateReprofile, RuntimeConstraint);
     ;         }
     ;         return getAndClearObjectResult(thread());
     ;     }
     ;
     ; If the stub returns a primitive or word, the graph created corresponds to this pseudo code
     ; (using {@code int} as the primitive return type):
     ;
     ;     int foreignFunctionStub(args...) {
     ;         int result = foreignFunction(currentThread,  args);
     ;         if (clearPendingException(thread())) {
     ;             DeoptimizeCallerNode.deopt(InvalidateReprofile, RuntimeConstraint);
     ;         }
     ;         return result;
     ;     }
     ;
     ; If the stub is void, the graph created corresponds to this pseudo code:
     ;
     ;     void foreignFunctionStub(args...) {
     ;         foreignFunction(currentThread,  args);
     ;         if (clearPendingException(thread())) {
     ;             DeoptimizeCallerNode.deopt(InvalidateReprofile, RuntimeConstraint);
     ;         }
     ;     }
     ;
     ; In each example above, the {@code currentThread} argument is the C++ JavaThread value
     ; (i.e. %r15 on AMD64) and is only prepended if #prependThread is true.
     ;;
    #_unused
    (§ override! #_"Graph" ForeignCallStub''getStubGraph-1 [#_"ForeignCallStub" this]
        (let [
            #_"Class[]" args (#_"Object" .clone (:argumentTypes (:descriptor (:linkage this))))
            #_"boolean" isObjectResult (not (LIRKind'isValue-1 (#_"CallingConvention" .getReturn (:outgoingCallingConvention (:linkage this)))))
            #_"ResolvedJavaMethod" thisMethod (#_"MetaAccessProvider" .lookupJavaMethod HotSpot'metaAccess, (#_"Class" .getDeclaredMethod ForeignCallStub, "getStubGraph"))
            #_"GraphKit" kit (GraphKit'new-1 thisMethod)
            #_"ParameterNode[]" params (ForeignCallStub''createParameters-3 this, kit, args)
            #_"ReadRegisterNode" thread (GraphKit''append-2 kit, (ReadRegisterNode'new-4 HotSpot'threadRegister, WordTypes'wordKind, true, false))
            #_"ValueNode" result (ForeignCallStub''createTargetCall-4 this, kit, params, thread)
            _ (GraphKit''createInvoke-4* kit, StubUtil, "handlePendingException", thread, (ConstantNode'forBoolean-2 isObjectResult, (:graph kit)))
            result
                (when isObjectResult => result
                    (GraphKit''createInvoke-4* kit, HotSpotReplacementsUtil, "getAndClearObjectResult", thread)
                )
        ]
            (GraphKit''append-2 kit, (ReturnNode'new-1 (when-not (= (:resultType (:descriptor (:linkage this))) void'class) result)))
            (GraphKit''inlineInvokes-1 kit)
            (Phase''apply-2 (RemoveValueProxyPhase'new-0), (:graph kit))

            (:graph kit)
        )
    )

    (§ method- #_"ParameterNode[]" ForeignCallStub''createParameters-3 [#_"ForeignCallStub" this, #_"GraphKit" kit, #_"Class[]" args]
        (let [
            #_"ParameterNode[]" params (make-array ParameterNode (count args))
            #_"ResolvedJavaType" accessingClass (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (#_"Object" .getClass this))
        ]
            (dotimes [#_"int" i (count args)]
                (let [
                    #_"ResolvedJavaType" type (#_"ResolvedJavaType" .resolve (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (nth args i)), accessingClass)
                    #_"StampPair" stamp (StampFactory'forDeclaredType-2 type, false)
                ]
                    (aset params i (GraphKit''unique-2 kit, (ParameterNode'new-2 i, stamp)))
                )
            )
            params
        )
    )

    (§ method- #_"StubForeignCallNode" ForeignCallStub''createTargetCall-4 [#_"ForeignCallStub" this, #_"GraphKit" kit, #_"ParameterNode[]" params, #_"ReadRegisterNode" thread]
        (let [
            #_"Stamp" stamp (StampFactory'forKind-1 (JavaKind/fromJavaClass (:resultType (:descriptor (:target this)))))
            params
                (when (:prependThread this) => params
                    (let [
                        #_"ValueNode[]" a (make-array ValueNode (inc (count params)))
                    ]
                        (aset a 0 thread)
                        (System/arraycopy params, 0, a, 1, (count params))
                        a
                    )
                )
        ]
            (GraphKit''append-2 kit, (StubForeignCallNode'new-3* stamp, (:descriptor (:target this)), params))
        )
    )
)

;;;
 ; Stub implementing the fast path for TLAB refill during instance class allocation. This stub is
 ; called from the inline allocation code when TLAB allocation fails.
 ; If this stub fails to refill the TLAB or allocate the object, it calls out to the HotSpot C++
 ; runtime to complete the allocation.
 ;;
(final-ns NewArrayStub (§ extends SnippetStub)
    (§ defn #_"NewArrayStub" NewArrayStub'new-1 [#_"ForeignCallLinkage" linkage]
        (SnippetStub'new-2 "newArray", linkage)
    )

    #_unused
    (§ override! #_"Object[]" NewArrayStub''makeConstArgs-1 [#_"NewArrayStub" this]
        (let [
            #_"HotSpotResolvedObjectType" intArrayType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, int*'class)
            #_"int" count (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature (:method this)), false)
            #_"Object[]" args (make-array Object count)
        ]
            (aset args 3 (ConstantNode'forConstant-2 KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass intArrayType)))
            (aset args 4 HotSpot'threadRegister)
            args
        )
    )

    ;;;
     ; Re-attempts allocation after an initial TLAB allocation failed or was skipped (e.g. due to -XX:-UseTLAB).
     ;
     ; @param hub the hub of the object to be allocated
     ; @param length the length of the array
     ; @param fillContents Should the array be filled with zeroes?
     ; @param intArrayHub the hub for {@code int[].class}
     ;;
    ; @Snippet
    #_unused
    (§ defn- #_"Object" NewArrayStub'newArray-5 [#_"KlassPointer" hub, #_"int" length, #_"boolean" fillContents, #_@ConstantParameter #_"KlassPointer" intArrayHub, #_@ConstantParameter #_"Register" threadRegister]
        (let [
            #_"int" layoutHelper (HotSpotReplacementsUtil'readLayoutHelper-1 hub)
            #_"int" log2ElementSize (& (>> layoutHelper HotSpot'layoutHelperLog2ElementSizeShift) HotSpot'layoutHelperLog2ElementSizeMask)
            #_"int" headerSize (& (>> layoutHelper HotSpot'layoutHelperHeaderSizeShift) HotSpot'layoutHelperHeaderSizeMask)
            #_"int" elementKind (& (>> layoutHelper HotSpot'layoutHelperElementTypeShift) HotSpot'layoutHelperElementTypeMask)
            #_"int" sizeInBytes (HotSpotReplacementsUtil'arrayAllocationSize-3 length, headerSize, log2ElementSize)
            ;; check that array length is small enough for fast path.
            #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
        ]
            (when (and (GraalHotSpotVMConfigNode'inlineContiguousAllocationSupported-0) (<= 0 length) (<= length NewObjectSnippets'MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH))
                (let [
                    #_"Word" memory (NewInstanceStub'refillAllocate-3 thread, intArrayHub, sizeInBytes)
                ]
                    (when (Word''notEqual-2 memory, 0)
                        (§ return (NewObjectSnippets'formatArray-8 hub, sizeInBytes, length, headerSize, memory, (WordFactory/unsigned HotSpot'arrayPrototypeMarkWord), fillContents, false))
                    )
                )
            )

            (NewArrayStub'newArrayC-4 ForeignCallDescriptor'NEW_ARRAY_C, thread, hub, length)
            (when (some? (HotSpotReplacementsUtil'clearPendingException-1 thread))
                (HotSpotReplacementsUtil'getAndClearObjectResult-1 thread)
                (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
            )
            (HotSpotReplacementsUtil'getAndClearObjectResult-1 thread)
        )
    )

    ; @NodeIntrinsic(StubForeignCallNode.class)
    (§ native #_"void" NewArrayStub'newArrayC-4 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" newArrayC, #_"Word" thread, #_"KlassPointer" hub, #_"int" length])
)

;;;
 ; Stub implementing the fast path for TLAB refill during instance class allocation. This stub is
 ; called from the inline allocation code when TLAB allocation fails.
 ; If this stub fails to refill the TLAB or allocate the object, it calls out to the HotSpot C++
 ; runtime for to complete the allocation.
 ;;
(final-ns NewInstanceStub (§ extends SnippetStub)
    (§ defn #_"NewInstanceStub" NewInstanceStub'new-1 [#_"ForeignCallLinkage" linkage]
        (SnippetStub'new-2 "newInstance", linkage)
    )

    #_unused
    (§ override! #_"Object[]" NewInstanceStub''makeConstArgs-1 [#_"NewInstanceStub" this]
        (let [
            #_"HotSpotResolvedObjectType" intArrayType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, int*'class)
            #_"int" count (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature (:method this)), false)
            #_"Object[]" args (make-array Object count)
        ]
            (aset args 1 (ConstantNode'forConstant-2 KlassPointerStamp'KLASS_NON_NULL, (#_"HotSpotResolvedObjectType" .klass intArrayType)))
            (aset args 2 HotSpot'threadRegister)
            args
        )
    )

    (§ defn- #_"Word" NewInstanceStub'allocate-2 [#_"Word" thread, #_"int" size]
        (let [
            #_"Word" top (HotSpotReplacementsUtil'readTlabTop-1 thread)
            #_"Word" end (HotSpotReplacementsUtil'readTlabEnd-1 thread)
            #_"Word" newTop (Word''add-2 top, size)
        ]
            ;; this check might lead to problems if the TLAB is within 16GB of the address space end (checked in C++ code)
            (when (BranchProbabilityNode'probability-2 BranchProbabilityNode'FAST_PATH_PROBABILITY, (Word''belowOrEqual-2 newTop, end)) => (WordFactory/zero)
                (HotSpotReplacementsUtil'writeTlabTop-2 thread, newTop)
                top
            )
        )
    )

    ;;;
     ; Re-attempts allocation after an initial TLAB allocation failed or was skipped (e.g. due to -XX:-UseTLAB).
     ;
     ; @param hub the hub of the object to be allocated
     ; @param intArrayHub the hub for {@code int[].class}
     ;;
    ; @Snippet
    #_unused
    (§ defn- #_"Object" NewInstanceStub'newInstance-3 [#_"KlassPointer" hub, #_@ConstantParameter #_"KlassPointer" intArrayHub, #_@ConstantParameter #_"Register" threadRegister]
        ;; The type is known to be an instance so Klass::_layout_helper is the instance size as a raw number.
        (let [
            #_"Word" thread (HotSpotReplacementsUtil'registerAsWord-1 threadRegister)
        ]
            (when (and (GraalHotSpotVMConfigNode'inlineContiguousAllocationSupported-0) (HotSpotReplacementsUtil'isInstanceKlassFullyInitialized-1 hub))
                (let [
                    #_"int" size (HotSpotReplacementsUtil'readLayoutHelper-1 hub)
                    #_"Word" memory (NewInstanceStub'refillAllocate-3 thread, intArrayHub, size)
                ]
                    (when (Word''notEqual-2 memory, 0)
                        (NewObjectSnippets'formatObjectForStub-4 hub, size, memory, (MetaspacePointer''readWord-3 hub, HotSpot'prototypeMarkWordOffset, HotSpotReplacementsUtil'PROTOTYPE_MARK_WORD_LOCATION))
                        (§ return (Word''toObject-1 memory))
                    )
                )
            )

            (NewInstanceStub'newInstanceC-3 ForeignCallDescriptor'NEW_INSTANCE_C, thread, hub)
            (when (some? (HotSpotReplacementsUtil'clearPendingException-1 thread))
                (HotSpotReplacementsUtil'getAndClearObjectResult-1 thread)
                (DeoptimizeCallerNode'deopt-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint)
            )
            (HotSpotReplacementsUtil'getAndClearObjectResult-1 thread)
        )
    )

    ;;;
     ; Attempts to refill the current thread's TLAB and retries the allocation.
     ;
     ; @param intArrayHub the hub for {@code int[].class}
     ; @param sizeInBytes the size of the allocation
     ;
     ; @return the newly allocated, uninitialized chunk of memory,
     ;         or WordFactory#zero() if the operation was unsuccessful
     ;;
    (§ defn #_"Word" NewInstanceStub'refillAllocate-3 [#_"Word" thread, #_"KlassPointer" intArrayHub, #_"int" sizeInBytes]
        ;; If G1 is enabled, the "eden" allocation space is not the same always
        ;; and therefore we have to go to slowpath to allocate a new TLAB.
        (cond
            HotSpot'useG1GC       (WordFactory/zero)
            (not HotSpot'useTLAB) (NewInstanceStub'edenAllocate-1 (WordFactory/unsigned sizeInBytes))
            :else
                (let [
                    #_"Word" intArrayMarkWord (WordFactory/unsigned HotSpot'tlabIntArrayMarkWord)
                    #_"int" alignmentReserveInBytes (* HotSpot'tlabAlignmentReserve (.wordSize HotSpot'target))
                    #_"Word" top (HotSpotReplacementsUtil'readTlabTop-1 thread)
                    #_"Word" end (HotSpotReplacementsUtil'readTlabEnd-1 thread)
                    ;; calculate amount of free space
                    #_"long" tlabFreeSpaceInBytes (Word''rawValue-1 (Word''subtract-2 end, top))
                    #_"long" tlabFreeSpaceInWords (>>> tlabFreeSpaceInBytes (CodeUtil/log2 (.wordSize HotSpot'target)))
                    ;; retain TLAB and allocate object in shared space if the amount free in the TLAB is too large to discard
                    #_"Word" refillWasteLimit (Word''readWord-3 thread, HotSpot'tlabRefillWasteLimitOffset, HotSpotReplacementsUtil'TLAB_REFILL_WASTE_LIMIT_LOCATION)
                ]
                    (if (<= tlabFreeSpaceInWords (Word''rawValue-1 refillWasteLimit))
                        (do
                            (when HotSpot'tlabStats
                                ;; increment number of refills
                                (Word''writeInt-4 thread, HotSpot'tlabNumberOfRefillsOffset, (inc (Word''readInt-3 thread, HotSpot'tlabNumberOfRefillsOffset, HotSpotReplacementsUtil'TLAB_NOF_REFILLS_LOCATION)), HotSpotReplacementsUtil'TLAB_NOF_REFILLS_LOCATION)
                                ;; accumulate wastage
                                (let [
                                    #_"int" wastage (+ (Word''readInt-3 thread, HotSpot'tlabFastRefillWasteOffset, HotSpotReplacementsUtil'TLAB_FAST_REFILL_WASTE_LOCATION) (int tlabFreeSpaceInWords))
                                ]
                                    (Word''writeInt-4 thread, HotSpot'tlabFastRefillWasteOffset, wastage, HotSpotReplacementsUtil'TLAB_FAST_REFILL_WASTE_LOCATION)
                                )
                            )

                            ;; if TLAB is currently allocated (top or end != nil), then fill (top ... end + alignment_reserve) with array object
                            (when (Word''notEqual-2 top, 0)
                                (let [
                                    #_"int" headerSize Unsafe'ARRAY_INT_BASE_OFFSET
                                    ;; just like the HotSpot assembler stubs, assumes that tlabFreeSpaceInInts fits in an int
                                    #_"int" tlabFreeSpaceInInts (>>> (int tlabFreeSpaceInBytes) 2)
                                    #_"int" length (+ (>>> (- alignmentReserveInBytes headerSize) 2) tlabFreeSpaceInInts)
                                ]
                                    (NewObjectSnippets'formatArray-8 intArrayHub, 0, length, headerSize, top, intArrayMarkWord, false, false)

                                    (let [
                                        #_"long" allocated (+ (Word''readLong-3 thread, HotSpot'threadAllocatedBytesOffset, HotSpotReplacementsUtil'TLAB_THREAD_ALLOCATED_BYTES_LOCATION) (Word''rawValue-1 (Word''subtract-2 top, (HotSpotReplacementsUtil'readTlabStart-1 thread))))
                                    ]
                                        (Word''writeLong-4 thread, HotSpot'threadAllocatedBytesOffset, allocated, HotSpotReplacementsUtil'TLAB_THREAD_ALLOCATED_BYTES_LOCATION)
                                    )
                                )
                            )

                            ;; refill the TLAB with an eden allocation
                            (let [
                                #_"Word" tlabRefillSizeInWords (Word''readWord-3 thread, HotSpot'threadTlabSizeOffset, HotSpotReplacementsUtil'TLAB_SIZE_LOCATION)
                                #_"Word" tlabRefillSizeInBytes (Word''multiply-2 tlabRefillSizeInWords, (.wordSize HotSpot'target))
                            ]
                                ;; allocate new TLAB, address returned in top
                                (§ ass top (NewInstanceStub'edenAllocate-1 tlabRefillSizeInBytes))
                                (if (Word''notEqual-2 top, 0)
                                    (do
                                        (§ ass end (Word''add-2 top, (Word''subtract-2 tlabRefillSizeInBytes, alignmentReserveInBytes)))
                                        (HotSpotReplacementsUtil'initializeTlab-3 thread, top, end)

                                        (NewInstanceStub'allocate-2 thread, sizeInBytes)
                                    )
                                    (WordFactory/zero)
                                )
                            )
                        )
                        ;; retain TLAB
                        (let [
                            #_"Word" newRefillWasteLimit (Word''add-2 refillWasteLimit, HotSpot'tlabRefillWasteIncrement)
                        ]
                            (Word''writeWord-4 thread, HotSpot'tlabRefillWasteLimitOffset, newRefillWasteLimit, HotSpotReplacementsUtil'TLAB_REFILL_WASTE_LIMIT_LOCATION)

                            (when HotSpot'tlabStats
                                (Word''writeInt-4 thread, HotSpot'tlabSlowAllocationsOffset, (inc (Word''readInt-3 thread, HotSpot'tlabSlowAllocationsOffset, HotSpotReplacementsUtil'TLAB_SLOW_ALLOCATIONS_LOCATION)), HotSpotReplacementsUtil'TLAB_SLOW_ALLOCATIONS_LOCATION)
                            )

                            (NewInstanceStub'edenAllocate-1 (WordFactory/unsigned sizeInBytes))
                        )
                    )
                )
        )
    )

    ;;;
     ; Attempts to allocate a chunk of memory from Eden space.
     ;
     ; @param sizeInBytes the size of the chunk to allocate
     ; @return the allocated chunk or WordFactory#zero() if allocation fails
     ;;
    (§ defn #_"Word" NewInstanceStub'edenAllocate-1 [#_"Word" sizeInBytes]
        (let [
            #_"Word" heapTopAddress (WordFactory/unsigned (GraalHotSpotVMConfigNode'heapTopAddress-0))
            #_"Word" heapEndAddress (WordFactory/unsigned (GraalHotSpotVMConfigNode'heapEndAddress-0))
        ]
            (loop []
                (let [
                    #_"Word" heapTop (Word''readWord-3 heapTopAddress, 0, HotSpotReplacementsUtil'HEAP_TOP_LOCATION)
                    #_"Word" newHeapTop (Word''add-2 heapTop, sizeInBytes)
                ]
                    (if (Word''belowOrEqual-2 newHeapTop, heapTop)
                        (WordFactory/zero)
                        (let [
                            #_"Word" heapEnd (Word''readWord-3 heapEndAddress, 0, HotSpotReplacementsUtil'HEAP_END_LOCATION)
                        ]
                            (cond
                                (Word''aboveThan-2 newHeapTop, heapEnd) (WordFactory/zero)
                                (Word''logicCompareAndSwapWord-5 heapTopAddress, 0, heapTop, newHeapTop, HotSpotReplacementsUtil'HEAP_TOP_LOCATION) heapTop
                                :else (recur)
                            )
                        )
                    )
                )
            )
        )
    )

    ; @NodeIntrinsic(StubForeignCallNode.class)
    (§ native #_"void" NewInstanceStub'newInstanceC-3 [#_@ConstantNodeParameter #_"ForeignCallDescriptor" newInstanceC, #_"Word" thread, #_"KlassPointer" hub])
)

;;;
 ; Base class for a stub defined by a snippet.
 ;;
(class-ns SnippetStub (§ extends Stub) (§ implements Snippets)
    (§ final #_"ResolvedJavaMethod" :method nil)

    ;;;
     ; Creates a new snippet stub.
     ;
     ; @param snippetMethodName name of the single Snippet annotated method in the class of this object
     ; @param linkage linkage details for a call to the stub
     ;;
    (§ defn #_"SnippetStub" SnippetStub'new-2 [#_"String" snippetMethodName, #_"ForeignCallLinkage" linkage]
        (let [
            #_"SnippetStub" this (Stub'new-1 linkage)
            #_"Method" method (AbstractTemplates'findMethod-3 (#_"Object" .getClass this), snippetMethodName)
            this (assoc this :method (#_"MetaAccessProvider" .lookupJavaMethod HotSpot'metaAccess, method))
        ]
            this
        )
    )

    #_unused
    (§ override #_"Graph" SnippetStub''getStubGraph-1 [#_"SnippetStub" this]
        (let [
            #_"Plugins" plugins (Plugins'copy-1 HotSpot'plugins)
            _ (§ ass! plugins (Plugins''prependParameterPlugin-2 plugins, (ConstantBindingParameterPlugin'new-1 (SnippetStub''makeConstArgs-1 this))))
            #_"GraphBuilderInstance" instance (GraphBuilderInstance'new-3 (GraphBuilderConfiguration'getSnippetDefault-1 plugins), OptimisticOptimizations'NONE, (IntrinsicContext'new-4 (:method this), (:method this), HotSpot'defaultBytecodeProvider, CompilationContext'INLINE_AFTER_PARSING))
            #_"Graph" graph (Graph'new-1 (:method this))
        ]
            (Phase''apply-2 instance, graph)
            (doseq [#_"ParameterNode" param (Graph''getNodes-2 graph, ParameterNode'TYPE)]
                (when (some? (#_"ResolvedJavaMethod" .getParameterAnnotation (:method this), NonNullParameter, (AbstractLocalNode''index-1 param)))
                    (§ ass! param (ValueNode''setStamp-2 param, (Stamp''join-2 (:stamp param), StampFactory'objectNonNullStamp)))
                )
            )
            (Phase''apply-2 (RemoveValueProxyPhase'new-0), graph)
            (§ ass! graph (Graph''setGuardsStage-2 graph, GuardsStage'FLOATING_GUARDS))
            (let [
                #_"CanonicalizerPhase" canonicalizer (CanonicalizerPhase'new-0)
                #_"PhaseContext" context (PhaseContext'new-0)
            ]
                (BasePhase''apply-3 canonicalizer, graph, context)
                (BasePhase''apply-3 (LoweringPhase'new-2 canonicalizer, LoweringStage'HIGH_TIER), graph, context)

                graph
            )
        )
    )

    (§ method #_"Object[]" SnippetStub''makeConstArgs-1 [#_"SnippetStub" this]
        (let [
            #_"int" n (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature (:method this)), false)
            #_"Object[]" args (make-array Object n)
        ]
            (dotimes [#_"int" i n]
                (when (some? (#_"ResolvedJavaMethod" .getParameterAnnotation (:method this), ConstantParameter, i))
                    (aset args i (SnippetStub''getConstantParameterValue-3 this, i, nil))
                )
            )
            args
        )
    )

    (§ method #_"Object" SnippetStub''getConstantParameterValue-3 [#_"SnippetStub" this, #_"int" index, #_"String" name]
        (throw! (str (#_"Class" .getName (#_"Object" .getClass this)) " must override getConstantParameterValue() to provide a value for parameter " index (if (some? name) (str " (" name ")") "")))
    )
)

;;;
 ; Base class for implementing some low level code providing the out-of-line slow path for a snippet
 ; and/or a callee saved call to a HotSpot C/C++ runtime function or even a another compiled Java method.
 ;;
(class-ns Stub
    ;;;
     ; The linkage information for a call to this stub from compiled code.
     ;;
    (§ final #_"ForeignCallLinkage" :linkage nil)
    ;;;
     ; The code installed for the stub.
     ;;
    (§ mutable #_"InstalledCode" :code nil)

    ;;;
     ; Creates a new stub.
     ;
     ; @param linkage linkage details for a call to the stub
     ;;
    (§ defn #_"Stub" Stub'new-1 [#_"ForeignCallLinkage" linkage]
        (let [
            #_"Stub" this (Object.)
            this (assoc this :linkage linkage)
        ]
            this
        )
    )

    ;;;
     ; Determines if this stub preserves all registers apart from those it
     ; {@linkplain #getDestroyedCallerRegisters() destroys}.
     ;;
    (§ method #_"boolean" Stub''preservesRegisters-1 [#_"Stub" this]
        true
    )

    ;;;
     ; Gets the graph that from which the code for this stub will be compiled.
     ;;
    (§ abstract #_"Graph" Stub''getStubGraph-1 [#_"Stub" this])

    ;;;
     ; Gets the code for this stub, compiling it first if necessary.
     ;;
    (§ method #_"InstalledCode" Stub''getCode-1 [#_"Stub" this]
        (locking this
            (when (nil? (:code this))
                (§ ass! this (assoc this :code (#_"CodeCacheProvider" .installCode HotSpot'codeCache, nil, (Compiler'createCompiledCode-1 (Compiler'compileStub-1 this)), nil, nil, false)))
            )

            (:code this)
        )
    )
)

;;;
 ; @target ElementType.METHOD
 ;;
(§ annotation HotSpotOperation
    (§ value #_"HotspotOpcode" opcode nil)
)

;;;
 ; @anno HotSpotOperation.HotspotOpcode
 ;;
(value-ns HotspotOpcode
    (§ enum HotspotOpcode'FROM_POINTER)
    (§ enum HotspotOpcode'TO_KLASS_POINTER)
    (§ enum HotspotOpcode'TO_METHOD_POINTER)
    (§ enum HotspotOpcode'POINTER_EQ)
    (§ enum HotspotOpcode'POINTER_NE)
    (§ enum HotspotOpcode'IS_NULL)
    (§ enum HotspotOpcode'READ_KLASS_POINTER)
)

(value-ns WordTypes
    (§ def #_"JavaKind" WordTypes'wordKind (.wordJavaKind HotSpot'target))

    (§ def #_"ResolvedJavaType" WordTypes'wordBase         (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, WordBase))
    (§ def #_"ResolvedJavaType" WordTypes'wordImpl         (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Word))
    (§ def #_"ResolvedJavaType" WordTypes'wordFactory      (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, WordFactory))
    (§ def #_"ResolvedJavaType" WordTypes'objectAccess     (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, ObjectAccess))
    (§ def #_"ResolvedJavaType" WordTypes'barrieredAccess  (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, BarrieredAccess))
    (§ def #_"ResolvedJavaType" WordTypes'metaspacePointer (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, MetaspacePointer))
    (§ def #_"ResolvedJavaType" WordTypes'klassPointer     (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, KlassPointer))
    (§ def #_"ResolvedJavaType" WordTypes'methodPointer    (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, MethodPointer))

    (§ init
        (Word'ensureInitialized-0)
        (#_"ResolvedJavaType" .initialize WordTypes'wordImpl)
    )

    ;;;
     ; Determines if a given method denotes a word operation.
     ;;
    (§ defn #_"boolean" WordTypes'isWordOperation-1 [#_"ResolvedJavaMethod" targetMethod]
        (let [
            #_"ResolvedJavaType" type (#_"ResolvedJavaMethod" .getDeclaringClass targetMethod)
        ]
            (or (any = type WordTypes'wordFactory WordTypes'objectAccess WordTypes'barrieredAccess) (WordTypes'isWord-1 type))
        )
    )

    ;;;
     ; Gets the method annotated with Operation based on a given method that represents a word operation
     ; (but may not necessarily have the annotation).
     ;
     ; @param callingContextType the type from which {@code targetMethod} is invoked
     ; @return the Operation method resolved for {@code targetMethod} if any
     ;;
    (§ defn #_"ResolvedJavaMethod" WordTypes'getWordOperation-2 [#_"ResolvedJavaMethod" targetMethod, #_"ResolvedJavaType" callingContextType]
        (let [
            #_"boolean" isWordBase (#_"ResolvedJavaType" .isAssignableFrom WordTypes'wordBase, (#_"ResolvedJavaMethod" .getDeclaringClass targetMethod))
        ]
            (when (and isWordBase (not (#_"ResolvedJavaMethod" .isStatic targetMethod))) => targetMethod
                (#_"ResolvedJavaType" .resolveConcreteMethod WordTypes'wordImpl, targetMethod, callingContextType)
            )
        )
    )

    ;;;
     ; Determines if a given node has a word type.
     ;;
    (§ defn #_"boolean" WordTypes'isWord-1 [#_"ValueNode" node]
        (WordTypes'isWord-1 (StampTool'typeOrNull-1 (:stamp node)))
    )

    ;;;
     ; Determines if a given type is a word type.
     ;;
    (§ defn #_"boolean" WordTypes'isWord-1 [#_"JavaType" type]
        (and (instance? ResolvedJavaType type)
            (or
                (#_"ResolvedJavaType" .isAssignableFrom WordTypes'metaspacePointer, type)
                (#_"ResolvedJavaType" .isAssignableFrom WordTypes'wordBase, type)
            )
        )
    )

    ;;;
     ; Gets the kind for a given type, returning the {@linkplain #getWordKind() word kind}
     ; if {@code type} is a {@linkplain #isWord(JavaType) word type}.
     ;;
    (§ defn #_"JavaKind" WordTypes'asKind-1 [#_"JavaType" type]
        (if (or (any = type WordTypes'klassPointer WordTypes'methodPointer) (WordTypes'isWord-1 type))
            WordTypes'wordKind
            (#_"JavaType" .getJavaKind type)
        )
    )

    ;;;
     ; Gets the stamp for a given {@linkplain #isWord(JavaType) word type}.
     ;;
    (§ defn #_"Stamp" WordTypes'getWordStamp-1 [#_"ResolvedJavaType" type]
        (condp = type
            WordTypes'klassPointer  KlassPointerStamp'KLASS
            WordTypes'methodPointer MethodPointerStamp'METHOD
                                    (StampFactory'forKind-1 WordTypes'wordKind)
        )
    )
)

;;;
 ; Marker type for a metaspace pointer to a type.
 ;;
(class-ns KlassPointer (§ extends MetaspacePointer)
    #_unused
    (§ defn #_"KlassPointer" KlassPointer'new-0 []
        (MetaspacePointer'new-0)
    )

    ; @HotSpotOperation(opcode = HotspotOpcode'POINTER_EQ)
    (§ abstract #_"boolean" KlassPointer''equal-2 [#_"KlassPointer" this, #_"KlassPointer" other])

    ; @HotSpotOperation(opcode = HotspotOpcode'POINTER_NE)
    (§ abstract #_"boolean" KlassPointer''notEqual-2 [#_"KlassPointer" this, #_"KlassPointer" other])

    ; @HotSpotOperation(opcode = HotspotOpcode'TO_KLASS_POINTER)
    (§ native #_"KlassPointer" KlassPointer'fromWord-1 [#_"Pointer" pointer])

    ; @HotSpotOperation(opcode = HotspotOpcode'READ_KLASS_POINTER)
    #_native
    (§ abstract #_"KlassPointer" KlassPointer''readKlassPointer-3 [#_"KlassPointer" this, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_native
    (§ abstract #_"void" KlassPointer''writeKlassPointer-4 [#_"KlassPointer" this, #_"int" offset, #_"KlassPointer" t, #_"LocationIdentity" locationIdentity])
)

;;;
 ; Marker type for a metaspace pointer.
 ;;
(class-ns MetaspacePointer
    (§ defn #_"MetaspacePointer" MetaspacePointer'new-0 []
        (Object.)
    )

    ; @HotSpotOperation(opcode = HotspotOpcode'IS_NULL)
    (§ abstract #_"boolean" MetaspacePointer''isNull-1 [#_"MetaspacePointer" this])

    ; @HotSpotOperation(opcode = HotspotOpcode'FROM_POINTER)
    #_unused
    (§ abstract #_"Pointer" MetaspacePointer''asWord-1 [#_"MetaspacePointer" this])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;
     ; The offset is always treated as a SignedWord value. However, the static type is
     ; WordBase to avoid the frequent casts of UnsignedWord values (where the caller
     ; knows that the highest-order bit of the unsigned value is never used).
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ abstract #_"byte" MetaspacePointer''readByte-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"char" MetaspacePointer''readChar-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"short" MetaspacePointer''readShort-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ abstract #_"int" MetaspacePointer''readInt-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"long" MetaspacePointer''readLong-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ abstract #_"Word" MetaspacePointer''readWord-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"Object" MetaspacePointer''readObject-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ abstract #_"byte" MetaspacePointer''readByte-3 [#_"MetaspacePointer" this, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"char" MetaspacePointer''readChar-3 [#_"MetaspacePointer" this, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"short" MetaspacePointer''readShort-3 [#_"MetaspacePointer" this, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ abstract #_"int" MetaspacePointer''readInt-3 [#_"MetaspacePointer" this, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"long" MetaspacePointer''readLong-3 [#_"MetaspacePointer" this, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ abstract #_"Word" MetaspacePointer''readWord-3 [#_"MetaspacePointer" this, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"Object" MetaspacePointer''readObject-3 [#_"MetaspacePointer" this, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeByte-4 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"byte" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeChar-4 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"char" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeShort-4 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"short" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeInt-4 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"int" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeLong-4 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"long" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeWord-4 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"WordBase" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Initializes the memory at address {@code (this + offset)}. Both the base address and offset
     ; are in bytes. The memory must be uninitialized or zero prior to this operation.
     ;;
    ; @Operation(opcode = WordOpcode'INITIALIZE)
    #_unused
    (§ abstract #_"void" MetaspacePointer''initializeLong-4 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"long" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeObject-4 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"Object" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeByte-4 [#_"MetaspacePointer" this, #_"int" offset, #_"byte" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeChar-4 [#_"MetaspacePointer" this, #_"int" offset, #_"char" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeShort-4 [#_"MetaspacePointer" this, #_"int" offset, #_"short" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeInt-4 [#_"MetaspacePointer" this, #_"int" offset, #_"int" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeLong-4 [#_"MetaspacePointer" this, #_"int" offset, #_"long" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeWord-4 [#_"MetaspacePointer" this, #_"int" offset, #_"WordBase" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeObject-4 [#_"MetaspacePointer" this, #_"int" offset, #_"Object" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"byte" MetaspacePointer''readByte-2 [#_"MetaspacePointer" this, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"char" MetaspacePointer''readChar-2 [#_"MetaspacePointer" this, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"short" MetaspacePointer''readShort-2 [#_"MetaspacePointer" this, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"int" MetaspacePointer''readInt-2 [#_"MetaspacePointer" this, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"long" MetaspacePointer''readLong-2 [#_"MetaspacePointer" this, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"Word" MetaspacePointer''readWord-2 [#_"MetaspacePointer" this, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"Object" MetaspacePointer''readObject-2 [#_"MetaspacePointer" this, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. This access will decompress the oop if
     ; the VM uses compressed oops, and it can be parameterized to allow read barriers (G1 referent field).
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"Object" MetaspacePointer''readObject-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"BarrierType" barrierType])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"byte" MetaspacePointer''readByte-2 [#_"MetaspacePointer" this, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"char" MetaspacePointer''readChar-2 [#_"MetaspacePointer" this, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"short" MetaspacePointer''readShort-2 [#_"MetaspacePointer" this, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"int" MetaspacePointer''readInt-2 [#_"MetaspacePointer" this, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"long" MetaspacePointer''readLong-2 [#_"MetaspacePointer" this, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"Word" MetaspacePointer''readWord-2 [#_"MetaspacePointer" this, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"Object" MetaspacePointer''readObject-2 [#_"MetaspacePointer" this, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (this + offset)}. This access will decompress the oop if
     ; the VM uses compressed oops, and it can be parameterized to allow read barriers (G1 referent field).
     ;;
    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_unused
    (§ abstract #_"Object" MetaspacePointer''readObject-3 [#_"MetaspacePointer" this, #_"int" offset, #_"BarrierType" barrierType])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeByte-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"byte" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeChar-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"char" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeShort-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"short" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeInt-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"int" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeLong-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"long" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeWord-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"WordBase" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeObject-3 [#_"MetaspacePointer" this, #_"WordBase" offset, #_"Object" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeByte-3 [#_"MetaspacePointer" this, #_"int" offset, #_"byte" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeChar-3 [#_"MetaspacePointer" this, #_"int" offset, #_"char" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeShort-3 [#_"MetaspacePointer" this, #_"int" offset, #_"short" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeInt-3 [#_"MetaspacePointer" this, #_"int" offset, #_"int" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeLong-3 [#_"MetaspacePointer" this, #_"int" offset, #_"long" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeWord-3 [#_"MetaspacePointer" this, #_"int" offset, #_"WordBase" val])

    ;;;
     ; Writes the memory at address {@code (this + offset)}. Both the base address and offset are in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_unused
    (§ abstract #_"void" MetaspacePointer''writeObject-3 [#_"MetaspacePointer" this, #_"int" offset, #_"Object" val])
)

;;;
 ; Marker type for a metaspace pointer to a method.
 ;;
(class-ns MethodPointer (§ extends MetaspacePointer)
    #_unused
    (§ defn #_"MethodPointer" MethodPointer'new-0 []
        (MetaspacePointer'new-0)
    )

    ; @HotSpotOperation(opcode = HotspotOpcode'POINTER_EQ)
    #_unused
    (§ abstract #_"boolean" MethodPointer''equal-2 [#_"MethodPointer" this, #_"KlassPointer" other])

    ; @HotSpotOperation(opcode = HotspotOpcode'POINTER_NE)
    #_unused
    (§ abstract #_"boolean" MethodPointer''notEqual-2 [#_"MethodPointer" this, #_"KlassPointer" other])

    ; @HotSpotOperation(opcode = HotspotOpcode'TO_METHOD_POINTER)
    #_unused
    (§ native #_"MethodPointer" MethodPointer'fromWord-1 [#_"Pointer" pointer])
)

;;;
 ; Cast between Word and metaspace pointers exposed by the HotspotOpcode#FROM_POINTER
 ; and HotspotOpcode#TO_KLASS_POINTER operations.
 ;;
(final-ns PointerCastNode (§ extends FloatingNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<PointerCastNode>" PointerCastNode'TYPE (NodeClass'create-1 PointerCastNode))

    ; @Input
    (§ mutable #_"ValueNode" :input nil)

    (§ defn #_"PointerCastNode" PointerCastNode'new-2 [#_"Stamp" stamp, #_"ValueNode" input]
        (let [
            #_"PointerCastNode" this (FloatingNode'new-2 PointerCastNode'TYPE, stamp)
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" PointerCastNode''generate-2 [#_"PointerCastNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRBuilder''operand-2 builder, (:input this)))
        nil
    )
)

;;;
 ; Builds a mapping between bytecodes and basic blocks and builds a conservative control flow graph
 ; (CFG). It makes one linear passes over the bytecodes to build the CFG where it detects block
 ; headers and connects them.
 ;
 ; It also creates exception dispatch blocks for exception handling. These blocks are between a
 ; bytecode that might throw an exception, and the actual exception handler entries, and are later
 ; used to create the type checks with the exception handler catch types. If a bytecode is covered
 ; by an exception handler, this bytecode ends the basic block. This guarantees that (a) control flow
 ; cannot be transferred to an exception dispatch block in the middle of a block, and (b) that every
 ; block has at most one exception dispatch block (which is always the last entry in the successor list).
 ;
 ; If a bytecode is covered by multiple exception handlers, a chain of exception dispatch blocks is
 ; created so that multiple exception handler types can be checked. The chains are re-used if
 ; multiple bytecodes are covered by the same exception handlers.
 ;
 ; Note that exception unwinds, i.e. bytecodes that can throw an exception but the exception is not
 ; handled in this method, do not end a basic block. Not modeling the exception unwind block reduces
 ; the complexity of the CFG, and there is no algorithm yet where the exception unwind block would matter.
 ;
 ; The class also handles subroutines (jsr and ret bytecodes): subroutines are inlined by
 ; duplicating the subroutine blocks. This is limited to simple, structured subroutines with a
 ; maximum subroutine nesting of 4. Otherwise, a bailout is thrown.
 ;
 ; Loops in the methods are detected. If a method contains an irreducible loop (a loop with more
 ; than one entry), a bailout is thrown. This simplifies the compiler later on since only structured
 ; loops need to be supported.
 ;
 ; A data flow analysis computes the live local variables from the point of view of the interpreter.
 ; The result is used later to prune frame states, i.e. remove local variable entries that are
 ; guaranteed to be never used again (even in the case of deoptimization).
 ;
 ; The algorithms and analysis in this class are conservative and do not use any assumptions or
 ; profiling information.
 ;;
(final-ns BciBlockMapping
    (def- #_"int" BciBlockMapping'LOOP_HEADER_MAX_CAPACITY Long/SIZE)
    (def- #_"int" BciBlockMapping'LOOP_HEADER_INITIAL_CAPACITY 4)

    ;;;
     ; The blocks found in this method, in reverse postorder.
     ;;
    (§ mutable #_"BciBlock[]" :blocks nil)
    (§ final #_"Bytecode" :code nil)
    (§ mutable #_"boolean" :hasJsrBytecodes false)

    (§ mutable #_"BciBlock" :startBlock nil)
    (§ mutable #_"BciBlock[]" :loopHeaders nil)

    (§ mutable #_"int" :blocksNotYetAssignedId 0)

    ;;;
     ; Creates a new BlockMap instance from {@code code}.
     ;;
    (§ defn- #_"BciBlockMapping" BciBlockMapping'new-1 [#_"Bytecode" code]
        (let [
            #_"BciBlockMapping" this (Object.)
            this (assoc this :code code)
        ]
            this
        )
    )

    ;;;
     ; Builds the block map and conservative CFG and numbers blocks.
     ;;
    (§ method! #_"BciBlockMapping" BciBlockMapping''build-2 [#_"BciBlockMapping" this, #_"BytecodeStream" stream]
        (let [
            #_"int" codeSize (Bytecode''getCodeSize-1 (:code this))
            #_"BciBlock[]" blockMap (make-array BciBlock codeSize)
            this (BciBlockMapping''iterateOverBytecodes-3 this, blockMap, stream)
            this
                (when (:hasJsrBytecodes this) => this
                    (BciBlockMapping''createJsrAlternatives-3 this, blockMap, (nth blockMap 0))
                )
            this (BciBlockMapping''computeBlockOrder-2 this, blockMap)
            this (BciBlockMapping''fixLoopBits-2 this, blockMap)
            this (assoc this :startBlock (nth blockMap 0))
        ]
            this
        )
    )

    (§ method- #_"BciBlockMapping" BciBlockMapping''iterateOverBytecodes-3 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap, #_"BytecodeStream" stream]
        ;; iterate over the bytecodes top to bottom,
        ;; mark the entrypoints of basic blocks and build lists of successors for all bytecodes
        ;; that end basic blocks (i.e. goto, ifs, switches, throw, jsr, returns, ret)
        (loop-when [this this #_"BciBlock" block nil _ (§ ass! stream (BytecodeStream''setBCI-2 stream, 0))] (not= (BytecodeStream''currentBC-1 stream) Bytecodes'END) => this
            (let [
                #_"int" bci (:curBCI stream)
                block
                    (when (or (nil? block) (some? (nth blockMap bci))) => block
                        (let [
                            #_"BciBlock" b (BciBlockMapping''makeBlock-3 this, blockMap, bci)
                        ]
                            (when (some? block)
                                (BciBlockMapping'addSuccessor-3 blockMap, (:endBci block), b)
                            )
                            b
                        )
                    )
                _ (aset blockMap bci block)
                block (assoc block :endBci bci)
                block
                    (condp =? (BytecodeStream''currentBC-1 stream)
                       [Bytecodes'IRETURN Bytecodes'LRETURN Bytecodes'ARETURN Bytecodes'RETURN]
                            nil
                       [Bytecodes'IFEQ Bytecodes'IFNE
                        Bytecodes'IFLT Bytecodes'IFGE
                        Bytecodes'IFGT Bytecodes'IFLE
                        Bytecodes'IF_ICMPEQ Bytecodes'IF_ICMPNE
                        Bytecodes'IF_ICMPLT Bytecodes'IF_ICMPGE
                        Bytecodes'IF_ICMPGT Bytecodes'IF_ICMPLE
                        Bytecodes'IF_ACMPEQ Bytecodes'IF_ACMPNE
                        Bytecodes'IFNULL Bytecodes'IFNONNULL]
                        (do
                            (BciBlockMapping'addSuccessor-3 blockMap, bci, (BciBlockMapping''makeBlock-3 this, blockMap, (BytecodeStream''readBranchDest-1 stream)))
                            (BciBlockMapping'addSuccessor-3 blockMap, bci, (BciBlockMapping''makeBlock-3 this, blockMap, (:nextBCI stream)))
                            nil
                        )
                       [Bytecodes'GOTO Bytecodes'GOTO_W]
                        (do
                            (BciBlockMapping'addSuccessor-3 blockMap, bci, (BciBlockMapping''makeBlock-3 this, blockMap, (BytecodeStream''readBranchDest-1 stream)))
                            nil
                        )
                        Bytecodes'TABLESWITCH
                        (do
                            (BciBlockMapping''addSwitchSuccessors-4 this, blockMap, bci, (BytecodeTableSwitch'new-2 stream, bci))
                            nil
                        )
                        Bytecodes'LOOKUPSWITCH
                        (do
                            (BciBlockMapping''addSwitchSuccessors-4 this, blockMap, bci, (BytecodeLookupSwitch'new-2 stream, bci))
                            nil
                        )
                       [Bytecodes'JSR Bytecodes'JSR_W]
                        (do
                            (§ ass! this (assoc this :hasJsrBytecodes true))
                            (let [
                                #_"int" target (BytecodeStream''readBranchDest-1 stream)
                            ]
                                (when (zero? target)
                                    (throw! "jsr target bci 0 not allowed")
                                )
                                (let [
                                    #_"BciBlock" b1 (BciBlockMapping''makeBlock-3 this, blockMap, target)
                                ]
                                    (BciBlock''setJsrSuccessor-2 block, b1)
                                    (BciBlock''setJsrReturnBci-2 block, (:nextBCI stream))
                                    (BciBlockMapping'addSuccessor-3 blockMap, bci, b1)
                                )
                            )
                            nil
                        )
                        Bytecodes'RET
                        (do
                            (BciBlock''setEndsWithRet-1 block)
                            nil
                        )
                       [Bytecodes'INVOKEINTERFACE Bytecodes'INVOKESPECIAL Bytecodes'INVOKESTATIC Bytecodes'INVOKEVIRTUAL Bytecodes'INVOKEDYNAMIC]
                        (do
                            (BciBlockMapping'addSuccessor-3 blockMap, bci, (BciBlockMapping''makeBlock-3 this, blockMap, (:nextBCI stream)))
                            nil
                        )
                        block
                    )
            ]
                (recur this block (§ ass! stream (BytecodeStream''next-1 stream)))
            )
        )
    )

    (§ method- #_"BciBlock" BciBlockMapping''makeBlock-3 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap, #_"int" startBci]
        (let [
            #_"BciBlock" oldBlock (nth blockMap startBci)
        ]
            (cond
                (nil? oldBlock)
                    (let [
                        #_"BciBlock" newBlock (BciBlock'new-1 startBci)
                    ]
                        (§ ass! this (update this :blocksNotYetAssignedId inc))
                        (aset blockMap startBci newBlock)
                        newBlock
                    )
                (not= (:startBci oldBlock) startBci)
                    ;; Backward branch into the middle of an already processed block.
                    ;; Add the correct fall-through successor.
                    (let [
                        #_"BciBlock" newBlock (BciBlock'new-1 startBci)
                    ]
                        (§ ass! this (update this :blocksNotYetAssignedId inc))
                        (§ ass newBlock (assoc newBlock :endBci (:endBci oldBlock)))
                        (doseq [#_"BciBlock" oldSuccessor (:successors oldBlock)]
                            (BciBlock''addSuccessor-2 newBlock, oldSuccessor)
                        )

                        (§ ass oldBlock (assoc oldBlock :endBci (dec startBci)))
                        (BciBlock''clearSucccessors-1 oldBlock)
                        (BciBlock''addSuccessor-2 oldBlock, newBlock)

                        (loop-when-recur [#_"int" i startBci] (<= i (:endBci newBlock)) [(inc i)]
                            (aset blockMap i newBlock)
                        )
                        newBlock
                    )
                :else
                    oldBlock
            )
        )
    )

    (§ method- #_"void" BciBlockMapping''addSwitchSuccessors-4 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap, #_"int" predBci, #_"BytecodeSwitch" bswitch]
        ;; adds distinct targets to the successor list
        (let [
            #_"Collection<Integer>" targets (TreeSet.)
        ]
            (dotimes [#_"int" i (BytecodeSwitch''numberOfCases-1 bswitch)]
                (#_"Collection" .add targets, (BytecodeSwitch''targetAt-2 bswitch, i))
            )
            (#_"Collection" .add targets, (BytecodeSwitch''defaultTarget-1 bswitch))
            (doseq [#_"int" targetBci targets]
                (BciBlockMapping'addSuccessor-3 blockMap, predBci, (BciBlockMapping''makeBlock-3 this, blockMap, targetBci))
            )
        )
        nil
    )

    (§ defn- #_"void" BciBlockMapping'addSuccessor-3 [#_"BciBlock[]" blockMap, #_"int" predBci, #_"BciBlock" sux]
        (BciBlock''addSuccessor-2 (nth blockMap predBci), sux)
        nil
    )

    (§ final #_"ArrayList<BciBlock>" :jsrVisited (ArrayList.))

    (§ method- #_"BciBlockMapping" BciBlockMapping''createJsrAlternatives-3 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap, #_"BciBlock" block]
        (#_"ArrayList" .add (:jsrVisited this), block)
        (let [
            #_"JsrScope" scope (BciBlock''getJsrScope-1 block)
        ]
            (when (BciBlock''endsWithRet-1 block)
                (BciBlock''setRetSuccessor-2 block, (nth blockMap (JsrScope''nextReturnAddress-1 scope)))
                (BciBlock''addSuccessor-2 block, (BciBlock''getRetSuccessor-1 block))
            )
            (when (or (some? (BciBlock''getJsrSuccessor-1 block)) (not (JsrScope''isEmpty-1 scope)))
                (loop-when-recur [#_"int" i 0] (< i (count (:successors block))) [(inc i)]
                    (let [
                        #_"BciBlock" successor (BciBlock''getSuccessor-2 block, i)
                        #_"JsrScope" nextScope scope
                        nextScope
                            (when (= successor (BciBlock''getJsrSuccessor-1 block)) => nextScope
                                (JsrScope''push-2 scope, (BciBlock''getJsrReturnBci-1 block))
                            )
                        nextScope
                            (when (= successor (BciBlock''getRetSuccessor-1 block)) => nextScope
                                (JsrScope''pop-1 scope)
                            )
                    ]
                        (when-not (JsrScope''isPrefixOf-2 (BciBlock''getJsrScope-1 successor), nextScope)
                            (throw! (str "unstructured control flow (" (BciBlock''getJsrScope-1 successor) " " nextScope ")"))
                        )
                        (when-not (JsrScope''isEmpty-1 nextScope)
                            (let [
                                #_"BciBlock" clone
                                    (if (and (some? (BciBlock''getJsrAlternatives-1 successor)) (contains? (BciBlock''getJsrAlternatives-1 successor) nextScope))
                                        (get (BciBlock''getJsrAlternatives-1 successor) nextScope)
                                        (do
                                            (BciBlock''initJsrAlternatives-1 successor)
                                            (let [
                                                clone (BciBlock''copy-1 successor)
                                            ]
                                                (§ ass! this (update this :blocksNotYetAssignedId inc))
                                                (BciBlock''setJsrScope-2 clone, nextScope)
                                                (#_"EconomicMap" .put (BciBlock''getJsrAlternatives-1 successor), nextScope, clone)
                                                clone
                                            )
                                        )
                                    )
                            ]
                                (#_"List" .set (:successors block), i, clone)
                                (when (= successor (BciBlock''getJsrSuccessor-1 block))
                                    (BciBlock''setJsrSuccessor-2 block, clone)
                                )
                                (when (= successor (BciBlock''getRetSuccessor-1 block))
                                    (BciBlock''setRetSuccessor-2 block, clone)
                                )
                            )
                        )
                    )
                )
            )
            (doseq [#_"BciBlock" successor (:successors block)]
                (when-not (#_"ArrayList" .contains (:jsrVisited this), successor)
                    (§ ass! this (BciBlockMapping''createJsrAlternatives-3 this, blockMap, successor))
                )
            )
            this
        )
    )

    (§ mutable #_"boolean" :loopChanges false)

    (§ method- #_"BciBlockMapping" BciBlockMapping''fixLoopBits-2 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap]
        (loop [this this]
            (let [
                this (assoc this :loopChanges false)
            ]
                (loop-when-recur [#_"ISeq" s (seq (:blocks this))] (some? s) [(next s)]
                    (let [
                        #_"BciBlock" b (first s)
                    ]
                        (§ ass! b (assoc b :visited false))
                    )
                )
                ;; => There is a path from a loop end to the method entry that does not pass the loop header.
                ;; Therefore, the loop is non reducible (has more than one entry).
                ;; We don't want to compile such methods because the IR only supports structured loops.
                (when (zero? (BciBlockMapping''fixLoopBits-3 this, blockMap, (nth blockMap 0))) => (throw! "non-reducible loop")
                    (recur-if (:loopChanges this) [this] => this)
                )
            )
        )
    )

    (§ method- #_"BciBlockMapping" BciBlockMapping''computeBlockOrder-2 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap]
        (let [
            #_"int" maxBlocks (:blocksNotYetAssignedId this)
            this (assoc this :blocks (make-array BciBlock maxBlocks))
        ]
            ;; => There is a path from a loop end to the method entry that does not pass the loop header.
            ;; Therefore, the loop is non reducible (has more than one entry).
            ;; We don't want to compile such methods because the IR only supports structured loops.
            (when (zero? (BciBlockMapping''computeBlockOrder-2 this, (nth blockMap 0))) => (throw! "non-reducible loop")
                ;; Purge nil entries for unreached blocks and sort blocks such that loop bodies are always
                ;; consecutively in the array.
                (let [
                    #_"int" blockCount (inc (- maxBlocks (:blocksNotYetAssignedId this)))
                    #_"BciBlock[]" newBlocks (make-array BciBlock blockCount)
                    #_"int" next
                        (loop-when [next 0 #_"int" i 0] (< i (count (:blocks this))) => next
                            (let [
                                next
                                    (let [
                                        #_"BciBlock" b (nth (:blocks this) i)
                                    ]
                                        (when (some? b) => next
                                            (let [
                                                b (BciBlock''setId-2 b, next)
                                                _ (aset newBlocks next b)
                                                next (inc next)
                                            ]
                                                (when (:isLoopHeader b) => next
                                                    (BciBlockMapping''handleLoopHeader-5 this, newBlocks, next, i, b)
                                                )
                                            )
                                        )
                                    )
                            ]
                                (recur next (inc i))
                            )
                        )
                    _ (aset newBlocks (dec (count newBlocks)) unwindBlock)
                ]
                    (assoc this :blocks newBlocks)
                )
            )
        )
    )

    (§ method- #_"int" BciBlockMapping''handleLoopHeader-5 [#_"BciBlockMapping" this, #_"BciBlock[]" newBlocks, #_"int" next, #_"int" i, #_"BciBlock" loopHeader]
        (let [
            [#_"int" endOfLoop next]
                (loop-when [endOfLoop (dec next) next next i (inc i)] (< i (count (:blocks this))) => [endOfLoop next]
                    (let [
                        #_"BciBlock" block (nth (:blocks this) i)
                        [endOfLoop next]
                            (when (and (some? block) (not (zero? (& (:loops block) (<< 1 (:loopId loopHeader)))))) => [endOfLoop next]
                                (§ ass! block (BciBlock''setId-2 block, next))
                                (let [
                                    endOfLoop next
                                    _ (aset newBlocks next block)
                                    next (inc next)
                                    _ (aset (:blocks this) i nil)
                                ]
                                    [endOfLoop (if (:isLoopHeader block) (BciBlockMapping''handleLoopHeader-5 this, newBlocks, next, i, block) next)]
                                )
                            )
                    ]
                        (recur endOfLoop next (inc i))
                    )
                )
        ]
            (§ ass! loopHeader (assoc loopHeader :loopEnd endOfLoop))
            next
        )
    )

    ;;;
     ; Get the header block for a loop index.
     ;;
    (§ method! #_"BciBlock" BciBlockMapping''getLoopHeader-2 [#_"BciBlockMapping" this, #_"int" index]
        (nth (:loopHeaders this) index)
    )

    ;;;
     ; The next available loop number.
     ;;
    (§ mutable #_"int" :nextLoop 0)

    ;;;
     ; Mark the block as a loop header, using the next available loop number. Also checks for corner
     ; cases that we don't want to compile.
     ;;
    (§ method- #_"BciBlockMapping" BciBlockMapping''makeLoopHeader-2 [#_"BciBlockMapping" this, #_"BciBlock" block]
        (when-not (:isLoopHeader block) => this
            (§ ass! block (assoc block :isLoopHeader true))
            (when (<= BciBlockMapping'LOOP_HEADER_MAX_CAPACITY (:nextLoop this))
                ;; This restriction can be removed by using a fall-back to a BitSet in case we have more than 64 loops.
                ;; Don't compile such methods for now, until we see a concrete case that allows checking for correctness.
                (throw! "too many loops in method")
            )
            (§ ass! block (assoc block :loops (<< 1 (:nextLoop this))))
            (cond
                (nil? (:loopHeaders this))
                    (§ ass! this (assoc this :loopHeaders (make-array BciBlock BciBlockMapping'LOOP_HEADER_INITIAL_CAPACITY)))
                (<= (count (:loopHeaders this)) (:nextLoop this))
                    (§ ass! this (assoc this :loopHeaders (Arrays/copyOf (:loopHeaders this), BciBlockMapping'LOOP_HEADER_MAX_CAPACITY)))
            )
            (aset (:loopHeaders this) (:nextLoop this) block)
            (§ ass! block (assoc block :loopId (:nextLoop this)))
            (update this :nextLoop inc)
        )
    )

    ;;;
     ; Depth-first traversal of the control flow graph. The flag {@linkplain BciBlock#visited} is used to visit
     ; every block only once. The flag {@linkplain BciBlock#active} is used to detect cycles (backward edges).
     ;;
    (§ method- #_"long" BciBlockMapping''computeBlockOrder-2 [#_"BciBlockMapping" this, #_"BciBlock" block]
        (if (:visited block)
            (cond
                (:active block)
                    (do
                        ;; Reached block via backward branch.
                        (§ ass! this (BciBlockMapping''makeLoopHeader-2 this, block))
                        ;; Return cached loop information for this block.
                        (:loops block)
                    )
                (:isLoopHeader block) (& (:loops block) (bit-not (<< 1 (:loopId block))))
                :else                 (:loops block)
            )
            (do
                (§ ass! block (assoc block :visited true))
                (§ ass! block (assoc block :active true))

                (let [
                    #_"long" loops
                        (loop-when [loops 0 #_"ISeq" s (seq (:successors block))] (some? s) => loops
                            (let [
                                #_"BciBlock" successor (first s)
                                ;; Recursively process successors.
                                loops (| loops (BciBlockMapping''computeBlockOrder-2 this, successor))
                                loops
                                    (when (:active successor) => loops
                                        ;; Reached block via backward branch.
                                        (| loops (<< 1 (:loopId successor)))
                                    )
                            ]
                                (recur loops (next s))
                            )
                        )
                ]
                    (§ ass! block (assoc block :loops loops))
                    (let [
                        loops
                            (when (:isLoopHeader block) => loops
                                (& loops (bit-not (<< 1 (:loopId block))))
                            )
                    ]
                        (§ ass! block (assoc block :active false))
                        (§ ass! this (update this :blocksNotYetAssignedId dec))
                        (aset (:blocks this) (:blocksNotYetAssignedId this) block)

                        loops
                    )
                )
            )
        )
    )

    (§ method- #_"long" BciBlockMapping''fixLoopBits-3 [#_"BciBlockMapping" this, #_"BciBlock[]" blockMap, #_"BciBlock" block]
        (if (:visited block)
            ;; Return cached loop information for this block.
            (if (:isLoopHeader block) (& (:loops block) (bit-not (<< 1 (:loopId block)))) (:loops block))
            (let [
                _ (§ ass! block (assoc block :visited true))
                #_"long" loops
                    (loop-when-recur [loops (:loops block) #_"ISeq" s (seq (:successors block))]
                                     (some? s)
                                     ;; Recursively process successors.
                                     [(| loops (BciBlockMapping''fixLoopBits-3 this, blockMap, (first s))) (next s)]
                                  => loops
                    )
            ]
                (when-not (= (:loops block) loops)
                    (§ ass! this (assoc this :loopChanges true))
                    (§ ass! block (assoc block :loops loops))
                )

                (if (:isLoopHeader block) (& loops (bit-not (<< 1 (:loopId block)))) loops)
            )
        )
    )

    (§ defn #_"BciBlockMapping" BciBlockMapping'create-2 [#_"BytecodeStream" stream, #_"Bytecode" code]
        (let [
            #_"BciBlockMapping" map (BciBlockMapping'new-1 code)
        ]
            (§ ass! map (BciBlockMapping''build-2 map, stream))
            map
        )
    )
)

;;;
 ; @anno BciBlockMapping.BciBlock
 ;;
(final-ns BciBlock
    (§ mutable #_"int" :id 0)
    (§ final #_"int" :startBci 0)
    (§ mutable #_"int" :endBci 0)
    (§ mutable #_"boolean" :isLoopHeader false)
    (§ mutable #_"int" :loopId 0)
    (§ mutable #_"int" :loopEnd 0)
    (§ mutable #_"List<BciBlock>" :successors (ArrayList.))
    (§ mutable #_"int" :predecessorCount 0)

    (§ mutable #_"boolean" :visited false)
    (§ mutable #_"boolean" :active false)
    (§ mutable #_"long" :loops 0)
    (§ mutable #_"JSRData" :jsrData nil)

    (§ defn #_"BciBlock" BciBlock'new-1 [#_"int" startBci]
        (let [
            #_"BciBlock" this (Object.)
            this (assoc this :startBci startBci)
        ]
            this
        )
    )

    (§ method! #_"BciBlock" BciBlock''copy-1 [#_"BciBlock" this]
        (let [
            #_"BciBlock" block (#_"Object" .clone (§ super ))
            block
                (when (some? (:jsrData block)) => block
                    (assoc block :jsrData (#_"Object" .clone (:jsrData block)))
                )
        ]
            (assoc block :successors (ArrayList. (:successors this)))
        )
    )

    #_unused
    (§ method! #_"int" BciBlock''getLoopDepth-1 [#_"BciBlock" this]
        (Long/bitCount (:loops this))
    )

    (§ method! #_"BciBlock" BciBlock''getSuccessor-2 [#_"BciBlock" this, #_"int" index]
        (nth (:successors this) index)
    )

    ;;;
     ; Get the loop id of the inner most loop.
     ;
     ; @return the loop id of the most inner loop or -1 if not part of any loop
     ;;
    #_unused
    (§ method! #_"int" BciBlock''getLoopId-1 [#_"BciBlock" this]
        (if (zero? (:loops this)) -1 (loop-when-recur [#_"int" i 0 #_"int" mask 1] (zero? (& (:loops this) mask)) [(inc i) (<< mask 1)] => i))
    )

    ;;;
     ; Iterate over loop ids.
     ;;
    #_unused
    (§ method! #_"Iterable<Integer>" BciBlock''loopIdIterable-1 [#_"BciBlock" this]
        (let [
            #_"BciBlock" block this
        ]
            (§ reify #_"Iterable<Integer>" (Iterable.)
                (§ override! #_"Iterator<Integer>" #_"Iterable" .iterator [#_"Iterable<Integer>" this]
                    (BciBlock'idIterator-1 (:loops block))
                )
            )
        )
    )

    (§ defn- #_"Iterator<Integer>" BciBlock'idIterator-1 [#_"long" field]
        (§ reify #_"Iterator<Integer>" (Iterator.)
            (let [
                #_"long" l field
                #_"int" i 0
                #_"int" mask 1
            ]
                (§ override! #_"Integer" #_"Iterator" .next [#_"Iterator<Integer>" this]
                    (§ ass mask
                        (loop-when-recur mask (zero? (& l mask)) (<< mask 1) => mask
                            (§ ass i (inc i))
                        )
                    )
                    (§ ass l (& l (bit-not mask)))
                    i
                )

                (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<Integer>" this]
                    (not (zero? l))
                )
            )
        )
    )

    (§ method- #_"JSRData" BciBlock''getOrCreateJSRData-1 [#_"BciBlock" this]
        (when (nil? (:jsrData this))
            (§ ass! this (assoc this :jsrData (JSRData'new-0)))
        )
        (:jsrData this)
    )

    (§ method! #_"void" BciBlock''setEndsWithRet-1 [#_"BciBlock" this]
        (§ ass! (:endsWithRet (BciBlock''getOrCreateJSRData-1 this)) true)
        nil
    )

    (§ method! #_"JsrScope" BciBlock''getJsrScope-1 [#_"BciBlock" this]
        (if (some? (:jsrData this)) (:jsrScope (:jsrData this)) JsrScope'EMPTY_SCOPE)
    )

    (§ method! #_"boolean" BciBlock''endsWithRet-1 [#_"BciBlock" this]
        (and (some? (:jsrData this)) (:endsWithRet (:jsrData this)))
    )

    (§ method! #_"void" BciBlock''setRetSuccessor-2 [#_"BciBlock" this, #_"BciBlock" bciBlock]
        (§ ass! (:retSuccessor (BciBlock''getOrCreateJSRData-1 this)) bciBlock)
        nil
    )

    (§ method! #_"BciBlock" BciBlock''getRetSuccessor-1 [#_"BciBlock" this]
        (when (some? (:jsrData this)) (:retSuccessor (:jsrData this)))
    )

    (§ method! #_"BciBlock" BciBlock''getJsrSuccessor-1 [#_"BciBlock" this]
        (when (some? (:jsrData this)) (:jsrSuccessor (:jsrData this)))
    )

    (§ method! #_"int" BciBlock''getJsrReturnBci-1 [#_"BciBlock" this]
        (if (some? (:jsrData this)) (:jsrReturnBci (:jsrData this)) -1)
    )

    (§ method! #_"EconomicMap<JsrScope, BciBlock>" BciBlock''getJsrAlternatives-1 [#_"BciBlock" this]
        (when (some? (:jsrData this)) (:jsrAlternatives (:jsrData this)))
    )

    (§ method! #_"void" BciBlock''initJsrAlternatives-1 [#_"BciBlock" this]
        (let [
            #_"JSRData" data (BciBlock''getOrCreateJSRData-1 this)
        ]
            (when (nil? (:jsrAlternatives data))
                (§ ass! data (assoc data :jsrAlternatives (EconomicMap/create Equivalence/DEFAULT)))
            )
        )
        nil
    )

    (§ method! #_"void" BciBlock''setJsrScope-2 [#_"BciBlock" this, #_"JsrScope" nextScope]
        (§ ass! (:jsrScope (BciBlock''getOrCreateJSRData-1 this)) nextScope)
        nil
    )

    (§ method! #_"void" BciBlock''setJsrSuccessor-2 [#_"BciBlock" this, #_"BciBlock" clone]
        (§ ass! (:jsrSuccessor (BciBlock''getOrCreateJSRData-1 this)) clone)
        nil
    )

    (§ method! #_"void" BciBlock''setJsrReturnBci-2 [#_"BciBlock" this, #_"int" bci]
        (§ ass! (:jsrReturnBci (BciBlock''getOrCreateJSRData-1 this)) bci)
        nil
    )

    (§ method! #_"BciBlock" BciBlock''setId-2 [#_"BciBlock" this, #_"int" i]
        (assoc this :id i)
    )

    (§ method! #_"void" BciBlock''addSuccessor-2 [#_"BciBlock" this, #_"BciBlock" sux]
        (#_"List" .add (:successors this), sux)
        (§ ass sux (update sux :predecessorCount inc))
        nil
    )

    (§ method! #_"void" BciBlock''clearSucccessors-1 [#_"BciBlock" this]
        (loop-when-recur [#_"ISeq" s (seq (:successors this))] (some? s) [(next s)]
            (let [
                #_"BciBlock" sux (first s)
            ]
                (§ ass! sux (update sux :predecessorCount dec))
            )
        )
        (#_"List" .clear (:successors this))
        nil
    )
)

;;;
 ; @anno BciBlockMapping.BciBlock.JSRData
 ;;
(final-ns JSRData
    (§ mutable #_"EconomicMap<JsrScope, BciBlock>" :jsrAlternatives nil)
    (§ mutable #_"JsrScope" :jsrScope JsrScope'EMPTY_SCOPE)
    (§ mutable #_"BciBlock" :jsrSuccessor nil)
    (§ mutable #_"int" :jsrReturnBci 0)
    (§ mutable #_"BciBlock" :retSuccessor nil)
    (§ mutable #_"boolean" :endsWithRet false)

    (§ defn #_"JSRData" JSRData'new-0 []
        (Object.)
    )
)

(final-ns BytecodeParser (§ implements GraphBuilderTool)
    (§ final #_"GraphBuilderInstance" :graphBuilderInstance nil)
    (§ final #_"Graph" :graph nil)

    (§ mutable #_"BciBlockMapping" :blockMap nil)
    (§ mutable #_"LocalLiveness" :liveness nil)
    (§ final #_"BytecodeParser" :parent nil)

    (§ mutable #_"ValueNode" :methodSynchronizedObject nil)

    (§ mutable #_"List<ReturnToCallerData>" :returnDataList nil)

    (§ mutable #_"FixedWithNextNode" :lastInstr nil) ;; the last instruction added
    (§ mutable #_"boolean" :controlFlowSplit false)
    (§ final #_"InvocationPluginReceiver" :invocationPluginReceiver (InvocationPluginReceiver'new-1 this))

    (§ mutable #_"FixedWithNextNode[]" :firstInstructionArray nil)
    (§ mutable #_"FrameStateBuilder[]" :entryStateArray nil)

    (§ mutable #_"boolean" :finalBarrierRequired false)
    (§ mutable #_"ValueNode" :originalReceiver nil)
    (§ final #_"boolean" :eagerInitializing false)
    (§ final #_"boolean" :uninitializedIsError false)

    (§ defn #_"BytecodeParser" BytecodeParser'new-5 [#_"GraphBuilderInstance" graphBuilderInstance, #_"Graph" graph, #_"BytecodeParser" parent, #_"ResolvedJavaMethod" method, #_"IntrinsicContext" intrinsicContext]
        (let [
            #_"BytecodeParser" this (Object.)
            this (assoc this :bytecodeProvider (if (some? intrinsicContext) (:bytecodeProvider intrinsicContext) ResolvedJavaMethodBytecodeProvider'INSTANCE))
            this (assoc this :code (BytecodeProvider''getBytecode-2 (:bytecodeProvider this), method))
            this (assoc this :method (Bytecode''getMethod-1 (:code this)))
            this (assoc this :graphBuilderInstance graphBuilderInstance)
            this (assoc this :graph graph)
            this (assoc this :graphBuilderConfig (:graphBuilderConfig graphBuilderInstance))
            this (assoc this :optimisticOpts (:optimisticOpts graphBuilderInstance))
            this (assoc this :stream (BytecodeStream'new-1 (Bytecode''getCode-1 (:code this))))
            this (assoc this :constantPool (Bytecode''getConstantPool-1 (:code this)))
            this (assoc this :intrinsicContext intrinsicContext)
            this (assoc this :parent parent)
            this (assoc this :eagerInitializing (:eagerResolving (:graphBuilderConfig this)))
            this (assoc this :uninitializedIsError (:unresolvedIsError (:graphBuilderConfig this)))
        ]
            this
        )
    )

    (§ method! #_"BytecodeParser" BytecodeParser''build-3 [#_"BytecodeParser" this, #_"FixedWithNextNode" startInstruction, #_"FrameStateBuilder" startFrameState]
        ;; compute the block map, setup exception handlers and get the entrypoint(s)
        (let [
            #_"BciBlockMapping" newMapping (BciBlockMapping'create-2 (:stream this), (:code this))
            this (assoc this :blockMap newMapping)
            this (assoc this :firstInstructionArray (make-array FixedWithNextNode (count (:blocks (:blockMap this)))))
            this (assoc this :entryStateArray (make-array FrameStateBuilder (count (:blocks (:blockMap this)))))
            this
                (when-not (#_"ResolvedJavaMethod" .isStatic (:method this)) => this
                    (assoc this :originalReceiver (FrameStateBuilder''loadLocal-3 startFrameState, 0, JavaKind/Object))
                )
            this (assoc this :liveness (LocalLiveness'compute-4 (:stream this), (:blocks (:blockMap this)), (#_"ResolvedJavaMethod" .getMaxLocals (:method this)), (:nextLoop (:blockMap this))))
            this (assoc this :lastInstr startInstruction)
            this (BytecodeParser''setCurrentFrameState-2 this, startFrameState)
            _ (§ ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), 0))
            #_"BciBlock" startBlock (:startBlock (:blockMap this))
        ]
            (when (nil? (:parent this))
                (let [
                    #_"StartNode" startNode (:start (:graph this))
                ]
                    (cond
                        (#_"ResolvedJavaMethod" .isSynchronized (:method this))
                            (BeginStateSplitNode''setStateAfter-2 startNode, (BytecodeParser''createFrameState-3 this, BytecodeFrame/BEFORE_BCI, startNode))
                        (BytecodeParser''parsingIntrinsic-1 this)
                            (when (nil? (BeginStateSplitNode''stateAfter-1 startNode))
                                (BeginStateSplitNode''setStateAfter-2 startNode, (BytecodeParser''createStateAfterStartOfReplacementGraph-1 this))
                            )
                        :else
                            (do
                                (FrameStateBuilder''clearNonLiveLocals-4 (:frameState this), startBlock, (:liveness this), true)
                                (BeginStateSplitNode''setStateAfter-2 startNode, (BytecodeParser''createFrameState-3 this, (BytecodeParser''bci-1 this), startNode))
                            )
                    )
                )
            )

            (let [
                this
                    (when (#_"ResolvedJavaMethod" .isSynchronized (:method this)) => this
                        ;; add a monitor enter to the start block
                        (let [
                            this (assoc this :methodSynchronizedObject (BytecodeParser''synchronizedObject-3 this, (:frameState this), (:method this)))
                        ]
                            (FrameStateBuilder''clearNonLiveLocals-4 (:frameState this), startBlock, (:liveness this), true)
                            (BytecodeParser''genMonitorEnter-3 this, (:methodSynchronizedObject this), (BytecodeParser''bci-1 this))
                            this
                        )
                    )
                this (assoc this :currentBlock (:startBlock (:blockMap this)))
            ]
                (BytecodeParser''setEntryState-3 this, startBlock, (:frameState this))
                (if (:isLoopHeader startBlock)
                    (BytecodeParser''appendGoto-2 this, startBlock)
                    (BytecodeParser''setFirstInstruction-3 this, startBlock, (:lastInstr this))
                )

                (doseq [#_"BciBlock" block (:blocks (:blockMap this))]
                    (§ ass! this (BytecodeParser''processBlock-2 this, block))
                )
                this
            )
        )
    )

    ; @SuppressWarnings("try")
    (§ method! #_"BytecodeParser" BytecodeParser''buildRootMethod-1 [#_"BytecodeParser" this]
        (let [
            #_"FrameStateBuilder" startFrameState (FrameStateBuilder'new-3 this, (:code this), (:graph this))
        ]
            (FrameStateBuilder''initializeForMethodStart-3 startFrameState, (or (:eagerResolving (:graphBuilderConfig this)) (some? (:intrinsicContext this))), (:plugins (:graphBuilderConfig this)))

            (try (§ with [#_"IntrinsicScope" _ (when (some? (:intrinsicContext this)) (IntrinsicScope'new-1 this))])
                (§ ass! this (BytecodeParser''build-3 this, (:start (:graph this)), startFrameState))
            )

            (BytecodeParser''cleanupFinalGraph-1 this)
            (ComputeLoopFrequenciesClosure'compute-1 (:graph this))
            this
        )
    )

    ;;;
     ; Adds a node to the graph. If the node is in the graph, returns immediately. If the node is a StateSplit
     ; with a nil {@linkplain StateSplit#stateAfter() frame state}, the frame state is initialized.
     ;
     ; @param value the value to add to the graph and push to the stack. The {@code value.getJavaKind()} kind
     ;            is used when type checking this operation.
     ; @return a node equivalent to {@code value} in the graph
     ;;
    (§ method! #_"ValueNode" BytecodeParser''add-2 [#_"BytecodeParser" this, #_"ValueNode" value]
        (when (nil? (:graph value)) => value
            (let [
                value (BytecodeParser''append-2 this, value)
            ]
                (when (and (instance? StateSplit value) (nil? (StateSplit''stateAfter-1 value)) (StateSplit''hasSideEffect-1 value))
                    (BytecodeParser''setStateAfter-2 this, value)
                )
                value
            )
        )
    )

    #_unused
    (§ method! #_"ValueNode" BytecodeParser''addNonNullCast-2 [#_"BytecodeParser" this, #_"ValueNode" value]
        (if (:never-nil? (:stamp value))
            value
            (BytecodeParser''add-2 this, (PiNode'create-3 value, (AbstractPointerStamp''improveWith-2 (:stamp value), StampFactory'objectNonNullStamp), (BytecodeParser''add-2 this, (FixedGuardNode'new-4 (BytecodeParser''add-2 this, (IsNullNode'create-1 value)), DeoptimizationReason/NullCheckException, DeoptimizationAction/None, true))))
        )
    )

    ;;;
     ; Adds a node with a non-void kind to the graph, pushes it to the stack. If the returned node is a StateSplit
     ; with a nil {@linkplain StateSplit#stateAfter() frame state}, the frame state is initialized.
     ;
     ; @param kind the kind to use when type checking this operation
     ; @param value the value to add to the graph and push to the stack
     ; @return a node equivalent to {@code value} in the graph
     ;;
    (§ method! #_"ValueNode" BytecodeParser''addPush-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"ValueNode" value]
        (let [
            value (if (some? (:graph value)) value (BytecodeParser''append-2 this, value))
        ]
            (BytecodeParser''push-3 this, kind, value)
            (when (and (instance? StateSplit value) (nil? (StateSplit''stateAfter-1 value)) (StateSplit''hasSideEffect-1 value))
                (BytecodeParser''setStateAfter-2 this, value)
            )
            value
        )
    )

    (§ method! #_"StampPair" BytecodeParser''getInvokeReturnStamp-1 [#_"BytecodeParser" this]
        (StampFactory'forDeclaredType-2 (BytecodeParser''getInvokeReturnType-1 this), false)
    )

    ;;;
     ; Gets the inline depth of this context. A return value of 0 implies that this is the context for the parse root.
     ;;
    (§ method! #_"int" BytecodeParser''getDepth-1 [#_"BytecodeParser" this]
        (loop-when-recur [#_"int" depth 0 #_"BytecodeParser" parent (BytecodeParser''getParent-1 this)]
                         (some? parent)
                         [(inc depth) (BytecodeParser''getParent-1 parent)]
                      => depth
        )
    )

    ;;;
     ; Gets a version of a given value that has a {@linkplain StampTool#isPointerNonNull(ValueNode) non-nil} stamp.
     ;;
    (§ method! #_"ValueNode" BytecodeParser''nullCheckedValue-3 [#_"BytecodeParser" this, #_"ValueNode" value, #_"DeoptimizationAction" action]
        (when-not (StampTool'isPointerNeverNull-1 (:stamp value)) => value
            (let [
                #_"LogicNode" logic (Graph''add-2 (:graph this), (IsNullNode'create-1 value))
                #_"Stamp" stamp (Stamp''join-2 (:stamp value), StampFactory'objectNonNullStamp)
                #_"FixedGuardNode" fixedGuard (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/NullCheckException, action, true))
                #_"ValueNode" nonNullReceiver (Graph''addOrUniqueWithInputs-2 (:graph this), (PiNode'create-3 value, stamp, fixedGuard))
            ]
                ;; TODO Propogating the non-nil into the frame state would remove subsequent nil-checks on the same value.
                ;;
                ;; frameState.replace(value, nonNullReceiver);
                nonNullReceiver
            )
        )
    )

    (§ method! #_"ValueNode" BytecodeParser''nullCheckedValue-2 [#_"BytecodeParser" this, #_"ValueNode" value]
        (BytecodeParser''nullCheckedValue-3 this, value, DeoptimizationAction/InvalidateReprofile)
    )

    (§ method! #_"void" BytecodeParser''cleanupFinalGraph-1 [#_"BytecodeParser" this]
        (GraphUtil'normalizeLoops-1 (:graph this))

        ;; Remove dead parameters.
        (doseq [#_"ParameterNode" param (Graph''getNodes-2 (:graph this), ParameterNode'TYPE)]
            (when (Node''hasNoUsages-1 param)
                (Node''safeDelete-1 param)
            )
        )

        ;; Remove redundant begin nodes.
        (doseq [#_"BeginNode" beginNode (Graph''getNodes-2 (:graph this), BeginNode'TYPE)]
            (when (and (not (instance? ControlSplitNode (:predecessor beginNode))) (not (Node''hasUsages-1 beginNode)))
                (GraphUtil'unlinkFixedNode-1 beginNode)
                (Node''safeDelete-1 beginNode)
            )
        )
        nil
    )

    ;;;
     ; Creates the frame state after the start node of a graph for an {@link IntrinsicContext
     ; intrinsic} that is the parse root (either for root compiling or for post-parse inlining).
     ;;
    (§ method- #_"FrameState" BytecodeParser''createStateAfterStartOfReplacementGraph-1 [#_"BytecodeParser" this]
        (if (IntrinsicContext''isPostParseInlined-1 (:intrinsicContext this))
            (Graph''add-2 (:graph this), (FrameState'new-1 BytecodeFrame/BEFORE_BCI))
            (let [
                #_"ResolvedJavaMethod" original (:originalMethod (:intrinsicContext this))
                #_"ValueNode[]" locals
                    (if (or (= (#_"ResolvedJavaMethod" .getMaxLocals original) (count (:locals (:frameState this)))) (#_"ResolvedJavaMethod" .isNative original))
                        (let [
                            locals (make-array ValueNode (#_"ResolvedJavaMethod" .getMaxLocals original))
                        ]
                            (dotimes [#_"int" i (count locals)]
                                (let [
                                    #_"ValueNode" node (nth (:locals (:frameState this)) i)
                                ]
                                    (aset locals i (when-not (= node FrameState'TWO_SLOT_MARKER) node))
                                )
                            )
                            locals
                        )
                        (let [
                            locals (make-array ValueNode (#_"ResolvedJavaMethod" .getMaxLocals original))
                            #_"int" n (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature original), (not (#_"ResolvedJavaMethod" .isStatic original)))
                        ]
                            (dotimes [#_"int" i n]
                                (let [
                                    #_"ValueNode" param (nth (:locals (:frameState this)) i)
                                ]
                                    (aset locals i (when-not (= param FrameState'TWO_SLOT_MARKER) param))
                                )
                            )
                            locals
                        )
                    )
            ]
                (Graph''add-2 (:graph this), (FrameState'new-9 nil, (ResolvedJavaMethodBytecode'new-1 original), 0, locals, (make-array ValueNode 0), 0, (make-array ValueNode 0), (Collections/emptyList), false))
            )
        )
    )

    ;;;
     ; @param type the unresolved type of the constant
     ;;
    (§ method! #_"void" BytecodeParser''handleUnresolvedLoadConstant-2 [#_"BytecodeParser" this, #_"JavaType" type]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    ;;;
     ; @param type the unresolved type of the type check
     ; @param object the object value whose type is being checked against {@code type}
     ;;
    (§ method! #_"void" BytecodeParser''handleUnresolvedCheckCast-3 [#_"BytecodeParser" this, #_"JavaType" type, #_"ValueNode" object]
        (BytecodeParser''append-2 this, (FixedGuardNode'new-3 (Graph''addOrUniqueWithInputs-2 (:graph this), (IsNullNode'create-1 object)), DeoptimizationReason/Unresolved, DeoptimizationAction/InvalidateRecompile))
        (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''appendConstant-2 this, JavaConstant/NULL_POINTER)))
        nil
    )

    ;;;
     ; @param type the unresolved type of the type check
     ; @param object the object value whose type is being checked against {@code type}
     ;;
    (§ method! #_"BytecodeParser" BytecodeParser''handleUnresolvedInstanceOf-3 [#_"BytecodeParser" this, #_"JavaType" type, #_"ValueNode" object]
        (let [
            #_"AbstractBeginNode" successor (Graph''add-2 (:graph this), (BeginNode'new-0))
            #_"DeoptimizeNode" deopt (Graph''add-2 (:graph this), (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        ]
            (BytecodeParser''append-2 this, (IfNode'new-4 (Graph''addOrUniqueWithInputs-2 (:graph this), (IsNullNode'create-1 object)), successor, deopt, 1))
            (let [
                this (assoc this :lastInstr successor)
            ]
                (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''appendConstant-2 this, JavaConstant/INT_0)))
                this
            )
        )
    )

    ;;;
     ; @param type the type being instantiated
     ;;
    (§ method! #_"void" BytecodeParser''handleUnresolvedNewInstance-2 [#_"BytecodeParser" this, #_"JavaType" type]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    ;;;
     ; @param type the type of the array being instantiated
     ; @param length the length of the array
     ;;
    (§ method! #_"void" BytecodeParser''handleUnresolvedNewObjectArray-3 [#_"BytecodeParser" this, #_"JavaType" type, #_"ValueNode" length]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    ;;;
     ; @param field the unresolved field
     ; @param receiver the object containing the field or nil if {@code field} is static
     ;;
    (§ method! #_"void" BytecodeParser''handleUnresolvedLoadField-3 [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" receiver]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    ;;;
     ; @param field the unresolved field
     ; @param value the value being stored to the field
     ; @param receiver the object containing the field or nil if {@code field} is static
     ;;
    (§ method! #_"void" BytecodeParser''handleUnresolvedStoreField-4 [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" value, #_"ValueNode" receiver]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    (§ method! #_"void" BytecodeParser''handleUnresolvedInvoke-3 [#_"BytecodeParser" this, #_"JavaMethod" javaMethod, #_"InvokeKind" invokeKind]
        (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/Unresolved))
        nil
    )

    (§ method! #_"ValueNode" BytecodeParser''genLoadIndexed-4 [#_"BytecodeParser" this, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" kind]
        (LoadIndexedNode'create-3 array, index, kind)
    )

    (§ method! #_"void" BytecodeParser''genStoreIndexed-5 [#_"BytecodeParser" this, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" kind, #_"ValueNode" value]
        (BytecodeParser''add-2 this, (StoreIndexedNode'new-4 array, index, kind, value))
        nil
    )

    (§ method! #_"ValueNode" BytecodeParser''genIntegerAdd-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (AddNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genIntegerSub-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (SubNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genIntegerMul-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (MulNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genIntegerDiv-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (SignedDivNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genIntegerRem-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (SignedRemNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genNegateOp-2 [#_"BytecodeParser" this, #_"ValueNode" x]
        (NegateNode'create-1 x)
    )

    (§ method! #_"ValueNode" BytecodeParser''genLeftShift-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (LeftShiftNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genRightShift-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (RightShiftNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genUnsignedRightShift-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (UnsignedRightShiftNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genAnd-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (AndNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genOr-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (OrNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genXor-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (XorNode'create-2 x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genNormalizeCompare-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (NormalizeCompareNode'create-3 x, y, JavaKind/Int)
    )

    (§ method! #_"ValueNode" BytecodeParser''genNarrow-3 [#_"BytecodeParser" this, #_"ValueNode" input, #_"int" bitCount]
        (NarrowNode'create-2 input, bitCount)
    )

    (§ method! #_"ValueNode" BytecodeParser''genSignExtend-3 [#_"BytecodeParser" this, #_"ValueNode" input, #_"int" bitCount]
        (SignExtendNode'create-2 input, bitCount)
    )

    (§ method! #_"ValueNode" BytecodeParser''genZeroExtend-3 [#_"BytecodeParser" this, #_"ValueNode" input, #_"int" bitCount]
        (ZeroExtendNode'create-2 input, bitCount)
    )

    (§ method! #_"void" BytecodeParser''genGoto-1 [#_"BytecodeParser" this]
        (BytecodeParser''appendGoto-2 this, (BciBlock''getSuccessor-2 (:currentBlock this), 0))
        nil
    )

    (§ method! #_"LogicNode" BytecodeParser''genObjectEquals-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (ObjectEqualsNode'createCanonical-2 x, y)
    )

    (§ method! #_"LogicNode" BytecodeParser''genIntegerEquals-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (IntegerEqualsNode'create-3 nil, x, y)
    )

    (§ method! #_"LogicNode" BytecodeParser''genIntegerLessThan-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" y]
        (IntegerLessThanNode'create-3 nil, x, y)
    )

    (§ method! #_"ValueNode" BytecodeParser''genUnique-2 [#_"BytecodeParser" this, #_"ValueNode" x]
        (Graph''addOrUniqueWithInputs-2 (:graph this), x)
    )

    (§ method! #_"LogicNode" BytecodeParser''genUnique-2 [#_"BytecodeParser" this, #_"LogicNode" x]
        (Graph''addOrUniqueWithInputs-2 (:graph this), x)
    )

    (§ method! #_"ValueNode" BytecodeParser''genIfNode-5 [#_"BytecodeParser" this, #_"LogicNode" logic, #_"FixedNode" falseSuccessor, #_"FixedNode" trueSuccessor, #_"double" d]
        (IfNode'new-4 logic, falseSuccessor, trueSuccessor, d)
    )

    (§ method! #_"LogicNode" BytecodeParser''createInstanceOf-3 [#_"BytecodeParser" this, #_"TypeReference" type, #_"ValueNode" object]
        (InstanceOfNode'create-2 type, object)
    )

    (§ method! #_"LogicNode" BytecodeParser''createInstanceOfAllowNull-3 [#_"BytecodeParser" this, #_"TypeReference" type, #_"ValueNode" object]
        (InstanceOfNode'createAllowNull-2 type, object)
    )

    (§ method! #_"ValueNode" BytecodeParser''genConditional-2 [#_"BytecodeParser" this, #_"ValueNode" logic]
        (ConditionalNode'create-1 (§ cast #_"LogicNode" logic))
    )

    (§ method! #_"NewInstanceNode" BytecodeParser''createNewInstance-3 [#_"BytecodeParser" this, #_"ResolvedJavaType" type, #_"boolean" fillContents]
        (NewInstanceNode'new-2 type, fillContents)
    )

    (§ method! #_"NewArrayNode" BytecodeParser''createNewArray-4 [#_"BytecodeParser" this, #_"ResolvedJavaType" elementType, #_"ValueNode" length, #_"boolean" fillContents]
        (NewArrayNode'new-3 elementType, length, fillContents)
    )

    (§ method! #_"ValueNode" BytecodeParser''genLoadField-3 [#_"BytecodeParser" this, #_"ValueNode" receiver, #_"ResolvedJavaField" field]
        (let [
            #_"StampPair" stamp (Plugins''getOverridingStamp-4 (:plugins (:graphBuilderConfig this)), this, (#_"ResolvedJavaField" .getType field), false)
        ]
            (if (some? stamp)
                (LoadFieldNode'createOverrideStamp-5 stamp, receiver, field, false, false)
                (LoadFieldNode'create-4 receiver, field, false, false)
            )
        )
    )

    (§ method! #_"StateSplitProxyNode" BytecodeParser''genVolatileFieldReadProxy-2 [#_"BytecodeParser" this, #_"ValueNode" fieldRead]
        (StateSplitProxyNode'new-1 fieldRead)
    )

    (§ method! #_"void" BytecodeParser''genStoreField-4 [#_"BytecodeParser" this, #_"ValueNode" receiver, #_"ResolvedJavaField" field, #_"ValueNode" value]
        (let [
            #_"StoreFieldNode" storeFieldNode (StoreFieldNode'new-3 receiver, field, value)
        ]
            (BytecodeParser''append-2 this, storeFieldNode)
            (StoreFieldNode''setStateAfter-2 storeFieldNode, (BytecodeParser''createFrameState-3 this, (:nextBCI (:stream this)), storeFieldNode))
        )
        nil
    )

    ;;;
     ; Ensure that concrete classes are at least linked before generating an invoke. Interfaces may
     ; never be linked so simply return true for them.
     ;
     ; @return true if the declared holder is an interface or is linked
     ;;
    (§ defn- #_"boolean" BytecodeParser'callTargetIsResolved-1 [#_"JavaMethod" target]
        (and (instance? ResolvedJavaMethod target)
            (let [
                #_"ResolvedJavaType" type (#_"ResolvedJavaMethod" .getDeclaringClass target)
            ]
                (or (#_"ResolvedJavaType" .isInterface type) (#_"ResolvedJavaType" .isLinked type))
            )
        )
    )

    (§ method! #_"void" BytecodeParser''genInvokeStatic-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeStatic-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (§ method! #_"void" BytecodeParser''genInvokeStatic-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (if (and (BytecodeParser'callTargetIsResolved-1 target) (or (#_"ResolvedJavaType" .isInitialized (#_"ResolvedJavaMethod" .getDeclaringClass target)) (not GraalOptions'resolveClassBeforeStaticInvoke)))
            (let [
                #_"InvokeNode" invoke (BytecodeParser''appendInvoke-4 this, InvokeKind'Static, target, (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature target), false)))
            ]
                (when (some? invoke)
                    (§ ass! invoke (InvokeNode''setClassInit-2 invoke, nil))
                )
            )
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Static)
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''genInvokeInterface-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeInterface-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (§ method! #_"void" BytecodeParser''genInvokeInterface-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (if (BytecodeParser'callTargetIsResolved-1 target)
            (BytecodeParser''appendInvoke-4 this, InvokeKind'Interface, target, (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"JavaMethod" .getSignature target), true)))
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Interface)
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''genInvokeDynamic-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeDynamic-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (§ method! #_"void" BytecodeParser''genInvokeDynamic-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (when-not (and (instance? ResolvedJavaMethod target) (BytecodeParser''genDynamicInvokeHelper-4 this, target, (BytecodeStream''readCPI4-1 (:stream this)), Bytecodes'INVOKEDYNAMIC))
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Static)
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''genInvokeVirtual-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeVirtual-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (§ method- #_"boolean" BytecodeParser''genDynamicInvokeHelper-4 [#_"BytecodeParser" this, #_"ResolvedJavaMethod" target, #_"int" cpi, #_"int" opcode]
        (let [
            #_"InvokeDynamicPlugin" invokeDynamicPlugin (:invokeDynamicPlugin (:plugins (:graphBuilderConfig this)))
        ]
            (if (and (= opcode Bytecodes'INVOKEVIRTUAL) (some? invokeDynamicPlugin) (not (InvokeDynamicPlugin''isResolvedDynamicInvoke-4 invokeDynamicPlugin, this, cpi, opcode)))
                false ;; regular invokevirtual, let caller handle it
                (let [
                    #_"JavaConstant" appendix (#_"ConstantPool" .lookupAppendix (:constantPool this), cpi, opcode)
                ]
                    (when (some? appendix)
                        (let [
                            #_"ValueNode" appendixNode
                                (if (some? invokeDynamicPlugin)
                                    (do
                                        (InvokeDynamicPlugin''recordDynamicMethod-5 invokeDynamicPlugin, this, cpi, opcode, target)

                                        ;; will perform runtime type checks and static initialization
                                        (let [
                                            #_"FrameState" stateBefore (FrameStateBuilder''create-6 (:frameState this), (BytecodeParser''bci-1 this), (BytecodeParser''getNonIntrinsicAncestor-1 this), false, nil, nil)
                                        ]
                                            (InvokeDynamicPlugin''genAppendixNode-6 invokeDynamicPlugin, this, cpi, opcode, appendix, stateBefore)
                                        )
                                    )
                                    (ConstantNode'forConstant-2 appendix, (:graph this))
                                )
                        ]
                            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, appendixNode))
                        )
                    )

                    (let [
                        #_"boolean" hasReceiver (and (not= opcode Bytecodes'INVOKEDYNAMIC) (not (#_"ResolvedJavaMethod" .isStatic target)))
                        #_"ValueNode[]" args (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature target), hasReceiver))
                    ]
                        (BytecodeParser''appendInvoke-4 this, (if hasReceiver InvokeKind'Virtual InvokeKind'Static), target, args)

                        true
                    )
                )
            )
        )
    )

    (§ method! #_"void" BytecodeParser''genInvokeVirtual-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (when-not (BytecodeParser''genInvokeVirtualHelper-2 this, target)
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Virtual)
        )
        nil
    )

    (§ method- #_"boolean" BytecodeParser''genInvokeVirtualHelper-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (and (BytecodeParser'callTargetIsResolved-1 target)
            (let [
                #_"int" cpi (BytecodeStream''readCPI-1 (:stream this))
            ]
                ;; Special handling for runtimes that rewrite an invocation of MethodHandle.invoke(...) or
                ;; MethodHandle.invokeExact(...) to a static adapter. HotSpot does this - see
                ;; https://wiki.openjdk.java.net/display/HotSpot/Method+handles+and+invokedynamic

                (or (BytecodeParser''genDynamicInvokeHelper-4 this, target, cpi, Bytecodes'INVOKEVIRTUAL)
                    (let [
                        #_"ValueNode[]" args (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"JavaMethod" .getSignature target), true))
                    ]
                        (BytecodeParser''appendInvoke-4 this, InvokeKind'Virtual, target, args)

                        true
                    )
                )
            )
        )
    )

    (§ method! #_"void" BytecodeParser''genInvokeSpecial-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genInvokeSpecial-2 this, (BytecodeParser''lookupMethod-3 this, cpi, opcode))
        nil
    )

    (§ method! #_"void" BytecodeParser''genInvokeSpecial-2 [#_"BytecodeParser" this, #_"JavaMethod" target]
        (if (BytecodeParser'callTargetIsResolved-1 target)
            (BytecodeParser''appendInvoke-4 this, InvokeKind'Special, target, (FrameStateBuilder''popArguments-2 (:frameState this), (#_"Signature" .getParameterCount (#_"JavaMethod" .getSignature target), true)))
            (BytecodeParser''handleUnresolvedInvoke-3 this, target, InvokeKind'Special)
        )
        nil
    )

    (§ mutable #_"CurrentInvoke" :currentInvoke nil)
    (§ mutable #_"FrameStateBuilder" :frameState nil)
    (§ mutable #_"BciBlock" :currentBlock nil)
    (§ final #_"BytecodeStream" :stream nil)
    (§ final #_"GraphBuilderConfiguration" :graphBuilderConfig nil)
    (§ final #_"ResolvedJavaMethod" :method nil)
    (§ final #_"Bytecode" :code nil)
    (§ final #_"BytecodeProvider" :bytecodeProvider nil)
    (§ final #_"OptimisticOptimizations" :optimisticOpts nil)
    (§ final #_"ConstantPool" :constantPool nil)
    (§ final #_"IntrinsicContext" :intrinsicContext nil)

    ;;;
     ; Gets the kind of invocation currently being parsed.
     ;;
    (§ method! #_"InvokeKind" BytecodeParser''getInvokeKind-1 [#_"BytecodeParser" this]
        (when (some? (:currentInvoke this)) (:kind (:currentInvoke this)))
    )

    ;;;
     ; Gets the return type of the invocation currently being parsed.
     ;;
    (§ method! #_"JavaType" BytecodeParser''getInvokeReturnType-1 [#_"BytecodeParser" this]
        (when (some? (:currentInvoke this)) (:returnType (:currentInvoke this)))
    )

    (§ mutable #_"boolean" :forceInliningEverything false)

    ;;;
     ; Handles an invocation that a plugin determines can replace the original invocation (i.e. the one
     ; for which the plugin was applied). This applies all standard graph builder processing to the replaced
     ; invocation including applying any relevant plugins.
     ;
     ; @param invokeKind the kind of the replacement invocation
     ; @param targetMethod the target of the replacement invocation
     ; @param args the arguments to the replacement invocation
     ; @param forceInliningEverything specifies if all invocations encountered in the scope of handling
     ;            the replaced invoke are to be force inlined
     ;;
    (§ method! #_"BytecodeParser" BytecodeParser''handleReplacedInvoke-5 [#_"BytecodeParser" this, #_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode[]" args, #_"boolean" forceInliningEverything]
        (let [
            #_"boolean" previous (:forceInliningEverything this)
            this (assoc this :forceInliningEverything (or previous forceInliningEverything))
        ]
            (try
                (BytecodeParser''appendInvoke-4 this, invokeKind, targetMethod, args)
                (finally
                    (§ ass! this (assoc this :forceInliningEverything previous))
                )
            )
            this
        )
    )

    #_unused
    (§ method! #_"void" BytecodeParser''handleReplacedInvoke-3 [#_"BytecodeParser" this, #_"CallTargetNode" callTarget, #_"JavaKind" resultType]
        (BytecodeParser''createInvoke-4 this, (BytecodeParser''bci-1 this), callTarget, resultType)
        nil
    )

    (§ method! #_"InvokeNode" BytecodeParser''appendInvoke-4 [#_"BytecodeParser" this, #_"InvokeKind" initialInvokeKind, #_"ResolvedJavaMethod" initialTargetMethod, #_"ValueNode[]" args]
        (let [
            [#_"ResolvedJavaMethod" targetMethod #_"InvokeKind" invokeKind]
                (when (InvokeKind''isIndirect-1 initialInvokeKind) => [initialTargetMethod initialInvokeKind]
                    (let [
                        #_"ResolvedJavaType" contextType (#_"ResolvedJavaMethod" .getDeclaringClass (FrameStateBuilder''getMethod-1 (:frameState this)))
                        #_"ResolvedJavaMethod" specialCallTarget (MethodCallTargetNode'findSpecialCallTarget-4 initialInvokeKind, (nth args 0), initialTargetMethod, contextType)
                    ]
                        (when (some? specialCallTarget) => [initialTargetMethod initialInvokeKind]
                            [specialCallTarget InvokeKind'Special]
                        )
                    )
                )
            #_"JavaKind" resultType (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature targetMethod))
        ]
            (if (and (not (BytecodeParser''parsingIntrinsic-1 this)) GraalOptions'deoptALot)
                (do
                    (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/None, DeoptimizationReason/RuntimeConstraint))
                    (§ ass! (:frameState this) (FrameStateBuilder''pushReturn-3 (:frameState this), resultType, (ConstantNode'defaultForKind-2 resultType, (:graph this))))
                    nil
                )
                (let [
                    #_"JavaType" returnType (#_"Signature" .getReturnType (#_"ResolvedJavaMethod" .getSignature targetMethod), (#_"ResolvedJavaMethod" .getDeclaringClass (:method this)))
                    returnType
                        (if (or (:eagerResolving (:graphBuilderConfig this)) (BytecodeParser''parsingIntrinsic-1 this))
                            (#_"JavaType" .resolve returnType, (#_"ResolvedJavaMethod" .getDeclaringClass targetMethod))
                            returnType
                        )
                ]
                    (when (and (= initialInvokeKind InvokeKind'Special) (not (#_"ResolvedJavaMethod" .isConstructor targetMethod)))
                        (BytecodeParser''emitCheckForInvokeSuperSpecial-2 this, args)
                    )
                    (try
                        (§ ass! this (assoc this :currentInvoke (CurrentInvoke'new-3 args, invokeKind, returnType)))
                        (when (BytecodeParser''tryNodePluginForInvocation-3 this, args, targetMethod)
                            (§ return nil)
                        )

                        (when (and (InvokeKind''hasReceiver-1 invokeKind) (ValueNode''isNullConstant-1 (nth args 0)))
                            (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/NullCheckException))
                            (§ return nil)
                        )

                        (when (and (:direct invokeKind) (= (BytecodeParser''tryInline-3 this, args, targetMethod) BytecodeParser'SUCCESSFULLY_INLINED))
                            (§ return nil)
                        )
                        (finally
                            (§ ass! this (assoc this :currentInvoke nil))
                        )
                    )

                    (let [
                        #_"int" invokeBci (BytecodeParser''bci-1 this)
                        #_"boolean" partialIntrinsicExit
                            (when (and (some? (:intrinsicContext this)) (IntrinsicContext''isCallToOriginal-2 (:intrinsicContext this), targetMethod)) => false
                                (let [
                                    #_"ResolvedJavaMethod" originalMethod (:originalMethod (:intrinsicContext this))
                                    #_"BytecodeParser" intrinsicCallSiteParser (BytecodeParser''getNonIntrinsicAncestor-1 this)
                                ]
                                    (if (some? intrinsicCallSiteParser)
                                        (do
                                            ;; When exiting a partial intrinsic, the invoke to the original
                                            ;; must use the same context as the call to the intrinsic.
                                            (§ ass invokeBci (BytecodeParser''bci-1 intrinsicCallSiteParser))
                                        )
                                        (do
                                            ;; We are parsing the intrinsic for the root compilation or for inlining.
                                            ;; This call is a partial intrinsic exit, and we do not have profile information
                                            ;; for this callsite. We also have to assume that the call needs an exception
                                            ;; edge. Finally, we know that this intrinsic is parsed for late inlining,
                                            ;; so the bci must be set to unknown, so that the inliner patches it later.
                                            (§ ass invokeBci BytecodeFrame/UNKNOWN_BCI)
                                        )
                                    )

                                    (if (#_"ResolvedJavaMethod" .isStatic originalMethod)
                                        (§ ass invokeKind InvokeKind'Static)
                                        ;; The original call to the intrinsic must have been devirtualized,
                                        ;; otherwise we wouldn't be here.
                                        (§ ass invokeKind InvokeKind'Special)
                                    )
                                    (let [
                                        #_"Signature" sig (#_"ResolvedJavaMethod" .getSignature originalMethod)
                                    ]
                                        (§ ass returnType (#_"Signature" .getReturnType sig, (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))))
                                        (§ ass resultType (#_"Signature" .getReturnKind sig))
                                        (§ ass targetMethod originalMethod)
                                        true
                                    )
                                )
                            )
                        #_"InvokeNode" invoke (BytecodeParser''createNonInlinedInvoke-7 this, invokeBci, args, targetMethod, invokeKind, resultType, returnType)
                    ]
                        (when partialIntrinsicExit
                            ;; This invoke must never be later inlined as it might select the intrinsic graph.
                            ;; Until there is a mechanism to guarantee that any late inlining will not select
                            ;; the intrinsic graph, prevent this invoke from being inlined.
                            (§ ass! invoke (InvokeNode''setUseForInlining-2 invoke, false))
                        )
                        invoke
                    )
                )
            )
        )
    )

    ;;;
     ; Checks that the class of the receiver of an Bytecodes#INVOKESPECIAL in a method
     ; declared in an interface (i.e. a default method) is assignable to the interface.
     ; If not, then deoptimize so that the interpreter can throw an IllegalAccessError.
     ;
     ; This is a check not performed by the verifier and so must be performed at runtime.
     ;
     ; @param args arguments to an Bytecodes#INVOKESPECIAL implementing a direct call to a method in a super class
     ;;
    (§ method! #_"void" BytecodeParser''emitCheckForInvokeSuperSpecial-2 [#_"BytecodeParser" this, #_"ValueNode[]" args]
        (let [
            #_"ResolvedJavaType" callingClass (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))
            callingClass
                (when (some? (#_"ResolvedJavaType" .getHostClass callingClass)) => callingClass
                    (#_"ResolvedJavaType" .getHostClass callingClass)
                )
        ]
            (when (#_"ResolvedJavaType" .isInterface callingClass)
                (let [
                    #_"ValueNode" receiver (nth args 0)
                    #_"TypeReference" checkedType (TypeReference'createTrusted-1 callingClass)
                    #_"LogicNode" logic (BytecodeParser''genUnique-2 this, (BytecodeParser''createInstanceOf-3 this, checkedType, receiver))
                    #_"FixedGuardNode" fixedGuard (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/ClassCastException, DeoptimizationAction/None, false))
                ]
                    (aset args 0 (BytecodeParser''append-2 this, (PiNode'create-3 receiver, (StampFactory'object-2 checkedType, true), fixedGuard)))
                )
            )
        )
        nil
    )

    (§ method! #_"InvokeNode" BytecodeParser''createNonInlinedInvoke-7 [#_"BytecodeParser" this, #_"int" invokeBci, #_"ValueNode[]" invokeArgs, #_"ResolvedJavaMethod" targetMethod, #_"InvokeKind" invokeKind, #_"JavaKind" resultType, #_"JavaType" returnType]
        (let [
            #_"StampPair" returnStamp
                (or (Plugins''getOverridingStamp-4 (:plugins (:graphBuilderConfig this)), this, returnType, false)
                    (StampFactory'forDeclaredType-2 returnType, false)
                )
            #_"MethodCallTargetNode" callTarget (Graph''add-2 (:graph this), (MethodCallTargetNode'new-4 invokeKind, targetMethod, invokeArgs, returnStamp))
            #_"InvokeNode" invoke (BytecodeParser''createInvoke-4 this, invokeBci, callTarget, resultType)
        ]
            (doseq [#_"InlineInvokePlugin" plugin (:inlineInvokePlugins (:plugins (:graphBuilderConfig this)))]
                (InlineInvokePlugin''notifyNotInlined-4 plugin, this, targetMethod, invoke)
            )

            invoke
        )
    )

    (§ method- #_"boolean" BytecodeParser''tryNodePluginForInvocation-3 [#_"BytecodeParser" this, #_"ValueNode[]" args, #_"ResolvedJavaMethod" targetMethod]
        (loop [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))]
            (and (some? s)
                (or (NodePlugin''handleInvoke-4 (first s), this, targetMethod, args)
                    (recur (next s))
                )
            )
        )
    )

    (§ def- #_"InlineInvokeInfo" BytecodeParser'SUCCESSFULLY_INLINED (InlineInvokeInfo'createStandardInlineInfo-1 nil))

    ;;;
     ; Try to inline a method. If the method was inlined, returns #SUCCESSFULLY_INLINED.
     ; Otherwise, it returns the InlineInvokeInfo that lead to the decision to not
     ; inline it, or nil if there is no InlineInvokeInfo for this method.
     ;;
    (§ method- #_"InlineInvokeInfo" BytecodeParser''tryInline-3 [#_"BytecodeParser" this, #_"ValueNode[]" args, #_"ResolvedJavaMethod" targetMethod]
        (when (or (:forceInliningEverything this) (BytecodeParser''parsingIntrinsic-1 this) (#_"ResolvedJavaMethod" .canBeInlined targetMethod))
            (if (:forceInliningEverything this)
                (when (BytecodeParser''inline-5 this, targetMethod, targetMethod, nil, args)
                    BytecodeParser'SUCCESSFULLY_INLINED
                )
                (loop [#_"ISeq" s (seq (:inlineInvokePlugins (:plugins (:graphBuilderConfig this))))]
                    (if (some? s)
                        (let [
                            #_"InlineInvokeInfo" inlineInfo (InlineInvokePlugin''shouldInlineInvoke-4 (first s), this, targetMethod, args)
                        ]
                            (when (some? inlineInfo) => (recur (next s))
                                (when (some? (:methodToInline inlineInfo)) => inlineInfo ;; do not inline, and do not ask the remaining plugins
                                    (when (BytecodeParser''inline-5 this, targetMethod, (:methodToInline inlineInfo), (:intrinsicBytecodeProvider inlineInfo), args)
                                        BytecodeParser'SUCCESSFULLY_INLINED
                                    )
                                )
                            )
                        )
                        ;; There was no inline plugin with a definite answer to whether or not to inline.
                        ;; If we're parsing an intrinsic, then we need to enforce the invariant here
                        ;; that methods are always force inlined in intrinsics/snippets.
                        (when (and (BytecodeParser''parsingIntrinsic-1 this) (BytecodeParser''inline-5 this, targetMethod, targetMethod, (:bytecodeProvider this), args))
                            BytecodeParser'SUCCESSFULLY_INLINED
                        )
                    )
                )
            )
        )
    )

    (def- #_"int" BytecodeParser'ACCESSOR_BYTECODE_LENGTH 5)

    ;;;
     ; Tries to inline {@code targetMethod} if it is an instance field accessor. This avoids the
     ; overhead of creating and using a nested BytecodeParser object.
     ;;
    (§ method- #_"boolean" BytecodeParser''tryFastInlineAccessor-3 [#_"BytecodeParser" this, #_"ValueNode[]" args, #_"ResolvedJavaMethod" targetMethod]
        (let [
            #_"byte[]" bytecode (#_"ResolvedJavaMethod" .getCode targetMethod)
        ]
            (and (some? bytecode) (= (count bytecode) BytecodeParser'ACCESSOR_BYTECODE_LENGTH) (= (Bytes'beU1-2 bytecode, 0) Bytecodes'ALOAD_0) (= (Bytes'beU1-2 bytecode, 1) Bytecodes'GETFIELD)
                (let [
                    #_"int" b4 (Bytes'beU1-2 bytecode, 4)
                ]
                    (and (<= Bytecodes'IRETURN b4 Bytecodes'ARETURN)
                        (let [
                            #_"int" cpi (Bytes'beU2-2 bytecode, 2)
                            #_"JavaField" field (#_"ConstantPool" .lookupField (#_"ResolvedJavaMethod" .getConstantPool targetMethod), cpi, targetMethod, Bytecodes'GETFIELD)
                        ]
                            (and (instance? ResolvedJavaField field)
                                (do
                                    (BytecodeParser''genGetField-3 this, field, (Receiver''get-1 (InvocationPluginReceiver''init-3 (:invocationPluginReceiver this), targetMethod, args)))
                                    (BytecodeParser''notifyBeforeInline-2 this, targetMethod)
                                    (BytecodeParser''notifyAfterInline-2 this, targetMethod)
                                    true
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method- #_"boolean" BytecodeParser''inline-5 [#_"BytecodeParser" this, #_"ResolvedJavaMethod" targetMethod, #_"ResolvedJavaMethod" inlinedMethod, #_"BytecodeProvider" intrinsicBytecodeProvider, #_"ValueNode[]" args]
        (let [
            #_"IntrinsicContext" intrinsic (:intrinsicContext this)
        ]
            (or (and (nil? intrinsic) (= targetMethod inlinedMethod) (zero? (& (#_"ResolvedJavaMethod" .getModifiers targetMethod) (| Modifier/STATIC Modifier/SYNCHRONIZED))) (BytecodeParser''tryFastInlineAccessor-3 this, args, targetMethod))
                (if (and (some? intrinsic) (IntrinsicContext''isCallToOriginal-2 intrinsic, targetMethod))
                    (if (IntrinsicContext''isCompilationRoot-1 intrinsic)
                        (do
                            ;; A root compiled intrinsic needs to deoptimize if the slow path is taken. During frame state
                            ;; assignment, the deopt node will get its stateBefore from the start node of the intrinsic.
                            (BytecodeParser''append-2 this, (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateRecompile, DeoptimizationReason/RuntimeConstraint))
                            true
                        )
                        (and (not (#_"ResolvedJavaMethod" .isNative (:originalMethod intrinsic)))
                            (BytecodeParser''canInlinePartialIntrinsicExit-1 this) GraalOptions'inlinePartialIntrinsicExitDuringParsing
                            (do
                                ;; Otherwise inline the original method. Any frame state created during the inlining
                                ;; will exclude frame(s) in the intrinsic method (see FrameStateBuilder.create(int bci)).
                                (BytecodeParser''notifyBeforeInline-2 this, inlinedMethod)
                                (§ ass! this (BytecodeParser''parseAndInlineCallee-4 this, (:originalMethod intrinsic), args, nil))
                                (BytecodeParser''notifyAfterInline-2 this, inlinedMethod)
                                true
                            )
                        )
                    )
                    (let [
                        intrinsic
                            (when (and (nil? intrinsic) (some? intrinsicBytecodeProvider)) => intrinsic
                                (IntrinsicContext'new-4 targetMethod, inlinedMethod, intrinsicBytecodeProvider, CompilationContext'INLINE_DURING_PARSING)
                            )
                    ]
                        (and (#_"ResolvedJavaMethod" .hasBytecodes inlinedMethod)
                            (do
                                (BytecodeParser''notifyBeforeInline-2 this, inlinedMethod)
                                (§ ass! this (BytecodeParser''parseAndInlineCallee-4 this, inlinedMethod, args, intrinsic))
                                (BytecodeParser''notifyAfterInline-2 this, inlinedMethod)
                                true
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"void" BytecodeParser''notifyBeforeInline-2 [#_"BytecodeParser" this, #_"ResolvedJavaMethod" inlinedMethod]
        (doseq [#_"InlineInvokePlugin" plugin (:inlineInvokePlugins (:plugins (:graphBuilderConfig this)))]
            (InlineInvokePlugin''notifyBeforeInline-2 plugin, inlinedMethod)
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''notifyAfterInline-2 [#_"BytecodeParser" this, #_"ResolvedJavaMethod" inlinedMethod]
        (doseq [#_"InlineInvokePlugin" plugin (:inlineInvokePlugins (:plugins (:graphBuilderConfig this)))]
            (InlineInvokePlugin''notifyAfterInline-2 plugin, inlinedMethod)
        )
        nil
    )

    ;;;
     ; Determines if a partial intrinsic exit (i.e. a call to the original method within an intrinsic) can be inlined.
     ;;
    (§ method! #_"boolean" BytecodeParser''canInlinePartialIntrinsicExit-1 [#_"BytecodeParser" this]
        true
    )

    (§ method! #_"BytecodeParser" BytecodeParser''parseAndInlineCallee-4 [#_"BytecodeParser" this, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode[]" args, #_"IntrinsicContext" calleeIntrinsicContext]
        (try (§ with [#_"IntrinsicScope" s (when (and (some? calleeIntrinsicContext) (not (BytecodeParser''parsingIntrinsic-1 this))) (IntrinsicScope'new-3 this, (#_"Signature" .toParameterKinds (#_"ResolvedJavaMethod" .getSignature targetMethod), (not (#_"ResolvedJavaMethod" .isStatic targetMethod))), args))])
            (let [
                #_"BytecodeParser" parser (BytecodeParser'new-5 (:graphBuilderInstance this), (:graph this), this, targetMethod, calleeIntrinsicContext)
                #_"FrameStateBuilder" startFrameState (FrameStateBuilder'new-3 parser, (:code parser), (:graph this))
            ]
                (when-not (#_"ResolvedJavaMethod" .isStatic targetMethod)
                    (aset args 0 (BytecodeParser''nullCheckedValue-2 this, (nth args 0)))
                )
                (FrameStateBuilder''initializeFromArgumentsArray-2 startFrameState, args)
                (let [
                    parser (BytecodeParser''build-3 parser, (:lastInstr this), startFrameState)
                    this
                        (when (some? (:returnDataList parser)) => (assoc this :lastInstr nil) ;; Callee does not return.
                            (let [
                                _
                                    (when (some? s)
                                        (§ ass! s (assoc s :returnDataList (:returnDataList parser)))
                                    )
                                [this #_"MergeNode" merge #_"ValueNode" calleeReturnValue]
                                    (if (= (count (:returnDataList parser)) 1)
                                        ;; Callee has a single return, we can continue parsing at that point.
                                        (let [
                                            #_"ReturnToCallerData" singleReturnData (nth (:returnDataList parser) 0)
                                            this (assoc this :lastInstr (:beforeReturnNode singleReturnData))
                                        ]
                                            [this nil (:returnValue singleReturnData)]
                                        )
                                        ;; Callee has multiple returns, we need to insert a control flow merge.
                                        (let [
                                            merge (Graph''add-2 (:graph this), (MergeNode'new-0))
                                            calleeReturnValue (ValueMergeUtil'mergeValueProducers-4 merge, (:returnDataList parser), (ß returnData -> (§ fun (:beforeReturnNode returnData))), (ß returnData -> (§ fun (:returnValue returnData))))
                                        ]
                                            [this merge calleeReturnValue]
                                        )
                                    )
                            ]
                                (when (some? calleeReturnValue)
                                    (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), (-> (#_"ResolvedJavaMethod" .getSignature targetMethod) (#_"Signature" .getReturnKind) (#_"JavaKind" .getStackKind)), calleeReturnValue))
                                )
                                (when (some? merge) => this
                                    (BeginStateSplitNode''setStateAfter-2 merge, (BytecodeParser''createFrameState-3 this, (:nextBCI (:stream this)), merge))
                                    (assoc this :lastInstr merge)
                                )
                            )
                        )
                ]
                    ;; Propagate any side effects into the caller when parsing intrinsics.
                    (when (and (FrameStateBuilder''isAfterSideEffect-1 (:frameState parser)) (BytecodeParser''parsingIntrinsic-1 this))
                        (doseq [#_"StateSplit" sideEffect (FrameStateBuilder''sideEffects-1 (:frameState parser))]
                            (FrameStateBuilder''addSideEffect-2 (:frameState this), sideEffect)
                        )
                    )
                    this
                )
            )
        )
    )

    (§ method! #_"InvokeNode" BytecodeParser''createInvoke-4 [#_"BytecodeParser" this, #_"int" invokeBci, #_"CallTargetNode" callTarget, #_"JavaKind" resultType]
        (let [
            #_"InvokeNode" invoke (BytecodeParser''append-2 this, (InvokeNode'new-2 callTarget, invokeBci))
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''pushReturn-3 (:frameState this), resultType, invoke))
            (AbstractStateSplit''setStateAfter-2 invoke, (BytecodeParser''createFrameState-3 this, (:nextBCI (:stream this)), invoke))
            invoke
        )
    )

    (§ method- #_"ValueNode" BytecodeParser''processReturnValue-3 [#_"BytecodeParser" this, #_"ValueNode" value, #_"JavaKind" kind]
        (let [
            #_"JavaKind" returnKind (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature (:method this)))
        ]
            (when-not (= kind returnKind) => value
                ;; sub-word integer
                (let [
                    #_"IntegerStamp" stamp (:stamp value)
                ]
                    ;; the bytecode verifier doesn't check that the value is in the correct range
                    (when (or (< (:lowerBound stamp) (#_"JavaKind" .getMinValue returnKind)) (< (#_"JavaKind" .getMaxValue returnKind) (:upperBound stamp))) => value
                        (let [
                            #_"ValueNode" narrow (BytecodeParser''append-2 this, (BytecodeParser''genNarrow-3 this, value, (#_"JavaKind" .getBitCount returnKind)))
                        ]
                            (if (#_"JavaKind" .isUnsigned returnKind)
                                (BytecodeParser''append-2 this, (BytecodeParser''genZeroExtend-3 this, narrow, 32))
                                (BytecodeParser''append-2 this, (BytecodeParser''genSignExtend-3 this, narrow, 32))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method- #_"void" BytecodeParser''beforeReturn-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"JavaKind" kind]
        (when (:finalBarrierRequired this)
            (BytecodeParser''append-2 this, (FinalFieldBarrierNode'new-1 (:originalReceiver this)))
        )
        (BytecodeParser''synchronizedEpilogue-4 this, BytecodeFrame/AFTER_BCI, x, kind)
        nil
    )

    (§ method! #_"BytecodeParser" BytecodeParser''genReturn-3 [#_"BytecodeParser" this, #_"ValueNode" returnVal, #_"JavaKind" returnKind]
        (when (and (BytecodeParser''parsingIntrinsic-1 this) (instance? StateSplit returnVal) (StateSplit''hasSideEffect-1 returnVal))
            (let [
                #_"FrameState" stateAfter (StateSplit''stateAfter-1 returnVal)
            ]
                (when (= (:bci stateAfter) BytecodeFrame/AFTER_BCI) ;; => must be the return value from within a partial intrinsification
                    (let [
                        stateAfter (Node''replaceAtUsages-2 stateAfter, (Graph''add-2 (:graph this), (FrameState'new-2 BytecodeFrame/AFTER_BCI, returnVal)))
                    ]
                        (GraphUtil'killWithUnusedFloatingInputs-1 stateAfter)
                    )
                )
            )
        )
        (let [
            #_"ValueNode" realReturnVal (BytecodeParser''processReturnValue-3 this, returnVal, returnKind)
            _ (§ ass! (:frameState this) (FrameStateBuilder''clearStack-1 (:frameState this)))
        ]
            (BytecodeParser''beforeReturn-3 this, realReturnVal, returnKind)
            (if (some? (:parent this))
                (let [
                    this
                        (when (nil? (:returnDataList this)) => this
                            (assoc this :returnDataList (ArrayList.))
                        )
                ]
                    (#_"ArrayList" .add (:returnDataList this), (ReturnToCallerData'new-2 realReturnVal, (:lastInstr this)))
                    (assoc this :lastInstr nil)
                )
                (do
                    (BytecodeParser''append-2 this, (ReturnNode'new-1 realReturnVal))
                    this
                )
            )
        )
    )

    (§ method! #_"MonitorEnterNode" BytecodeParser''createMonitorEnterNode-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"MonitorIdNode" monitorId]
        (MonitorEnterNode'new-2 x, monitorId)
    )

    (§ method! #_"void" BytecodeParser''genMonitorEnter-3 [#_"BytecodeParser" this, #_"ValueNode" x, #_"int" bci]
        (let [
            #_"MonitorIdNode" monitorId (Graph''add-2 (:graph this), (MonitorIdNode'new-1 (FrameStateBuilder''lockDepth-2 (:frameState this), true)))
            #_"MonitorEnterNode" monitorEnter (BytecodeParser''append-2 this, (BytecodeParser''createMonitorEnterNode-3 this, x, monitorId))
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''pushLock-3 (:frameState this), x, monitorId))
            (AbstractStateSplit''setStateAfter-2 monitorEnter, (BytecodeParser''createFrameState-3 this, bci, monitorEnter))
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''genMonitorExit-4 [#_"BytecodeParser" this, #_"ValueNode" x, #_"ValueNode" escapedReturnValue, #_"int" bci]
        (when (zero? (FrameStateBuilder''lockDepth-2 (:frameState this), false))
            (throw! "unbalanced monitors: too many exits")
        )
        (let [
            #_"MonitorIdNode" monitorId (FrameStateBuilder''peekMonitorId-1 (:frameState this))
            #_"ValueNode" lockedObject (FrameStateBuilder''popLock-1 (:frameState this))
        ]
            (when-not (= (GraphUtil'originalValue-1 lockedObject) (GraphUtil'originalValue-1 x))
                (throw! (str "unbalanced monitors: mismatch at monitorexit, " (GraphUtil'originalValue-1 x) " != " (GraphUtil'originalValue-1 lockedObject)))
            )
            (let [
                #_"MonitorExitNode" monitorExit (BytecodeParser''append-2 this, (MonitorExitNode'new-3 lockedObject, monitorId, escapedReturnValue))
            ]
                (AbstractStateSplit''setStateAfter-2 monitorExit, (BytecodeParser''createFrameState-3 this, bci, monitorExit))
            )
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''genJsr-2 [#_"BytecodeParser" this, #_"int" dest]
        (let [
            #_"BciBlock" successor (BciBlock''getJsrSuccessor-1 (:currentBlock this))
            #_"JsrScope" scope (BciBlock''getJsrScope-1 (:currentBlock this))
            #_"int" nextBci (:nextBCI (:stream this))
        ]
            (when-not (= (JsrScope''pop-1 (BciBlock''getJsrScope-1 successor)) scope)
                (throw! "unstructured control flow (internal limitation)")
            )
            (when-not (= (JsrScope''nextReturnAddress-1 (BciBlock''getJsrScope-1 successor)) nextBci)
                (throw! "unstructured control flow (internal limitation)")
            )
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''getJsrConstant-2 this, nextBci)))
            (BytecodeParser''appendGoto-2 this, successor)
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''genRet-2 [#_"BytecodeParser" this, #_"int" localIndex]
        (let [
            #_"BciBlock" successor (BciBlock''getRetSuccessor-1 (:currentBlock this))
            #_"ValueNode" local (FrameStateBuilder''loadLocal-3 (:frameState this), localIndex, JavaKind/Object)
            #_"JsrScope" scope (BciBlock''getJsrScope-1 (:currentBlock this))
            #_"int" retAddress (JsrScope''nextReturnAddress-1 scope)
            #_"ConstantNode" returnBciNode (BytecodeParser''getJsrConstant-2 this, retAddress)
            #_"LogicNode" guard (Graph''addOrUniqueWithInputs-2 (:graph this), (IntegerEqualsNode'create-3 nil, local, returnBciNode))
        ]
            (BytecodeParser''append-2 this, (FixedGuardNode'new-3 guard, DeoptimizationReason/JavaSubroutineMismatch, DeoptimizationAction/InvalidateReprofile))
            (when (= (BciBlock''getJsrScope-1 successor) (JsrScope''pop-1 scope)) => (throw! "unstructured control flow (ret leaves more than one scope)")
                (BytecodeParser''appendGoto-2 this, successor)
            )
        )
        nil
    )

    (§ method- #_"ConstantNode" BytecodeParser''getJsrConstant-2 [#_"BytecodeParser" this, #_"long" bci]
        (let [
            #_"JavaConstant" nextBciConstant (RawConstant. bci)
        ]
            (Graph''add-2 (:graph this), (ConstantNode'new-2 nextBciConstant, (StampFactory'forPrimitiveConstant-1 nextBciConstant)))
        )
    )

    (§ method! #_"BytecodeParser" BytecodeParser''genIntegerSwitch-6 [#_"BytecodeParser" this, #_"ValueNode" value, #_"ArrayList<BciBlock>" actualSuccessors, #_"int[]" keys, #_"double[]" keyProbabilities, #_"int[]" keySuccessors]
        (if (instance? ConstantNode value)
            (let [
                #_"int" constantValue (#_"JavaConstant" .asInt (:value value))
            ]
                (loop-when [#_"int" i 0] (< i (count keys)) => (BytecodeParser''appendGoto-2 this, (nth actualSuccessors (nth keySuccessors i)))
                    (if (= (nth keys i) constantValue)
                        (BytecodeParser''appendGoto-2 this, (nth actualSuccessors (nth keySuccessors i)))
                        (recur (inc i))
                    )
                )
                this
            )
            (let [
                this (assoc this :controlFlowSplit true)
                #_"double[]" successorProbabilities (BytecodeParser'successorProbabilites-3 (count actualSuccessors), keySuccessors, keyProbabilities)
                #_"IntegerSwitchNode" switchNode (BytecodeParser''append-2 this, (IntegerSwitchNode'new-5 value, (count actualSuccessors), keys, keyProbabilities, keySuccessors))
            ]
                (dotimes [#_"int" i (count actualSuccessors)]
                    (SwitchNode''setBlockSuccessor-3 switchNode, i, (BytecodeParser''createBlockTarget-4 this, (nth successorProbabilities i), (nth actualSuccessors i), (:frameState this)))
                )
                this
            )
        )
    )

    ;;;
     ; Helper function that sums up the probabilities of all keys that lead to a specific successor.
     ;
     ; @return an array of size successorCount with the accumulated probability for each successor
     ;;
    (§ defn- #_"double[]" BytecodeParser'successorProbabilites-3 [#_"int" successorCount, #_"int[]" keySuccessors, #_"double[]" keyProbabilities]
        (let [
            #_"double[]" probability (double-array successorCount)
        ]
            (dotimes [#_"int" i (count keySuccessors)]
                (aswap probability (nth keySuccessors i) + (nth keyProbabilities i))
            )
            probability
        )
    )

    (§ method! #_"ConstantNode" BytecodeParser''appendConstant-2 [#_"BytecodeParser" this, #_"JavaConstant" constant]
        (ConstantNode'forConstant-2 constant, (:graph this))
    )

    (§ override! #_"ValueNode" BytecodeParser''append-2 [#_"BytecodeParser" this, #_"ValueNode" node]
        (if (some? (:graph node))
            node
            (let [
                #_"ValueNode" added (Graph''addOrUniqueWithInputs-2 (:graph this), node)
            ]
                (when (= added node)
                    (§ ass! this (BytecodeParser''updateLastInstruction-2 this, node))
                )
                added
            )
        )
    )

    (§ method- #_"BytecodeParser" BytecodeParser''updateLastInstruction-2 [#_"BytecodeParser" this, #_"ValueNode" node]
        (when (instance? FixedNode node) => this
            (let [
                _ (§ ass! (:lastInstr this) (FixedWithNextNode''setNext-2 (:lastInstr this), node))
            ]
                (assoc this :lastInstr (when (instance? FixedWithNextNode node) node))
            )
        )
    )

    (§ method- #_"FixedTarget" BytecodeParser''checkLoopExit-4 [#_"BytecodeParser" this, #_"FixedNode" target, #_"BciBlock" targetBlock, #_"FrameStateBuilder" state]
        (when (some? (:currentBlock this)) => (FixedTarget'new-2 target, state)
            (let [
                #_"long" exits (& (:loops (:currentBlock this)) (bit-not (:loops targetBlock)))
            ]
                (when-not (zero? exits) => (FixedTarget'new-2 target, state)
                    (let [
                        #_"ArrayList<BciBlock>" exitLoops (ArrayList.)
                        exits
                            (loop [exits exits #_"int" i 0]
                                (let [
                                    #_"long" lMask (<< 1 i)
                                    exits
                                        (when-not (zero? (& exits lMask)) => exits
                                            (#_"ArrayList" .add exitLoops, (BciBlockMapping''getLoopHeader-2 (:blockMap this), i))
                                            (& exits (bit-not lMask))
                                        )
                                ]
                                    (recur-if (not (zero? exits)) [exits (inc i)] => exits)
                                )
                            )
                        _
                            (Collections/sort exitLoops,
                                (§ reify #_"Comparator<BciBlock>" (Comparator.)
                                    (§ override! #_"int" #_"Comparator" .compare [#_"Comparator<BciBlock>" this, #_"BciBlock" o1, #_"BciBlock" o2]
                                        (- (Long/bitCount (:loops o2)) (Long/bitCount (:loops o1)))
                                    )
                                )
                            )
                        #_"FrameStateBuilder" newState (FrameStateBuilder''copy-1 state)
                        [#_"LoopExitNode" firstLoopExit #_"LoopExitNode" lastLoopExit]
                            (loop-when [firstLoopExit nil lastLoopExit nil #_"ISeq" s (seq exitLoops)] (some? s) => [firstLoopExit lastLoopExit]
                                (let [
                                    #_"BciBlock" loop (first s)
                                    #_"LoopBeginNode" loopBegin (BytecodeParser''getFirstInstruction-2 this, loop)
                                    #_"LoopExitNode" loopExit (Graph''add-2 (:graph this), (LoopExitNode'new-1 loopBegin))
                                ]
                                    (when (some? lastLoopExit)
                                        (§ ass! lastLoopExit (FixedWithNextNode''setNext-2 lastLoopExit, loopExit))
                                    )
                                    (let [
                                        firstLoopExit (or firstLoopExit loopExit)
                                        lastLoopExit loopExit
                                    ]
                                        (FrameStateBuilder''clearNonLiveLocals-4 newState, targetBlock, (:liveness this), true)
                                        (FrameStateBuilder''insertLoopProxies-3 newState, loopExit, (BytecodeParser''getEntryState-2 this, loop))
                                        (BeginStateSplitNode''setStateAfter-2 loopExit, (FrameStateBuilder''create-3 newState, (:startBci targetBlock), loopExit))
                                        (recur firstLoopExit lastLoopExit (next s))
                                    )
                                )
                            )
                    ]
                        (§ ass! lastLoopExit (FixedWithNextNode''setNext-2 lastLoopExit, target))
                        (FixedTarget'new-2 firstLoopExit, newState)
                    )
                )
            )
        )
    )

    (§ method- #_"FrameStateBuilder" BytecodeParser''getEntryState-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (nth (:entryStateArray this) (:id block))
    )

    (§ method- #_"void" BytecodeParser''setEntryState-3 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FrameStateBuilder" entryState]
        (aset (:entryStateArray this) (:id block) entryState)
        nil
    )

    (§ method- #_"void" BytecodeParser''setFirstInstruction-3 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FixedWithNextNode" firstInstruction]
        (aset (:firstInstructionArray this) (:id block) firstInstruction)
        nil
    )

    (§ method- #_"FixedWithNextNode" BytecodeParser''getFirstInstruction-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (nth (:firstInstructionArray this) (:id block))
    )

    (§ method- #_"FixedNode" BytecodeParser''createTarget-4 [#_"BytecodeParser" this, #_"double" probability, #_"BciBlock" block, #_"FrameStateBuilder" stateAfter]
        (if (BytecodeParser''isNeverExecutedCode-2 this, probability)
            (Graph''add-2 (:graph this), (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateReprofile, DeoptimizationReason/UnreachedCode))
            (BytecodeParser''createTarget-3 this, block, stateAfter)
        )
    )

    (§ method- #_"FixedNode" BytecodeParser''createTarget-3 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FrameStateBuilder" state]
        (BytecodeParser''createTarget-5 this, block, state, false, false)
    )

    (§ method- #_"FixedNode" BytecodeParser''createTarget-5 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FrameStateBuilder" state, #_"boolean" canReuseInstruction, #_"boolean" canReuseState]
        (when (nil? (BytecodeParser''getFirstInstruction-2 this, block))
            ;; This is the first time we see this block as a branch target. Create and return a
            ;; placeholder that later can be replaced with a MergeNode when we see this block again.
            (if (and canReuseInstruction (or (= (:predecessorCount block) 1) (not (:controlFlowSplit this))) (not (:isLoopHeader block)) (zero? (& (:loops (:currentBlock this)) (bit-not (:loops block)))))
                (do
                    (BytecodeParser''setFirstInstruction-3 this, block, (:lastInstr this))
                    (§ ass! this (assoc this :lastInstr nil))
                )
                (BytecodeParser''setFirstInstruction-3 this, block, (Graph''add-2 (:graph this), (BeginNode'new-0)))
            )
            (let [
                #_"FixedNode" targetNode (BytecodeParser''getFirstInstruction-2 this, block)
                #_"FixedTarget" target (BytecodeParser''checkLoopExit-4 this, targetNode, block, state)
                #_"FixedNode" result (:fixed target)
                #_"FrameStateBuilder" currentEntryState (cond (not= (:state target) state) (:state target) canReuseState state :else (FrameStateBuilder''copy-1 state))
            ]
                (BytecodeParser''setEntryState-3 this, block, currentEntryState)
                (FrameStateBuilder''clearNonLiveLocals-4 currentEntryState, block, (:liveness this), true)

                (§ return result)
            )
        )

        ;; We already saw this block before, so we have to merge states.
        (when-not (FrameStateBuilder''isCompatibleWith-2 (BytecodeParser''getEntryState-2 this, block), state)
            (throw! (str "stacks do not match on merge from " (BytecodeParser''bci-1 this) " into " block "; bytecodes would not verify:\nexpect: " (BytecodeParser''getEntryState-2 this, block) "\nactual: " state))
        )

        (when (instance? LoopBeginNode (BytecodeParser''getFirstInstruction-2 this, block))
            ;; Backward loop edge. We need to create a special LoopEndNode and merge with the
            ;; loop begin node created before.
            (let [
                #_"LoopBeginNode" loopBegin (BytecodeParser''getFirstInstruction-2 this, block)
                #_"LoopEndNode" loopEnd (Graph''add-2 (:graph this), (LoopEndNode'new-1 loopBegin))
                #_"FixedTarget" target (BytecodeParser''checkLoopExit-4 this, loopEnd, block, state)
                #_"FixedNode" result (:fixed target)
            ]
                (§ ass! (BytecodeParser''getEntryState-2 this, block) (FrameStateBuilder''merge-3 (BytecodeParser''getEntryState-2 this, block), loopBegin, (:state target)))

                (§ return result)
            )
        )

        (when (and (instance? AbstractBeginNode (BytecodeParser''getFirstInstruction-2 this, block)) (not (instance? AbstractMergeNode (BytecodeParser''getFirstInstruction-2 this, block))))
            ;; This is the second time we see this block. Create the actual MergeNode and the
            ;; End Node for the already existing edge.
            (let [
                #_"AbstractBeginNode" beginNode (BytecodeParser''getFirstInstruction-2 this, block)
                ;; The EndNode for the already existing edge.
                #_"EndNode" end (Graph''add-2 (:graph this), (EndNode'new-0))
                ;; The MergeNode that replaces the placeholder.
                #_"AbstractMergeNode" mergeNode (Graph''add-2 (:graph this), (MergeNode'new-0))
                #_"FixedNode" next (:next beginNode)
            ]
                (if (instance? ControlSplitNode (:predecessor beginNode))
                    (§ ass! beginNode (FixedWithNextNode''setNext-2 beginNode, end))
                    (do
                        (Node''replaceAtPredecessor-2 beginNode, end)
                        (Node''safeDelete-1 beginNode)
                    )
                )

                (AbstractMergeNode''addForwardEnd-2 mergeNode, end)
                (§ ass! mergeNode (FixedWithNextNode''setNext-2 mergeNode, next))

                (BytecodeParser''setFirstInstruction-3 this, block, mergeNode)
            )
        )

        (let [
            #_"AbstractMergeNode" mergeNode (BytecodeParser''getFirstInstruction-2 this, block)
            ;; The EndNode for the newly merged edge.
            #_"EndNode" newEnd (Graph''add-2 (:graph this), (EndNode'new-0))
            #_"FixedTarget" target (BytecodeParser''checkLoopExit-4 this, newEnd, block, state)
            #_"FixedNode" result (:fixed target)
        ]
            (§ ass! (BytecodeParser''getEntryState-2 this, block) (FrameStateBuilder''merge-3 (BytecodeParser''getEntryState-2 this, block), mergeNode, (:state target)))
            (AbstractMergeNode''addForwardEnd-2 mergeNode, newEnd)

            result
        )
    )

    ;;;
     ; Returns a block begin node with the specified state. If the specified probability is 0, the block deoptimizes immediately.
     ;;
    (§ method- #_"AbstractBeginNode" BytecodeParser''createBlockTarget-4 [#_"BytecodeParser" this, #_"double" probability, #_"BciBlock" block, #_"FrameStateBuilder" stateAfter]
        (BeginNode'begin-1 (BytecodeParser''createTarget-4 this, probability, block, stateAfter))
    )

    (§ method- #_"ValueNode" BytecodeParser''synchronizedObject-3 [#_"BytecodeParser" this, #_"FrameStateBuilder" state, #_"ResolvedJavaMethod" target]
        (if (#_"ResolvedJavaMethod" .isStatic target)
            (BytecodeParser''appendConstant-2 this, (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"ResolvedJavaMethod" .getDeclaringClass target)))
            (FrameStateBuilder''loadLocal-3 state, 0, JavaKind/Object)
        )
    )

    (§ method! #_"BytecodeParser" BytecodeParser''processBlock-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        ;; ignore blocks that have no predecessors by the time their bytecodes are parsed
        (let [
            #_"FixedWithNextNode" firstInstruction (BytecodeParser''getFirstInstruction-2 this, block)
        ]
            (when (some? firstInstruction) => this
                (let [
                    this (assoc this :lastInstr firstInstruction)
                    this (assoc this :frameState (BytecodeParser''getEntryState-2 this, block))
                    this (BytecodeParser''setCurrentFrameState-2 this, (:frameState this))
                    this (assoc this :currentBlock block)
                ]
                    (when (instance? AbstractMergeNode firstInstruction)
                        (BytecodeParser''setMergeStateAfter-3 this, block, firstInstruction)
                    )
                    (BytecodeParser''iterateBytecodesForBlock-2 this, block)
                )
            )
        )
    )

    (§ method- #_"void" BytecodeParser''setMergeStateAfter-3 [#_"BytecodeParser" this, #_"BciBlock" block, #_"FixedWithNextNode" firstInstruction]
        (when (nil? (BeginStateSplitNode''stateAfter-1 firstInstruction))
            (BeginStateSplitNode''setStateAfter-2 firstInstruction, (BytecodeParser''createFrameState-3 this, (:startBci block), firstInstruction))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''synchronizedEpilogue-4 [#_"BytecodeParser" this, #_"int" bci, #_"ValueNode" currentReturnValue, #_"JavaKind" currentReturnValueKind]
        (when (#_"ResolvedJavaMethod" .isSynchronized (:method this))
            (when (some? currentReturnValue)
                (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), currentReturnValueKind, currentReturnValue))
            )
            (BytecodeParser''genMonitorExit-4 this, (:methodSynchronizedObject this), currentReturnValue, bci)
        )
        (when-not (zero? (FrameStateBuilder''lockDepth-2 (:frameState this), false))
            (throw! "unbalanced monitors: too few exits exiting frame")
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''appendGoto-2 [#_"BytecodeParser" this, #_"BciBlock" successor]
        (let [
            #_"FixedNode" targetInstr (BytecodeParser''createTarget-5 this, successor, (:frameState this), true, true)
        ]
            (when (and (some? (:lastInstr this)) (not= (:lastInstr this) targetInstr))
                (§ ass! (:lastInstr this) (FixedWithNextNode''setNext-2 (:lastInstr this), targetInstr))
            )
        )
        nil
    )

    (§ method! #_"BytecodeParser" BytecodeParser''iterateBytecodesForBlock-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (let [
            this
                (if (:isLoopHeader block)
                    ;; Create the loop header block, which later will merge the backward branches of the loop.
                    (let [
                        this (assoc this :controlFlowSplit true)
                        #_"LoopBeginNode" loopBegin (BytecodeParser''appendLoopBegin-3 this, (:lastInstr this), (:startBci block))
                        this (assoc this :lastInstr loopBegin)
                    ]
                        ;; Create phi functions for all local variables and operand stack slots.
                        (FrameStateBuilder''insertLoopPhis-6 (:frameState this), (:liveness this), (:loopId block), loopBegin, false, false)
                        (BeginStateSplitNode''setStateAfter-2 loopBegin, (BytecodeParser''createFrameState-3 this, (:startBci block), loopBegin))
                        ;; We have seen all forward branches. All subsequent backward branches will merge to the
                        ;; loop header. This ensures that the loop header has exactly one non-loop predecessor.
                        (BytecodeParser''setFirstInstruction-3 this, block, loopBegin)
                        ;; We need to preserve the frame state builder of the loop header so that we can merge
                        ;; values for phi functions, so make a copy of it.
                        (BytecodeParser''setEntryState-3 this, block, (FrameStateBuilder''copy-1 (:frameState this)))
                        this
                    )
                    (when (instance? MergeNode (:lastInstr this)) => this
                        ;; All inputs of non-loop phi nodes are known by now. We can infer the stamp
                        ;; for the phi, so that parsing continues with more precise type information.
                        (FrameStateBuilder''inferPhiStamps-2 (:frameState this), (:lastInstr this))
                        this
                    )
                )
            #_"int" endBCI (BytecodeStream''endBCI-1 (:stream this))
            _ (§ ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:startBci block)))
        ]
            (loop-when [this this #_"int" bci (:startBci block)] (< bci endBCI) => this
                (let [
                    this (BytecodeParser''processBytecode-3 this, bci, (BytecodeStream''currentBC-1 (:stream this)))
                ]
                    (when (and (some? (:lastInstr this)) (nil? (:next (:lastInstr this)))) => this
                        (let [
                            _ (§ ass! (:stream this) (BytecodeStream''next-1 (:stream this)))
                            bci (:curBCI (:stream this))
                        ]
                            (when (< (:endBci block) bci endBCI) => (recur this bci)
                                ;; we fell through to the next block, add a goto and break
                                (BytecodeParser''appendGoto-2 this, (BciBlock''getSuccessor-2 block, 0))
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method- #_"LoopBeginNode" BytecodeParser''appendLoopBegin-3 [#_"BytecodeParser" this, #_"FixedWithNextNode" fixedWithNext, #_"int" startBci]
        (let [
            #_"EndNode" preLoopEnd (Graph''add-2 (:graph this), (EndNode'new-0))
            #_"LoopBeginNode" loopBegin (Graph''add-2 (:graph this), (LoopBeginNode'new-0))
            loopBegin
                (when (BytecodeParser''parsingIntrinsic-1 this) => loopBegin
                    (LoopBeginNode''disableSafepoint-1 loopBegin)
                )
        ]
            (§ ass! fixedWithNext (FixedWithNextNode''setNext-2 fixedWithNext, preLoopEnd))
            ;; Add the single non-loop predecessor of the loop header.
            (AbstractMergeNode''addForwardEnd-2 loopBegin, preLoopEnd)
            loopBegin
        )
    )

    (§ method! #_"BytecodeParser" BytecodeParser''genIf-4 [#_"BytecodeParser" this, #_"ValueNode" x, #_"Condition" condition, #_"ValueNode" y]
        (let [
            #_"BciBlock" then (BciBlock''getSuccessor-2 (:currentBlock this), 0)
            #_"BciBlock" else (BciBlock''getSuccessor-2 (:currentBlock this), 1)
        ]
            (when-not (= then else) => (BytecodeParser''appendGoto-2 this, then) => this
                (let [
                    #_"CanonicalizedCondition" canon (Condition''canonicalize-1 condition)
                    [x y] (if (:mirror? canon) [y x] [x y])
                    #_"LogicNode" logic (BytecodeParser''createLogicNode-4 this, (:canonicalCondition canon), x, y)
                    [then else] (if (:negate? canon) [else then] [then else])
                    #_"double" probability (if (instance? IntegerEqualsNode logic) (BytecodeParser'extractInjectedProbability-1 logic) -1.0)
                    probability (if (= probability -1.0) (BytecodeParser''getProfileProbability-2 this, (:negate? canon)) probability)
                    probability (BytecodeParser''clampProbability-2 this, probability)
                ]
                    (BytecodeParser''genIf-5 this, logic, then, else, probability)
                )
            )
        )
    )

    (§ method! #_"double" BytecodeParser''getProfileProbability-2 [#_"BytecodeParser" this, #_"boolean" negate?]
        0.5
    )

    (§ defn- #_"double" BytecodeParser'extractInjectedProbability-1 [#_"IntegerEqualsNode" equalsNode]
        ;; Propagate injected branch probability if any.
        (let [
            [#_"BranchProbabilityNode" probabilityNode #_"ValueNode" valueNode]
                (cond
                    (instance? BranchProbabilityNode (:x equalsNode)) [(:x equalsNode) (:y equalsNode)]
                    (instance? BranchProbabilityNode (:y equalsNode)) [(:y equalsNode) (:x equalsNode)]
                )
        ]
            (if (and (some? probabilityNode) (instance? ConstantNode (:probability probabilityNode)) (some? valueNode) (instance? ConstantNode valueNode))
                (let [
                    #_"double" probability (#_"JavaConstant" .asDouble (ValueNode''asJavaConstant-1 (:probability probabilityNode)))
                ]
                    (if (zero? (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 valueNode))) (- 1.0 probability) probability)
                )
                -1.0
            )
        )
    )

    (§ method! #_"BytecodeParser" BytecodeParser''genIf-5 [#_"BytecodeParser" this, #_"LogicNode" logic, #_"BciBlock" trueBlock, #_"BciBlock" falseBlock, #_"double" probability]
        ;; Remove a logic negation node.
        (let [
            [logic trueBlock falseBlock probability]
                (when (instance? LogicNegationNode logic) => [logic trueBlock falseBlock probability]
                    [(LogicNegationNode''getValue-1 logic) falseBlock trueBlock (- 1.0 probability)]
                )
        ]
            (when-not (instance? LogicConstantNode logic) => (BytecodeParser''genConstantTargetIf-4 this, trueBlock, falseBlock, logic) => this
                (let [
                    logic (if (nil? (:graph logic)) (BytecodeParser''genUnique-2 this, logic) logic)
                ]
                    (cond
                        (BytecodeParser''isNeverExecutedCode-2 this, probability)
                            (do
                                (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/UnreachedCode, DeoptimizationAction/InvalidateReprofile, true))
                                (BytecodeParser''appendGoto-2 this, falseBlock)
                                this
                            )
                        (BytecodeParser''isNeverExecutedCode-2 this, (- 1.0 probability))
                            (do
                                (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/UnreachedCode, DeoptimizationAction/InvalidateReprofile, false))
                                (BytecodeParser''appendGoto-2 this, trueBlock)
                                this
                            )
                        :else
                            (let [
                                #_"int" oldBci (:curBCI (:stream this))
                                #_"int" trueBlockInt (BytecodeParser''checkPositiveIntConstantPushed-2 this, trueBlock)
                            ]
                                (when-not (= trueBlockInt -1)
                                    (let [
                                        #_"int" falseBlockInt (BytecodeParser''checkPositiveIntConstantPushed-2 this, falseBlock)
                                    ]
                                        (when-not (= falseBlockInt -1)
                                            (when (BytecodeParser''tryGenConditionalForIf-7 this, trueBlock, falseBlock, logic, oldBci, trueBlockInt, falseBlockInt)
                                                (§ return this)
                                            )
                                        )
                                    )
                                )
                                (let [
                                    this (assoc this :controlFlowSplit true)
                                    #_"FixedNode" trueSuccessor (BytecodeParser''createTarget-5 this, trueBlock, (:frameState this), false, false)
                                    #_"FixedNode" falseSuccessor (BytecodeParser''createTarget-5 this, falseBlock, (:frameState this), false, true)
                                ]
                                    (BytecodeParser''append-2 this, (BytecodeParser''genIfNode-5 this, logic, trueSuccessor, falseSuccessor, probability))
                                    this
                                )
                            )
                    )
                )
            )
        )
    )

    (§ method- #_"boolean" BytecodeParser''tryGenConditionalForIf-7 [#_"BytecodeParser" this, #_"BciBlock" trueBlock, #_"BciBlock" falseBlock, #_"LogicNode" logic, #_"int" oldBci, #_"int" trueBlockInt, #_"int" falseBlockInt]
        (cond
            (and (BytecodeParser''gotoOrFallThroughAfterConstant-2 this, trueBlock) (BytecodeParser''gotoOrFallThroughAfterConstant-2 this, falseBlock) (= (BciBlock''getSuccessor-2 trueBlock, 0) (BciBlock''getSuccessor-2 falseBlock, 0)))
            (do
                (§ ass! this (BytecodeParser''genConditionalForIf-7 this, trueBlock, logic, oldBci, trueBlockInt, falseBlockInt, false))
                true
            )
            (and (some? (:parent this)) (BytecodeParser''returnAfterConstant-2 this, trueBlock) (BytecodeParser''returnAfterConstant-2 this, falseBlock))
            (do
                (§ ass! this (BytecodeParser''genConditionalForIf-7 this, trueBlock, logic, oldBci, trueBlockInt, falseBlockInt, true))
                true
            )
            :else
                false
        )
    )

    (§ method- #_"BytecodeParser" BytecodeParser''genConditionalForIf-7 [#_"BytecodeParser" this, #_"BciBlock" trueBlock, #_"LogicNode" logic, #_"int" oldBci, #_"int" trueBlockInt, #_"int" falseBlockInt, #_"boolean" genReturn]
        (let [
            #_"ConstantNode" trueValue (Graph''add-2 (:graph this), (ConstantNode'forInt-1 trueBlockInt))
            #_"ConstantNode" falseValue (Graph''add-2 (:graph this), (ConstantNode'forInt-1 falseBlockInt))
            #_"ValueNode" conditionalNode (ConditionalNode'create-3 logic, trueValue, falseValue)
            conditionalNode
                (when (nil? (:graph conditionalNode)) => conditionalNode
                    (Graph''addOrUniqueWithInputs-2 (:graph this), conditionalNode)
                )
        ]
            (if genReturn
                (BytecodeParser''genReturn-3 this, conditionalNode, (#_"JavaKind" .getStackKind (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature (:method this)))))
                (do
                    (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, conditionalNode))
                    (BytecodeParser''appendGoto-2 this, (BciBlock''getSuccessor-2 trueBlock, 0))
                    (§ ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), oldBci))
                    this
                )
            )
        )
    )

    (§ method- #_"LogicNode" BytecodeParser''createLogicNode-4 [#_"BytecodeParser" this, #_"CanonicalCondition" condition, #_"ValueNode" a, #_"ValueNode" b]
        (condp = condition
            CanonicalCondition'EQ
                (if (= (ValueNode''getStackKind-1 a) JavaKind/Object)
                    (BytecodeParser''genObjectEquals-3 this, a, b)
                    (BytecodeParser''genIntegerEquals-3 this, a, b)
                )
            CanonicalCondition'LT
                (BytecodeParser''genIntegerLessThan-3 this, a, b)
        )
    )

    (§ method- #_"void" BytecodeParser''genConstantTargetIf-4 [#_"BytecodeParser" this, #_"BciBlock" trueBlock, #_"BciBlock" falseBlock, #_"LogicNode" logic]
        (let [
            #_"BciBlock" nextBlock (if (:value logic) trueBlock falseBlock)
            #_"int" targetAtStart (BytecodeStream''readUByte-2 (:stream this), (:startBci nextBlock))
        ]
            ;; If this is an empty block, skip it.
            (BytecodeParser''appendGoto-2 this, (if (and (= targetAtStart Bytecodes'GOTO) (= (:predecessorCount nextBlock) 1)) (nth (:successors nextBlock) 0) nextBlock))
        )
        nil
    )

    (§ method- #_"int" BytecodeParser''checkPositiveIntConstantPushed-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (§ ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:startBci block)))
        (let [
            #_"int" currentBC (BytecodeStream''currentBC-1 (:stream this))
        ]
            (if (<= Bytecodes'ICONST_0 currentBC Bytecodes'ICONST_5) (- currentBC Bytecodes'ICONST_0) -1)
        )
    )

    (§ method- #_"boolean" BytecodeParser''gotoOrFallThroughAfterConstant-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (§ ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:startBci block)))
        (§ ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:nextBCI (:stream this))))
        (or (< (:endBci block) (:curBCI (:stream this))) (any = (BytecodeStream''currentBC-1 (:stream this)) Bytecodes'GOTO Bytecodes'GOTO_W))
    )

    (§ method- #_"boolean" BytecodeParser''returnAfterConstant-2 [#_"BytecodeParser" this, #_"BciBlock" block]
        (§ ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:startBci block)))
        (§ ass! (:stream this) (BytecodeStream''setBCI-2 (:stream this), (:nextBCI (:stream this))))
        (= (BytecodeStream''currentBC-1 (:stream this)) Bytecodes'IRETURN)
    )

    ;;;
     ; Pushes a given value to the frame state stack using an explicit kind. This should be used
     ; when {@code value.getJavaKind()} is different from the kind that the bytecode instruction
     ; currently being parsed pushes to the stack.
     ;
     ; @param kind the kind to use when type checking this operation
     ; @param value the value to push to the stack. The value must already have been
     ;            {@linkplain #append(ValueNode) appended}.
     ;;
    (§ method! #_"void" BytecodeParser''push-3 [#_"BytecodeParser" this, #_"JavaKind" slotKind, #_"ValueNode" value]
        (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), slotKind, value))
        nil
    )

    ;;;
     ; Gets the parsing context for the method that inlines the method being parsed by this context.
     ;;
    (§ method! #_"BytecodeParser" BytecodeParser''getParent-1 [#_"BytecodeParser" this]
        (:parent this)
    )

    (§ method- #_"FrameState" BytecodeParser''createFrameState-3 [#_"BytecodeParser" this, #_"int" bci, #_"StateSplit" forStateSplit]
        (when (and (some? (:currentBlock this)) (< (:endBci (:currentBlock this)) bci))
            (FrameStateBuilder''clearNonLiveLocals-4 (:frameState this), (:currentBlock this), (:liveness this), false)
        )
        (FrameStateBuilder''create-3 (:frameState this), bci, forStateSplit)
    )

    ;;;
     ; Creates a snap shot of the current frame state with the BCI of the instruction after the one currently
     ; being parsed and assigns it to a given {@linkplain StateSplit#hasSideEffect() side effect} node.
     ;
     ; @param sideEffect a side effect node just appended to the graph
     ;;
    (§ method! #_"void" BytecodeParser''setStateAfter-2 [#_"BytecodeParser" this, #_"StateSplit" sideEffect]
        (StateSplit''setStateAfter-2 sideEffect, (BytecodeParser''createFrameState-3 this, (:nextBCI (:stream this)), sideEffect))
        nil
    )

    (§ method! #_"BytecodeParser" BytecodeParser''setCurrentFrameState-2 [#_"BytecodeParser" this, #_"FrameStateBuilder" frameState]
        (assoc this :frameState frameState)
    )

    ;;;
     ; Gets the index of the bytecode instruction currently being parsed.
     ;;
    (§ method! #_"int" BytecodeParser''bci-1 [#_"BytecodeParser" this]
        (:curBCI (:stream this))
    )

    (§ method! #_"void" BytecodeParser''loadLocal-3 [#_"BytecodeParser" this, #_"int" index, #_"JavaKind" kind]
        (let [
            #_"ValueNode" value (FrameStateBuilder''loadLocal-3 (:frameState this), index, kind)
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, value))
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''loadLocalObject-2 [#_"BytecodeParser" this, #_"int" index]
        (let [
            #_"ValueNode" value (FrameStateBuilder''loadLocal-3 (:frameState this), index, JavaKind/Object)
            #_"int" nextBCI (:nextBCI (:stream this))
            #_"int" nextBC (BytecodeStream''readUByte-2 (:stream this), nextBCI)
        ]
            (if (and (<= nextBCI (:endBci (:currentBlock this))) (= nextBC Bytecodes'GETFIELD))
                (do
                    (§ ass! (:stream this) (BytecodeStream''next-1 (:stream this)))
                    (BytecodeParser''genGetField-4 this, (BytecodeStream''readCPI-1 (:stream this)), Bytecodes'GETFIELD, value)
                )
                (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, value))
            )
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''storeLocal-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" index]
        (let [
            #_"ValueNode" value (FrameStateBuilder''pop-2 (:frameState this), kind)
        ]
            (FrameStateBuilder''storeLocal-4 (:frameState this), index, kind, value)
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genLoadConstant-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (let [
            #_"Object" constant (BytecodeParser''lookupConstant-3 this, cpi, opcode)
        ]
            (condp instance? constant
                JavaType ;; this is a load of class constant which might be unresolved
                    (if (instance? ResolvedJavaType constant)
                        (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''appendConstant-2 this, (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, constant))))
                        (BytecodeParser''handleUnresolvedLoadConstant-2 this, constant)
                    )
                JavaConstant
                    (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), (#_"JavaConstant" .getJavaKind constant), (BytecodeParser''appendConstant-2 this, constant)))
            )
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genLoadIndexed-2 [#_"BytecodeParser" this, #_"JavaKind" kind]
        (let [
            #_"ValueNode" index (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
            #_"ValueNode" array (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (loop [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))]
                (if (some? s)
                    (when-not (NodePlugin''handleLoadIndexed-5 (first s), this, array, index, kind)
                        (recur (next s))
                    )
                    (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, (BytecodeParser''genLoadIndexed-4 this, array, index, kind))))
                )
            )
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genStoreIndexed-2 [#_"BytecodeParser" this, #_"JavaKind" kind]
        (let [
            #_"ValueNode" value (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" index (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
            #_"ValueNode" array (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (loop [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))]
                (if (some? s)
                    (when-not (NodePlugin''handleStoreIndexed-6 (first s), this, array, index, kind, value)
                        (recur (next s))
                    )
                    (BytecodeParser''genStoreIndexed-5 this, array, index, kind, value)
                )
            )
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genArithmeticOp-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" opcode]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" v
                (condp =? opcode
                    [Bytecodes'IADD Bytecodes'LADD] (BytecodeParser''genIntegerAdd-3 this, x, y)
                    [Bytecodes'ISUB Bytecodes'LSUB] (BytecodeParser''genIntegerSub-3 this, x, y)
                    [Bytecodes'IMUL Bytecodes'LMUL] (BytecodeParser''genIntegerMul-3 this, x, y)
                )
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, v)))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genIntegerDivOp-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" opcode]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" v
                (condp =? opcode
                    [Bytecodes'IDIV Bytecodes'LDIV] (BytecodeParser''genIntegerDiv-3 this, x, y)
                    [Bytecodes'IREM Bytecodes'LREM] (BytecodeParser''genIntegerRem-3 this, x, y)
                )
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, v)))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genNegateOp-2 [#_"BytecodeParser" this, #_"JavaKind" kind]
        (let [
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, (BytecodeParser''genNegateOp-2 this, x))))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genShiftOp-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" opcode]
        (let [
            #_"ValueNode" s (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" v
                (condp =? opcode
                    [Bytecodes'ISHL  Bytecodes'LSHL ] (BytecodeParser''genLeftShift-3 this, x, s)
                    [Bytecodes'ISHR  Bytecodes'LSHR ] (BytecodeParser''genRightShift-3 this, x, s)
                    [Bytecodes'IUSHR Bytecodes'LUSHR] (BytecodeParser''genUnsignedRightShift-3 this, x, s)
                )
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, v)))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genLogicOp-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"int" opcode]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" v
                (condp =? opcode
                    [Bytecodes'IAND Bytecodes'LAND] (BytecodeParser''genAnd-3 this, x, y)
                    [Bytecodes'IOR  Bytecodes'LOR ] (BytecodeParser''genOr-3 this, x, y)
                    [Bytecodes'IXOR Bytecodes'LXOR] (BytecodeParser''genXor-3 this, x, y)
                )
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), kind, (BytecodeParser''append-2 this, v)))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genCompareOp-2 [#_"BytecodeParser" this, #_"JavaKind" kind]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''append-2 this, (BytecodeParser''genNormalizeCompare-3 this, x, y))))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genSignExtend-3 [#_"BytecodeParser" this, #_"JavaKind" from, #_"JavaKind" to]
        (let [
            #_"ValueNode" input (FrameStateBuilder''pop-2 (:frameState this), from)
        ]
            (when-not (= from (#_"JavaKind" .getStackKind from))
                (§ ass input (BytecodeParser''append-2 this, (BytecodeParser''genNarrow-3 this, input, (#_"JavaKind" .getBitCount from))))
            )
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), to, (BytecodeParser''append-2 this, (BytecodeParser''genSignExtend-3 this, input, (#_"JavaKind" .getBitCount to)))))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genZeroExtend-3 [#_"BytecodeParser" this, #_"JavaKind" from, #_"JavaKind" to]
        (let [
            #_"ValueNode" input (FrameStateBuilder''pop-2 (:frameState this), from)
        ]
            (when-not (= from (#_"JavaKind" .getStackKind from))
                (§ ass input (BytecodeParser''append-2 this, (BytecodeParser''genNarrow-3 this, input, (#_"JavaKind" .getBitCount from))))
            )
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), to, (BytecodeParser''append-2 this, (BytecodeParser''genZeroExtend-3 this, input, (#_"JavaKind" .getBitCount to)))))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genNarrow-3 [#_"BytecodeParser" this, #_"JavaKind" from, #_"JavaKind" to]
        (let [
            #_"ValueNode" input (FrameStateBuilder''pop-2 (:frameState this), from)
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), to, (BytecodeParser''append-2 this, (BytecodeParser''genNarrow-3 this, input, (#_"JavaKind" .getBitCount to)))))
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genIncrement-1 [#_"BytecodeParser" this]
        (let [
            #_"int" index (BytecodeStream''readLocalIndex-1 (:stream this))
            #_"int" delta (BytecodeStream''readIncrement-1 (:stream this))
            #_"ValueNode" x (FrameStateBuilder''loadLocal-3 (:frameState this), index, JavaKind/Int)
            #_"ValueNode" y (BytecodeParser''appendConstant-2 this, (JavaConstant/forInt delta))
        ]
            (FrameStateBuilder''storeLocal-4 (:frameState this), index, JavaKind/Int, (BytecodeParser''append-2 this, (BytecodeParser''genIntegerAdd-3 this, x, y)))
        )
        nil
    )

    (§ method- #_"BytecodeParser" BytecodeParser''genIfZero-2 [#_"BytecodeParser" this, #_"Condition" cond]
        (let [
            #_"ValueNode" y (BytecodeParser''appendConstant-2 this, JavaConstant/INT_0)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
        ]
            (BytecodeParser''genIf-4 this, x, cond, y)
        )
    )

    (§ method- #_"BytecodeParser" BytecodeParser''genIfNull-2 [#_"BytecodeParser" this, #_"Condition" cond]
        (let [
            #_"ValueNode" y (BytecodeParser''appendConstant-2 this, JavaConstant/NULL_POINTER)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (BytecodeParser''genIf-4 this, x, cond, y)
        )
    )

    (§ method- #_"BytecodeParser" BytecodeParser''genIfSame-3 [#_"BytecodeParser" this, #_"JavaKind" kind, #_"Condition" cond]
        (let [
            #_"ValueNode" y (FrameStateBuilder''pop-2 (:frameState this), kind)
            #_"ValueNode" x (FrameStateBuilder''pop-2 (:frameState this), kind)
        ]
            (BytecodeParser''genIf-4 this, x, cond, y)
        )
    )

    (§ defn- #_"void" BytecodeParser'initialize-1 [#_"ResolvedJavaType" resolvedType]
        ;; Since we're potentially triggering class initialization here, we need synchronization
        ;; to mitigate the potential for class initialization related deadlock being caused by
        ;; the compiler (e.g. https://github.com/graalvm/graal-core/pull/232/files#r90788550).
        (locking BytecodeParser
            (#_"ResolvedJavaType" .initialize resolvedType)
        )
        nil
    )

    (§ method! #_"JavaType" BytecodeParser''lookupType-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" bytecode]
        (BytecodeParser''maybeEagerlyResolve-3 this, cpi, bytecode)
        (#_"ConstantPool" .lookupType (:constantPool this), cpi, bytecode)
    )

    (§ method- #_"JavaMethod" BytecodeParser''lookupMethod-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''maybeEagerlyResolve-3 this, cpi, opcode)
        (#_"ConstantPool" .lookupMethod (:constantPool this), cpi, opcode)
    )

    (§ method! #_"JavaField" BytecodeParser''lookupField-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''maybeEagerlyResolve-3 this, cpi, opcode)
        (let [
            #_"JavaField" result (#_"ConstantPool" .lookupField (:constantPool this), cpi, (:method this), opcode)
        ]
            (when (or (BytecodeParser''parsingIntrinsic-1 this) (:eagerInitializing this))
                (when (instance? ResolvedJavaField result)
                    (let [
                        #_"ResolvedJavaType" declaringClass (#_"ResolvedJavaField" .getDeclaringClass result)
                    ]
                        (when-not (#_"ResolvedJavaType" .isInitialized declaringClass)
                            ;; even with eager initialization, superinterfaces are not always initialized (see StaticInterfaceFieldTest)
                            (BytecodeParser'initialize-1 declaringClass)
                        )
                    )
                )
            )
            result
        )
    )

    (§ method- #_"Object" BytecodeParser''lookupConstant-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''maybeEagerlyResolve-3 this, cpi, opcode)
        (#_"ConstantPool" .lookupConstant (:constantPool this), cpi)
    )

    (§ method! #_"void" BytecodeParser''maybeEagerlyResolve-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" bytecode]
        (cond
            (some? (:intrinsicContext this))
                (#_"ConstantPool" .loadReferencedType (:constantPool this), cpi, bytecode)
            (:eagerResolving (:graphBuilderConfig this))
                ;; Since we're potentially triggering class initialization here, we need synchronization
                ;; to mitigate the potential for class initialization related deadlock being caused by
                ;; the compiler (e.g. https://github.com/graalvm/graal-core/pull/232/files#r90788550).
                (locking BytecodeParser
                    (#_"ConstantPool" .loadReferencedType (:constantPool this), cpi, bytecode)
                )
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genCheckCast-1 [#_"BytecodeParser" this]
        (let [
            #_"int" cpi (BytecodeStream''readCPI-1 (:stream this))
            #_"JavaType" type (BytecodeParser''lookupType-3 this, cpi, Bytecodes'CHECKCAST)
            #_"ValueNode" object (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (when (instance? ResolvedJavaType type) => (BytecodeParser''handleUnresolvedCheckCast-3 this, type, object)
                (let [
                    #_"TypeReference" checkedType (TypeReference'createTrusted-1 type)
                ]
                    (loop [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))]
                        (if (some? s)
                            (when-not (NodePlugin''handleCheckCast-4 (first s), this, object, (:type checkedType))
                                (recur (next s))
                            )
                            (let [
                                #_"ValueNode" castNode
                                    (let [
                                        #_"LogicNode" logic (BytecodeParser''genUnique-2 this, (BytecodeParser''createInstanceOfAllowNull-3 this, checkedType, object))
                                    ]
                                        (if (LogicNode''isTautology-1 logic)
                                            object
                                            (BytecodeParser''append-2 this, (PiNode'create-3 object, (StampFactory'object-2 checkedType, (:never-nil? (:stamp object))), (BytecodeParser''append-2 this, (FixedGuardNode'new-4 logic, DeoptimizationReason/ClassCastException, DeoptimizationAction/InvalidateReprofile, false))))
                                        )
                                    )
                            ]
                                (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, castNode))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"BytecodeParser" BytecodeParser''genInstanceOf-1 [#_"BytecodeParser" this]
        (let [
            #_"int" cpi (BytecodeStream''readCPI-1 (:stream this))
            #_"JavaType" type (BytecodeParser''lookupType-3 this, cpi, Bytecodes'INSTANCEOF)
            #_"ValueNode" object (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (when (instance? ResolvedJavaType type) => (§ ass! this (BytecodeParser''handleUnresolvedInstanceOf-3 this, type, object)) => this
                (let [
                    #_"TypeReference" resolvedType (TypeReference'createTrusted-1 type)
                ]
                    (loop [this this #_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))]
                        (if (some? s)
                            (when-not (NodePlugin''handleInstanceOf-4 (first s), this, object, (:type resolvedType)) => this
                                (recur this (next s))
                            )
                            (let [
                                #_"LogicNode" instanceOfNode (BytecodeParser''createInstanceOf-3 this, resolvedType, object)
                                #_"LogicNode" logic (BytecodeParser''genUnique-2 this, instanceOfNode)
                                #_"int" next (:nextBCI (:stream this))
                                #_"int" value (BytecodeStream''readUByte-2 (:stream this), next)
                            ]
                                (if (and (<= next (:endBci (:currentBlock this))) (or (= value Bytecodes'IFEQ) (= value Bytecodes'IFNE)))
                                    (let [
                                        _ (§ ass! (:stream this) (BytecodeStream''next-1 (:stream this)))
                                        #_"BciBlock" succ1 (BciBlock''getSuccessor-2 (:currentBlock this), 0)
                                        #_"BciBlock" succ2 (BciBlock''getSuccessor-2 (:currentBlock this), 1)
                                    ]
                                        (if (= succ1 succ2)
                                            (do
                                                (BytecodeParser''appendGoto-2 this, succ1)
                                                this
                                            )
                                            (let [
                                                #_"boolean" negate? (not= value Bytecodes'IFNE)
                                                [succ1 succ2] (if negate? [succ2 succ1] [succ1 succ2])
                                            ]
                                                (BytecodeParser''genIf-5 this, instanceOfNode, succ1, succ2, (BytecodeParser''getProfileProbability-2 this, negate?))
                                            )
                                        )
                                    )
                                    ;; Most frequent for value is IRETURN, followed by ISTORE.
                                    (do
                                        (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''append-2 this, (BytecodeParser''genConditional-2 this, logic))))
                                        this
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"void" BytecodeParser''genNewInstance-2 [#_"BytecodeParser" this, #_"int" cpi]
        (BytecodeParser''genNewInstance-2 this, (BytecodeParser''lookupType-3 this, cpi, Bytecodes'NEW))
        nil
    )

    (§ method! #_"void" BytecodeParser''genNewInstance-2 [#_"BytecodeParser" this, #_"JavaType" type]
        (when (and (instance? ResolvedJavaType type) (#_"ResolvedJavaType" .isInitialized type)) => (BytecodeParser''handleUnresolvedNewInstance-2 this, type)
            (or
                (loop-when [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))] (some? s)
                    (when (NodePlugin''handleNewInstance-3 (first s), this, type) => (recur (next s))
                        :done
                    )
                )
                (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''append-2 this, (BytecodeParser''createNewInstance-3 this, type, true))))
            )
        )
        nil
    )

    ;;;
     ; Gets the kind of array elements for the array type code that appears in a Bytecodes#NEWARRAY bytecode.
     ;
     ; @param code the array type code
     ; @return the kind from the array type code
     ;;
    (§ defn- #_"Class" BytecodeParser'arrayTypeCodeToClass-1 [#_"int" code]
        (case code
             4 boolean'class
             5 char'class
             6 float'class
             7 double'class
             8 byte'class
             9 short'class
            10 int'class
            11 long'class
        )
    )

    (§ method- #_"void" BytecodeParser''genNewPrimitiveArray-2 [#_"BytecodeParser" this, #_"int" typeCode]
        (let [
            #_"ResolvedJavaType" elementType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (BytecodeParser'arrayTypeCodeToClass-1 typeCode))
            #_"ValueNode" length (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
        ]
            (or
                (loop-when [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))] (some? s)
                    (when (NodePlugin''handleNewArray-4 (first s), this, elementType, length) => (recur (next s))
                        :done
                    )
                )
                (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''append-2 this, (BytecodeParser''createNewArray-4 this, elementType, length, true))))
            )
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genNewObjectArray-2 [#_"BytecodeParser" this, #_"int" cpi]
        (let [
            #_"JavaType" type (BytecodeParser''lookupType-3 this, cpi, Bytecodes'ANEWARRAY)
            #_"ValueNode" length (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
        ]
            (when (instance? ResolvedJavaType type) => (BytecodeParser''handleUnresolvedNewObjectArray-3 this, type, length)
                (or
                    (loop-when [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))] (some? s)
                        (when (NodePlugin''handleNewArray-4 (first s), this, type, length) => (recur (next s))
                            :done
                        )
                    )
                    (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''append-2 this, (BytecodeParser''createNewArray-4 this, type, length, true))))
                )
            )
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''genGetField-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genGetField-4 this, cpi, opcode, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object))
        nil
    )

    (§ method! #_"void" BytecodeParser''genGetField-4 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode, #_"ValueNode" receiver]
        (BytecodeParser''genGetField-3 this, (BytecodeParser''lookupField-3 this, cpi, opcode), receiver)
        nil
    )

    (§ method- #_"void" BytecodeParser''genGetField-3 [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" receiver]
        (when (instance? ResolvedJavaField field) => (BytecodeParser''handleUnresolvedLoadField-3 this, field, receiver)
            (BytecodeParser''genGetField-3 this, field, receiver)
        )
        nil
    )

    (§ method- #_"void" BytecodeParser''genGetField-3 [#_"BytecodeParser" this, #_"ResolvedJavaField" resolvedField, #_"ValueNode" receiver]
        (or
            (loop-when [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))] (some? s)
                (when (NodePlugin''handleLoadField-4 (first s), this, receiver, resolvedField) => (recur (next s))
                    :done
                )
            )
            (let [
                #_"ValueNode" fieldRead (BytecodeParser''append-2 this, (BytecodeParser''genLoadField-3 this, receiver, resolvedField))
            ]
                (when (and (= (#_"ResolvedJavaType" .getName (#_"ResolvedJavaField" .getDeclaringClass resolvedField)) "Ljava/lang/ref/Reference;") (= (#_"ResolvedJavaField" .getName resolvedField) "referent"))
                    (BytecodeParser''append-2 this, (MembarNode'new-2 0, (FieldLocationIdentity'new-1 resolvedField)))
                )
                (let [
                    #_"JavaKind" fieldKind (#_"ResolvedJavaField" .getJavaKind resolvedField)
                ]
                    (if (and (#_"ResolvedJavaField" .isVolatile resolvedField) (instance? LoadFieldNode fieldRead))
                        (let [
                            #_"StateSplitProxyNode" readProxy (BytecodeParser''append-2 this, (BytecodeParser''genVolatileFieldReadProxy-2 this, fieldRead))
                        ]
                            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), fieldKind, readProxy))
                            (StateSplitProxyNode''setStateAfter-2 readProxy, (FrameStateBuilder''create-3 (:frameState this), (:nextBCI (:stream this)), readProxy))
                        )
                        (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), fieldKind, fieldRead))
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"BytecodeParser" BytecodeParser''genPutField-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genPutField-2 this, (BytecodeParser''lookupField-3 this, cpi, opcode))
    )

    (§ method! #_"BytecodeParser" BytecodeParser''genPutField-2 [#_"BytecodeParser" this, #_"JavaField" field]
        (BytecodeParser''genPutField-3 this, field, (FrameStateBuilder''pop-2 (:frameState this), (#_"JavaField" .getJavaKind field)))
    )

    (§ method- #_"BytecodeParser" BytecodeParser''genPutField-3 [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" value]
        (let [
            #_"ValueNode" receiver (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (when (instance? ResolvedJavaField field) => (BytecodeParser''handleUnresolvedStoreField-4 this, field, value, receiver)
                (or
                    (loop-when [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))] (some? s)
                        (when (NodePlugin''handleStoreField-5 (first s), this, receiver, field, value) => (recur (next s))
                            :done
                        )
                    )
                    (do
                        (when (and (#_"ResolvedJavaField" .isFinal field) (#_"ResolvedJavaMethod" .isConstructor (:method this)))
                            (§ ass! this (assoc this :finalBarrierRequired true))
                        )
                        (BytecodeParser''genStoreField-4 this, receiver, field, value)
                    )
                )
            )
        )
        this
    )

    (§ method! #_"void" BytecodeParser''genGetStatic-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genGetStatic-2 this, (BytecodeParser''lookupField-3 this, cpi, opcode))
        nil
    )

    (§ method- #_"void" BytecodeParser''genGetStatic-2 [#_"BytecodeParser" this, #_"JavaField" field]
        (let [
            #_"ResolvedJavaField" resolvedField (BytecodeParser''resolveStaticFieldAccess-3 this, field, nil)
        ]
            (when (some? resolvedField)
                (or
                    ;; Javac does not allow the use of "$assertionsDisabled" for a field name as Eclipse does.
                    ;; In this case a suffix is added to the generated field.
                    (when (and (#_"ResolvedJavaField" .isSynthetic resolvedField) (#_"String" .startsWith (#_"ResolvedJavaField" .getName resolvedField), "$assertionsDisabled"))
                        (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), (#_"JavaField" .getJavaKind field), (ConstantNode'forBoolean-2 true, (:graph this))))
                        :done
                    )
                    (loop-when [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))] (some? s)
                        (when (NodePlugin''handleLoadStaticField-3 (first s), this, resolvedField) => (recur (next s))
                            :done
                        )
                    )
                    (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), (#_"JavaField" .getJavaKind field), (BytecodeParser''append-2 this, (BytecodeParser''genLoadField-3 this, nil, resolvedField))))
                )
            )
        )
        nil
    )

    (§ method- #_"ResolvedJavaField" BytecodeParser''resolveStaticFieldAccess-3 [#_"BytecodeParser" this, #_"JavaField" field, #_"ValueNode" value]
        (when (instance? ResolvedJavaField field)
            (when (#_"ResolvedJavaType" .isInitialized (#_"ResolvedJavaField" .getDeclaringClass field))
                (§ return field)
            )
            ;; Static fields have initialization semantics but may be safely accessed under certain
            ;; conditions while the class is being initialized. Executing in the clinit or init of
            ;; classes which are subtypes of the field holder are sure to be running in a context
            ;; where the access is safe.
            (when (and (#_"ResolvedJavaType" .isAssignableFrom (#_"ResolvedJavaField" .getDeclaringClass field), (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))) (or (#_"ResolvedJavaMethod" .isClassInitializer (:method this)) (#_"ResolvedJavaMethod" .isConstructor (:method this))))
                (§ return field)
            )
        )
        (if (nil? value)
            (BytecodeParser''handleUnresolvedLoadField-3 this, field, nil)
            (BytecodeParser''handleUnresolvedStoreField-4 this, field, value, nil)
        )
        nil
    )

    (§ method! #_"void" BytecodeParser''genPutStatic-3 [#_"BytecodeParser" this, #_"int" cpi, #_"int" opcode]
        (BytecodeParser''genPutStatic-2 this, (BytecodeParser''lookupField-3 this, cpi, opcode))
        nil
    )

    (§ method! #_"void" BytecodeParser''genPutStatic-2 [#_"BytecodeParser" this, #_"JavaField" field]
        (let [
            #_"ValueNode" value (FrameStateBuilder''pop-2 (:frameState this), (#_"JavaField" .getJavaKind field))
            #_"ResolvedJavaField" resolvedField (BytecodeParser''resolveStaticFieldAccess-3 this, field, value)
        ]
            (when (some? resolvedField)
                (or
                    (loop-when [#_"ISeq" s (seq (:nodePlugins (:plugins (:graphBuilderConfig this))))] (some? s)
                        (when (NodePlugin''handleStoreStaticField-4 (first s), this, resolvedField, value) => (recur (next s))
                            :done
                        )
                    )
                    (BytecodeParser''genStoreField-4 this, nil, resolvedField, value)
                )
            )
        )
        nil
    )

    (§ method- #_"double[]" BytecodeParser''switchProbability-3 [#_"BytecodeParser" this, #_"int" numberOfCases, #_"int" bci]
        (let [
            #_"double[]" prob (double-array numberOfCases)
        ]
            (dotimes [#_"int" i numberOfCases]
                (aset prob i (/ 1.0 numberOfCases))
            )
            prob
        )
    )

    (§ method- #_"BytecodeParser" BytecodeParser''genSwitch-2 [#_"BytecodeParser" this, #_"BytecodeSwitch" bs]
        (let [
            #_"int" bci (BytecodeParser''bci-1 this)
            #_"ValueNode" value (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int)
            #_"int" nofCases (BytecodeSwitch''numberOfCases-1 bs)
            #_"int" nofCasesPlusDefault (inc nofCases)
            #_"double[]" keyProbabilities (BytecodeParser''switchProbability-3 this, nofCasesPlusDefault, bci)
            #_"EconomicMap<Integer, SuccessorInfo>" bciToBlockSuccessorIndex (EconomicMap/create Equivalence/DEFAULT)
            _
                (dotimes [#_"int" i (count (:successors (:currentBlock this)))]
                    (#_"EconomicMap" .put bciToBlockSuccessorIndex, (:startBci (BciBlock''getSuccessor-2 (:currentBlock this), i)), (SuccessorInfo'new-1 i))
                )
            #_"ArrayList<BciBlock>" actualSuccessors (ArrayList.)
            #_"int[]" keys (int-array nofCases)
            #_"int[]" keySuccessors (int-array nofCasesPlusDefault)
            [#_"int" deoptSuccessorIndex #_"int" nextSuccessorIndex]
                (loop-when [deoptSuccessorIndex -1 nextSuccessorIndex 0 #_"int" i 0] (< i nofCasesPlusDefault) => [deoptSuccessorIndex nextSuccessorIndex]
                    (when (< i nofCases)
                        (aset keys i (BytecodeSwitch''keyAt-2 bs, i))
                    )
                    (let [
                        [deoptSuccessorIndex nextSuccessorIndex]
                            (if (and (not (instance? ConstantNode value)) (BytecodeParser''isNeverExecutedCode-2 this, (nth keyProbabilities i)))
                                (let [
                                    [deoptSuccessorIndex nextSuccessorIndex]
                                        (when (neg? deoptSuccessorIndex) => [deoptSuccessorIndex nextSuccessorIndex]
                                            (#_"ArrayList" .add actualSuccessors, nil)
                                            [nextSuccessorIndex (inc nextSuccessorIndex)]
                                        )
                                ]
                                    (aset keySuccessors i deoptSuccessorIndex)
                                    [deoptSuccessorIndex nextSuccessorIndex]
                                )
                                (let [
                                    #_"int" targetBci (if (< i nofCases) (BytecodeSwitch''targetAt-2 bs, i) (BytecodeSwitch''defaultTarget-1 bs))
                                    #_"SuccessorInfo" info (get bciToBlockSuccessorIndex targetBci)
                                    [info nextSuccessorIndex]
                                        (when (neg? (:actualIndex info)) => [info nextSuccessorIndex]
                                            (#_"ArrayList" .add actualSuccessors, (BciBlock''getSuccessor-2 (:currentBlock this), (:blockIndex info)))
                                            [(assoc info :actualIndex nextSuccessorIndex) (inc nextSuccessorIndex)]
                                        )
                                ]
                                    (aset keySuccessors i (:actualIndex info))
                                    [deoptSuccessorIndex nextSuccessorIndex]
                                )
                            )
                    ]
                        (recur deoptSuccessorIndex nextSuccessorIndex (inc i))
                    )
                )
        ]
            ;; When the profile indicates a case is never taken, the above code will cause the case to
            ;; deopt should it be subsequently encountered. However, the case may share code with
            ;; another case that is taken according to the profile.
            ;;
            ;; For example:
            ;;
            ;; switch (opcode) {
            ;;     case GOTO:
            ;;     case GOTO_W: {
            ;;         // emit goto code
            ;;         break;
            ;;     }
            ;; }
            ;;
            ;; The profile may indicate the GOTO_W case is never taken, and thus a deoptimization stub
            ;; will be emitted. There might be optimization opportunity if additional branching based
            ;; on opcode is within the case block. Specially, if there is only single case that
            ;; reaches a target, we have better chance cutting out unused branches. Otherwise,
            ;; it might be beneficial routing to the same code instead of deopting.
            ;;
            ;; The following code rewires deoptimization stub to existing resolved branch target if
            ;; the target is connected by more than 1 cases.
            (when (<= 0 deoptSuccessorIndex)
                (let [
                    #_"int[]" connectedCases (int-array nextSuccessorIndex)
                ]
                    (dotimes [#_"int" i nofCasesPlusDefault]
                        (aswap connectedCases (nth keySuccessors i) inc)
                    )

                    (dotimes [#_"int" i nofCasesPlusDefault]
                        (when (= (nth keySuccessors i) deoptSuccessorIndex)
                            (let [
                                #_"int" targetBci (if (< i nofCases) (BytecodeSwitch''targetAt-2 bs, i) (BytecodeSwitch''defaultTarget-1 bs))
                                #_"SuccessorInfo" info (get bciToBlockSuccessorIndex targetBci)
                                #_"int" rewiredIndex (:actualIndex info)
                            ]
                                (when (and (<= 0 rewiredIndex) (< 1 (nth connectedCases rewiredIndex)))
                                    (aset keySuccessors i (:actualIndex info))
                                )
                            )
                        )
                    )
                )
            )

            (BytecodeParser''genIntegerSwitch-6 this, value, actualSuccessors, keys, keyProbabilities, keySuccessors)
        )
    )

    (§ method! #_"boolean" BytecodeParser''isNeverExecutedCode-2 [#_"BytecodeParser" this, #_"double" probability]
        (and (zero? probability) (OptimisticOptimizations''removeNeverExecutedCode-1 (:optimisticOpts this)))
    )

    (§ method- #_"double" BytecodeParser''clampProbability-2 [#_"BytecodeParser" this, #_"double" probability]
        (when-not (OptimisticOptimizations''removeNeverExecutedCode-1 (:optimisticOpts this)) => probability
            (case probability 0.0 0.0000001 1.0 0.999999 probability)
        )
    )

    (§ method! #_"BytecodeParser" BytecodeParser''processBytecode-3 [#_"BytecodeParser" this, #_"int" bci, #_"int" opcode]
        (condp =? opcode
            Bytecodes'NOP             nil ;; nothing to do
            Bytecodes'ACONST_NULL     (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Object, (BytecodeParser''appendConstant-2 this, JavaConstant/NULL_POINTER)))
           [Bytecodes'ICONST_M1
            Bytecodes'ICONST_0
            Bytecodes'ICONST_1
            Bytecodes'ICONST_2
            Bytecodes'ICONST_3
            Bytecodes'ICONST_4
            Bytecodes'ICONST_5]       (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''appendConstant-2 this, (JavaConstant/forInt (- opcode Bytecodes'ICONST_0)))))
           [Bytecodes'LCONST_0
            Bytecodes'LCONST_1]       (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Long, (BytecodeParser''appendConstant-2 this, (JavaConstant/forLong (- opcode Bytecodes'LCONST_0)))))
            Bytecodes'BIPUSH          (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''appendConstant-2 this, (JavaConstant/forInt (BytecodeStream''readByte-1 (:stream this))))))
            Bytecodes'SIPUSH          (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''appendConstant-2 this, (JavaConstant/forInt (BytecodeStream''readShort-1 (:stream this))))))
           [Bytecodes'LDC
            Bytecodes'LDC_W
            Bytecodes'LDC2_W]         (BytecodeParser''genLoadConstant-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'ILOAD           (BytecodeParser''loadLocal-3 this, (BytecodeStream''readLocalIndex-1 (:stream this)), JavaKind/Int)
            Bytecodes'LLOAD           (BytecodeParser''loadLocal-3 this, (BytecodeStream''readLocalIndex-1 (:stream this)), JavaKind/Long)
            Bytecodes'ALOAD           (BytecodeParser''loadLocalObject-2 this, (BytecodeStream''readLocalIndex-1 (:stream this)))
           [Bytecodes'ILOAD_0
            Bytecodes'ILOAD_1
            Bytecodes'ILOAD_2
            Bytecodes'ILOAD_3]        (BytecodeParser''loadLocal-3 this, (- opcode Bytecodes'ILOAD_0), JavaKind/Int)
           [Bytecodes'LLOAD_0
            Bytecodes'LLOAD_1
            Bytecodes'LLOAD_2
            Bytecodes'LLOAD_3]        (BytecodeParser''loadLocal-3 this, (- opcode Bytecodes'LLOAD_0), JavaKind/Long)
           [Bytecodes'ALOAD_0
            Bytecodes'ALOAD_1
            Bytecodes'ALOAD_2
            Bytecodes'ALOAD_3]        (BytecodeParser''loadLocalObject-2 this, (- opcode Bytecodes'ALOAD_0))
            Bytecodes'IALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Int)
            Bytecodes'LALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Long)
            Bytecodes'AALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Object)
            Bytecodes'BALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Byte)
            Bytecodes'CALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Char)
            Bytecodes'SALOAD          (BytecodeParser''genLoadIndexed-2 this, JavaKind/Short)
            Bytecodes'ISTORE          (BytecodeParser''storeLocal-3 this, JavaKind/Int, (BytecodeStream''readLocalIndex-1 (:stream this)))
            Bytecodes'LSTORE          (BytecodeParser''storeLocal-3 this, JavaKind/Long, (BytecodeStream''readLocalIndex-1 (:stream this)))
            Bytecodes'ASTORE          (BytecodeParser''storeLocal-3 this, JavaKind/Object, (BytecodeStream''readLocalIndex-1 (:stream this)))
           [Bytecodes'ISTORE_0
            Bytecodes'ISTORE_1
            Bytecodes'ISTORE_2
            Bytecodes'ISTORE_3]       (BytecodeParser''storeLocal-3 this, JavaKind/Int, (- opcode Bytecodes'ISTORE_0))
           [Bytecodes'LSTORE_0
            Bytecodes'LSTORE_1
            Bytecodes'LSTORE_2
            Bytecodes'LSTORE_3]       (BytecodeParser''storeLocal-3 this, JavaKind/Long, (- opcode Bytecodes'LSTORE_0))
           [Bytecodes'ASTORE_0
            Bytecodes'ASTORE_1
            Bytecodes'ASTORE_2
            Bytecodes'ASTORE_3]       (BytecodeParser''storeLocal-3 this, JavaKind/Object, (- opcode Bytecodes'ASTORE_0))
            Bytecodes'IASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Int)
            Bytecodes'LASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Long)
            Bytecodes'AASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Object)
            Bytecodes'BASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Byte)
            Bytecodes'CASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Char)
            Bytecodes'SASTORE         (BytecodeParser''genStoreIndexed-2 this, JavaKind/Short)
           [Bytecodes'POP
            Bytecodes'POP2
            Bytecodes'DUP
            Bytecodes'DUP_X1
            Bytecodes'DUP_X2
            Bytecodes'DUP2
            Bytecodes'DUP2_X1
            Bytecodes'DUP2_X2
            Bytecodes'SWAP]           (§ ass! (:frameState this) (FrameStateBuilder''stackOp-2 (:frameState this), opcode))
           [Bytecodes'IADD
            Bytecodes'ISUB
            Bytecodes'IMUL]           (BytecodeParser''genArithmeticOp-3 this, JavaKind/Int, opcode)
           [Bytecodes'IDIV
            Bytecodes'IREM]           (BytecodeParser''genIntegerDivOp-3 this, JavaKind/Int, opcode)
           [Bytecodes'LADD
            Bytecodes'LSUB
            Bytecodes'LMUL]           (BytecodeParser''genArithmeticOp-3 this, JavaKind/Long, opcode)
           [Bytecodes'LDIV
            Bytecodes'LREM]           (BytecodeParser''genIntegerDivOp-3 this, JavaKind/Long, opcode)
            Bytecodes'INEG            (BytecodeParser''genNegateOp-2 this, JavaKind/Int)
            Bytecodes'LNEG            (BytecodeParser''genNegateOp-2 this, JavaKind/Long)
           [Bytecodes'ISHL
            Bytecodes'ISHR
            Bytecodes'IUSHR]          (BytecodeParser''genShiftOp-3 this, JavaKind/Int, opcode)
           [Bytecodes'IAND
            Bytecodes'IOR
            Bytecodes'IXOR]           (BytecodeParser''genLogicOp-3 this, JavaKind/Int, opcode)
           [Bytecodes'LSHL
            Bytecodes'LSHR
            Bytecodes'LUSHR]          (BytecodeParser''genShiftOp-3 this, JavaKind/Long, opcode)
           [Bytecodes'LAND
            Bytecodes'LOR
            Bytecodes'LXOR]           (BytecodeParser''genLogicOp-3 this, JavaKind/Long, opcode)
            Bytecodes'IINC            (BytecodeParser''genIncrement-1 this)
            Bytecodes'L2I             (BytecodeParser''genNarrow-3 this, JavaKind/Long, JavaKind/Int)
            Bytecodes'I2L             (BytecodeParser''genSignExtend-3 this, JavaKind/Int, JavaKind/Long)
            Bytecodes'I2B             (BytecodeParser''genSignExtend-3 this, JavaKind/Byte, JavaKind/Int)
            Bytecodes'I2S             (BytecodeParser''genSignExtend-3 this, JavaKind/Short, JavaKind/Int)
            Bytecodes'I2C             (BytecodeParser''genZeroExtend-3 this, JavaKind/Char, JavaKind/Int)
            Bytecodes'LCMP            (BytecodeParser''genCompareOp-2 this, JavaKind/Long)
            Bytecodes'IFEQ            (§ ass! this (BytecodeParser''genIfZero-2 this, Condition'EQ))
            Bytecodes'IFNE            (§ ass! this (BytecodeParser''genIfZero-2 this, Condition'NE))
            Bytecodes'IFLT            (§ ass! this (BytecodeParser''genIfZero-2 this, Condition'LT))
            Bytecodes'IFGE            (§ ass! this (BytecodeParser''genIfZero-2 this, Condition'GE))
            Bytecodes'IFGT            (§ ass! this (BytecodeParser''genIfZero-2 this, Condition'GT))
            Bytecodes'IFLE            (§ ass! this (BytecodeParser''genIfZero-2 this, Condition'LE))
            Bytecodes'IF_ICMPEQ       (§ ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'EQ))
            Bytecodes'IF_ICMPNE       (§ ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'NE))
            Bytecodes'IF_ICMPLT       (§ ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'LT))
            Bytecodes'IF_ICMPGE       (§ ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'GE))
            Bytecodes'IF_ICMPGT       (§ ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'GT))
            Bytecodes'IF_ICMPLE       (§ ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Int, Condition'LE))
            Bytecodes'IF_ACMPEQ       (§ ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Object, Condition'EQ))
            Bytecodes'IF_ACMPNE       (§ ass! this (BytecodeParser''genIfSame-3 this, JavaKind/Object, Condition'NE))
            Bytecodes'GOTO            (BytecodeParser''genGoto-1 this)
            Bytecodes'JSR             (BytecodeParser''genJsr-2 this, (BytecodeStream''readBranchDest-1 (:stream this)))
            Bytecodes'RET             (BytecodeParser''genRet-2 this, (BytecodeStream''readLocalIndex-1 (:stream this)))
            Bytecodes'TABLESWITCH     (§ ass! this (BytecodeParser''genSwitch-2 this, (BytecodeTableSwitch'new-2 (:stream this), (BytecodeParser''bci-1 this))))
            Bytecodes'LOOKUPSWITCH    (§ ass! this (BytecodeParser''genSwitch-2 this, (BytecodeLookupSwitch'new-2 (:stream this), (BytecodeParser''bci-1 this))))
            Bytecodes'IRETURN         (§ ass! this (BytecodeParser''genReturn-3 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Int), JavaKind/Int))
            Bytecodes'LRETURN         (§ ass! this (BytecodeParser''genReturn-3 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Long), JavaKind/Long))
            Bytecodes'ARETURN         (§ ass! this (BytecodeParser''genReturn-3 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object), JavaKind/Object))
            Bytecodes'RETURN          (§ ass! this (BytecodeParser''genReturn-3 this, nil, JavaKind/Void))
            Bytecodes'GETSTATIC       (BytecodeParser''genGetStatic-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'PUTSTATIC       (BytecodeParser''genPutStatic-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'GETFIELD        (BytecodeParser''genGetField-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'PUTFIELD        (§ ass! this (BytecodeParser''genPutField-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode))
            Bytecodes'INVOKEVIRTUAL   (BytecodeParser''genInvokeVirtual-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'INVOKESPECIAL   (BytecodeParser''genInvokeSpecial-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'INVOKESTATIC    (BytecodeParser''genInvokeStatic-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'INVOKEINTERFACE (BytecodeParser''genInvokeInterface-3 this, (BytecodeStream''readCPI-1 (:stream this)), opcode)
            Bytecodes'INVOKEDYNAMIC   (BytecodeParser''genInvokeDynamic-3 this, (BytecodeStream''readCPI4-1 (:stream this)), opcode)
            Bytecodes'NEW             (BytecodeParser''genNewInstance-2 this, (BytecodeStream''readCPI-1 (:stream this)))
            Bytecodes'NEWARRAY        (BytecodeParser''genNewPrimitiveArray-2 this, (BytecodeStream''readLocalIndex-1 (:stream this)))
            Bytecodes'ANEWARRAY       (BytecodeParser''genNewObjectArray-2 this, (BytecodeStream''readCPI-1 (:stream this)))
            Bytecodes'ARRAYLENGTH     (BytecodeParser''genArrayLength-1 this)
            Bytecodes'CHECKCAST       (BytecodeParser''genCheckCast-1 this)
            Bytecodes'INSTANCEOF      (§ ass! this (BytecodeParser''genInstanceOf-1 this))
            Bytecodes'MONITORENTER    (BytecodeParser''genMonitorEnter-3 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object), (:nextBCI (:stream this)))
            Bytecodes'MONITOREXIT     (BytecodeParser''genMonitorExit-4 this, (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object), nil, (:nextBCI (:stream this)))
            Bytecodes'IFNULL          (§ ass! this (BytecodeParser''genIfNull-2 this, Condition'EQ))
            Bytecodes'IFNONNULL       (§ ass! this (BytecodeParser''genIfNull-2 this, Condition'NE))
            Bytecodes'GOTO_W          (BytecodeParser''genGoto-1 this)
            Bytecodes'JSR_W           (BytecodeParser''genJsr-2 this, (BytecodeStream''readBranchDest-1 (:stream this)))
        )
        this
    )

    (§ method- #_"void" BytecodeParser''genArrayLength-1 [#_"BytecodeParser" this]
        (let [
            #_"ValueNode" array (FrameStateBuilder''pop-2 (:frameState this), JavaKind/Object)
        ]
            (§ ass! (:frameState this) (FrameStateBuilder''push-3 (:frameState this), JavaKind/Int, (BytecodeParser''append-2 this, (ArrayLengthNode'create-1 array))))
        )
        nil
    )

    ;;;
     ; Gets the method being parsed by this context.
     ;;
    (§ method! #_"ResolvedJavaMethod" BytecodeParser''getMethod-1 [#_"BytecodeParser" this]
        (:method this)
    )

    ;;;
     ; Gets the code being parsed.
     ;;
    #_unused
    (§ method! #_"Bytecode" BytecodeParser''getCode-1 [#_"BytecodeParser" this]
        (:code this)
    )

    ;;;
     ; Determines if this parsing context is within the bytecode of an intrinsic or a method inlined by an intrinsic.
     ;;
    (§ override! #_"boolean" BytecodeParser''parsingIntrinsic-1 [#_"BytecodeParser" this]
        (some? (:intrinsicContext this))
    )

    ;;;
     ; Gets the first ancestor parsing context that is not parsing a {@linkplain #parsingIntrinsic() intrinsic}.
     ;;
    (§ method! #_"BytecodeParser" BytecodeParser''getNonIntrinsicAncestor-1 [#_"BytecodeParser" this]
        (loop-when-recur [#_"BytecodeParser" ancestor (:parent this)]
                         (and (some? ancestor) (BytecodeParser''parsingIntrinsic-1 ancestor))
                         [(:parent ancestor)]
                      => ancestor
        )
    )
)

;;;
 ; A scoped object for tasks to be performed after parsing an intrinsic such as processing
 ; {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frames states.
 ;
 ; @anno BytecodeParser.IntrinsicScope
 ;;
(final-ns IntrinsicScope (§ implements AutoCloseable)
    (§ mutable #_"FrameState" :stateBefore nil)
    (§ final #_"NodeMark" :mark nil)
    (§ final #_"BytecodeParser" :parser nil)
    (§ mutable #_"List<ReturnToCallerData>" :returnDataList nil)

    ;;;
     ; Creates a scope for root parsing an intrinsic.
     ;
     ; @param parser the parsing context of the intrinsic
     ;;
    (§ defn #_"IntrinsicScope" IntrinsicScope'new-1 [#_"BytecodeParser" parser]
        (let [
            #_"IntrinsicScope" this (Object.)
            this (assoc this :parser parser)
            this (assoc this :mark nil)
        ]
            this
        )
    )

    ;;;
     ; Creates a scope for parsing an intrinsic during graph builder inlining.
     ;
     ; @param parser the parsing context of the (non-intrinsic) method calling the intrinsic
     ; @param args the arguments to the call
     ;;
    (§ defn #_"IntrinsicScope" IntrinsicScope'new-3 [#_"BytecodeParser" parser, #_"JavaKind[]" argSlotKinds, #_"ValueNode[]" args]
        (let [
            #_"IntrinsicScope" this (Object.)
            this (assoc this :parser parser)
            this (assoc this :mark (NodeMark'new-1 (:graph parser)))
            this (assoc this :stateBefore (FrameStateBuilder''create-6 (:frameState parser), (BytecodeParser''bci-1 parser), (BytecodeParser''getNonIntrinsicAncestor-1 parser), false, argSlotKinds, args))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" IntrinsicScope''close-1 [#_"IntrinsicScope" this]
        (let [
            #_"IntrinsicContext" intrinsic (:intrinsicContext (:parser this))
        ]
            (when-not (and (some? intrinsic) (IntrinsicContext''isPostParseInlined-1 intrinsic))
                (§ ass! this (IntrinsicScope''processPlaceholderFrameStates-2 this, intrinsic))
            )
        )
        nil
    )

    ;;;
     ; Fixes up the {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frame states
     ; added to the graph while parsing/inlining the intrinsic for which this object exists.
     ;;
    (§ method- #_"IntrinsicScope" IntrinsicScope''processPlaceholderFrameStates-2 [#_"IntrinsicScope" this, #_"IntrinsicContext" intrinsic]
        (let [
            #_"Graph" graph (:graph (:parser this))
            #_"boolean" invalid?
                (loop-when [invalid? false #_"ISeq" s (seq (Graph''getNewNodes-2 graph, (:mark this)))] (some? s) => invalid?
                    (let [
                        #_"Node" node (first s)
                        invalid?
                            (when (instance? FrameState node) => invalid?
                                (let [
                                    #_"FrameState" frameState node
                                ]
                                    (when (BytecodeFrame/isPlaceholderBci (:bci frameState)) => invalid?
                                        (condp = (:bci frameState)
                                            BytecodeFrame/AFTER_BCI
                                                (if (nil? (BytecodeParser''getInvokeReturnType-1 (:parser this)))
                                                    ;; A frame state in a root compiled intrinsic.
                                                    (do
                                                        (§ ass! frameState (Node''replaceAndDelete-2 frameState, (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/INVALID_FRAMESTATE_BCI))))
                                                        invalid?
                                                    )
                                                    (let [
                                                        #_"JavaKind" returnKind (#_"JavaType" .getJavaKind (BytecodeParser''getInvokeReturnType-1 (:parser this)))
                                                        #_"FrameStateBuilder" frameStateBuilder (:frameState (:parser this))
                                                    ]
                                                        (cond
                                                            (not (zero? (:stackSize frameState)))
                                                                (let [
                                                                    #_"ValueNode" returnVal (FrameState''stackAt-2 frameState, 0)
                                                                ]
                                                                    (when-not (ReturnToCallerData'containsReturnValue-2 (:returnDataList this), returnVal)
                                                                        (throw! (str "AFTER_BCI frame state within an intrinsic has a non-return value on the stack: " returnVal))
                                                                    )
                                                                    ;; Swap the top-of-stack value with the return value.
                                                                    (let [
                                                                        #_"ValueNode" tos (FrameStateBuilder''pop-2 frameStateBuilder, returnKind)
                                                                    ]
                                                                        (§ ass! frameState (Node''replaceAndDelete-2 frameState, (FrameStateBuilder''create-6 frameStateBuilder, (:nextBCI (:stream (:parser this))), (BytecodeParser''getNonIntrinsicAncestor-1 (:parser this)), false, (into-array JavaKind [ returnKind ]), (into-array ValueNode [ returnVal ]))))
                                                                        (§ ass! frameStateBuilder (FrameStateBuilder''push-3 frameStateBuilder, returnKind, tos))
                                                                    )
                                                                    invalid?
                                                                )
                                                            (= returnKind JavaKind/Void)
                                                                ;; An intrinsic for a void method.
                                                                (do
                                                                    (§ ass! frameState (Node''replaceAndDelete-2 frameState, (FrameStateBuilder''create-3 frameStateBuilder, (:nextBCI (:stream (:parser this))), nil)))
                                                                    invalid?
                                                                )
                                                            :else
                                                                ;; If the intrinsic returns a non-void value, then any frame state with an empty stack
                                                                ;; is invalid as it cannot be used to deoptimize to just after the call returns.
                                                                ;; These invalid frame states are expected to be removed by later compilation stages.
                                                                (do
                                                                    (§ ass! frameState (Node''replaceAndDelete-2 frameState, (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/INVALID_FRAMESTATE_BCI))))
                                                                    true
                                                                )
                                                        )
                                                    )
                                                )
                                            BytecodeFrame/BEFORE_BCI
                                                (do
                                                    (when (nil? (:stateBefore this))
                                                        (§ ass! this (assoc this :stateBefore (BeginStateSplitNode''stateAfter-1 (:start graph))))
                                                    )
                                                    (when-not (= (:stateBefore this) frameState)
                                                        (§ ass! frameState (Node''replaceAndDelete-2 frameState, (:stateBefore this)))
                                                    )
                                                    invalid?
                                                )
                                            #_else
                                                invalid?
                                        )
                                    )
                                )
                            )
                    ]
                        (recur invalid? (next s))
                    )
                )
        ]
            (when invalid?
                (let [
                    #_"JavaKind" returnKind (#_"JavaType" .getJavaKind (BytecodeParser''getInvokeReturnType-1 (:parser this)))
                    #_"ValueNode" returnValue (FrameStateBuilder''pop-2 (:frameState (:parser this)), returnKind)
                    #_"StateSplitProxyNode" proxy (Graph''add-2 graph, (StateSplitProxyNode'new-1 returnValue))
                ]
                    (§ ass! (:lastInstr (:parser this)) (FixedWithNextNode''setNext-2 (:lastInstr (:parser this)), proxy))
                    (§ ass! (:frameState (:parser this)) (FrameStateBuilder''push-3 (:frameState (:parser this)), returnKind, proxy))
                    (StateSplitProxyNode''setStateAfter-2 proxy, (BytecodeParser''createFrameState-3 (:parser this), (:nextBCI (:stream (:parser this))), proxy))
                    (§ ass! (:lastInstr (:parser this)) proxy)
                )
            )
            this
        )
    )
)

;;;
 ; @anno BytecodeParser.FixedTarget
 ;;
(final-ns FixedTarget
    (§ final #_"FixedNode" :fixed nil)
    (§ final #_"FrameStateBuilder" :state nil)

    (§ defn #_"FixedTarget" FixedTarget'new-2 [#_"FixedNode" fixed, #_"FrameStateBuilder" state]
        (let [
            #_"FixedTarget" this (Object.)
            this (assoc this :fixed fixed)
            this (assoc this :state state)
        ]
            this
        )
    )
)

;;;
 ; @anno BytecodeParser.ReturnToCallerData
 ;;
(final-ns ReturnToCallerData
    (§ final #_"ValueNode" :returnValue nil)
    (§ final #_"FixedWithNextNode" :beforeReturnNode nil)

    (§ defn #_"ReturnToCallerData" ReturnToCallerData'new-2 [#_"ValueNode" returnValue, #_"FixedWithNextNode" beforeReturnNode]
        (let [
            #_"ReturnToCallerData" this (Object.)
            this (assoc this :returnValue returnValue)
            this (assoc this :beforeReturnNode beforeReturnNode)
        ]
            this
        )
    )

    (§ defn #_"boolean" ReturnToCallerData'containsReturnValue-2 [#_"List<ReturnToCallerData>" list, #_"ValueNode" value]
        (loop [#_"ISeq" s (seq list)] (and (some? s) (or (= (:returnValue (first s)) value) (recur (next s)))))
    )
)

;;;
 ; @anno BytecodeParser.CurrentInvoke
 ;;
(final-ns CurrentInvoke
    (§ final #_"ValueNode[]" :args nil)
    (§ final #_"InvokeKind" :kind nil)
    (§ final #_"JavaType" :returnType nil)

    (§ defn #_"CurrentInvoke" CurrentInvoke'new-3 [#_"ValueNode[]" args, #_"InvokeKind" kind, #_"JavaType" returnType]
        (let [
            #_"CurrentInvoke" this (Object.)
            this (assoc this :args args)
            this (assoc this :kind kind)
            this (assoc this :returnType returnType)
        ]
            this
        )
    )
)

;;;
 ; @anno BytecodeParser.SuccessorInfo
 ;;
(final-ns SuccessorInfo
    (§ final #_"int" :blockIndex 0)
    (§ mutable #_"int" :actualIndex 0)

    (§ defn #_"SuccessorInfo" SuccessorInfo'new-1 [#_"int" blockSuccessorIndex]
        (let [
            #_"SuccessorInfo" this (Object.)
            this (assoc this :blockIndex blockSuccessorIndex)
            this (assoc this :actualIndex -1)
        ]
            this
        )
    )
)

(final-ns ComputeLoopFrequenciesClosure (§ extends NodeIteratorClosure #_"<Double>")
    (§ def- #_"ComputeLoopFrequenciesClosure" ComputeLoopFrequenciesClosure'INSTANCE (ComputeLoopFrequenciesClosure'new-0))

    (§ defn- #_"ComputeLoopFrequenciesClosure" ComputeLoopFrequenciesClosure'new-0 []
        (NodeIteratorClosure'new-0)
    )

    #_unused
    (§ override! #_"Double" ComputeLoopFrequenciesClosure''processNode-3 [#_"ComputeLoopFrequenciesClosure" this, #_"FixedNode" node, #_"Double" currentState]
        ;; normal nodes never change the probability of a path
        currentState
    )

    #_unused
    (§ override! #_"Double" ComputeLoopFrequenciesClosure''merge-3 [#_"ComputeLoopFrequenciesClosure" this, #_"AbstractMergeNode" merge, #_"List<Double>" states]
        ;; a merge has the sum of all predecessor probabilities
        (reduce + 0.0 states)
    )

    #_unused
    (§ override! #_"Double" ComputeLoopFrequenciesClosure''afterSplit-3 [#_"ComputeLoopFrequenciesClosure" this, #_"AbstractBeginNode" node, #_"Double" oldState]
        ;; a control split splits up the probability
        (* oldState (ControlSplitNode''probability-2 (:predecessor node), node))
    )

    #_unused
    (§ override! #_"EconomicMap<LoopExitNode, Double>" ComputeLoopFrequenciesClosure''processLoop-3 [#_"ComputeLoopFrequenciesClosure" this, #_"LoopBeginNode" loop, #_"Double" initialState]
        (let [
            #_"EconomicMap<LoopExitNode, Double>" exitStates (:exitStates (ReentrantNodeIterator'processLoop-3 this, loop, 1.0))
            #_"double" exitProbability (reduce + 0.0 (vals exitStates))
            exitProbability (max ControlFlowGraph'MIN_PROBABILITY (min exitProbability 1.0))
            #_"double" loopFrequency (/ 1.0 exitProbability)
        ]
            (§ ass! loop (LoopBeginNode''setLoopFrequency-2 loop, loopFrequency))

            (let [
                #_"double" adjustmentFactor (* initialState loopFrequency)
            ]
                (#_"EconomicMap" .replaceAll exitStates, (ß (exitNode, probability) -> (§ fun (ControlFlowGraph'multiplyProbabilities-2 probability, adjustmentFactor))))

                exitStates
            )
        )
    )

    ;;;
     ; Computes the frequencies of all loops in the given graph. This is done by performing a
     ; reverse postorder iteration and computing the probability of all fixed nodes. The combined
     ; probability of all exits of a loop can be used to compute the loop's expected frequency.
     ;;
    (§ defn #_"void" ComputeLoopFrequenciesClosure'compute-1 [#_"Graph" graph]
        (when (Graph''hasLoops-1 graph)
            (ReentrantNodeIterator'apply-3 ComputeLoopFrequenciesClosure'INSTANCE, (:start graph), 1.0)
        )
        nil
    )

    (§ def #_"ComputeLoopFrequencyPhase" ComputeLoopFrequenciesClosure'PHASE_INSTANCE (ComputeLoopFrequencyPhase'new-0))
)

;;;
 ; @anno ComputeLoopFrequenciesClosure.ComputeLoopFrequencyPhase
 ;;
(final-ns ComputeLoopFrequencyPhase (§ extends Phase)
    (§ defn #_"ComputeLoopFrequencyPhase" ComputeLoopFrequencyPhase'new-0 []
        (Phase'new-0)
    )

    #_unused
    (§ override! #_"void" ComputeLoopFrequencyPhase''run-2 [#_"ComputeLoopFrequencyPhase" this, #_"Graph" graph]
        (ComputeLoopFrequenciesClosure'compute-1 graph)
        nil
    )
)

(final-ns FrameStateBuilder (§ implements SideEffectsState)
    (§ def- #_"ValueNode[]" FrameStateBuilder'EMPTY_ARRAY (make-array ValueNode 0))
    (§ def- #_"MonitorIdNode[]" FrameStateBuilder'EMPTY_MONITOR_ARRAY (make-array MonitorIdNode 0))

    (§ final #_"BytecodeParser" :parser nil)
    (§ final #_"GraphBuilderTool" :tool nil)
    (§ final #_"Bytecode" :code nil)
    ;;;
     ; Current size (height) of the stack.
     ;;
    (§ mutable #_"int" :stackSize 0)
    (§ final #_"ValueNode[]" :locals nil)
    (§ final #_"ValueNode[]" :stack nil)
    (§ mutable #_"ValueNode[]" :lockedObjects nil)

    (§ mutable #_"MonitorIdNode[]" :monitorIds nil)
    (§ final #_"Graph" :graph nil)
    (§ mutable #_"FrameState" :outerFrameState nil)

    ;;;
     ; The closest {@link StateSplit#hasSideEffect() side-effect} predecessors. There will be more
     ; than one when the current block contains no side-effects but merging predecessor blocks do.
     ;;
    (§ mutable #_"List<StateSplit>" :sideEffects nil)

    (§ defn- #_"ValueNode[]" FrameStateBuilder'allocateArray-1 [#_"int" length]
        (if (zero? length) FrameStateBuilder'EMPTY_ARRAY (make-array ValueNode length))
    )

    ;;;
     ; Creates a new frame state builder for the given code attribute, method and the given target graph.
     ;
     ; @param code the bytecode in which the frame exists
     ; @param graph the target graph of Graal nodes created by the builder
     ;;
    (§ defn #_"FrameStateBuilder" FrameStateBuilder'new-3 [#_"GraphBuilderTool" tool, #_"Bytecode" code, #_"Graph" graph]
        (let [
            #_"FrameStateBuilder" this (Object.)
            this (assoc this :tool tool)
            this (assoc this :parser (when (instance? BytecodeParser tool) tool))
            this (assoc this :code code)
            this (assoc this :locals (FrameStateBuilder'allocateArray-1 (Bytecode''getMaxLocals-1 code)))
            this (assoc this :stack (FrameStateBuilder'allocateArray-1 (max 1 (Bytecode''getMaxStackSize-1 code))))
            this (assoc this :lockedObjects (FrameStateBuilder'allocateArray-1 0))
            this (assoc this :monitorIds FrameStateBuilder'EMPTY_MONITOR_ARRAY)
            this (assoc this :graph graph)
        ]
            this
        )
    )

    ;;;
     ; Creates a new frame state builder for the given method and the given target graph.
     ;
     ; @param method the method whose frame is simulated
     ; @param graph the target graph of Graal nodes created by the builder
     ;;
    (§ defn #_"FrameStateBuilder" FrameStateBuilder'new-3 [#_"GraphBuilderTool" tool, #_"ResolvedJavaMethod" method, #_"Graph" graph]
        (FrameStateBuilder'new-3 tool, (ResolvedJavaMethodBytecode'new-1 method), graph)
    )

    (§ defn- #_"FrameStateBuilder" FrameStateBuilder'new-1 [#_"FrameStateBuilder" other]
        (let [
            #_"FrameStateBuilder" this (Object.)
            this (assoc this :parser (:parser other))
            this (assoc this :tool (:tool other))
            this (assoc this :code (:code other))
            this (assoc this :stackSize (:stackSize other))
            this (assoc this :locals (#_"Object" .clone (:locals other)))
            this (assoc this :stack (#_"Object" .clone (:stack other)))
            this (assoc this :lockedObjects (if (empty? (:lockedObjects other)) (:lockedObjects other) (#_"Object" .clone (:lockedObjects other))))
            this (assoc this :graph (:graph other))
            this (assoc this :monitorIds (if (empty? (:monitorIds other)) (:monitorIds other) (#_"Object" .clone (:monitorIds other))))
        ]
            this
        )
    )

    (§ method! #_"FrameStateBuilder" FrameStateBuilder''copy-1 [#_"FrameStateBuilder" this]
        (FrameStateBuilder'new-1 this)
    )

    (§ method! #_"void" FrameStateBuilder''initializeFromArgumentsArray-2 [#_"FrameStateBuilder" this, #_"ValueNode[]" arguments]
        (let [
            #_"ResolvedJavaMethod" method (FrameStateBuilder''getMethod-1 this)
            [#_"int" i #_"int" j]
                (when-not (#_"ResolvedJavaMethod" .isStatic method) => [0 0]
                    ;; set the receiver
                    (aset (:locals this) 0 (nth arguments 0))
                    [1 1]
                )
            #_"Signature" sig (#_"ResolvedJavaMethod" .getSignature method)
        ]
            (loop-when [i i j j #_"int" k 0] (< k (#_"Signature" .getParameterCount sig, false))
                (aset (:locals this) j (nth arguments i))
                (let [
                    j (inc j)
                    j
                        (when (#_"JavaKind" .needsTwoSlots (#_"Signature" .getParameterKind sig, k)) => j
                            (aset (:locals this) j FrameState'TWO_SLOT_MARKER)
                            (inc j)
                        )
                ]
                    (recur (inc i) j (inc k))
                )
            )
        )
        nil
    )

    (§ method! #_"void" FrameStateBuilder''initializeForMethodStart-3 [#_"FrameStateBuilder" this, #_"boolean" eagerResolve, #_"Plugins" plugins]
        (let [
            #_"ResolvedJavaMethod" method (FrameStateBuilder''getMethod-1 this)
            #_"ResolvedJavaType" originalType (#_"ResolvedJavaMethod" .getDeclaringClass method)
            [#_"int" i #_"int" j]
                (when-not (#_"ResolvedJavaMethod" .isStatic method) => [0 0]
                    (let [
                        #_"StampPair" receiverStamp
                            (or (when (some? plugins) (Plugins''getOverridingStamp-4 plugins, (:tool this), originalType, true))
                                (StampFactory'forDeclaredType-2 originalType, true)
                            )
                        #_"FloatingNode" receiver
                            (when (some? plugins)
                                (loop-when [#_"ISeq" s (seq (:parameterPlugins plugins))] (some? s)
                                    (or (ParameterPlugin''interceptParameter-4 (first s), (:tool this), 0, receiverStamp)
                                        (recur (next s))
                                    )
                                )
                            )
                    ]
                        (aset (:locals this) 0 (Graph''addOrUniqueWithInputs-2 (:graph this), (or receiver (ParameterNode'new-2 0, receiverStamp))))
                        [1 1]
                    )
                )
            #_"Signature" sig (#_"ResolvedJavaMethod" .getSignature method)
        ]
            (loop-when [i i j j #_"int" k 0] (< k (#_"Signature" .getParameterCount sig, false))
                (let [
                    #_"JavaType" type (#_"Signature" .getParameterType sig, k, originalType)
                    type (if eagerResolve (#_"JavaType" .resolve type, originalType) type)
                    #_"JavaKind" kind (#_"JavaType" .getJavaKind type)
                    #_"StampPair" stamp
                        (or (when (some? plugins) (Plugins''getOverridingStamp-4 plugins, (:tool this), type, false))
                            (StampFactory'forDeclaredType-2 type, false)
                        )
                    #_"FloatingNode" param
                        (when (some? plugins)
                            (loop-when [#_"ISeq" s (seq (:parameterPlugins plugins))] (some? s)
                                (or (ParameterPlugin''interceptParameter-4 (first s), (:tool this), i, stamp)
                                    (recur (next s))
                                )
                            )
                        )
                ]
                    (aset (:locals this) j (Graph''addOrUniqueWithInputs-2 (:graph this), (or param (ParameterNode'new-2 i, stamp))))
                    (let [
                        j (inc j)
                        j
                            (when (#_"JavaKind" .needsTwoSlots kind) => j
                                (aset (:locals this) j FrameState'TWO_SLOT_MARKER)
                                (inc j)
                            )
                    ]
                        (recur (inc i) j (inc k))
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"ResolvedJavaMethod" FrameStateBuilder''getMethod-1 [#_"FrameStateBuilder" this]
        (Bytecode''getMethod-1 (:code this))
    )

    (§ method! #_"FrameState" FrameStateBuilder''create-3 [#_"FrameStateBuilder" this, #_"int" bci, #_"StateSplit" forStateSplit]
        (if (and (some? (:parser this)) (BytecodeParser''parsingIntrinsic-1 (:parser this)))
            (IntrinsicContext''createFrameState-4 (:intrinsicContext (:parser this)), (:graph (:parser this)), this, forStateSplit)
            ;; skip intrinsic frames
            (FrameStateBuilder''create-6 this, bci, (when (some? (:parser this)) (BytecodeParser''getNonIntrinsicAncestor-1 (:parser this))), false, nil, nil)
        )
    )

    ;;;
     ; @param pushedValues if non-nil, values to #push(JavaKind, ValueNode) to the stack before creating the FrameState
     ;;
    (§ method! #_"FrameState" FrameStateBuilder''create-6 [#_"FrameStateBuilder" this, #_"int" bci, #_"BytecodeParser" parent, #_"boolean" duringCall, #_"JavaKind[]" pushedSlotKinds, #_"ValueNode[]" pushedValues]
        (when (and (nil? (:outerFrameState this)) (some? parent))
            (§ ass! this (assoc this :outerFrameState (FrameStateBuilder''create-6 (:frameState parent), (BytecodeParser''bci-1 parent), (BytecodeParser''getNonIntrinsicAncestor-1 parent), true, nil, nil)))
        )
        (when-not (= bci BytecodeFrame/INVALID_FRAMESTATE_BCI) => (throw! "should not reach here")
            (if (some? pushedValues)
                (let [
                    #_"int" o'stackSize (:stackSize this)
                ]
                    (dotimes [#_"int" i (count pushedValues)]
                        (§ ass! this (FrameStateBuilder''push-3 this, (nth pushedSlotKinds i), (nth pushedValues i)))
                    )
                    (let [
                        #_"FrameState" res (Graph''add-2 (:graph this), (FrameState'new-9 (:outerFrameState this), (:code this), bci, (:locals this), (:stack this), (:stackSize this), (:lockedObjects this), (Arrays/asList (:monitorIds this)), duringCall))
                    ]
                        (§ ass! this (assoc this :stackSize o'stackSize))
                        res
                    )
                )
                (Graph''add-2 (:graph this), (FrameState'new-9 (:outerFrameState this), (:code this), bci, (:locals this), (:stack this), (:stackSize this), (:lockedObjects this), (Arrays/asList (:monitorIds this)), duringCall))
            )
        )
    )

    (§ method! #_"boolean" FrameStateBuilder''isCompatibleWith-2 [#_"FrameStateBuilder" this, #_"FrameStateBuilder" other]
        (and (= (:stackSize this) (:stackSize other))
            (loop [#_"int" i 0]
                (if (< i (:stackSize this))
                    (let [
                        #_"ValueNode" x (nth (:stack this) i)
                        #_"ValueNode" y (nth (:stack other) i)
                    ]
                        (if (and (not= x y) (or (= x FrameState'TWO_SLOT_MARKER) (Node''isDeleted-1 x) (= y FrameState'TWO_SLOT_MARKER) (Node''isDeleted-1 y) (not= (ValueNode''getStackKind-1 x) (ValueNode''getStackKind-1 y))))
                            false
                            (recur (inc i))
                        )
                    )
                    (and (= (count (:lockedObjects this)) (count (:lockedObjects other)))
                        (loop-when-recur [#_"int" i 0] (< i (count (:lockedObjects this))) [(inc i)] => true
                            (when (or (not= (GraphUtil'originalValue-1 (nth (:lockedObjects this) i)) (GraphUtil'originalValue-1 (nth (:lockedObjects other) i))) (not= (nth (:monitorIds this) i) (nth (:monitorIds other) i)))
                                (throw! "unbalanced monitors")
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"FrameStateBuilder" FrameStateBuilder''merge-3 [#_"FrameStateBuilder" this, #_"AbstractMergeNode" block, #_"FrameStateBuilder" other]
        (dotimes [#_"int" i (count (:locals this))]
            (aset (:locals this) i (FrameStateBuilder''merge-4 this, (nth (:locals this) i), (nth (:locals other) i), block))
        )
        (dotimes [#_"int" i (:stackSize this)]
            (aset (:stack this) i (FrameStateBuilder''merge-4 this, (nth (:stack this) i), (nth (:stack other) i), block))
        )
        (dotimes [#_"int" i (count (:lockedObjects this))]
            (aset (:lockedObjects this) i (FrameStateBuilder''merge-4 this, (nth (:lockedObjects this) i), (nth (:lockedObjects other) i), block))
        )

        (when (some? (:sideEffects this)) => (assoc this :sideEffects (:sideEffects other))
            (when (some? (:sideEffects other))
                (#_"List" .addAll (:sideEffects this), (:sideEffects other))
            )
            this
        )
    )

    (§ method- #_"ValueNode" FrameStateBuilder''merge-4 [#_"FrameStateBuilder" this, #_"ValueNode" currentValue, #_"ValueNode" otherValue, #_"AbstractMergeNode" block]
        (when (and (some? currentValue) (not (Node''isDeleted-1 currentValue)))
            (cond
                (AbstractMergeNode''isPhiAtMerge-2 block, currentValue)
                (do
                    (if (and (some? otherValue) (not= otherValue FrameState'TWO_SLOT_MARKER) (not (Node''isDeleted-1 otherValue)) (= (ValueNode''getStackKind-1 currentValue) (ValueNode''getStackKind-1 otherValue)))
                        (PhiNode''addInput-2 currentValue, otherValue)
                        ;; This phi must be dead anyway, add input of correct stack kind to keep the graph invariants.
                        (PhiNode''addInput-2 currentValue, (ConstantNode'defaultForKind-2 (ValueNode''getStackKind-1 currentValue), (:graph this)))
                    )
                    currentValue
                )
                (= currentValue otherValue)
                    currentValue
                (or (= currentValue FrameState'TWO_SLOT_MARKER) (= otherValue FrameState'TWO_SLOT_MARKER))
                    nil
                (and (some? otherValue) (not (Node''isDeleted-1 otherValue)) (= (ValueNode''getStackKind-1 currentValue) (ValueNode''getStackKind-1 otherValue)))
                    (FrameStateBuilder''createValuePhi-4 this, currentValue, otherValue, block)
            )
        )
    )

    (§ method- #_"ValuePhiNode" FrameStateBuilder''createValuePhi-4 [#_"FrameStateBuilder" this, #_"ValueNode" currentValue, #_"ValueNode" otherValue, #_"AbstractMergeNode" block]
        (let [
            #_"ValuePhiNode" phi (Graph''add-2 (:graph this), (ValuePhiNode'new-2 (Stamp''unrestricted-1 (:stamp currentValue)), block))
        ]
            (dotimes [#_"int" i (AbstractMergeNode''phiPredecessorCount-1 block)]
                (PhiNode''addInput-2 phi, currentValue)
            )
            (PhiNode''addInput-2 phi, otherValue)
            phi
        )
    )

    (§ method! #_"void" FrameStateBuilder''inferPhiStamps-2 [#_"FrameStateBuilder" this, #_"AbstractMergeNode" block]
        (dotimes [#_"int" i (count (:locals this))]
            (FrameStateBuilder'inferPhiStamp-2 block, (nth (:locals this) i))
        )
        (dotimes [#_"int" i (:stackSize this)]
            (FrameStateBuilder'inferPhiStamp-2 block, (nth (:stack this) i))
        )
        (dotimes [#_"int" i (count (:lockedObjects this))]
            (FrameStateBuilder'inferPhiStamp-2 block, (nth (:lockedObjects this) i))
        )
        nil
    )

    (§ defn- #_"void" FrameStateBuilder'inferPhiStamp-2 [#_"AbstractMergeNode" block, #_"ValueNode" node]
        (when (AbstractMergeNode''isPhiAtMerge-2 block, node)
            (ValueNode''inferStamp-1 node)
        )
        nil
    )

    (§ method! #_"void" FrameStateBuilder''insertLoopPhis-6 [#_"FrameStateBuilder" this, #_"LocalLiveness" liveness, #_"int" loopId, #_"LoopBeginNode" loopBegin, #_"boolean" forcePhis, #_"boolean" stampFromValueForForcedPhis]
        (dotimes [#_"int" i (count (:locals this))]
            (let [
                #_"boolean" changedInLoop (LocalLiveness''localIsChangedInLoop-3 liveness, loopId, i)
            ]
                (when (or forcePhis changedInLoop)
                    (aset (:locals this) i (FrameStateBuilder''createLoopPhi-4 this, loopBegin, (nth (:locals this) i), (and stampFromValueForForcedPhis (not changedInLoop))))
                )
            )
        )
        (dotimes [#_"int" i (:stackSize this)]
            (aset (:stack this) i (FrameStateBuilder''createLoopPhi-4 this, loopBegin, (nth (:stack this) i), false))
        )
        (dotimes [#_"int" i (count (:lockedObjects this))]
            (aset (:lockedObjects this) i (FrameStateBuilder''createLoopPhi-4 this, loopBegin, (nth (:lockedObjects this) i), false))
        )
        nil
    )

    (§ method! #_"void" FrameStateBuilder''insertLoopProxies-3 [#_"FrameStateBuilder" this, #_"LoopExitNode" loopExit, #_"FrameStateBuilder" loopEntryState]
        (dotimes [#_"int" i (count (:locals this))]
            (let [
                #_"ValueNode" value (nth (:locals this) i)
            ]
                (when (and (some? value) (not= value FrameState'TWO_SLOT_MARKER) (or (not (FrameStateBuilder''contains-2 loopEntryState, value)) (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin loopExit), value)))
                    (aset (:locals this) i (ProxyNode'forValue-3 value, loopExit, (:graph this)))
                )
            )
        )
        (dotimes [#_"int" i (:stackSize this)]
            (let [
                #_"ValueNode" value (nth (:stack this) i)
            ]
                (when (and (some? value) (not= value FrameState'TWO_SLOT_MARKER) (or (not (FrameStateBuilder''contains-2 loopEntryState, value)) (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin loopExit), value)))
                    (aset (:stack this) i (ProxyNode'forValue-3 value, loopExit, (:graph this)))
                )
            )
        )
        (dotimes [#_"int" i (count (:lockedObjects this))]
            (let [
                #_"ValueNode" value (nth (:lockedObjects this) i)
            ]
                (when (and (some? value) (or (not (FrameStateBuilder''contains-2 loopEntryState, value)) (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin loopExit), value)))
                    (aset (:lockedObjects this) i (ProxyNode'forValue-3 value, loopExit, (:graph this)))
                )
            )
        )
        nil
    )

    (§ method- #_"ValueNode" FrameStateBuilder''createLoopPhi-4 [#_"FrameStateBuilder" this, #_"AbstractMergeNode" block, #_"ValueNode" value, #_"boolean" stampFromValue]
        (when (and (some? value) (not= value FrameState'TWO_SLOT_MARKER)) => value
            (let [
                #_"ValuePhiNode" phi (Graph''add-2 (:graph this), (ValuePhiNode'new-2 (if stampFromValue (:stamp value) (Stamp''unrestricted-1 (:stamp value))), block))
            ]
                (PhiNode''addInput-2 phi, value)
                phi
            )
        )
    )

    ;;;
     ; Adds a locked monitor to this frame state.
     ;
     ; @param object the object whose monitor will be locked.
     ;;
    (§ method! #_"FrameStateBuilder" FrameStateBuilder''pushLock-3 [#_"FrameStateBuilder" this, #_"ValueNode" object, #_"MonitorIdNode" monitorId]
        (let [
            this (assoc this :lockedObjects (Arrays/copyOf (:lockedObjects this), (inc (count (:lockedObjects this)))))
            this (assoc this :monitorIds (Arrays/copyOf (:monitorIds this), (inc (count (:monitorIds this)))))
        ]
            (aset (:lockedObjects this) (dec (count (:lockedObjects this))) object)
            (aset (:monitorIds this) (dec (count (:monitorIds this))) monitorId)
            this
        )
    )

    ;;;
     ; Removes a locked monitor from this frame state.
     ;
     ; @return the object whose monitor was removed from the locks list
     ;;
    (§ method! #_"ValueNode" FrameStateBuilder''popLock-1 [#_"FrameStateBuilder" this]
        (try
            (nth (:lockedObjects this) (dec (count (:lockedObjects this))))
            (finally
                (§ ass! this (assoc this :lockedObjects (if (= (count (:lockedObjects this)) 1) FrameStateBuilder'EMPTY_ARRAY (Arrays/copyOf (:lockedObjects this), (dec (count (:lockedObjects this)))))))
                (§ ass! this (assoc this :monitorIds (if (= (count (:monitorIds this)) 1) FrameStateBuilder'EMPTY_MONITOR_ARRAY (Arrays/copyOf (:monitorIds this), (dec (count (:monitorIds this)))))))
            )
        )
    )

    (§ method! #_"MonitorIdNode" FrameStateBuilder''peekMonitorId-1 [#_"FrameStateBuilder" this]
        (nth (:monitorIds this) (dec (count (:monitorIds this))))
    )

    (§ method! #_"int" FrameStateBuilder''lockDepth-2 [#_"FrameStateBuilder" this, #_"boolean" includeParents]
        (let [
            #_"int" depth (count (:lockedObjects this))
        ]
            (when (and includeParents (some? (BytecodeParser''getParent-1 (:parser this)))) => depth
                (+ depth (FrameStateBuilder''lockDepth-2 (:frameState (BytecodeParser''getParent-1 (:parser this))), true))
            )
        )
    )

    (§ method! #_"boolean" FrameStateBuilder''contains-2 [#_"FrameStateBuilder" this, #_"ValueNode" value]
        (or
            (loop-when [#_"int" i 0] (< i (count (:locals this))) => false
                (or (= (nth (:locals this) i) value)
                    (recur (inc i))
                )
            )
            (loop-when [#_"int" i 0] (< i (:stackSize this)) => false
                (or (= (nth (:stack this) i) value)
                    (recur (inc i))
                )
            )
            (loop-when [#_"int" i 0] (< i (count (:lockedObjects this))) => false
                (or (= (nth (:lockedObjects this) i) value) (= (nth (:monitorIds this) i) value)
                    (recur (inc i))
                )
            )
        )
    )

    (§ method! #_"void" FrameStateBuilder''clearNonLiveLocals-4 [#_"FrameStateBuilder" this, #_"BciBlock" block, #_"LocalLiveness" liveness, #_"boolean" liveIn]
        ;; If somebody is tempted to remove/disable this clearing code: it's possible to remove it for normal compilations,
        ;; but not for OSR, as dead object slots at the OSR entry aren't cleared then. It is also not enough to rely on
        ;; PiNodes with Kind.Illegal, because the conflicting branch might not have been parsed.
        (when GraalOptions'optClearNonLiveLocals
            (if liveIn
                (dotimes [#_"int" i (count (:locals this))]
                    (when-not (LocalLiveness''localIsLiveIn-3 liveness, block, i)
                        (aset (:locals this) i nil)
                    )
                )
                (dotimes [#_"int" i (count (:locals this))]
                    (when-not (LocalLiveness''localIsLiveOut-3 liveness, block, i)
                        (aset (:locals this) i nil)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Clears all local variables.
     ;;
    #_unused
    (§ method! #_"void" FrameStateBuilder''clearLocals-1 [#_"FrameStateBuilder" this]
        (dotimes [#_"int" i (count (:locals this))]
            (aset (:locals this) i nil)
        )
        nil
    )

    ;;;
     ; Loads the local variable at the specified index, checking that the returned value is non-nil
     ; and that two-stack values are properly handled.
     ;
     ; @param i the index of the local variable to load
     ; @param slotKind the kind of the local variable from the point of view of the bytecodes
     ;
     ; @return the instruction that produced the specified local
     ;;
    (§ method! #_"ValueNode" FrameStateBuilder''loadLocal-3 [#_"FrameStateBuilder" this, #_"int" i, #_"JavaKind" slotKind]
        (nth (:locals this) i)
    )

    ;;;
     ; Stores a given local variable at the specified index. If the value occupies two slots, then
     ; the next local variable index is also overwritten.
     ;
     ; @param i the index at which to store
     ; @param slotKind the kind of the local variable from the point of view of the bytecodes
     ; @param x the instruction which produces the value for the local
     ;;
    (§ method! #_"void" FrameStateBuilder''storeLocal-4 [#_"FrameStateBuilder" this, #_"int" i, #_"JavaKind" slotKind, #_"ValueNode" x]
        (when (= (nth (:locals this) i) FrameState'TWO_SLOT_MARKER)
            ;; Writing the second slot of a two-slot value invalidates the first slot.
            (aset (:locals this) (dec i) nil)
        )
        (aset (:locals this) i x)
        (cond
            (#_"JavaKind" .needsTwoSlots slotKind)
            (do
                ;; Writing a two-slot value: mark the second slot.
                (aset (:locals this) (inc i) FrameState'TWO_SLOT_MARKER)
            )
            (and (< i (dec (count (:locals this)))) (= (nth (:locals this) (inc i)) FrameState'TWO_SLOT_MARKER))
            (do
                ;; Writing a one-slot value to an index previously occupied by a two-slot value: clear the old marker of the second slot.
                (aset (:locals this) (inc i) nil)
            )
        )
        nil
    )

    ;;;
     ; Pushes an instruction onto the stack with the expected type.
     ;
     ; @param slotKind the kind of the stack element from the point of view of the bytecodes
     ; @param x the instruction to push onto the stack
     ;;
    (§ method! #_"FrameStateBuilder" FrameStateBuilder''push-3 [#_"FrameStateBuilder" this, #_"JavaKind" slotKind, #_"ValueNode" x]
        (let [
            this (FrameStateBuilder''xpush-2 this, x)
        ]
            (when (#_"JavaKind" .needsTwoSlots slotKind) => this
                (FrameStateBuilder''xpush-2 this, FrameState'TWO_SLOT_MARKER)
            )
        )
    )

    (§ method! #_"FrameStateBuilder" FrameStateBuilder''pushReturn-3 [#_"FrameStateBuilder" this, #_"JavaKind" slotKind, #_"ValueNode" x]
        (when-not (= slotKind JavaKind/Void) => this
            (FrameStateBuilder''push-3 this, slotKind, x)
        )
    )

    ;;;
     ; Pops an instruction off the stack with the expected type.
     ;
     ; @param slotKind the kind of the stack element from the point of view of the bytecodes
     ; @return the instruction on the top of the stack
     ;;
    (§ method! #_"ValueNode" FrameStateBuilder''pop-2 [#_"FrameStateBuilder" this, #_"JavaKind" slotKind]
        (when (#_"JavaKind" .needsTwoSlots slotKind)
            (FrameStateBuilder''xpop-1 this)
        )
        (FrameStateBuilder''xpop-1 this)
    )

    (§ method- #_"FrameStateBuilder" FrameStateBuilder''xpush-2 [#_"FrameStateBuilder" this, #_"ValueNode" x]
        (aset (:stack this) (:stackSize this) x)
        (update this :stackSize inc)
    )

    (§ method- #_"ValueNode" FrameStateBuilder''xpop-1 [#_"FrameStateBuilder" this]
        (§ ass! this (update this :stackSize dec))
        (nth (:stack this) (:stackSize this))
    )

    (§ method- #_"ValueNode" FrameStateBuilder''xpeek-1 [#_"FrameStateBuilder" this]
        (nth (:stack this) (dec (:stackSize this)))
    )

    ;;;
     ; Pop the specified number of slots off of this stack and return them as an array of instructions.
     ;
     ; @return an array containing the arguments off of the stack
     ;;
    (§ method! #_"ValueNode[]" FrameStateBuilder''popArguments-2 [#_"FrameStateBuilder" this, #_"int" argSize]
        (let [
            #_"ValueNode[]" result (FrameStateBuilder'allocateArray-1 argSize)
        ]
            (loop-when-recur [#_"int" i (dec argSize)] (<= 0 i) [(dec i)]
                (let [
                    #_"ValueNode" x (FrameStateBuilder''xpop-1 this)
                    x
                        (when (= x FrameState'TWO_SLOT_MARKER) => x
                            ;; Ignore second slot of two-slot value.
                            (FrameStateBuilder''xpop-1 this)
                        )
                ]
                    (aset result i x)
                )
            )
            result
        )
    )

    ;;;
     ; Clears all values on this stack.
     ;;
    (§ method! #_"FrameStateBuilder" FrameStateBuilder''clearStack-1 [#_"FrameStateBuilder" this]
        (assoc this :stackSize 0)
    )

    ;;;
     ; Performs a raw stack operation as defined in the Java bytecode specification.
     ;
     ; @param opcode The Java bytecode.
     ;;
    (§ method! #_"FrameStateBuilder" FrameStateBuilder''stackOp-2 [#_"FrameStateBuilder" this, #_"int" opcode]
        (condp = opcode
            Bytecodes'POP
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                ]
                    this
                )
            Bytecodes'POP2
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                ]
                    this
                )
            Bytecodes'DUP
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpeek-1 this)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP_X1
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP_X2
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w3 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w3)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP2
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP2_X1
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w3 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w3)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'DUP2_X2
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w3 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w4 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w4)
                    this (FrameStateBuilder''xpush-2 this, w3)
                    this (FrameStateBuilder''xpush-2 this, w2)
                    this (FrameStateBuilder''xpush-2 this, w1)
                ]
                    this
                )
            Bytecodes'SWAP
                (let [
                    #_"ValueNode" w1 (FrameStateBuilder''xpop-1 this)
                    #_"ValueNode" w2 (FrameStateBuilder''xpop-1 this)
                    this (FrameStateBuilder''xpush-2 this, w1)
                    this (FrameStateBuilder''xpush-2 this, w2)
                ]
                    this
                )
        )
    )

    (§ override! #_"boolean" FrameStateBuilder''isAfterSideEffect-1 [#_"FrameStateBuilder" this]
        (some? (:sideEffects this))
    )

    (§ override! #_"Iterable<StateSplit>" FrameStateBuilder''sideEffects-1 [#_"FrameStateBuilder" this]
        (:sideEffects this)
    )

    (§ override! #_"void" FrameStateBuilder''addSideEffect-2 [#_"FrameStateBuilder" this, #_"StateSplit" sideEffect]
        (when (nil? (:sideEffects this))
            (§ ass! this (assoc this :sideEffects (ArrayList.)))
        )
        (#_"List" .add (:sideEffects this), sideEffect)
        nil
    )
)

;;;
 ; Parses the bytecodes of a method and builds the IR graph.
 ;;
(final-ns GraphBuilderPhase (§ extends BasePhase #_"<HighTierContext>")
    (§ final #_"GraphBuilderConfiguration" :graphBuilderConfig (GraphBuilderConfiguration'getDefault-0))

    (§ defn #_"GraphBuilderPhase" GraphBuilderPhase'new-0 []
        (BasePhase'new-0)
    )

    #_unused
    (§ override! #_"void" GraphBuilderPhase''run-3 [#_"GraphBuilderPhase" this, #_"Graph" graph, #_"HighTierContext" context]
        (GraphBuilderInstance''run-2 (GraphBuilderInstance'new-3 (:graphBuilderConfig this), (:optimisticOpts context), nil), graph)
        nil
    )
)

;;;
 ; @anno GraphBuilderPhase.GraphBuilderInstance
 ;;
(final-ns GraphBuilderInstance (§ extends Phase)
    (§ final #_"GraphBuilderConfiguration" :graphBuilderConfig nil)
    (§ final #_"OptimisticOptimizations" :optimisticOpts nil)
    (§ final #_"IntrinsicContext" :initialIntrinsicContext nil)

    (§ defn #_"GraphBuilderInstance" GraphBuilderInstance'new-3 [#_"GraphBuilderConfiguration" graphBuilderConfig, #_"OptimisticOptimizations" optimisticOpts, #_"IntrinsicContext" initialIntrinsicContext]
        (let [
            #_"GraphBuilderInstance" this (Phase'new-0)
            this (assoc this :graphBuilderConfig graphBuilderConfig)
            this (assoc this :optimisticOpts optimisticOpts)
            this (assoc this :initialIntrinsicContext initialIntrinsicContext)
        ]
            this
        )
    )

    (§ override! #_"void" GraphBuilderInstance''run-2 [#_"GraphBuilderInstance" this, #_"Graph" graph]
        (§ ass! (BytecodeParser'new-5 this, graph, nil, (:rootMethod graph), (:initialIntrinsicContext this)) (BytecodeParser''buildRootMethod-1 (BytecodeParser'new-5 this, graph, nil, (:rootMethod graph), (:initialIntrinsicContext this))))
        nil
    )
)

(final-ns JsrScope
    (§ def #_"JsrScope" JsrScope'EMPTY_SCOPE (JsrScope'new-0))

    (§ final #_"long" :scope 0)

    (§ defn- #_"JsrScope" JsrScope'new-1 [#_"long" scope]
        (let [
            #_"JsrScope" this (Object.)
            this (assoc this :scope scope)
        ]
            this
        )
    )

    (§ defn #_"JsrScope" JsrScope'new-0 []
        (let [
            #_"JsrScope" this (Object.)
            this (assoc this :scope 0)
        ]
            this
        )
    )

    (§ method! #_"int" JsrScope''nextReturnAddress-1 [#_"JsrScope" this]
        (int (& (:scope this) 0xffff))
    )

    (§ method! #_"JsrScope" JsrScope''push-2 [#_"JsrScope" this, #_"int" jsrReturnBci]
        (when-not (zero? (& (:scope this) 0xffff000000000000))
            (throw! "only 4 jsr nesting levels are supported")
        )
        (JsrScope'new-1 (| (<< (:scope this) 16) jsrReturnBci))
    )

    (§ method! #_"boolean" JsrScope''isEmpty-1 [#_"JsrScope" this]
        (zero? (:scope this))
    )

    (§ method! #_"boolean" JsrScope''isPrefixOf-2 [#_"JsrScope" this, #_"JsrScope" other]
        (= (& (:scope this) (:scope other)) (:scope this))
    )

    (§ method! #_"JsrScope" JsrScope''pop-1 [#_"JsrScope" this]
        (JsrScope'new-1 (>>> (:scope this) 16))
    )
)

(final-ns LargeLocalLiveness (§ extends LocalLiveness)
    (§ mutable #_"BitSet[]" :localsLiveIn nil)
    (§ mutable #_"BitSet[]" :localsLiveOut nil)
    (§ mutable #_"BitSet[]" :localsLiveGen nil)
    (§ mutable #_"BitSet[]" :localsLiveKill nil)
    (§ mutable #_"BitSet[]" :localsChangedInLoop nil)

    (§ defn #_"LargeLocalLiveness" LargeLocalLiveness'new-3 [#_"BciBlock[]" blocks, #_"int" maxLocals, #_"int" loopCount]
        (let [
            #_"LargeLocalLiveness" this (LocalLiveness'new-1 blocks)
            #_"int" n (count blocks)
            this (assoc this :localsLiveIn (make-array BitSet n))
            this (assoc this :localsLiveOut (make-array BitSet n))
            this (assoc this :localsLiveGen (make-array BitSet n))
            this (assoc this :localsLiveKill (make-array BitSet n))
            _
                (dotimes [#_"int" i n]
                    (aset (:localsLiveIn this) i (BitSet. maxLocals))
                    (aset (:localsLiveOut this) i (BitSet. maxLocals))
                    (aset (:localsLiveGen this) i (BitSet. maxLocals))
                    (aset (:localsLiveKill this) i (BitSet. maxLocals))
                )
            this (assoc this :localsChangedInLoop (make-array BitSet loopCount))
            _
                (dotimes [#_"int" i loopCount]
                    (aset (:localsChangedInLoop this) i (BitSet. maxLocals))
                )
        ]
            this
        )
    )

    #_unused
    (§ override! #_"int" LargeLocalLiveness''liveOutCardinality-2 [#_"LargeLocalLiveness" this, #_"int" blockID]
        (#_"BitSet" .cardinality (nth (:localsLiveOut this) blockID))
    )

    #_unused
    (§ override! #_"void" LargeLocalLiveness''propagateLiveness-3 [#_"LargeLocalLiveness" this, #_"int" blockID, #_"int" successorID]
        (#_"BitSet" .or (nth (:localsLiveOut this) blockID), (nth (:localsLiveIn this) successorID))
        nil
    )

    #_unused
    (§ override! #_"void" LargeLocalLiveness''updateLiveness-2 [#_"LargeLocalLiveness" this, #_"int" blockID]
        (let [
            #_"BitSet" liveIn (nth (:localsLiveIn this) blockID)
        ]
            (#_"BitSet" .clear liveIn)
            (#_"BitSet" .or liveIn, (nth (:localsLiveOut this) blockID))
            (#_"BitSet" .andNot liveIn, (nth (:localsLiveKill this) blockID))
            (#_"BitSet" .or liveIn, (nth (:localsLiveGen this) blockID))
        )
        nil
    )

    #_unused
    (§ override! #_"void" LargeLocalLiveness''loadOne-3 [#_"LargeLocalLiveness" this, #_"int" blockID, #_"int" local]
        (when-not (#_"BitSet" .get (nth (:localsLiveKill this) blockID), local)
            (#_"BitSet" .set (nth (:localsLiveGen this) blockID), local)
        )
        nil
    )

    #_unused
    (§ override! #_"void" LargeLocalLiveness''storeOne-3 [#_"LargeLocalLiveness" this, #_"int" blockID, #_"int" local]
        (when-not (#_"BitSet" .get (nth (:localsLiveGen this) blockID), local)
            (#_"BitSet" .set (nth (:localsLiveKill this) blockID), local)
        )
        (loop-when-recur [#_"long" loops (:loops (nth (:blocks this) blockID)) #_"int" i 0] (not (zero? loops)) [(>>> loops 1) (inc i)]
            (when (= (& loops 1) 1)
                (#_"BitSet" .set (nth (:localsChangedInLoop this) i), local)
            )
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" LargeLocalLiveness''localIsLiveIn-3 [#_"LargeLocalLiveness" this, #_"BciBlock" block, #_"int" local]
        (or (<= Integer/MAX_VALUE (:id block)) (#_"BitSet" .get (nth (:localsLiveIn this) (:id block)), local))
    )

    #_unused
    (§ override! #_"boolean" LargeLocalLiveness''localIsLiveOut-3 [#_"LargeLocalLiveness" this, #_"BciBlock" block, #_"int" local]
        (or (<= Integer/MAX_VALUE (:id block)) (#_"BitSet" .get (nth (:localsLiveOut this) (:id block)), local))
    )

    #_unused
    (§ override! #_"boolean" LargeLocalLiveness''localIsChangedInLoop-3 [#_"LargeLocalLiveness" this, #_"int" loopId, #_"int" local]
        (#_"BitSet" .get (nth (:localsChangedInLoop this) loopId), local)
    )
)

;;;
 ; Encapsulates the liveness calculation, so that subclasses for locals <= 64 and locals > 64 can be implemented.
 ;;
(class-ns LocalLiveness
    (§ final #_"BciBlock[]" :blocks nil)

    (§ defn #_"LocalLiveness" LocalLiveness'compute-4 [#_"BytecodeStream" stream, #_"BciBlock[]" blocks, #_"int" maxLocals, #_"int" loopCount]
        (let [
            #_"LocalLiveness" liveness (if (<= maxLocals 64) (SmallLocalLiveness'new-3 blocks, maxLocals, loopCount) (LargeLocalLiveness'new-3 blocks, maxLocals, loopCount))
        ]
            (LocalLiveness''computeLiveness-2 liveness, stream)
            liveness
        )
    )

    (§ defn #_"LocalLiveness" LocalLiveness'new-1 [#_"BciBlock[]" blocks]
        (let [
            #_"LocalLiveness" this (Object.)
            this (assoc this :blocks blocks)
        ]
            this
        )
    )

    (§ method! #_"void" LocalLiveness''computeLiveness-2 [#_"LocalLiveness" this, #_"BytecodeStream" stream]
        (doseq [#_"BciBlock" block (:blocks this)]
            (LocalLiveness''computeLocalLiveness-3 this, stream, block)
        )
        (loop [#_"int" iteration 0]
            (let [
                #_"boolean" changed?
                    (loop-when [changed? false #_"int" i (dec (count (:blocks this)))] (<= 0 i) => changed?
                        (let [
                            #_"BciBlock" block (nth (:blocks this) i)
                            #_"boolean" blockChanged (zero? iteration)
                            blockChanged
                                (when (seq (:successors block)) => blockChanged
                                    (let [
                                        #_"int" o'cardinality (LocalLiveness''liveOutCardinality-2 this, (:id block))
                                    ]
                                        (doseq [#_"BciBlock" sux (:successors block)]
                                            (LocalLiveness''propagateLiveness-3 this, (:id block), (:id sux))
                                        )
                                        (or blockChanged (not= o'cardinality (LocalLiveness''liveOutCardinality-2 this, (:id block))))
                                    )
                                )
                        ]
                            (when blockChanged
                                (LocalLiveness''updateLiveness-2 this, (:id block))
                            )
                            (recur (or changed? blockChanged) (dec i))
                        )
                    )
            ]
                (recur-if changed? [(inc iteration)])
            )
        )
        nil
    )

    ;;;
     ; Returns whether the local is live at the beginning of the given block.
     ;;
    (§ abstract #_"boolean" LocalLiveness''localIsLiveIn-3 [#_"LocalLiveness" this, #_"BciBlock" block, #_"int" local])

    ;;;
     ; Returns whether the local is set in the given loop.
     ;;
    (§ abstract #_"boolean" LocalLiveness''localIsChangedInLoop-3 [#_"LocalLiveness" this, #_"int" loopId, #_"int" local])

    ;;;
     ; Returns whether the local is live at the end of the given block.
     ;;
    (§ abstract #_"boolean" LocalLiveness''localIsLiveOut-3 [#_"LocalLiveness" this, #_"BciBlock" block, #_"int" local])

    ;;;
     ; Returns the number of live locals at the end of the given block.
     ;;
    (§ abstract #_"int" LocalLiveness''liveOutCardinality-2 [#_"LocalLiveness" this, #_"int" blockID])

    ;;;
     ; Adds all locals the are in the liveIn of the successor to the liveOut of the block.
     ;;
    (§ abstract #_"void" LocalLiveness''propagateLiveness-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" successorID])

    ;;;
     ; Calculates a new liveIn for the given block from liveOut, liveKill and liveGen.
     ;;
    (§ abstract #_"void" LocalLiveness''updateLiveness-2 [#_"LocalLiveness" this, #_"int" blockID])

    ;;;
     ; Adds the local to liveGen if it wasn't already killed in this block.
     ;;
    (§ abstract #_"void" LocalLiveness''loadOne-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" local])

    ;;;
     ; Add this local to liveKill if it wasn't already generated in this block.
     ;;
    (§ abstract #_"void" LocalLiveness''storeOne-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" local])

    (§ method- #_"void" LocalLiveness''computeLocalLiveness-3 [#_"LocalLiveness" this, #_"BytecodeStream" stream, #_"BciBlock" block]
        (let [
            #_"int" blockID (:id block)
        ]
            (loop-when-recur [_ (§ ass! stream (BytecodeStream''setBCI-2 stream, (:startBci block)))] (<= (:curBCI stream) (:endBci block)) [(§ ass! stream (BytecodeStream''next-1 stream))]
                (condp =? (BytecodeStream''currentBC-1 stream)
                    Bytecodes'LLOAD                                (LocalLiveness''loadTwo-3 this, blockID, (BytecodeStream''readLocalIndex-1 stream))
                    Bytecodes'LLOAD_0                              (LocalLiveness''loadTwo-3 this, blockID, 0)
                    Bytecodes'LLOAD_1                              (LocalLiveness''loadTwo-3 this, blockID, 1)
                    Bytecodes'LLOAD_2                              (LocalLiveness''loadTwo-3 this, blockID, 2)
                    Bytecodes'LLOAD_3                              (LocalLiveness''loadTwo-3 this, blockID, 3)
                    Bytecodes'IINC
                        (let [
                            #_"int" i (BytecodeStream''readLocalIndex-1 stream)
                        ]
                            (LocalLiveness''loadOne-3 this, blockID, i)
                            (LocalLiveness''storeOne-3 this, blockID, i)
                        )
                    [Bytecodes'ILOAD Bytecodes'ALOAD Bytecodes'RET] (LocalLiveness''loadOne-3 this, blockID, (BytecodeStream''readLocalIndex-1 stream))
                    [Bytecodes'ILOAD_0 Bytecodes'ALOAD_0]           (LocalLiveness''loadOne-3 this, blockID, 0)
                    [Bytecodes'ILOAD_1 Bytecodes'ALOAD_1]           (LocalLiveness''loadOne-3 this, blockID, 1)
                    [Bytecodes'ILOAD_2 Bytecodes'ALOAD_2]           (LocalLiveness''loadOne-3 this, blockID, 2)
                    [Bytecodes'ILOAD_3 Bytecodes'ALOAD_3]           (LocalLiveness''loadOne-3 this, blockID, 3)
                    Bytecodes'LSTORE                               (LocalLiveness''storeTwo-3 this, blockID, (BytecodeStream''readLocalIndex-1 stream))
                    Bytecodes'LSTORE_0                             (LocalLiveness''storeTwo-3 this, blockID, 0)
                    Bytecodes'LSTORE_1                             (LocalLiveness''storeTwo-3 this, blockID, 1)
                    Bytecodes'LSTORE_2                             (LocalLiveness''storeTwo-3 this, blockID, 2)
                    Bytecodes'LSTORE_3                             (LocalLiveness''storeTwo-3 this, blockID, 3)
                    [Bytecodes'ISTORE Bytecodes'ASTORE]             (LocalLiveness''storeOne-3 this, blockID, (BytecodeStream''readLocalIndex-1 stream))
                    [Bytecodes'ISTORE_0 Bytecodes'ASTORE_0]         (LocalLiveness''storeOne-3 this, blockID, 0)
                    [Bytecodes'ISTORE_1 Bytecodes'ASTORE_1]         (LocalLiveness''storeOne-3 this, blockID, 1)
                    [Bytecodes'ISTORE_2 Bytecodes'ASTORE_2]         (LocalLiveness''storeOne-3 this, blockID, 2)
                    [Bytecodes'ISTORE_3 Bytecodes'ASTORE_3]         (LocalLiveness''storeOne-3 this, blockID, 3)
                    nil
                )
            )
        )
        nil
    )

    (§ method- #_"void" LocalLiveness''loadTwo-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" local]
        (LocalLiveness''loadOne-3 this, blockID, local)
        (LocalLiveness''loadOne-3 this, blockID, (inc local))
        nil
    )

    (§ method- #_"void" LocalLiveness''storeTwo-3 [#_"LocalLiveness" this, #_"int" blockID, #_"int" local]
        (LocalLiveness''storeOne-3 this, blockID, local)
        (LocalLiveness''storeOne-3 this, blockID, (inc local))
        nil
    )
)

(final-ns SmallLocalLiveness (§ extends LocalLiveness)
    ;; local n is represented by the bit accessible as (1 << n)

    (§ final #_"long[]" :localsLiveIn nil)
    (§ final #_"long[]" :localsLiveOut nil)
    (§ final #_"long[]" :localsLiveGen nil)
    (§ final #_"long[]" :localsLiveKill nil)
    (§ final #_"long[]" :localsChangedInLoop nil)
    (§ final #_"int" :maxLocals 0)

    (§ defn #_"SmallLocalLiveness" SmallLocalLiveness'new-3 [#_"BciBlock[]" blocks, #_"int" maxLocals, #_"int" loopCount]
        (let [
            #_"SmallLocalLiveness" this (LocalLiveness'new-1 blocks)
            this (assoc this :maxLocals maxLocals)
            #_"int" n (count blocks)
            this (assoc this :localsLiveIn (long-array n))
            this (assoc this :localsLiveOut (long-array n))
            this (assoc this :localsLiveGen (long-array n))
            this (assoc this :localsLiveKill (long-array n))
            this (assoc this :localsChangedInLoop (long-array loopCount))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"int" SmallLocalLiveness''liveOutCardinality-2 [#_"SmallLocalLiveness" this, #_"int" blockID]
        (Long/bitCount (nth (:localsLiveOut this) blockID))
    )

    #_unused
    (§ override! #_"void" SmallLocalLiveness''propagateLiveness-3 [#_"SmallLocalLiveness" this, #_"int" blockID, #_"int" successorID]
        (aswap (:localsLiveOut this) blockID | (nth (:localsLiveIn this) successorID))
        nil
    )

    #_unused
    (§ override! #_"void" SmallLocalLiveness''updateLiveness-2 [#_"SmallLocalLiveness" this, #_"int" blockID]
        (aset (:localsLiveIn this) blockID (| (& (nth (:localsLiveOut this) blockID) (bit-not (nth (:localsLiveKill this) blockID))) (nth (:localsLiveGen this) blockID)))
        nil
    )

    #_unused
    (§ override! #_"void" SmallLocalLiveness''loadOne-3 [#_"SmallLocalLiveness" this, #_"int" blockID, #_"int" local]
        (let [
            #_"long" bit (<< 1 local)
        ]
            (when (zero? (& (nth (:localsLiveKill this) blockID) bit))
                (aswap (:localsLiveGen this) blockID | bit)
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" SmallLocalLiveness''storeOne-3 [#_"SmallLocalLiveness" this, #_"int" blockID, #_"int" local]
        (let [
            #_"long" bit (<< 1 local)
        ]
            (when (zero? (& (nth (:localsLiveGen this) blockID) bit))
                (aswap (:localsLiveKill this) blockID | bit)
            )
            (loop-when-recur [#_"long" loops (:loops (nth (:blocks this) blockID)) #_"int" i 0] (not (zero? loops)) [(>>> loops 1) (inc i)]
                (when (= (& loops 1) 1)
                    (aswap (:localsChangedInLoop this) i | bit)
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" SmallLocalLiveness''localIsLiveIn-3 [#_"SmallLocalLiveness" this, #_"BciBlock" block, #_"int" local]
        (and (< (:id block) Integer/MAX_VALUE) (not (zero? (& (nth (:localsLiveIn this) (:id block)) (<< 1 local)))))
    )

    #_unused
    (§ override! #_"boolean" SmallLocalLiveness''localIsLiveOut-3 [#_"SmallLocalLiveness" this, #_"BciBlock" block, #_"int" local]
        (and (< (:id block) Integer/MAX_VALUE) (not (zero? (& (nth (:localsLiveOut this) (:id block)) (<< 1 local)))))
    )

    #_unused
    (§ override! #_"boolean" SmallLocalLiveness''localIsChangedInLoop-3 [#_"SmallLocalLiveness" this, #_"int" loopId, #_"int" local]
        (not (zero? (& (nth (:localsChangedInLoop this) loopId) (<< 1 local))))
    )
)

;;;
 ; Represents an interval in the linear scan register allocator.
 ;;
(final-ns Interval
    (§ def #_"int" Interval'END_MARKER_OPERAND_NUMBER Integer/MIN_VALUE)

    ;;;
     ; The register or variable for this interval prior to register allocation.
     ;;
    (§ final #_"AllocatableValue" :operand nil)
    ;;;
     ; The operand number for this interval's {@linkplain #operand operand}.
     ;;
    (§ final #_"int" :operandNumber 0)
    ;;;
     ; The register or spill slot assigned to this interval.
     ; In case of a spilled interval which is re-materialized this is Value#ILLEGAL.
     ;;
    (§ mutable #_"AllocatableValue" :location nil)
    ;;;
     ; The stack slot to which all splits of this interval are spilled if necessary.
     ;;
    (§ mutable #_"AllocatableValue" :spillSlot nil)
    ;;;
     ; The kind of this interval.
     ;;
    (§ mutable #_"ValueKind" :kind nil)
    ;;;
     ; The head of the list of ranges describing this interval. This list is sorted by
     ; {@linkplain LIRInstruction#id instruction ids}.
     ;;
    (§ mutable #_"Range" :first nil)
    ;;;
     ; List of (use-positions, register-priorities) pairs, sorted by use-positions.
     ;;
    (§ mutable #_"UsePosList" :usePosList nil)
    ;;;
     ; Iterator used to traverse the ranges of an interval.
     ;;
    (§ mutable #_"Range" :current nil)
    ;;;
     ; Link to next interval in a sorted list of intervals that ends with LinearScan.intervalEndMarker.
     ;;
    (§ mutable #_"Interval" :next nil)
    ;;;
     ; The linear-scan state of this interval.
     ;;
    (§ mutable #_"IntervalState" :state nil)

    (§ mutable #_"int" :cachedTo 0) ;; cached value: to of last range (-1: not cached)

    ;;;
     ; The interval from which this one is derived. If this is a {@linkplain #isSplitParent() split parent}, it points to itself.
     ;;
    (§ mutable #_"Interval" :splitParent nil)
    ;;;
     ; List of all intervals that are split off from this interval. This is only used if this is a {@linkplain #isSplitParent() split parent}.
     ;;
    (§ mutable #_"List<Interval>" :splitChildren (Collections/emptyList))
    ;;;
     ; Current split child that has been active or inactive last (always stored in split parents).
     ;;
    (§ mutable #_"Interval" :currentSplitChild nil)
    ;;;
     ; Specifies if move is inserted between currentSplitChild and this interval when interval gets active the first time.
     ;;
    (§ mutable #_"boolean" :insertMoveWhenActivated false)
    ;;;
     ; For spill move optimization.
     ;;
    (§ mutable #_"SpillState" :spillState nil)
    ;;;
     ; Position where this interval is defined (if defined only once).
     ;;
    (§ mutable #_"int" :spillDefinitionPos 0)
    ;;;
     ; This interval should be assigned the same location as the hint interval.
     ;;
    (§ mutable #_"Interval" :locationHint nil)
    ;;;
     ; The value with which a spilled child interval can be re-materialized. Currently this must be a Constant.
     ;;
    (§ mutable #_"Constant" :materializedValue nil)
    ;;;
     ; The number of times #addMaterializationValue(Constant) is called.
     ;;
    (§ mutable #_"int" :numMaterializationValuesAdded 0)

    (§ method! #_"Interval" Interval''assignLocation-2 [#_"Interval" this, #_"AllocatableValue" newLocation]
        (assoc this :location (if (and (instance? RegisterValue newLocation) (= (#_"AllocatableValue" .getValueKind newLocation) LIRKind'Illegal) (not (= (:kind this) LIRKind'Illegal))) (#_"Register" .asValue (#_"RegisterValue" .getRegister newLocation), (:kind this)) newLocation))
    )

    ;;;
     ; Returns true is this is the sentinel interval that denotes the end of an interval list.
     ;;
    (§ method! #_"boolean" Interval''isEndMarker-1 [#_"Interval" this]
        (= (:operandNumber this) Interval'END_MARKER_OPERAND_NUMBER)
    )

    (§ method! #_"Interval" Interval''setKind-2 [#_"Interval" this, #_"ValueKind" kind]
        (assoc this :kind kind)
    )

    (§ method! #_"int" Interval''from-1 [#_"Interval" this]
        (:from (:first this))
    )

    (§ method! #_"int" Interval''to-1 [#_"Interval" this]
        (when (= (:cachedTo this) -1)
            (§ ass! this (assoc this :cachedTo (Interval''calcTo-1 this)))
        )
        (:cachedTo this)
    )

    #_unused
    (§ method! #_"int" Interval''numUsePositions-1 [#_"Interval" this]
        (UsePosList''size-1 (:usePosList this))
    )

    (§ method! #_"Interval" Interval''setLocationHint-2 [#_"Interval" this, #_"Interval" interval]
        (assoc this :locationHint interval)
    )

    (§ method! #_"boolean" Interval''isSplitParent-1 [#_"Interval" this]
        (= (:splitParent this) this)
    )

    (§ method! #_"boolean" Interval''isSplitChild-1 [#_"Interval" this]
        (not= (:splitParent this) this)
    )

    ;;;
     ; Gets the canonical spill slot for this interval.
     ;;
    (§ method! #_"AllocatableValue" Interval''spillSlot-1 [#_"Interval" this]
        (:spillSlot (:splitParent this))
    )

    (§ method! #_"void" Interval''setSpillSlot-2 [#_"Interval" this, #_"AllocatableValue" slot]
        (§ ass! (:spillSlot (:splitParent this)) slot)
        nil
    )

    (§ method! #_"Interval" Interval''currentSplitChild-1 [#_"Interval" this]
        (:currentSplitChild (:splitParent this))
    )

    (§ method! #_"void" Interval''makeCurrentSplitChild-1 [#_"Interval" this]
        (§ ass! (:currentSplitChild (:splitParent this)) this)
        nil
    )

    (§ method! #_"Interval" Interval''setInsertMoveWhenActivated-2 [#_"Interval" this, #_"boolean" b]
        (assoc this :insertMoveWhenActivated b)
    )

    ;; for spill optimization
    (§ method! #_"SpillState" Interval''spillState-1 [#_"Interval" this]
        (:spillState (:splitParent this))
    )

    (§ method! #_"int" Interval''spillDefinitionPos-1 [#_"Interval" this]
        (:spillDefinitionPos (:splitParent this))
    )

    (§ method! #_"void" Interval''setSpillState-2 [#_"Interval" this, #_"SpillState" state]
        (§ ass! (:spillState (:splitParent this)) state)
        nil
    )

    (§ method! #_"void" Interval''setSpillDefinitionPos-2 [#_"Interval" this, #_"int" pos]
        (§ ass! (:spillDefinitionPos (:splitParent this)) pos)
        nil
    )

    ;; returns true if this interval has a shadow copy on the stack that is always correct
    (§ method! #_"boolean" Interval''alwaysInMemory-1 [#_"Interval" this]
        (and (#_"EnumSet" .contains SpillState'ALWAYS_IN_MEMORY, (Interval''spillState-1 this)) (not (Interval''canMaterialize-1 this)))
    )

    (§ method! #_"void" Interval''removeFirstUsePos-1 [#_"Interval" this]
        (UsePosList''removeLowestUsePos-1 (:usePosList this))
        nil
    )

    ;; test intersection
    #_unused
    (§ method! #_"boolean" Interval''intersects-2 [#_"Interval" this, #_"Interval" i]
        (Range''intersects-2 (:first this), (:first i))
    )

    (§ method! #_"int" Interval''intersectsAt-2 [#_"Interval" this, #_"Interval" i]
        (Range''intersectsAt-2 (:first this), (:first i))
    )

    ;; range iteration
    (§ method! #_"Interval" Interval''rewindRange-1 [#_"Interval" this]
        (assoc this :current (:first this))
    )

    (§ method! #_"Interval" Interval''nextRange-1 [#_"Interval" this]
        (assoc this :current (:next (:current this)))
    )

    (§ method! #_"int" Interval''currentFrom-1 [#_"Interval" this]
        (:from (:current this))
    )

    (§ method! #_"int" Interval''currentTo-1 [#_"Interval" this]
        (:to (:current this))
    )

    (§ method! #_"boolean" Interval''currentAtEnd-1 [#_"Interval" this]
        (Range''isEndMarker-1 (:current this))
    )

    (§ method! #_"boolean" Interval''currentIntersects-2 [#_"Interval" this, #_"Interval" it]
        (Range''intersects-2 (:current this), (:current it))
    )

    (§ method! #_"int" Interval''currentIntersectsAt-2 [#_"Interval" this, #_"Interval" it]
        (Range''intersectsAt-2 (:current this), (:current it))
    )

    (§ defn #_"Interval" Interval'new-4 [#_"AllocatableValue" operand, #_"int" operandNumber, #_"Interval" intervalEndMarker, #_"Range" rangeEndMarker]
        (let [
            #_"Interval" this (Object.)
            this (assoc this :operand operand)
            this (assoc this :operandNumber operandNumber)
            this (if (instance? RegisterValue operand) (assoc this :location operand) this)
            this (assoc this :kind LIRKind'Illegal)
            this (assoc this :first rangeEndMarker)
            this (assoc this :usePosList (UsePosList'new-1 4))
            this (assoc this :current rangeEndMarker)
            this (assoc this :next intervalEndMarker)
            this (assoc this :cachedTo -1)
            this (assoc this :spillState SpillState'NoDefinitionFound)
            this (assoc this :spillDefinitionPos -1)
            this (assoc this :splitParent this)
            this (assoc this :currentSplitChild this)
        ]
            this
        )
    )

    ;;;
     ; Sets the value which is used for re-materialization.
     ;;
    (§ method! #_"Interval" Interval''addMaterializationValue-2 [#_"Interval" this, #_"Constant" value]
        (let [
            ;; => Interval is defined on multiple places -> no materialization is possible.
            this (assoc this :materializedValue (when (zero? (:numMaterializationValuesAdded this)) value))
        ]
            (update this :numMaterializationValuesAdded inc)
        )
    )

    ;;;
     ; Returns true if this interval can be re-materialized when spilled. This means that no
     ; spill-moves are needed. Instead of restore-moves the #materializedValue is restored.
     ;;
    (§ method! #_"boolean" Interval''canMaterialize-1 [#_"Interval" this]
        (some? (Interval''getMaterializedValue-1 this))
    )

    ;;;
     ; Returns a value which can be moved to a register instead of a restore-move from stack.
     ;;
    (§ method! #_"Constant" Interval''getMaterializedValue-1 [#_"Interval" this]
        (:materializedValue (:splitParent this))
    )

    (§ method! #_"int" Interval''calcTo-1 [#_"Interval" this]
        (loop-when-recur [#_"Range" r (:first this)] (not (Range''isEndMarker-1 (:next r))) [(:next r)] => (:to r))
    )

    (§ method! #_"Interval" Interval''locationHint-2 [#_"Interval" this, #_"boolean" searchSplitChild]
        (let [
            #_"Interval" hint (:locationHint this)
        ]
            (when searchSplitChild => hint
                (when (some? hint) ;; => no hint interval found that has a register assigned
                    (cond
                        (and (some? (:location hint)) (instance? RegisterValue (:location hint)))
                            hint
                        (seq (:splitChildren hint))
                            ;; search the first split child that has a register assigned
                            (loop-when [#_"int" i 0] (< i (count (:splitChildren hint)))
                                (let [
                                    #_"Interval" interval (nth (:splitChildren hint) i)
                                ]
                                    (if (and (some? (:location interval)) (instance? RegisterValue (:location interval)))
                                        interval
                                        (recur (inc i))
                                    )
                                )
                            )
                    )
                )
            )
        )
    )

    ;;;
     ; Sets the element at a given position of a list and ensures that this position exists.
     ;
     ; @param list the list to put the element into
     ; @param pos the position at which to insert the element
     ; @param x the element that should be inserted
     ;;
    (§ defn- #_"<T> void" Interval'atPutGrow-3 [#_"List<T>" list, #_"int" pos, #_"T" x]
        (while (< (count list) (inc pos))
            (#_"List" .add list, nil)
        )
        (#_"List" .set list, pos, x)
        nil
    )

    (§ method! #_"Interval" Interval''getSplitChildAtOpId-4 [#_"Interval" this, #_"int" opId, #_"OperandMode" mode, #_"LinearScan" allocator]
        (when (seq (:splitChildren this)) => this
            (let [
                ;; in outputMode, the end of the interval (opId == cur.to()) is not valid
                #_"int" toOffset (if (= mode OperandMode'DEF) 0 1)
            ]
                (loop-when [#_"int" i 0] (< i (count (:splitChildren this)))
                    (let [
                        #_"Interval" interval (nth (:splitChildren this) i)
                    ]
                        (when (and (<= (Interval''from-1 interval) opId) (< opId (+ (Interval''to-1 interval) toOffset))) => (recur (inc i))
                            (when (pos? i)
                                ;; exchange current split child to start of list (faster access for next call)
                                (Interval'atPutGrow-3 (:splitChildren this), i, (nth (:splitChildren this) 0))
                                (Interval'atPutGrow-3 (:splitChildren this), 0, interval)
                            )
                            interval ;; found
                        )
                    )
                )
            )
        )
    )

    ;; returns the interval that covers the given opId or nil if there is none
    (§ method! #_"Interval" Interval''getIntervalCoveringOpId-2 [#_"Interval" this, #_"int" opId]
        (when (< opId (Interval''from-1 this)) => this
            (let [
                #_"Interval" parent (:splitParent this)
            ]
                (loop-when [#_"Interval" result nil #_"int" i (dec (count (:splitChildren parent)))] (<= 0 i) => result
                    (let [
                        #_"Interval" interval (nth (:splitChildren parent) i)
                        result
                            (when (and (<= (Interval''from-1 interval) opId) (< opId (Interval''to-1 interval))) => result
                                interval
                            )
                    ]
                        (recur result (dec i))
                    )
                )
            )
        )
    )

    ;; returns the last split child that ends before the given opId
    (§ method! #_"Interval" Interval''getSplitChildBeforeOpId-2 [#_"Interval" this, #_"int" opId]
        (let [
            #_"Interval" parent (:splitParent this)
        ]
            (loop-when [#_"Interval" result nil #_"int" i (dec (count (:splitChildren parent)))] (<= 0 i) => result
                (let [
                    #_"Interval" interval (nth (:splitChildren parent) i)
                    result
                        (when (and (<= (Interval''to-1 interval) opId) (or (nil? result) (< (Interval''to-1 result) (Interval''to-1 interval)))) => result
                            interval
                        )
                ]
                    (recur result (dec i))
                )
            )
        )
    )

    ;; checks if opId is covered by any split child
    #_unused
    (§ method! #_"boolean" Interval''splitChildCovers-3 [#_"Interval" this, #_"int" opId, #_"OperandMode" mode]
        (when (seq (:splitChildren this)) => (Interval''covers-3 this, opId, mode)
            (loop [#_"int" i 0]
                (and (< i (count (:splitChildren this)))
                    (or (Interval''covers-3 (nth (:splitChildren this) i), opId, mode)
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (§ method- #_"RegisterPriority" Interval''adaptPriority-2 [#_"Interval" this, #_"RegisterPriority" priority]
        ;; In case of re-materialized values we require that use-operands are registers,
        ;; because we don't have the value in a stack location.
        ;; (Note that ShouldHaveRegister means that the operand can also be a StackSlot).
        (when (and (= priority RegisterPriority'ShouldHaveRegister) (Interval''canMaterialize-1 this)) => priority
            RegisterPriority'MustHaveRegister
        )
    )

    ;; note: use positions are sorted descending = first use has highest index
    (§ method! #_"int" Interval''firstUsage-2 [#_"Interval" this, #_"RegisterPriority" minRegisterPriority]
        (loop-when [#_"int" i (dec (UsePosList''size-1 (:usePosList this)))] (<= 0 i) => Integer/MAX_VALUE
            (let [
                #_"RegisterPriority" registerPriority (Interval''adaptPriority-2 this, (UsePosList''registerPriority-2 (:usePosList this), i))
            ]
                (when (RegisterPriority'greaterEqual-2 registerPriority, minRegisterPriority) => (recur (dec i))
                    (UsePosList''usePos-2 (:usePosList this), i)
                )
            )
        )
    )

    (§ method! #_"int" Interval''nextUsage-3 [#_"Interval" this, #_"RegisterPriority" minRegisterPriority, #_"int" from]
        (loop-when [#_"int" i (dec (UsePosList''size-1 (:usePosList this)))] (<= 0 i) => Integer/MAX_VALUE
            (let [
                #_"int" usePos (UsePosList''usePos-2 (:usePosList this), i)
            ]
                (when (and (<= from usePos) (RegisterPriority'greaterEqual-2 (Interval''adaptPriority-2 this, (UsePosList''registerPriority-2 (:usePosList this), i)), minRegisterPriority)) => (recur (dec i))
                    usePos
                )
            )
        )
    )

    (§ method! #_"int" Interval''nextUsageExact-3 [#_"Interval" this, #_"RegisterPriority" exactRegisterPriority, #_"int" from]
        (loop-when [#_"int" i (dec (UsePosList''size-1 (:usePosList this)))] (<= 0 i) => Integer/MAX_VALUE
            (let [
                #_"int" usePos (UsePosList''usePos-2 (:usePosList this), i)
            ]
                (when (and (<= from usePos) (= (Interval''adaptPriority-2 this, (UsePosList''registerPriority-2 (:usePosList this), i)) exactRegisterPriority)) => (recur (dec i))
                    usePos
                )
            )
        )
    )

    (§ method! #_"int" Interval''previousUsage-3 [#_"Interval" this, #_"RegisterPriority" minRegisterPriority, #_"int" from]
        (loop-when [#_"int" prev -1 #_"int" i (dec (UsePosList''size-1 (:usePosList this)))] (<= 0 i) => prev
            (let [
                #_"int" usePos (UsePosList''usePos-2 (:usePosList this), i)
            ]
                (when (<= usePos from) => prev
                    (let [
                        prev
                            (when (RegisterPriority'greaterEqual-2 (Interval''adaptPriority-2 this, (UsePosList''registerPriority-2 (:usePosList this), i)), minRegisterPriority) => prev
                                usePos
                            )
                    ]
                        (recur prev (dec i))
                    )
                )
            )
        )
    )

    (§ method! #_"void" Interval''addUsePos-3 [#_"Interval" this, #_"int" pos, #_"RegisterPriority" registerPriority]
        ;; do not add use positions for precolored intervals because they are never used
        (when (and (not= registerPriority RegisterPriority'None) (instance? Variable (:operand this)))
            ;; note: addUse is called in descending order, so list gets sorted automatically by just appending new use positions
            (let [
                #_"int" len (UsePosList''size-1 (:usePosList this))
            ]
                (cond
                    (or (zero? len) (< pos (UsePosList''usePos-2 (:usePosList this), (dec len))))
                        (UsePosList''add-3 (:usePosList this), pos, registerPriority)
                    (RegisterPriority'lessThan-2 (UsePosList''registerPriority-2 (:usePosList this), (dec len)), registerPriority)
                        (UsePosList''setRegisterPriority-3 (:usePosList this), (dec len), registerPriority)
                )
            )
        )
        nil
    )

    (§ method! #_"Interval" Interval''addRange-3 [#_"Interval" this, #_"int" from, #_"int" to]
        (if (<= (:from (:first this)) to)
            ;; join intersecting ranges
            (let [
                _ (§ ass! (:from (:first this)) (min from (:from (:first this))))
                _ (§ ass! (:to (:first this)) (max to (:to (:first this))))
            ]
                this
            )
            ;; insert new range
            (assoc this :first (Range'new-3 from, to, (:first this)))
        )
    )

    (§ method! #_"Interval" Interval''newSplitChild-2 [#_"Interval" this, #_"LinearScan" allocator]
        ;; allocate new interval
        (let [
            #_"Interval" parent (:splitParent this)
            #_"Interval" result (LinearScan''createDerivedInterval-2 allocator, parent)
        ]
            (§ ass! result (Interval''setKind-2 result, (:kind this)))

            (§ ass result (assoc result :splitParent parent))
            (§ ass! result (Interval''setLocationHint-2 result, parent))

            ;; insert new interval in children-list of parent
            (when (empty? (:splitChildren parent))
                ;; create new non-shared list
                (§ ass parent (assoc parent :splitChildren (ArrayList.)))
                (#_"List" .add (:splitChildren parent), this)
            )
            (#_"List" .add (:splitChildren parent), result)

            result
        )
    )

    ;;;
     ; Splits this interval at a specified position and returns the remainder as a new <i>child</i>
     ; interval of this interval's {@linkplain #splitParent() parent} interval.
     ;
     ; When an interval is split, a bi-directional link is established between the original
     ; <i>parent</i> interval and the <i>children</i> intervals that are split off this interval.
     ; When a split child is split again, the new created interval is a direct child of the original
     ; parent. That is, there is no tree of split children stored, just a flat list. All split
     ; children are spilled to the same {@linkplain #spillSlot spill slot}.
     ;
     ; @param splitPos the position at which to split this interval
     ; @param allocator the register allocator context
     ; @return the child interval split off from this interval
     ;;
    (§ method! #_"Interval" Interval''split-3 [#_"Interval" this, #_"int" splitPos, #_"LinearScan" allocator]
        ;; allocate new interval
        (let [
            #_"Interval" result (Interval''newSplitChild-2 this, allocator)
            ;; split the ranges
            [#_"Range" prev #_"Range" cur]
                (loop-when-recur [prev nil cur (:first this)] (and (not (Range''isEndMarker-1 cur)) (<= (:to cur) splitPos)) [cur (:next cur)] => [prev cur])
        ]
            (if (< (:from cur) splitPos)
                (do
                    (§ ass result (assoc result :first (Range'new-3 splitPos, (:to cur), (:next cur))))
                    (§ ass! cur (assoc cur :to splitPos :next (:rangeEndMarker allocator)))
                )
                (do
                    (§ ass result (assoc result :first cur))
                    (§ ass! prev (assoc prev :next (:rangeEndMarker allocator)))
                )
            )
            (§ ass result (assoc result :current (:first result)))
            (§ ass! this (assoc this :cachedTo -1)) ;; clear cached value

            ;; split list of use positions
            (§ ass result (assoc result :usePosList (UsePosList''splitAt-2 (:usePosList this), splitPos)))

            result
        )
    )

    ;;;
     ; Splits this interval at a specified position and returns the head as a new interval (this interval is the tail).
     ;
     ; Currently, only the first range can be split, and the new interval must not have split positions
     ;;
    #_unused
    (§ method! #_"Interval" Interval''splitFromStart-3 [#_"Interval" this, #_"int" splitPos, #_"LinearScan" allocator]
        ;; allocate new interval
        (let [
            #_"Interval" result (Interval''newSplitChild-2 this, allocator)
        ]
            ;; the new interval should only have one range, so the splitting of the ranges is very simple
            (§ ass! result (Interval''addRange-3 result, (:from (:first this)), splitPos))

            (if (= splitPos (:to (:first this)))
                (§ ass! this (assoc this :first (:next (:first this))))
                (§ ass! (:from (:first this)) splitPos)
            )

            result
        )
    )

    ;; returns true if the opId is inside the interval
    (§ method! #_"boolean" Interval''covers-3 [#_"Interval" this, #_"int" opId, #_"OperandMode" mode]
        (let [
            #_"Range" r (loop-when-recur [r (:first this)] (and (not (Range''isEndMarker-1 r)) (< (:to r) opId)) [(:next r)] => r)
        ]
            (and (not (Range''isEndMarker-1 r))
                (if (= mode OperandMode'DEF)
                    (and (<= (:from r) opId) (< opId (:to r)))
                    (and (<= (:from r) opId) (<= opId (:to r)))
                )
            )
        )
    )

    ;; returns true if the interval has any hole between holeFrom and holeTo
    ;; (even if the hole has only the length 1)
    (§ method! #_"boolean" Interval''hasHoleBetween-3 [#_"Interval" this, #_"int" holeFrom, #_"int" holeTo]
        (loop-when [#_"Range" r (:first this)] (not (Range''isEndMarker-1 r)) => false
            (cond
                (< holeFrom (:from r)) true  ;; hole-range starts before this range . hole
                (<= holeTo (:to r))    false ;; hole-range completely inside this range . no hole
                (<= holeFrom (:to r))  true  ;; overlapping of hole-range with this range . hole
                :else                  (recur (:next r))
            )
        )
    )

    (§ method! #_"List<Interval>" Interval''getSplitChildren-1 [#_"Interval" this]
        (Collections/unmodifiableList (:splitChildren this))
    )
)

;;;
 ; A set of interval lists, one per binding type.
 ;
 ; @anno Interval.RegisterBindingLists
 ;;
(final-ns RegisterBindingLists
    ;;;
     ; List of intervals whose binding is currently RegisterBinding#Fixed.
     ;;
    (§ mutable #_"Interval" :fixed nil)

    ;;;
     ; List of intervals whose binding is currently RegisterBinding#Any.
     ;;
    (§ mutable #_"Interval" :any nil)

    ;;;
     ; List of intervals whose binding is currently RegisterBinding#Stack.
     ;;
    (§ mutable #_"Interval" :stack nil)

    (§ defn #_"RegisterBindingLists" RegisterBindingLists'new-3 [#_"Interval" fixed, #_"Interval" any, #_"Interval" stack]
        (let [
            #_"RegisterBindingLists" this (Object.)
            this (assoc this :fixed fixed)
            this (assoc this :any any)
            this (assoc this :stack stack)
        ]
            this
        )
    )

    ;;;
     ; Gets the list for a specified binding.
     ;
     ; @param binding specifies the list to be returned
     ; @return the list of intervals whose binding is {@code binding}
     ;;
    (§ method! #_"Interval" RegisterBindingLists''get-2 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding]
        (condp = binding
            RegisterBinding'Any   (:any this)
            RegisterBinding'Fixed (:fixed this)
            RegisterBinding'Stack (:stack this)
        )
    )

    ;;;
     ; Sets the list for a specified binding.
     ;
     ; @param binding specifies the list to be replaced
     ; @param list a list of intervals whose binding is {@code binding}
     ;;
    (§ method! #_"RegisterBindingLists" RegisterBindingLists''set-3 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding, #_"Interval" list]
        (condp = binding
            RegisterBinding'Any   (assoc this :any   list)
            RegisterBinding'Fixed (assoc this :fixed list)
            RegisterBinding'Stack (assoc this :stack list)
        )
    )

    ;;;
     ; Adds an interval to a list sorted by {@linkplain Interval#currentFrom() current from} positions.
     ;
     ; @param binding specifies the list to be updated
     ; @param interval the interval to add
     ;;
    (§ method! #_"RegisterBindingLists" RegisterBindingLists''addToListSortedByCurrentFromPositions-3 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding, #_"Interval" interval]
        (let [
            #_"Interval" list (RegisterBindingLists''get-2 this, binding)
            [#_"Interval" prev #_"Interval" cur]
                (loop-when-recur [prev nil cur list] (< (Interval''currentFrom-1 cur) (Interval''currentFrom-1 interval)) [cur (:next cur)] => [prev cur])
            #_"Interval" result list
        ]
            (if (nil? prev)
                (§ ass result interval)                   ;; add to head of list
                (§ ass! prev (assoc prev :next interval)) ;; add before 'cur'
            )
            (§ ass! interval (assoc interval :next cur))
            (RegisterBindingLists''set-3 this, binding, result)
        )
    )

    ;;;
     ; Adds an interval to a list sorted by {@linkplain Interval#from() start} positions and
     ; {@linkplain Interval#firstUsage(RegisterPriority) first usage} positions.
     ;
     ; @param binding specifies the list to be updated
     ; @param interval the interval to add
     ;;
    (§ method! #_"RegisterBindingLists" RegisterBindingLists''addToListSortedByStartAndUsePositions-3 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding, #_"Interval" interval]
        (let [
            #_"Interval" list (RegisterBindingLists''get-2 this, binding)
            [#_"Interval" prev #_"Interval" cur]
                (loop-when-recur [prev nil cur list] (or (< (Interval''from-1 cur) (Interval''from-1 interval)) (and (= (Interval''from-1 cur) (Interval''from-1 interval)) (< (Interval''firstUsage-2 cur, RegisterPriority'None) (Interval''firstUsage-2 interval, RegisterPriority'None)))) [cur (:next cur)] => [prev cur])
        ]
            (if (nil? prev)
                (§ ass list interval)
                (§ ass! prev (assoc prev :next interval))
            )
            (§ ass! interval (assoc interval :next cur))
            (RegisterBindingLists''set-3 this, binding, list)
        )
    )

    ;;;
     ; Removes an interval from a list.
     ;
     ; @param binding specifies the list to be updated
     ; @param i the interval to remove
     ;;
    (§ method! #_"RegisterBindingLists" RegisterBindingLists''remove-3 [#_"RegisterBindingLists" this, #_"RegisterBinding" binding, #_"Interval" i]
        (let [
            #_"Interval" list (RegisterBindingLists''get-2 this, binding)
            [#_"Interval" prev #_"Interval" cur]
                (loop-when-recur [prev nil cur list] (not= cur i) [cur (:next cur)] => [prev cur])
        ]
            (if (nil? prev)
                (§ ass! this (RegisterBindingLists''set-3 this, binding, (:next cur)))
                (§ ass! prev (assoc prev :next (:next cur)))
            )
            this
        )
    )
)

;;;
 ; Constants denoting the register usage priority for an interval. The constants are declared in
 ; increasing order of priority are are used to optimize spilling when multiple overlapping
 ; intervals compete for limited registers.
 ;
 ; @anno Interval.RegisterPriority
 ;;
(value-ns RegisterPriority
    ;;;
     ; No special reason for an interval to be allocated a register.
     ;;
    (§ enum RegisterPriority'None)
    ;;;
     ; Priority level for intervals live at the end of a loop.
     ;;
    (§ enum RegisterPriority'LiveAtLoopEnd)
    ;;;
     ; Priority level for intervals that should be allocated to a register.
     ;;
    (§ enum RegisterPriority'ShouldHaveRegister)
    ;;;
     ; Priority level for intervals that must be allocated to a register.
     ;;
    (§ enum RegisterPriority'MustHaveRegister)

    (§ def #_"RegisterPriority[]" RegisterPriority'VALUES (RegisterPriority'values-0))

    ;;;
     ; Determines if a priority is higher than or equal to an other.
     ;;
    (§ defn #_"boolean" RegisterPriority'greaterEqual-2 [#_"RegisterPriority" a, #_"RegisterPriority" b]
        (>= (RegisterPriority''ordinal-1 a) (RegisterPriority''ordinal-1 b))
    )

    ;;;
     ; Determines if a priority is lower than an other.
     ;;
    (§ defn #_"boolean" RegisterPriority'lessThan-2 [#_"RegisterPriority" a, #_"RegisterPriority" b]
        (< (RegisterPriority''ordinal-1 a) (RegisterPriority''ordinal-1 b))
    )
)

;;;
 ; Constants denoting whether an interval is bound to a specific register. This models platform
 ; dependencies on register usage for certain instructions.
 ;
 ; @anno Interval.RegisterBinding
 ;;
(value-ns RegisterBinding
    ;;;
     ; Interval is bound to a specific register as required by the platform.
     ;;
    (§ enum RegisterBinding'Fixed)
    ;;;
     ; Interval has no specific register requirements.
     ;;
    (§ enum RegisterBinding'Any)
    ;;;
     ; Interval is bound to a stack slot.
     ;;
    (§ enum RegisterBinding'Stack)

    (§ def #_"RegisterBinding[]" RegisterBinding'VALUES (RegisterBinding'values-0))
)

;;;
 ; Constants denoting the linear-scan states an interval may be in with respect to the
 ; {@linkplain Interval#from() start} {@code position} of the interval being processed.
 ;
 ; @anno Interval.IntervalState
 ;;
(value-ns IntervalState
    ;;;
     ; An interval that starts after {@code position}.
     ;;
    (§ enum IntervalState'Unhandled)
    ;;;
     ; An interval that {@linkplain Interval#covers covers} {@code position} and has an assigned register.
     ;;
    (§ enum IntervalState'Active)
    ;;;
     ; An interval that starts before and ends after {@code position} but does not
     ; {@linkplain Interval#covers cover} it due to a lifetime hole.
     ;;
    (§ enum IntervalState'Inactive)
    ;;;
     ; An interval that ends before {@code position} or is spilled to memory.
     ;;
    (§ enum IntervalState'Handled)
)

;;;
 ; Constants used in optimization of spilling of an interval.
 ;
 ; @anno Interval.SpillState
 ;;
(value-ns SpillState
    ;;;
     ; Starting state of calculation: no definition found yet.
     ;;
    (§ enum SpillState'NoDefinitionFound)
    ;;;
     ; One definition has already been found. Two consecutive definitions are treated as one
     ; (e.g. a consecutive move and add because of two-operand LIR form). The position of this
     ; definition is given by Interval#spillDefinitionPos().
     ;;
    (§ enum SpillState'NoSpillStore)
    ;;;
     ; One spill move has already been inserted.
     ;;
    (§ enum SpillState'OneSpillStore)
    ;;;
     ; The interval is spilled multiple times or is spilled in a loop. Place the store somewhere
     ; on the dominator path between the definition and the usages.
     ;;
    (§ enum SpillState'SpillInDominator)
    ;;;
     ; The interval should be stored immediately after its definition to prevent multiple
     ; redundant stores.
     ;;
    (§ enum SpillState'StoreAtDefinition)
    ;;;
     ; The interval starts in memory (e.g. method parameter), so a store is never necessary.
     ;;
    (§ enum SpillState'StartInMemory)
    ;;;
     ; The interval has more than one definition (e.g. resulting from phi moves), so stores to
     ; memory are not optimized.
     ;;
    (§ enum SpillState'NoOptimization)

    (§ def #_"EnumSet<SpillState>" SpillState'ALWAYS_IN_MEMORY (EnumSet/of SpillState'SpillInDominator, SpillState'StoreAtDefinition, SpillState'StartInMemory))
)

;;;
 ; List of use positions. Each entry in the list records the use position and register priority
 ; associated with the use position. The entries in the list are in descending order of use position.
 ;
 ; @anno Interval.UsePosList
 ;;
(final-ns UsePosList
    (§ mutable #_"IntList" :list nil)

    ;;;
     ; Creates a use list.
     ;
     ; @param initialCapacity the initial capacity of the list in terms of entries
     ;;
    (§ defn #_"UsePosList" UsePosList'new-1 [#_"int" initialCapacity]
        (let [
            #_"UsePosList" this (Object.)
            this (assoc this :list (IntList'new-1 (* initialCapacity 2)))
        ]
            this
        )
    )

    (§ defn- #_"UsePosList" UsePosList'new-1 [#_"IntList" list]
        (let [
            #_"UsePosList" this (Object.)
            this (assoc this :list list)
        ]
            this
        )
    )

    ;;;
     ; Splits this list around a given position. All entries in this list with a use position
     ; greater or equal than {@code at} are removed from this list and added to the returned list.
     ;
     ; @param at the position for the split
     ; @return a use position list containing all entries removed from this list that have a use
     ;         position greater or equal than {@code at}
     ;;
    (§ method! #_"UsePosList" UsePosList''splitAt-2 [#_"UsePosList" this, #_"int" at]
        (let [
            [#_"int" i #_"int" n]
                (loop-when-recur [i (dec (UsePosList''size-1 this)) n 0]
                                 (and (<= 0 i) (< (UsePosList''usePos-2 this, i) at))
                                 [(dec i) (+ n 2)]
                              => [(<< (inc i) 1) n]
                )
            #_"IntList" list (:list this)
        ]
            (§ ass! this (assoc this :list (IntList'copy-3 (:list this), i, n)))
            (§ ass! list (IntList''setSize-2 list, i))
            (UsePosList'new-1 list)
        )
    )

    ;;;
     ; Gets the use position at a specified index in this list.
     ;
     ; @param index the index of the entry for which the use position is returned
     ; @return the use position of entry {@code index} in this list
     ;;
    (§ method! #_"int" UsePosList''usePos-2 [#_"UsePosList" this, #_"int" index]
        (IntList''get-2 (:list this), (<< index 1))
    )

    ;;;
     ; Gets the register priority for the use position at a specified index in this list.
     ;
     ; @param index the index of the entry for which the register priority is returned
     ; @return the register priority of entry {@code index} in this list
     ;;
    (§ method! #_"RegisterPriority" UsePosList''registerPriority-2 [#_"UsePosList" this, #_"int" index]
        (nth RegisterPriority'VALUES (IntList''get-2 (:list this), (inc (<< index 1))))
    )

    (§ method! #_"void" UsePosList''add-3 [#_"UsePosList" this, #_"int" usePos, #_"RegisterPriority" registerPriority]
        (§ ass! (:list this) (IntList''add-2 (:list this), usePos))
        (§ ass! (:list this) (IntList''add-2 (:list this), (RegisterPriority''ordinal-1 registerPriority)))
        nil
    )

    (§ method! #_"int" UsePosList''size-1 [#_"UsePosList" this]
        (>> (:size (:list this)) 1)
    )

    (§ method! #_"void" UsePosList''removeLowestUsePos-1 [#_"UsePosList" this]
        (§ ass! (:list this) (IntList''setSize-2 (:list this), (- (:size (:list this)) 2)))
        nil
    )

    (§ method! #_"void" UsePosList''setRegisterPriority-3 [#_"UsePosList" this, #_"int" index, #_"RegisterPriority" registerPriority]
        (IntList''set-3 (:list this), (inc (<< index 1)), (RegisterPriority''ordinal-1 registerPriority))
        nil
    )
)

(class-ns IntervalWalker
    (§ final #_"LinearScan" :allocator nil)

    ;;;
     ; Sorted list of intervals, not live before the current position.
     ;;
    (§ mutable #_"RegisterBindingLists" :unhandledLists nil)

    ;;;
     ; Sorted list of intervals, live at the current position.
     ;;
    (§ mutable #_"RegisterBindingLists" :activeLists nil)

    ;;;
     ; Sorted list of intervals in a life time hole at the current position.
     ;;
    (§ mutable #_"RegisterBindingLists" :inactiveLists nil)

    ;;;
     ; The current position (intercept point through the intervals).
     ;;
    (§ mutable #_"int" :currentPosition 0)

    ;;;
     ; The binding of the current interval being processed.
     ;;
    (§ mutable #_"RegisterBinding" :currentBinding nil)

    ;;;
     ; Processes the {@code currentInterval} interval in an attempt to allocate a physical register
     ; to it and thus allow it to be moved to a list of {@linkplain #activeLists active} intervals.
     ;
     ; @return true if a register was allocated to the {@code currentInterval} interval
     ;;
    (§ method #_"boolean" IntervalWalker''activateCurrent-2 [#_"IntervalWalker" this, #_"Interval" currentInterval]
        true
    )

    #_unused
    (§ method! #_"IntervalWalker" IntervalWalker''walkBefore-2 [#_"IntervalWalker" this, #_"int" lirOpId]
        (IntervalWalker''walkTo-2 this, (dec lirOpId))
    )

    (§ method #_"void" IntervalWalker''walk-1 [#_"IntervalWalker" this]
        (§ ass! this (IntervalWalker''walkTo-2 this, Integer/MAX_VALUE))
        nil
    )

    ;;;
     ; Creates a new interval walker.
     ;
     ; @param allocator the register allocator context
     ; @param unhandledFixed the list of unhandled {@linkplain RegisterBinding#Fixed fixed} intervals
     ; @param unhandledAny the list of unhandled {@linkplain RegisterBinding#Any non-fixed} intervals
     ;;
    (§ defn #_"IntervalWalker" IntervalWalker'new-3 [#_"LinearScan" allocator, #_"Interval" unhandledFixed, #_"Interval" unhandledAny]
        (let [
            #_"IntervalWalker" this (Object.)
            this (assoc this :allocator allocator)
            this (assoc this :unhandledLists (RegisterBindingLists'new-3 unhandledFixed, unhandledAny, (:intervalEndMarker allocator)))
            this (assoc this :activeLists (RegisterBindingLists'new-3 (:intervalEndMarker allocator), (:intervalEndMarker allocator), (:intervalEndMarker allocator)))
            this (assoc this :inactiveLists (RegisterBindingLists'new-3 (:intervalEndMarker allocator), (:intervalEndMarker allocator), (:intervalEndMarker allocator)))
            this (assoc this :currentPosition -1)
        ]
            this
        )
    )

    (§ method! #_"void" IntervalWalker''removeFromList-2 [#_"IntervalWalker" this, #_"Interval" interval]
        (if (= (:state interval) IntervalState'Active)
            (§ ass! (:activeLists this) (RegisterBindingLists''remove-3 (:activeLists this), RegisterBinding'Any, interval))
            (§ ass! (:inactiveLists this) (RegisterBindingLists''remove-3 (:inactiveLists this), RegisterBinding'Any, interval))
        )
        nil
    )

    (§ method- #_"void" IntervalWalker''walkTo-3 [#_"IntervalWalker" this, #_"IntervalState" state, #_"int" from]
        (doseq [#_"RegisterBinding" binding RegisterBinding'VALUES]
            (IntervalWalker''walkTo-4 this, state, from, binding)
        )
        nil
    )

    (§ method- #_"void" IntervalWalker''walkTo-4 [#_"IntervalWalker" this, #_"IntervalState" state, #_"int" from, #_"RegisterBinding" binding]
        (let [
            #_"Interval" prev (if (= state IntervalState'Active) (RegisterBindingLists''get-2 (:activeLists this), binding) (RegisterBindingLists''get-2 (:inactiveLists this), binding))
        ]
            (loop-when [#_"Interval" prevprev nil prev prev #_"Interval" next prev] (<= (Interval''currentFrom-1 next) from)
                (let [
                    #_"Interval" cur next
                    next (:next cur)
                    #_"boolean" rangeHasChanged
                        (loop-when-recur [rangeHasChanged false] (<= (Interval''currentTo-1 cur) from) [true] => rangeHasChanged
                            (§ ass! cur (Interval''nextRange-1 cur))
                        )
                    ;; also handle move from inactive list to active list
                    rangeHasChanged (or rangeHasChanged (and (= state IntervalState'Inactive) (<= (Interval''currentFrom-1 cur) from)))
                ]
                    (when rangeHasChanged => (recur prev (:next cur) next)
                        ;; remove cur from list
                        (if (nil? prevprev)
                            (if (= state IntervalState'Active)
                                (§ ass! (:activeLists this) (RegisterBindingLists''set-3 (:activeLists this), binding, next))
                                (§ ass! (:inactiveLists this) (RegisterBindingLists''set-3 (:inactiveLists this), binding, next))
                            )
                            (§ ass! prevprev (assoc prevprev :next next))
                        )
                        (let [
                            prev next
                            [prevprev prev #_"IntervalState" newState]
                                (if (Interval''currentAtEnd-1 cur)
                                    ;; move to handled state (not maintained as a list)
                                    (let [
                                        newState IntervalState'Handled
                                    ]
                                        (§ ass! cur (assoc cur :state newState))
                                        [prevprev prev newState]
                                    )
                                    (let [
                                        newState
                                            (if (<= (Interval''currentFrom-1 cur) from)
                                                (do
                                                    ;; sort into active list
                                                    (§ ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), binding, cur))
                                                    IntervalState'Active
                                                )
                                                (do
                                                    ;; sort into inactive list
                                                    (§ ass! (:inactiveLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:inactiveLists this), binding, cur))
                                                    IntervalState'Inactive
                                                )
                                            )
                                    ]
                                        (§ ass! cur (assoc cur :state newState))
                                        (when (= prev cur) => [prevprev prev newState]
                                            [prev (:next cur) newState]
                                        )
                                    )
                                )
                        ]
                            (IntervalWalker''intervalMoved-4 this, cur, state, newState)
                            (recur prevprev prev next)
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Get the next interval from {@linkplain #unhandledLists} which starts before or at
     ; {@code toOpId}. The returned interval is removed and #currentBinding is set.
     ;
     ; @postcondition all intervals in {@linkplain #unhandledLists} start after {@code toOpId}.
     ;
     ; @return the next interval or nil if there is no {@linkplain #unhandledLists unhandled}
     ;         interval at position {@code toOpId}.
     ;;
    (§ method- #_"Interval" IntervalWalker''nextInterval-2 [#_"IntervalWalker" this, #_"int" toOpId]
        (let [
            #_"Interval" any (:any (:unhandledLists this))
            #_"Interval" fixed (:fixed (:unhandledLists this))
            #_"RegisterBinding" binding
                (cond
                    (not (Interval''isEndMarker-1 any))
                        ;; intervals may start at same position . prefer fixed interval
                        (if (and (not (Interval''isEndMarker-1 fixed)) (<= (Interval''from-1 fixed) (Interval''from-1 any))) RegisterBinding'Fixed RegisterBinding'Any)
                    (not (Interval''isEndMarker-1 fixed))
                        RegisterBinding'Fixed
                    :else
                        (§ return nil)
                )
            #_"Interval" interval (RegisterBindingLists''get-2 (:unhandledLists this), binding)
        ]
            (when-not (< toOpId (Interval''from-1 interval))
                (§ ass! this (assoc this :currentBinding binding))
                (§ ass! (:unhandledLists this) (RegisterBindingLists''set-3 (:unhandledLists this), binding, (:next interval)))
                (§ ass! interval (assoc interval :next (:intervalEndMarker (:allocator this))))
                (§ ass! interval (Interval''rewindRange-1 interval))
                interval
            )
        )
    )

    ;;;
     ; Walk up to {@code toOpId}.
     ;
     ; @postcondition #currentPosition is set to {@code toOpId}, #activeLists and #inactiveLists
     ;                are populated and Interval#states are up to date
     ;;
    (§ method! #_"IntervalWalker" IntervalWalker''walkTo-2 [#_"IntervalWalker" this, #_"int" toOpId]
        (let [
            this
                (loop-when [this this #_"Interval" interval (IntervalWalker''nextInterval-2 this, toOpId)] (some? interval) => this
                    (let [
                        #_"int" opId (Interval''from-1 interval)
                        ;; set currentPosition prior to call of walkTo
                        this (assoc this :currentPosition opId)
                    ]
                        ;; update unhandled stack intervals
                        (IntervalWalker''updateUnhandledStackIntervals-2 this, opId)

                        ;; call walkTo even if currentPosition == id
                        (IntervalWalker''walkTo-3 this, IntervalState'Active, opId)
                        (IntervalWalker''walkTo-3 this, IntervalState'Inactive, opId)

                        (§ ass! interval (assoc interval :state IntervalState'Active))
                        (when (IntervalWalker''activateCurrent-2 this, interval)
                            (§ ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), (:currentBinding this), interval))
                            (IntervalWalker''intervalMoved-4 this, interval, IntervalState'Unhandled, IntervalState'Active)
                        )
                        (recur this (IntervalWalker''nextInterval-2 this, toOpId))
                    )
                )
            ;; set currentPosition prior to call of walkTo
            this (assoc this :currentPosition toOpId)
        ]
            (when (<= (:currentPosition this) (LinearScan''maxOpId-1 (:allocator this)))
                ;; update unhandled stack intervals
                (IntervalWalker''updateUnhandledStackIntervals-2 this, toOpId)

                ;; call walkTo if still in range
                (IntervalWalker''walkTo-3 this, IntervalState'Active, toOpId)
                (IntervalWalker''walkTo-3 this, IntervalState'Inactive, toOpId)
            )
            this
        )
    )

    (§ method- #_"void" IntervalWalker''intervalMoved-4 [#_"IntervalWalker" this, #_"Interval" interval, #_"IntervalState" from, #_"IntervalState" to]
        ;; intervalMoved() is called whenever an interval moves from one interval list to another.
        ;; In the implementation of this method it is prohibited to move the interval to any list.
        nil
    )

    ;;;
     ; Move {@linkplain #unhandledLists unhandled} stack intervals to
     ; {@linkplain IntervalWalker #activeLists active}.
     ;
     ; Note that for {@linkplain RegisterBinding#Fixed fixed} and {@linkplain RegisterBinding#Any
     ; any} intervals this is done in #nextInterval(int).
     ;;
    (§ method- #_"void" IntervalWalker''updateUnhandledStackIntervals-2 [#_"IntervalWalker" this, #_"int" opId]
        (let [
            #_"Interval" interval
                (loop-when [interval (RegisterBindingLists''get-2 (:unhandledLists this), RegisterBinding'Stack)] (and (not (Interval''isEndMarker-1 interval)) (<= (Interval''from-1 interval) opId)) => interval
                    (let [
                        #_"Interval" next (:next interval)
                    ]
                        (if (< opId (Interval''to-1 interval))
                            (do
                                (§ ass! interval (assoc interval :state IntervalState'Active))
                                (§ ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), RegisterBinding'Stack, interval))
                                (IntervalWalker''intervalMoved-4 this, interval, IntervalState'Unhandled, IntervalState'Active)
                            )
                            (do
                                (§ ass! interval (assoc interval :state IntervalState'Handled))
                                (IntervalWalker''intervalMoved-4 this, interval, IntervalState'Unhandled, IntervalState'Handled)
                            )
                        )
                        (recur next)
                    )
                )
        ]
            (§ ass! (:unhandledLists this) (RegisterBindingLists''set-3 (:unhandledLists this), RegisterBinding'Stack, interval))
        )
        nil
    )
)

;;;
 ; An implementation of the linear scan register allocator algorithm described in
 ; <a href="http://doi.acm.org/10.1145/1064979.1064998">"Optimized Interval Splitting in a Linear Scan Register Allocator"</a>
 ; by Christian Wimmer and Hanspeter Moessenboeck.
 ;;
(class-ns LinearScan
    (def #_"int" LinearScan'DOMINATOR_SPILL_MOVE_ID -2)
    (def- #_"int" LinearScan'SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT 1)

    (§ final #_"LIR" :lir nil)
    (§ final #_"FrameMapBuilder" :frameMapBuilder nil)
    (§ final #_"RegisterAttributes[]" :registerAttributes nil)
    (§ final #_"RegisterArray" :registers nil)
    (§ final #_"RegisterAllocationConfig" :regAllocConfig nil)
    (§ final #_"MoveFactory" :moveFactory nil)
    (§ final #_"BlockMap<BlockData>" :blockData nil)
    ;;;
     ; List of blocks in linear-scan order. This is only correct as long as the CFG does not change.
     ;;
    (§ final #_"Block[]" :sortedBlocks nil)
    ;;;
     ; Map from {@linkplain #operandNumber(Value) operand numbers} to intervals.
     ;;
    (§ mutable #_"Interval[]" :intervals nil)
    ;;;
     ; The number of valid entries in #intervals.
     ;;
    (§ mutable #_"int" :intervalsSize 0)
    ;;;
     ; The index of the first entry in #intervals for a
     ; {@linkplain #createDerivedInterval(Interval) derived interval}.
     ;;
    (§ mutable #_"int" :firstDerivedIntervalIndex -1)
    ;;;
     ; Intervals sorted by Interval#from().
     ;;
    (§ mutable #_"Interval[]" :sortedIntervals nil)
    ;;;
     ; Map from an instruction {@linkplain LIRInstruction#id id} to the instruction. Entries should
     ; be retrieved with #instructionForId(int) as the id is not simply an index into this array.
     ;;
    (§ mutable #_"LIRInstruction[]" :opIdToInstructionMap nil)
    ;;;
     ; Map from an instruction {@linkplain LIRInstruction#id id} to the
     ; block containing the instruction. Entries should be retrieved
     ; with #blockForId(int) as the id is not simply an index into this array.
     ;;
    (§ mutable #_"Block[]" :opIdToBlockMap nil)
    ;;;
     ; The {@linkplain #operandNumber(Value) number} of the first variable operand allocated.
     ;;
    (§ final #_"int" :firstVariableNumber 0)
    (§ mutable #_"int" :numVariables 0)
    (§ final #_"boolean" :neverSpillConstants false)
    ;;;
     ; Sentinel interval to denote the end of an interval list.
     ;;
    (§ final #_"Interval" :intervalEndMarker nil)
    (§ final #_"Range" :rangeEndMarker nil)

    (§ defn #_"LinearScan" LinearScan'new-5 [#_"LIRGenerationResult" res, #_"MoveFactory" moveFactory, #_"RegisterAllocationConfig" regAllocConfig, #_"Block[]" sortedBlocks, #_"boolean" neverSpillConstants]
        (let [
            #_"LinearScan" this (Object.)
            this (assoc this :lir (:lir res))
            this (assoc this :moveFactory moveFactory)
            this (assoc this :frameMapBuilder (:frameMapBuilder res))
            this (assoc this :sortedBlocks sortedBlocks)
            this (assoc this :registerAttributes (#_"RegisterConfig" .getAttributesMap HotSpot'registerConfig))
            this (assoc this :regAllocConfig regAllocConfig)
            this (assoc this :registers (#_"Architecture" .getRegisters (.arch HotSpot'target)))
            this (assoc this :firstVariableNumber (#_"RegisterArray" .size (LinearScan''getRegisters-1 this)))
            this (assoc this :numVariables (:numVariables (:lir this)))
            this (assoc this :blockData (BlockMap'new-1 (:cfg (:lir this))))
            this (assoc this :neverSpillConstants neverSpillConstants)
            this (assoc this :rangeEndMarker (Range'new-3 Integer/MAX_VALUE, Integer/MAX_VALUE, nil))
            this (assoc this :intervalEndMarker (Interval'new-4 Value/ILLEGAL, Interval'END_MARKER_OPERAND_NUMBER, nil, (:rangeEndMarker this)))
        ]
            (§ ass! (:next (:intervalEndMarker this)) (:intervalEndMarker this))
            this
        )
    )

    #_unused
    (§ method! #_"Interval" LinearScan''intervalEndMarker-1 [#_"LinearScan" this]
        (:intervalEndMarker this)
    )

    (§ method! #_"int" LinearScan''getFirstLirInstructionId-2 [#_"LinearScan" this, #_"Block" block]
        (LIRInstruction''id-1 (nth (LIR''getLIRforBlock-2 (:lir this), block) 0))
    )

    (§ method! #_"int" LinearScan''getLastLirInstructionId-2 [#_"LinearScan" this, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
        ]
            (LIRInstruction''id-1 (nth ops (dec (count ops))))
        )
    )

    (§ method #_"MoveResolver" LinearScan''createMoveResolver-1 [#_"LinearScan" this]
        (MoveResolver'new-1 this)
    )

    (§ defn #_"boolean" LinearScan'isVariableOrRegister-1 [#_"Value" value]
        (or (instance? Variable value) (instance? RegisterValue value))
    )

    ;;;
     ; Converts an operand (variable or register) to an index in a flat address space covering all
     ; the variables and registers being processed by this allocator.
     ;;
    (§ method! #_"int" LinearScan''operandNumber-2 [#_"LinearScan" this, #_"Value" operand]
        (if (instance? RegisterValue operand)
            (.number (#_"RegisterValue" .getRegister operand))
            (+ (:firstVariableNumber this) (:index operand))
        )
    )

    ;;;
     ; Gets the number of operands. This value will increase by 1 for new variable.
     ;;
    (§ method! #_"int" LinearScan''operandSize-1 [#_"LinearScan" this]
        (+ (:firstVariableNumber this) (:numVariables this))
    )

    ;;;
     ; Gets the highest operand number for a register operand. This value will never change.
     ;;
    #_unused
    (§ method #_"int" LinearScan''maxRegisterNumber-1 [#_"LinearScan" this]
        (dec (:firstVariableNumber this))
    )

    (§ method! #_"BlockData" LinearScan''getBlockData-2 [#_"LinearScan" this, #_"Block" block]
        (BlockMap''get-2 (:blockData this), block)
    )

    (§ method #_"void" LinearScan''initBlockData-2 [#_"LinearScan" this, #_"Block" block]
        (BlockMap''put-3 (:blockData this), block, (BlockData'new-0))
        nil
    )

    (§ def #_"IntervalPredicate" LinearScan'IS_PRECOLORED_INTERVAL
        (§ reify #_"IntervalPredicate" (IntervalPredicate'new-0)
            (§ override! #_"boolean" IntervalPredicate''apply-2 [#_"IntervalPredicate" this, #_"Interval" i]
                (instance? RegisterValue (:operand i))
            )
        )
    )

    (§ def #_"IntervalPredicate" LinearScan'IS_VARIABLE_INTERVAL
        (§ reify #_"IntervalPredicate" (IntervalPredicate'new-0)
            (§ override! #_"boolean" IntervalPredicate''apply-2 [#_"IntervalPredicate" this, #_"Interval" i]
                (instance? Variable (:operand i))
            )
        )
    )

    (§ def #_"IntervalPredicate" LinearScan'IS_STACK_INTERVAL
        (§ reify #_"IntervalPredicate" (IntervalPredicate'new-0)
            (§ override! #_"boolean" IntervalPredicate''apply-2 [#_"IntervalPredicate" this, #_"Interval" i]
                (not (instance? RegisterValue (:operand i)))
            )
        )
    )

    ;;;
     ; Gets an object describing the attributes of a given register according to this register configuration.
     ;;
    (§ method #_"RegisterAttributes" LinearScan''attributes-2 [#_"LinearScan" this, #_"Register" reg]
        (nth (:registerAttributes this) (.number reg))
    )

    (§ method! #_"void" LinearScan''assignSpillSlot-2 [#_"LinearScan" this, #_"Interval" interval]
        ;; Assign the canonical spill slot of the parent (if a part of the interval is already spilled)
        ;; or allocate a new spill slot.
        (cond
            (Interval''canMaterialize-1 interval)
                (§ ass! interval (Interval''assignLocation-2 interval, Value/ILLEGAL))
            (some? (Interval''spillSlot-1 interval))
                (§ ass! interval (Interval''assignLocation-2 interval, (Interval''spillSlot-1 interval)))
            :else
                (let [
                    #_"VirtualStackSlot" slot (FrameMapBuilder''allocateSpillSlot-2 (:frameMapBuilder this), (:kind interval))
                ]
                    (Interval''setSpillSlot-2 interval, slot)
                    (§ ass! interval (Interval''assignLocation-2 interval, slot))
                )
        )
        nil
    )

    (§ method! #_"LinearScan" LinearScan''initIntervals-1 [#_"LinearScan" this]
        (let [
            this (assoc this :intervalsSize (LinearScan''operandSize-1 this))
            this (assoc this :intervals (make-array Interval (+ (:intervalsSize this) (>> (:intervalsSize this) LinearScan'SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT))))
        ]
            this
        )
    )

    ;;;
     ; Creates a new interval.
     ;
     ; @param operand the operand for the interval
     ; @return the created interval
     ;;
    (§ method! #_"Interval" LinearScan''createInterval-2 [#_"LinearScan" this, #_"AllocatableValue" operand]
        (let [
            #_"int" operandNumber (LinearScan''operandNumber-2 this, operand)
            #_"Interval" interval (Interval'new-4 operand, operandNumber, (:intervalEndMarker this), (:rangeEndMarker this))
        ]
            (aset (:intervals this) operandNumber interval)
            interval
        )
    )

    ;;;
     ; Creates an interval as a result of splitting or spilling another interval.
     ;
     ; @param source an interval being split of spilled
     ; @return a new interval derived from {@code source}
     ;;
    (§ method! #_"Interval" LinearScan''createDerivedInterval-2 [#_"LinearScan" this, #_"Interval" source]
        (when (= (:firstDerivedIntervalIndex this) -1)
            (§ ass! this (assoc this :firstDerivedIntervalIndex (:intervalsSize this)))
        )
        (when (= (:intervalsSize this) (count (:intervals this)))
            (§ ass! this (assoc this :intervals (Arrays/copyOf (:intervals this), (+ (count (:intervals this)) (>> (count (:intervals this)) LinearScan'SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT) 1))))
        )
        (§ ass! this (update this :intervalsSize inc))
        ;; note: these variables are not managed and must therefore never be inserted into the LIR
        (let [
            #_"Variable" variable (Variable'new-2 (:kind source), (:numVariables this))
        ]
            (§ ass! this (update this :numVariables inc))
            (LinearScan''createInterval-2 this, variable)
        )
    )

    ;; access to block list (sorted in linear scan order)
    (§ method #_"int" LinearScan''blockCount-1 [#_"LinearScan" this]
        (count (:sortedBlocks this))
    )

    (§ method #_"Block" LinearScan''blockAt-2 [#_"LinearScan" this, #_"int" index]
        (nth (:sortedBlocks this) index)
    )

    ;;;
     ; Gets the size of the BlockData#liveIn and BlockData#liveOut sets for a basic block.
     ; These sets do not include any operands allocated as a result of creating
     ; {@linkplain #createDerivedInterval(Interval) derived intervals}.
     ;;
    (§ method! #_"int" LinearScan''liveSetSize-1 [#_"LinearScan" this]
        (if (= (:firstDerivedIntervalIndex this) -1) (LinearScan''operandSize-1 this) (:firstDerivedIntervalIndex this))
    )

    (§ method! #_"int" LinearScan''numLoops-1 [#_"LinearScan" this]
        (count (:loops (:cfg (:lir this))))
    )

    (§ method! #_"Interval" LinearScan''intervalFor-2 [#_"LinearScan" this, #_"int" operandNumber]
        (nth (:intervals this) operandNumber)
    )

    (§ method! #_"Interval" LinearScan''intervalFor-2 [#_"LinearScan" this, #_"Value" operand]
        (nth (:intervals this) (LinearScan''operandNumber-2 this, operand))
    )

    (§ method #_"Interval" LinearScan''getOrCreateInterval-2 [#_"LinearScan" this, #_"AllocatableValue" operand]
        (or (LinearScan''intervalFor-2 this, operand) (LinearScan''createInterval-2 this, operand))
    )

    (§ method! #_"LinearScan" LinearScan''initOpIdMaps-2 [#_"LinearScan" this, #_"int" n]
        (let [
            this (assoc this :opIdToInstructionMap (make-array LIRInstruction n))
            this (assoc this :opIdToBlockMap (make-array Block n))
        ]
            this
        )
    )

    (§ method! #_"void" LinearScan''putOpIdMaps-4 [#_"LinearScan" this, #_"int" index, #_"LIRInstruction" op, #_"Block" block]
        (aset (:opIdToInstructionMap this) index op)
        (aset (:opIdToBlockMap this) index block)
        nil
    )

    ;;;
     ; Gets the highest instruction id allocated by this object.
     ;;
    (§ method #_"int" LinearScan''maxOpId-1 [#_"LinearScan" this]
        (<< (dec (count (:opIdToInstructionMap this))) 1)
    )

    ;;;
     ; Converts an {@linkplain LIRInstruction#id instruction id} to an instruction index. All LIR
     ; instructions in a method have an index one greater than their linear-scan order predecessor
     ; with the first instruction having an index of 0.
     ;;
    (§ defn- #_"int" LinearScan'opIdToIndex-1 [#_"int" opId]
        (>> opId 1)
    )

    ;;;
     ; Retrieves the LIRInstruction based on its {@linkplain LIRInstruction#id id}.
     ;
     ; @param opId an instruction {@linkplain LIRInstruction#id id}
     ; @return the instruction whose {@linkplain LIRInstruction#id} {@code == id}
     ;;
    (§ method! #_"LIRInstruction" LinearScan''instructionForId-2 [#_"LinearScan" this, #_"int" opId]
        (nth (:opIdToInstructionMap this) (LinearScan'opIdToIndex-1 opId))
    )

    ;;;
     ; Gets the block containing a given instruction.
     ;
     ; @param opId an instruction {@linkplain LIRInstruction#id id}
     ; @return the block containing the instruction denoted by {@code opId}
     ;;
    (§ method! #_"Block" LinearScan''blockForId-2 [#_"LinearScan" this, #_"int" opId]
        (nth (:opIdToBlockMap this) (LinearScan'opIdToIndex-1 opId))
    )

    (§ method! #_"boolean" LinearScan''isBlockBegin-2 [#_"LinearScan" this, #_"int" opId]
        (or (zero? opId) (not= (LinearScan''blockForId-2 this, opId) (LinearScan''blockForId-2 this, (dec opId))))
    )

    #_unused
    (§ method! #_"boolean" LinearScan''coversBlockBegin-3 [#_"LinearScan" this, #_"int" opId1, #_"int" opId2]
        (not= (LinearScan''blockForId-2 this, opId1) (LinearScan''blockForId-2 this, opId2))
    )

    ;;;
     ; Determines if an LIRInstruction destroys all caller saved registers.
     ;
     ; @param opId an instruction {@linkplain LIRInstruction#id id}
     ; @return true if the instruction denoted by {@code id} destroys all caller saved registers
     ;;
    (§ method! #_"boolean" LinearScan''hasCall-2 [#_"LinearScan" this, #_"int" opId]
        (LIRInstruction''destroysCallerSavedRegisters-1 (LinearScan''instructionForId-2 this, opId))
    )

    (§ method! #_"boolean" LinearScan''isProcessed-2 [#_"LinearScan" this, #_"Value" operand]
        (or (not (instance? RegisterValue operand)) (#_"RegisterAttributes" .isAllocatable (LinearScan''attributes-2 this, (#_"RegisterValue" .getRegister operand))))
    )

    ;; * Phase 5: actual register allocation

    (§ defn #_"Interval" LinearScan'addToList-3 [#_"Interval" first, #_"Interval" prev, #_"Interval" interval]
        (let [
            #_"Interval" newFirst first
        ]
            (if (some? prev)
                (§ ass! prev (assoc prev :next interval))
                (§ ass newFirst interval)
            )
            newFirst
        )
    )

    (§ method! #_"Pair<Interval, Interval>" LinearScan''createUnhandledLists-3 [#_"LinearScan" this, #_"IntervalPredicate" isList1, #_"IntervalPredicate" isList2]
        (let [
            [#_"Interval" list1 #_"Interval" list2 #_"Interval" prev1 #_"Interval" prev2]
                (loop-when [list1 (:intervalEndMarker this) list2 (:intervalEndMarker this) prev1 nil prev2 nil #_"int" i 0] (< i (count (:sortedIntervals this))) => [list1 list2 prev1 prev2]
                    (let [
                        #_"Interval" interval (nth (:sortedIntervals this) i)
                        [list1 list2 prev1 prev2]
                            (when (some? interval) => [list1 list2 prev1 prev2]
                                (cond
                                    (IntervalPredicate''apply-2 isList1, interval)
                                        [(LinearScan'addToList-3 list1, prev1, interval) list2 interval prev2]
                                    (or (nil? isList2) (IntervalPredicate''apply-2 isList2, interval))
                                        [list1 (LinearScan'addToList-3 list2, prev2, interval) prev1 interval]
                                    :else
                                        [list1 list2 prev1 prev2]
                                )
                            )
                    ]
                        (recur list1 list2 prev1 prev2 (inc i))
                    )
                )
        ]
            (when (some? prev1)
                (§ ass! prev1 (assoc prev1 :next (:intervalEndMarker this)))
            )
            (when (some? prev2)
                (§ ass! prev2 (assoc prev2 :next (:intervalEndMarker this)))
            )
            (Pair/create list1, list2)
        )
    )

    (§ method! #_"LinearScan" LinearScan''sortIntervalsBeforeAllocation-1 [#_"LinearScan" this]
        (let [
            #_"Interval[]" a (make-array Interval (count (filter some? (:intervals this))))
        ]
            ;; special sorting algorithm: the original interval list is almost sorted, only
            ;; some intervals are swapped, so this is much faster than a complete QuickSort
            (loop-when [#_"int" i 0 #_"int" fromMax -1 #_"ISeq" s (seq (filter some? (:intervals this)))] (some? s)
                (let [
                    #_"Interval" interval (first s)
                    #_"int" from (Interval''from-1 interval)
                    [i fromMax]
                        (if (<= fromMax from)
                            (do
                                (aset a i interval)
                                [(inc i) from]
                            )
                            ;; the assumption that the intervals are already sorted failed,
                            ;; so this interval must be sorted in manually
                            (do
                                (loop-when-recur [#_"int" j (dec i)] (and (<= 0 j) (< from (Interval''from-1 (nth a j)))) [(dec j)] => (aset a (inc j) interval)
                                    (aset a (inc j) (nth a j))
                                )
                                [(inc i) fromMax]
                            )
                        )
                ]
                    (recur i fromMax (next s))
                )
            )
            (assoc this :sortedIntervals a)
        )
    )

    (§ method! #_"LinearScan" LinearScan''sortIntervalsAfterAllocation-1 [#_"LinearScan" this]
        (when-not (= (:firstDerivedIntervalIndex this) -1) => this ;; no intervals have been added during allocation, so sorted list is already up to date
            (let [
                #_"Interval[]" oldList (:sortedIntervals this)
                #_"Interval[]" newList (Arrays/copyOfRange (:intervals this), (:firstDerivedIntervalIndex this), (:intervalsSize this))
                #_"int" oldLen (count oldList)
                #_"int" newLen (count newList)
            ]
                ;; conventional sort-algorithm for new intervals
                (Arrays/sort newList, (ß (Interval a, Interval b) -> (§ fun (- (Interval''from-1 a) (Interval''from-1 b)))))

                ;; merge old and new list (both already sorted) into one combined list
                (let [
                    #_"Interval[]" a (make-array Interval (+ oldLen newLen))
                ]
                    (loop-when [#_"int" oldIdx 0 #_"int" newIdx 0] (< (+ oldIdx newIdx) (count a))
                        (if (or (<= newLen newIdx) (and (< oldIdx oldLen) (<= (Interval''from-1 (nth oldList oldIdx)) (Interval''from-1 (nth newList newIdx)))))
                            (do
                                (aset a (+ oldIdx newIdx) (nth oldList oldIdx))
                                (recur (inc oldIdx) newIdx)
                            )
                            (do
                                (aset a (+ oldIdx newIdx) (nth newList newIdx))
                                (recur oldIdx (inc newIdx))
                            )
                        )
                    )
                    (assoc this :sortedIntervals a)
                )
            )
        )
    )

    ;; wrapper for Interval.splitChildAtOpId that performs a bailout in product mode instead of returning nil
    (§ method! #_"Interval" LinearScan''splitChildAtOpId-4 [#_"LinearScan" this, #_"Interval" interval, #_"int" opId, #_"OperandMode" mode]
        (or (Interval''getSplitChildAtOpId-4 interval, opId, mode, this)
            (throw! "linear scan: interval is nil")
        )
    )

    (§ defn #_"AllocatableValue" LinearScan'canonicalSpillOpr-1 [#_"Interval" interval]
        (Interval''spillSlot-1 interval)
    )

    (§ method! #_"boolean" LinearScan''isMaterialized-4 [#_"LinearScan" this, #_"AllocatableValue" operand, #_"int" opId, #_"OperandMode" mode]
        (let [
            #_"Interval" interval (LinearScan''intervalFor-2 this, operand)
            interval
                (when-not (= opId -1) => interval
                    ;; operands are not changed when an interval is split during allocation, so search the right interval here
                    (LinearScan''splitChildAtOpId-4 this, interval, opId, mode)
                )
        ]
            (and (= (:location interval) Value/ILLEGAL) (Interval''canMaterialize-1 interval))
        )
    )

    #_unused
    (§ method! #_"boolean" LinearScan''isCallerSave-2 [#_"LinearScan" this, #_"Value" operand]
        (#_"RegisterAttributes" .isCallerSave (LinearScan''attributes-2 this, (#_"RegisterValue" .getRegister operand)))
    )

    (§ method #_"void" LinearScan''allocate-3 [#_"LinearScan" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context]
        (LinearScanAllocationPhase''apply-3 (LinearScan''createLifetimeAnalysisPhase-1 this), lirGenRes, context)

        (§ ass! this (LinearScan''sortIntervalsBeforeAllocation-1 this))

        (LinearScanAllocationPhase''apply-3 (LinearScan''createRegisterAllocationPhase-1 this), lirGenRes, context)

        (when GraalOptions'lirOptLSRAOptimizeSpillPosition
            (LinearScanAllocationPhase''apply-3 (LinearScan''createOptimizeSpillPositionPhase-1 this), lirGenRes, context)
        )
        (LinearScanAllocationPhase''apply-3 (LinearScan''createResolveDataFlowPhase-1 this), lirGenRes, context)

        (§ ass! this (LinearScan''sortIntervalsAfterAllocation-1 this))

        (LinearScan''beforeSpillMoveElimination-1 this)
        (LinearScanAllocationPhase''apply-3 (LinearScan''createSpillMoveEliminationPhase-1 this), lirGenRes, context)
        (LinearScanAllocationPhase''apply-3 (LinearScan''createAssignLocationsPhase-1 this), lirGenRes, context)
        nil
    )

    (§ method #_"void" LinearScan''beforeSpillMoveElimination-1 [#_"LinearScan" this]
        nil
    )

    (§ method #_"LinearScanLifetimeAnalysisPhase" LinearScan''createLifetimeAnalysisPhase-1 [#_"LinearScan" this]
        (LinearScanLifetimeAnalysisPhase'new-1 this)
    )

    (§ method! #_"LinearScanRegisterAllocationPhase" LinearScan''createRegisterAllocationPhase-1 [#_"LinearScan" this]
        (LinearScanRegisterAllocationPhase'new-1 this)
    )

    (§ method! #_"LinearScanOptimizeSpillPositionPhase" LinearScan''createOptimizeSpillPositionPhase-1 [#_"LinearScan" this]
        (LinearScanOptimizeSpillPositionPhase'new-1 this)
    )

    (§ method #_"LinearScanResolveDataFlowPhase" LinearScan''createResolveDataFlowPhase-1 [#_"LinearScan" this]
        (LinearScanResolveDataFlowPhase'new-1 this)
    )

    (§ method #_"LinearScanEliminateSpillMovePhase" LinearScan''createSpillMoveEliminationPhase-1 [#_"LinearScan" this]
        (LinearScanEliminateSpillMovePhase'new-1 this)
    )

    (§ method! #_"LinearScanAssignLocationsPhase" LinearScan''createAssignLocationsPhase-1 [#_"LinearScan" this]
        (LinearScanAssignLocationsPhase'new-1 this)
    )

    (§ method #_"FrameMapBuilder" LinearScan''getFrameMapBuilder-1 [#_"LinearScan" this]
        (:frameMapBuilder this)
    )

    (§ method! #_"Block[]" LinearScan''sortedBlocks-1 [#_"LinearScan" this]
        (:sortedBlocks this)
    )

    (§ method #_"RegisterArray" LinearScan''getRegisters-1 [#_"LinearScan" this]
        (:registers this)
    )

    (§ method! #_"RegisterAllocationConfig" LinearScan''getRegisterAllocationConfig-1 [#_"LinearScan" this]
        (:regAllocConfig this)
    )

    (§ method! #_"boolean" LinearScan''callKillsRegisters-1 [#_"LinearScan" this]
        (#_"RegisterConfig" .areAllAllocatableRegistersCallerSaved HotSpot'registerConfig)
    )

    (§ method! #_"boolean" LinearScan''neverSpillConstants-1 [#_"LinearScan" this]
        (:neverSpillConstants this)
    )
)

;;;
 ; @anno LinearScan.BlockData
 ;;
(final-ns BlockData
    (§ defn #_"BlockData" BlockData'new-0 []
        (Object.)
    )

    ;;;
     ; Bit map specifying which operands are live upon entry to this block. These are values
     ; used in this block or any of its successors where such value are not defined in this
     ; block. The bit index of an operand is its {@linkplain LinearScan#operandNumber(Value)
     ; operand number}.
     ;;
    (§ mutable #_"BitSet" :liveIn nil)

    ;;;
     ; Bit map specifying which operands are live upon exit from this block. These are values
     ; used in a successor block that are either defined in this block or were live upon entry
     ; to this block. The bit index of an operand is its
     ; {@linkplain LinearScan#operandNumber(Value) operand number}.
     ;;
    (§ mutable #_"BitSet" :liveOut nil)

    ;;;
     ; Bit map specifying which operands are used (before being defined) in this block. That is,
     ; these are the values that are live upon entry to the block. The bit index of an operand
     ; is its {@linkplain LinearScan#operandNumber(Value) operand number}.
     ;;
    (§ mutable #_"BitSet" :liveGen nil)

    ;;;
     ; Bit map specifying which operands are defined/overwritten in this block. The bit index of
     ; an operand is its {@linkplain LinearScan#operandNumber(Value) operand number}.
     ;;
    (§ mutable #_"BitSet" :liveKill nil)
)

;;;
 ; @anno LinearScan.IntervalPredicate
 ;;
(class-ns IntervalPredicate
    (§ defn #_"IntervalPredicate" IntervalPredicate'new-0 []
        (Object.)
    )

    (§ abstract #_"boolean" IntervalPredicate''apply-2 [#_"IntervalPredicate" this, #_"Interval" i])
)

(class-ns LinearScanAllocationPhase
    (§ defn #_"LinearScanAllocationPhase" LinearScanAllocationPhase'new-0 []
        (Object.)
    )

    (§ abstract #_"void" LinearScanAllocationPhase''run-3 [#_"LinearScanAllocationPhase" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context])

    (§ method! #_"void" LinearScanAllocationPhase''apply-3 [#_"LinearScanAllocationPhase" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context]
        (LinearScanAllocationPhase''run-3 this, lirGenRes, context)
        nil
    )
)

;;;
 ; Phase 7: Assign register numbers back to LIR.
 ;;
(final-ns LinearScanAssignLocationsPhase (§ extends LinearScanAllocationPhase)
    (§ final #_"LinearScan" :allocator nil)

    (§ defn #_"LinearScanAssignLocationsPhase" LinearScanAssignLocationsPhase'new-1 [#_"LinearScan" allocator]
        (let [
            #_"LinearScanAssignLocationsPhase" this (LinearScanAllocationPhase'new-0)
            this (assoc this :allocator allocator)
        ]
            this
        )
    )

    ;;;
     ; Assigns the allocated location for an LIR instruction operand back into the instruction.
     ;
     ; @param op current LIRInstruction
     ; @param operand an LIR instruction operand
     ; @param mode the usage mode for {@code operand} by the instruction
     ; @return the location assigned for the operand
     ;;
    (§ method! #_"Value" LinearScanAssignLocationsPhase''colorLirOperand-4 [#_"LinearScanAssignLocationsPhase" this, #_"LIRInstruction" op, #_"Variable" operand, #_"OperandMode" mode]
        (let [
            #_"int" opId (LIRInstruction''id-1 op)
            #_"Interval" interval (LinearScan''intervalFor-2 (:allocator this), operand)
            interval
                (when-not (= opId -1) => interval
                    ;; operands are not changed when an interval is split during allocation, so search the right interval here
                    (LinearScan''splitChildAtOpId-4 (:allocator this), interval, opId, mode)
                )
        ]
            (when (and (= (:location interval) Value/ILLEGAL) (Interval''canMaterialize-1 interval)) => (:location interval)
                (ConstantValue'new-2 (:kind interval), (Interval''getMaterializedValue-1 interval))
            )
        )
    )

    ;;;
     ; Assigns the operand of an LIRInstruction.
     ;
     ; @param op The LIRInstruction that should be colored.
     ; @return true if the instruction should be deleted
     ;;
    (§ method! #_"boolean" LinearScanAssignLocationsPhase''assignLocations-2 [#_"LinearScanAssignLocationsPhase" this, #_"LIRInstruction" op]
        (or
            ;; remove useless moves
            (when (LIRInstruction''isMoveOp-1 op)
                (let [
                    #_"AllocatableValue" result (MoveOp''getResult-1 op)
                ]
                    (when (and (instance? Variable result) (LinearScan''isMaterialized-4 (:allocator this), result, (LIRInstruction''id-1 op), OperandMode'DEF))
                        ;; It happens when a materializable interval is originally not spilled, but kicked out in LinearScanWalker.splitForSpilling().
                        ;; When kicking out such an interval, this move operation has already been generated.
                        true
                    )
                )
            )

            (let [
                #_"LinearScanAssignLocationsPhase" phase this
                #_"InstructionValueProcedure" assignProc
                    (§ reify #_"InstructionValueProcedure" (InstructionValueProcedure'reify-0)
                        (§ override! #_"Value" InstructionValueProcedure''doValue-5 [#_"InstructionValueProcedure" this, #_"LIRInstruction" instruction, #_"Value" value, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags]
                            (when (instance? Variable value) => value
                                (LinearScanAssignLocationsPhase''colorLirOperand-4 phase, instruction, value, mode)
                            )
                        )
                    )
            ]
                (LIRInstruction''forEachInput-2 op, assignProc)
                (LIRInstruction''forEachAlive-2 op, assignProc)
                (LIRInstruction''forEachTemp-2 op, assignProc)
                (LIRInstruction''forEachOutput-2 op, assignProc)

                ;; remove useless moves
                (and (LIRInstruction''isValueMoveOp-1 op) (= (ValueMoveOp''getInput-1 op) (MoveOp''getResult-1 op)))
            )
        )
    )

    (§ method- #_"void" LinearScanAssignLocationsPhase''assignLocations-2 [#_"LinearScanAssignLocationsPhase" this, #_"List<LIRInstruction>" ops]
        (let [
            #_"boolean" hasDead
                (loop-when [hasDead false #_"int" i 0] (< i (count ops)) => hasDead
                    (let [
                        #_"LIRInstruction" op (nth ops i)
                        hasDead
                            (cond
                                (nil? op)
                                (do
                                    ;; this can happen when spill-moves are removed in eliminateSpillMoves
                                    true
                                )
                                (LinearScanAssignLocationsPhase''assignLocations-2 this, op)
                                (do
                                    (#_"ArrayList" .set ops, i, nil)
                                    true
                                )
                                :else
                                    hasDead
                            )
                    ]
                        (recur hasDead (inc i))
                    )
                )
        ]
            (when hasDead
                ;; Remove nil values from the list.
                (#_"ArrayList" .removeAll ops, (Collections/singleton nil))
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" LinearScanAssignLocationsPhase''run-3 [#_"LinearScanAssignLocationsPhase" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context]
        (doseq [#_"Block" block (LinearScan''sortedBlocks-1 (:allocator this))]
            (LinearScanAssignLocationsPhase''assignLocations-2 this, (LIR''getLIRforBlock-2 (:lir (:allocator this)), block))
        )
        nil
    )
)

(class-ns LinearScanEliminateSpillMovePhase (§ extends LinearScanAllocationPhase)
    (§ def- #_"IntervalPredicate" LinearScanEliminateSpillMovePhase'mustStoreAtDefinition
        (§ reify #_"IntervalPredicate" (IntervalPredicate'new-0)
            (§ override! #_"boolean" IntervalPredicate''apply-2 [#_"IntervalPredicate" this, #_"Interval" i]
                (and (Interval''isSplitParent-1 i) (= (Interval''spillState-1 i) SpillState'StoreAtDefinition))
            )
        )
    )

    (§ final #_"LinearScan" :allocator nil)

    (§ defn #_"LinearScanEliminateSpillMovePhase" LinearScanEliminateSpillMovePhase'new-1 [#_"LinearScan" allocator]
        (let [
            #_"LinearScanEliminateSpillMovePhase" this (LinearScanAllocationPhase'new-0)
            this (assoc this :allocator allocator)
        ]
            this
        )
    )

    ;;;
     ; @return the index of the first instruction that is of interest for #eliminateSpillMoves
     ;;
    (§ method #_"int" LinearScanEliminateSpillMovePhase''firstInstructionOfInterest-1 [#_"LinearScanEliminateSpillMovePhase" this]
        ;; skip the first because it is always a label
        1
    )

    ;;;
     ; @param block The block {@code move} is located in.
     ; @param move Spill move.
     ;;
    (§ method #_"boolean" LinearScanEliminateSpillMovePhase''canEliminateSpillMove-3 [#_"LinearScanEliminateSpillMovePhase" this, #_"Block" block, #_"MoveOp" move]
        (let [
            #_"Interval" interval (LinearScan''intervalFor-2 (:allocator this), (MoveOp''getResult-1 move))
        ]
            (and (not (instance? RegisterValue (:location interval))) (Interval''alwaysInMemory-1 interval))
        )
    )

    ;; Called once before assignment of register numbers.
    (§ method! #_"void" LinearScanEliminateSpillMovePhase''eliminateSpillMoves-2 [#_"LinearScanEliminateSpillMovePhase" this, #_"LIRGenerationResult" res]
        ;; Collect all intervals that must be stored after their definition. The list is sorted by Interval.spillDefinitionPos.
        (let [
            #_"LIRInsertionBuffer" buffer (LIRInsertionBuffer'new-0)
        ]
            (loop-when [#_"Interval" interval (#_"Pair" .getLeft (LinearScan''createUnhandledLists-3 (:allocator this), LinearScanEliminateSpillMovePhase'mustStoreAtDefinition, nil)) #_"ISeq" s (seq (LinearScan''sortedBlocks-1 (:allocator this)))] (some? s)
                (let [
                    #_"Block" block (first s)
                    #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)
                    ;; Iterate all instructions of the block.
                    interval
                        (loop-when [interval interval #_"int" i (LinearScanEliminateSpillMovePhase''firstInstructionOfInterest-1 this)] (< i (count ops)) => interval
                            (let [
                                #_"LIRInstruction" op (nth ops i)
                                #_"int" opId (LIRInstruction''id-1 op)
                                interval
                                    (if (= opId -1)
                                        (do
                                            ;; Remove move from register to stack if the stack slot is guaranteed to be correct.
                                            ;; Only moves that have been inserted by LinearScan can be removed.
                                            (when (and GraalOptions'lirOptLSRAEliminateSpillMoves (LinearScanEliminateSpillMovePhase''canEliminateSpillMove-3 this, block, op))
                                                ;; Move target is a stack slot that is always correct, so eliminate instruction.
                                                ;; nil-instructions are deleted by assignRegNum
                                                (#_"ArrayList" .set ops, i, nil)
                                            )
                                            interval
                                        )
                                        ;; Insert move from register to stack just after the beginning of the interval.
                                        (loop-when interval (and (not (Interval''isEndMarker-1 interval)) (= (Interval''spillDefinitionPos-1 interval) opId)) => interval
                                            (when-not (Interval''canMaterialize-1 interval)
                                                (when-not (LIRInsertionBuffer''initialized-1 buffer)
                                                    ;; prepare insertion buffer (appended when all instructions in the block are processed)
                                                    (§ ass! buffer (LIRInsertionBuffer''init-2 buffer, ops))
                                                )
                                                (let [
                                                    #_"AllocatableValue" fromLocation (:location interval)
                                                    #_"AllocatableValue" toLocation (LinearScan'canonicalSpillOpr-1 interval)
                                                ]
                                                    (when-not (= fromLocation toLocation)
                                                        (§ ass! buffer (LIRInsertionBuffer''append-3 buffer, (inc i), (MoveFactory''createMove-3 (:moveFactory (:allocator this)), toLocation, fromLocation)))
                                                    )
                                                )
                                            )
                                            (recur (:next interval))
                                        )
                                    )
                            ]
                                (recur interval (inc i))
                            )
                        )
                ]
                    (when (LIRInsertionBuffer''initialized-1 buffer)
                        (§ ass! buffer (LIRInsertionBuffer''finish-1 buffer))
                    )
                    (recur interval (next s))
                )
            )
        )
        nil
    )

    #_unused
    (§ override #_"void" LinearScanEliminateSpillMovePhase''run-3 [#_"LinearScanEliminateSpillMovePhase" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context]
        (LinearScanEliminateSpillMovePhase''eliminateSpillMoves-2 this, lirGenRes)
        nil
    )
)

(class-ns LinearScanLifetimeAnalysisPhase (§ extends LinearScanAllocationPhase)
    (§ final #_"LinearScan" :allocator nil)
    ;;;
     ; Bit set for each variable that is contained in each loop.
     ;;
    (§ mutable #_"BitMap2D" :intervalInLoop nil)

    (§ defn #_"LinearScanLifetimeAnalysisPhase" LinearScanLifetimeAnalysisPhase'new-1 [#_"LinearScan" linearScan]
        (let [
            #_"LinearScanLifetimeAnalysisPhase" this (LinearScanAllocationPhase'new-0)
            this (assoc this :allocator linearScan)
        ]
            this
        )
    )

    (§ method! #_"boolean" LinearScanLifetimeAnalysisPhase''isIntervalInLoop-3 [#_"LinearScanLifetimeAnalysisPhase" this, #_"int" interval, #_"int" loop]
        (BitMap2D''at-3 (:intervalInLoop this), interval, loop)
    )

    ;;;
     ; Numbers all instructions in all blocks. The numbering follows the linear scan order.
     ;;
    (§ method! #_"void" LinearScanLifetimeAnalysisPhase''numberInstructions-1 [#_"LinearScanLifetimeAnalysisPhase" this]
        (§ ass! (:allocator this) (LinearScan''initIntervals-1 (:allocator this)))

        (let [
            #_"ValueConsumer" setVariableConsumer (ß (value, mode, flags) ->
                (§ fun
                    (when (instance? Variable value)
                        (LinearScan''getOrCreateInterval-2 (:allocator this), value)
                    )
                )
            )
            ;; Assign IDs to LIR nodes and build a mapping, lirOps, from ID to LIRInstruction node.
            #_"int" n
                (loop-when-recur [n 0 #_"ISeq" s (seq (LinearScan''sortedBlocks-1 (:allocator this)))]
                                 (some? s)
                                 [(+ n (count (LIR''getLIRforBlock-2 (:lir (:allocator this)), (first s)))) (next s)]
                              => n
                )
        ]
            ;; initialize with correct length
            (§ ass! (:allocator this) (LinearScan''initOpIdMaps-2 (:allocator this), n))

            (loop-when [#_"int" opId 0 #_"int" index 0 #_"ISeq" s (seq (LinearScan''sortedBlocks-1 (:allocator this)))] (some? s)
                (let [
                    #_"Block" block (first s)
                ]
                    (LinearScan''initBlockData-2 (:allocator this), block)

                    (let [
                        #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)
                        [opId index]
                            (loop-when [opId opId index index #_"int" i 0] (< i (count ops)) => [opId index]
                                (let [
                                    #_"LIRInstruction" op (nth ops i)
                                ]
                                    (§ ass! op (LIRInstruction''setId-2 op, opId))

                                    (LinearScan''putOpIdMaps-4 (:allocator this), index, op, block)

                                    (LIRInstruction''visitEachTemp-2 op, setVariableConsumer)
                                    (LIRInstruction''visitEachOutput-2 op, setVariableConsumer)

                                    ;; numbering of lirOps by two
                                    (recur (+ opId 2) (inc index) (inc i))
                                )
                            )
                    ]
                        (recur opId index (next s))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Computes local live sets (i.e. BlockData#liveGen and BlockData#liveKill) separately for each block.
     ;;
    (§ method! #_"LinearScanLifetimeAnalysisPhase" LinearScanLifetimeAnalysisPhase''computeLocalLiveSets-1 [#_"LinearScanLifetimeAnalysisPhase" this]
        (let [
            #_"int" liveSize (LinearScan''liveSetSize-1 (:allocator this))
            this (assoc this :intervalInLoop (BitMap2D'new-2 (LinearScan''operandSize-1 (:allocator this)), (LinearScan''numLoops-1 (:allocator this))))
            #_"BitSet" liveGenScratch (BitSet. liveSize)
            #_"BitSet" liveKillScratch (BitSet. liveSize)
        ]
            ;; iterate all blocks
            (loop-when-recur [#_"ISeq" s (seq (LinearScan''sortedBlocks-1 (:allocator this)))] (some? s) [(next s)]
                (let [
                    #_"Block" block (first s)
                ]
                    (#_"BitSet" .clear liveGenScratch)
                    (#_"BitSet" .clear liveKillScratch)

                    (let [
                        #_"ValueConsumer" useConsumer (ß (operand, mode, flags) ->
                            (§ fun
                                (when (instance? Variable operand)
                                    (let [
                                        #_"int" operandNum (LinearScan''operandNumber-2 (:allocator this), operand)
                                    ]
                                        (when-not (nth liveKillScratch operandNum)
                                            (#_"BitSet" .set liveGenScratch, operandNum)
                                        )
                                        (when (some? (:loop block))
                                            (BitMap2D''setBit-3 (:intervalInLoop this), operandNum, (:index (:loop block)))
                                        )
                                    )
                                )
                            )
                        )
                        #_"ValueConsumer" defConsumer (ß (operand, mode, flags) ->
                            (§ fun
                                (when (instance? Variable operand)
                                    (let [
                                        #_"int" varNum (LinearScan''operandNumber-2 (:allocator this), operand)
                                    ]
                                        (#_"BitSet" .set liveKillScratch, varNum)
                                        (when (some? (:loop block))
                                            (BitMap2D''setBit-3 (:intervalInLoop this), varNum, (:index (:loop block)))
                                        )
                                    )
                                )
                            )
                        )
                    ]
                        ;; iterate all instructions of the block
                        (doseq [#_"LIRInstruction" op (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)]
                            (LIRInstruction''visitEachInput-2 op, useConsumer)
                            (LIRInstruction''visitEachAlive-2 op, useConsumer)

                            (LIRInstruction''visitEachTemp-2 op, defConsumer)
                            (LIRInstruction''visitEachOutput-2 op, defConsumer)
                        )

                        (let [
                            #_"BlockData" blockSets (LinearScan''getBlockData-2 (:allocator this), block)
                        ]
                            (§ ass! blockSets (assoc blockSets :liveGen (LinearScanLifetimeAnalysisPhase'trimClone-1 liveGenScratch)))
                            (§ ass! blockSets (assoc blockSets :liveKill (LinearScanLifetimeAnalysisPhase'trimClone-1 liveKillScratch)))
                            ;; sticky size, will get non-sticky in computeGlobalLiveSets
                            (§ ass! blockSets (assoc blockSets :liveIn (BitSet. 0)))
                            (§ ass! blockSets (assoc blockSets :liveOut (BitSet. 0)))
                        )
                    )
                )
            )
            this
        )
    )

    ;;;
     ; Performs a backward dataflow analysis to compute global live sets (i.e. BlockData#liveIn and BlockData#liveOut) for each block.
     ;;
    (§ method! #_"void" LinearScanLifetimeAnalysisPhase''computeGlobalLiveSets-1 [#_"LinearScanLifetimeAnalysisPhase" this]
        (let [
            #_"int" numBlocks (LinearScan''blockCount-1 (:allocator this))
            #_"BitSet" scratch (BitSet. (LinearScan''liveSetSize-1 (:allocator this))) ;; scratch set for calculations
        ]
            ;; Perform a backward dataflow analysis to compute liveOut and liveIn for each block.
            ;; The loop is executed until a fixpoint is reached (no changes in an iteration).
            (loop [#_"int" iteration 0]
                (let [
                    ;; iterate all blocks in reverse order
                    #_"boolean" changed?
                        (loop-when [changed? false #_"int" i (dec numBlocks)] (<= 0 i) => changed?
                            (let [
                                #_"Block" block (LinearScan''blockAt-2 (:allocator this), i)
                                #_"BlockData" blockSets (LinearScan''getBlockData-2 (:allocator this), block)
                                [#_"boolean" blockChanged changed?]
                                    (when (pos? (count (:successors block))) => [false changed?]
                                        (#_"BitSet" .clear scratch)
                                        (doseq [#_"Block" successor (:successors block)]
                                            (#_"BitSet" .or scratch, (:liveIn (LinearScan''getBlockData-2 (:allocator this), successor)))
                                        )
                                        ;; liveOut(block) is the union of liveIn(sux), for successors sux of block
                                        (when-not (= (:liveOut blockSets) scratch) => [false changed?]
                                            (§ ass! blockSets (assoc blockSets :liveOut (LinearScanLifetimeAnalysisPhase'trimClone-1 scratch)))
                                            [true true]
                                        )
                                    )
                            ]
                                (when (or (zero? iteration) blockChanged)
                                    ;; liveIn(block) is the union of liveGen(block) with (liveOut(block) & !liveKill(block))
                                    ;;
                                    ;; Note: liveIn has to be computed only in first iteration or if liveOut has changed!
                                    ;; Note: liveIn set can only grow, never shrink. No need to clear it.
                                    (let [
                                        #_"BitSet" liveIn (:liveIn blockSets)
                                    ]
                                        ;; BitSet#or will call BitSet#ensureSize (since the bit set is of length 0 initially)
                                        ;; and set sticky to false
                                        (#_"BitSet" .or liveIn, (:liveOut blockSets))
                                        (#_"BitSet" .andNot liveIn, (:liveKill blockSets))
                                        (#_"BitSet" .or liveIn, (:liveGen blockSets))

                                        (#_"Object" .clone liveIn) ;; trimToSize()
                                    )
                                )
                                (recur changed? (dec i))
                            )
                        )
                ]
                    (when (and changed? (<= 50 iteration))
                        ;; Very unlikely, should never happen, though when happens, we cannot guarantee it won't happen again.
                        (throw! "too many iterations in computeGlobalLiveSets")
                    )
                    (recur-if changed? [(inc iteration)])
                )
            )

            ;; check that the liveIn set of the first block is empty
            (let [
                #_"Block" startBlock (ControlFlowGraph''getStartBlock-1 (:cfg (:lir (:allocator this))))
            ]
                (when-not (zero? (#_"BitSet" .cardinality (:liveIn (LinearScan''getBlockData-2 (:allocator this), startBlock))))
                    ;; bailout if this occurs in product mode.
                    (throw! (str "liveIn set of first block must be empty: " (:liveIn (LinearScan''getBlockData-2 (:allocator this), startBlock))))
                )
            )
        )
        nil
    )

    ;;;
     ; Creates a trimmed copy a bit set.
     ;
     ; BitSet#clone() cannot be used since it will not {@linkplain BitSet#trimToSize trim}
     ; the array if the bit set is {@linkplain BitSet#sizeIsSticky sticky}.
     ;;
    (§ defn- #_"BitSet" LinearScanLifetimeAnalysisPhase'trimClone-1 [#_"BitSet" set]
        (let [
            #_"BitSet" trimmedSet (BitSet. 0) ;; zero-length words array, sticky
        ]
            (#_"BitSet" .or trimmedSet, set) ;; words size ensured to be words-in-use of set, also makes it non-sticky
            trimmedSet
        )
    )

    (§ method #_"void" LinearScanLifetimeAnalysisPhase''addUse-6 [#_"LinearScanLifetimeAnalysisPhase" this, #_"AllocatableValue" operand, #_"int" from, #_"int" to, #_"RegisterPriority" registerPriority, #_"ValueKind" kind]
        (when (LinearScan''isProcessed-2 (:allocator this), operand)
            (let [
                #_"Interval" interval (LinearScan''getOrCreateInterval-2 (:allocator this), operand)
            ]
                (when-not (= kind LIRKind'Illegal)
                    (§ ass! interval (Interval''setKind-2 interval, kind))
                )
                (§ ass! interval (Interval''addRange-3 interval, from, to))
                ;; Register use position at even instruction id.
                (Interval''addUsePos-3 interval, (& to (bit-not 1)), registerPriority)
            )
        )
        nil
    )

    (§ method! #_"void" LinearScanLifetimeAnalysisPhase''addTemp-5 [#_"LinearScanLifetimeAnalysisPhase" this, #_"AllocatableValue" operand, #_"int" tempPos, #_"RegisterPriority" registerPriority, #_"ValueKind" kind]
        (when (LinearScan''isProcessed-2 (:allocator this), operand)
            (let [
                #_"Interval" interval (LinearScan''getOrCreateInterval-2 (:allocator this), operand)
            ]
                (when-not (= kind LIRKind'Illegal)
                    (§ ass! interval (Interval''setKind-2 interval, kind))
                )
                (§ ass! interval (Interval''addRange-3 interval, tempPos, (inc tempPos)))
                (Interval''addUsePos-3 interval, tempPos, registerPriority)
                (§ ass! interval (Interval''addMaterializationValue-2 interval, nil))
            )
        )
        nil
    )

    ;;;
     ; Returns a value for a interval definition, which can be used for re-materialization.
     ;
     ; @param op An instruction which defines a value
     ; @param operand The destination operand of the instruction
     ; @param interval The interval for this defined value.
     ; @return the value which is moved to the instruction and which can be reused at all
     ;         reload-locations in case the interval of this instruction is spilled.
     ;         Currently this can only be a JavaConstant.
     ;;
    (§ method #_"Constant" LinearScanLifetimeAnalysisPhase''getMaterializedValue-4 [#_"LinearScanLifetimeAnalysisPhase" this, #_"LIRInstruction" op, #_"Value" operand, #_"Interval" interval]
        (when (LIRInstruction''isLoadConstantOp-1 op)
            (when-not (LinearScan''neverSpillConstants-1 (:allocator this)) => (LoadConstantOp''getConstant-1 op)
                ;; Check if the interval has any uses which would accept an stack location (priority == ShouldHaveRegister).
                ;; Rematerialization of such intervals can result in a degradation, because rematerialization always inserts
                ;; a constant load, even if the value is not needed in a register.
                (loop-when [#_"int" i 0] (< i (UsePosList''size-1 (:usePosList interval))) => (LoadConstantOp''getConstant-1 op)
                    (when-not (= (UsePosList''registerPriority-2 (:usePosList interval), i) RegisterPriority'ShouldHaveRegister)
                        (recur (inc i))
                    )
                )
            )
        )
    )

    ;;;
     ; Eliminates moves from register to stack if the stack slot is known to be correct.
     ;;
    (§ method! #_"void" LinearScanLifetimeAnalysisPhase''changeSpillDefinitionPos-5 [#_"LinearScanLifetimeAnalysisPhase" this, #_"LIRInstruction" op, #_"AllocatableValue" operand, #_"Interval" interval, #_"int" defPos]
        (condp = (Interval''spillState-1 interval)
            SpillState'NoDefinitionFound
                (do
                    (Interval''setSpillDefinitionPos-2 interval, defPos)
                    (Interval''setSpillState-2 interval, SpillState'NoSpillStore)
                )
            SpillState'NoSpillStore
                (when (< defPos (- (Interval''spillDefinitionPos-1 interval) 2))
                    ;; second definition found, so no spill optimization possible for this interval
                    (Interval''setSpillState-2 interval, SpillState'NoOptimization)
                    ;; else: two consecutive definitions (because of two-operand LIR form)
                )
            nil
        )
        nil
    )

    (§ method #_"void" LinearScanLifetimeAnalysisPhase''addDef-5 [#_"LinearScanLifetimeAnalysisPhase" this, #_"AllocatableValue" operand, #_"LIRInstruction" op, #_"RegisterPriority" registerPriority, #_"ValueKind" kind]
        (when (LinearScan''isProcessed-2 (:allocator this), operand)
            (let [
                #_"int" defPos (LIRInstruction''id-1 op)
                #_"Interval" interval (LinearScan''getOrCreateInterval-2 (:allocator this), operand)
            ]
                (when-not (= kind LIRKind'Illegal)
                    (§ ass! interval (Interval''setKind-2 interval, kind))
                )
                (let [
                    #_"Range" r (:first interval)
                ]
                    (if (<= (:from r) defPos)
                        (do
                            ;; Update the starting point (when a range is first created for a use, its start is the
                            ;; beginning of the current block until a def is encountered).
                            (§ ass r (assoc r :from defPos))
                            (Interval''addUsePos-3 interval, defPos, registerPriority)
                        )
                        (do
                            ;; dead value - make vacuous interval also add register priority for dead intervals
                            (§ ass! interval (Interval''addRange-3 interval, defPos, (inc defPos)))
                            (Interval''addUsePos-3 interval, defPos, registerPriority)
                        )
                    )

                    (LinearScanLifetimeAnalysisPhase''changeSpillDefinitionPos-5 this, op, operand, interval, defPos)
                    (when (and (= registerPriority RegisterPriority'None) (<= (SpillState''ordinal-1 (Interval''spillState-1 interval)) (SpillState''ordinal-1 SpillState'StartInMemory)) (instance? StackSlot operand))
                        ;; detection of method-parameters and roundfp-results
                        (Interval''setSpillState-2 interval, SpillState'StartInMemory)
                    )
                    (§ ass! interval (Interval''addMaterializationValue-2 interval, (LinearScanLifetimeAnalysisPhase''getMaterializedValue-4 this, op, operand, interval)))
                )
            )
        )
        nil
    )

    (§ method #_"void" LinearScanLifetimeAnalysisPhase''addRegisterHint-6 [#_"LinearScanLifetimeAnalysisPhase" this, #_"LIRInstruction" op, #_"Value" targetValue, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags, #_"boolean" hintAtDef]
        (when (and (#_"EnumSet" .contains flags, OperandFlag'HINT) (LinearScan'isVariableOrRegister-1 targetValue))
            (LIRInstruction''forEachRegisterHint-4 op, targetValue, mode, (ß (registerHint, valueMode, valueFlags) ->
                (§ fun
                    (when (LinearScan'isVariableOrRegister-1 registerHint)
                        (let [
                            #_"Interval" from (LinearScan''getOrCreateInterval-2 (:allocator this), registerHint)
                            #_"Interval" to (LinearScan''getOrCreateInterval-2 (:allocator this), targetValue)
                        ]
                            ;; hints always point from def to use
                            (if hintAtDef
                                (§ ass! to (Interval''setLocationHint-2 to, from))
                                (§ ass! from (Interval''setLocationHint-2 from, to))
                            )

                            registerHint
                        )
                    )
                ))
            )
        )
        nil
    )

    (§ defn- #_"boolean" LinearScanLifetimeAnalysisPhase'optimizeMethodArgument-1 [#_"Value" value]
        ;; Object method arguments that are passed on the stack are currently not optimized because
        ;; this requires that the runtime visits method arguments during stack walking.
        (and (instance? StackSlot value) (#_"StackSlot" .isInCallerFrame value) (LIRKind'isValue-1 value))
    )

    ;;;
     ; Determines the register priority for an instruction's output/result operand.
     ;;
    (§ method #_"RegisterPriority" LinearScanLifetimeAnalysisPhase''registerPriorityOfOutputOperand-2 [#_"LinearScanLifetimeAnalysisPhase" this, #_"LIRInstruction" op]
        (if (and (LIRInstruction''isValueMoveOp-1 op) (LinearScanLifetimeAnalysisPhase'optimizeMethodArgument-1 (ValueMoveOp''getInput-1 op)))
            RegisterPriority'None
            ;; all other operands require a register
            RegisterPriority'MustHaveRegister
        )
    )

    ;;;
     ; Determines the priority which with an instruction's input operand will be allocated a register.
     ;;
    (§ defn #_"RegisterPriority" LinearScanLifetimeAnalysisPhase'registerPriorityOfInputOperand-1 [#_"EnumSet<OperandFlag>" flags]
        (if (#_"EnumSet" .contains flags, OperandFlag'STACK)
            RegisterPriority'ShouldHaveRegister
            ;; all other operands require a register
            RegisterPriority'MustHaveRegister
        )
    )

    ;;;
     ; Optimizes moves related to incoming stack based arguments. The interval for the destination
     ; of such moves is assigned the stack slot (which is in the caller's frame) as its spill slot.
     ;;
    (§ method! #_"void" LinearScanLifetimeAnalysisPhase''handleMethodArguments-2 [#_"LinearScanLifetimeAnalysisPhase" this, #_"LIRInstruction" op]
        (when (and (LIRInstruction''isValueMoveOp-1 op) (LinearScanLifetimeAnalysisPhase'optimizeMethodArgument-1 (ValueMoveOp''getInput-1 op)))
            (let [
                #_"StackSlot" slot (ValueMoveOp''getInput-1 op)
                #_"Interval" interval (LinearScan''intervalFor-2 (:allocator this), (MoveOp''getResult-1 op))
            ]
                (Interval''setSpillSlot-2 interval, slot)
                (§ ass! interval (Interval''assignLocation-2 interval, slot))
            )
        )
        nil
    )

    (§ method #_"void" LinearScanLifetimeAnalysisPhase''buildIntervals-1 [#_"LinearScanLifetimeAnalysisPhase" this]
        (let [
            #_"InstructionValueConsumer" outputConsumer (ß (op, operand, mode, flags) ->
                (§ fun
                    (when (LinearScan'isVariableOrRegister-1 operand)
                        (LinearScanLifetimeAnalysisPhase''addDef-5 this, operand, op, (LinearScanLifetimeAnalysisPhase''registerPriorityOfOutputOperand-2 this, op), (#_"Value" .getValueKind operand))
                        (LinearScanLifetimeAnalysisPhase''addRegisterHint-6 this, op, operand, mode, flags, true)
                    )
                )
            )
            #_"InstructionValueConsumer" tempConsumer (ß (op, operand, mode, flags) ->
                (§ fun
                    (when (LinearScan'isVariableOrRegister-1 operand)
                        (LinearScanLifetimeAnalysisPhase''addTemp-5 this, operand, (LIRInstruction''id-1 op), RegisterPriority'MustHaveRegister, (#_"Value" .getValueKind operand))
                        (LinearScanLifetimeAnalysisPhase''addRegisterHint-6 this, op, operand, mode, flags, false)
                    )
                )
            )
            #_"InstructionValueConsumer" aliveConsumer (ß (op, operand, mode, flags) ->
                (§ fun
                    (when (LinearScan'isVariableOrRegister-1 operand)
                        (let [
                            #_"RegisterPriority" p (LinearScanLifetimeAnalysisPhase'registerPriorityOfInputOperand-1 flags)
                            #_"int" opId (LIRInstruction''id-1 op)
                            #_"int" blockFrom (LinearScan''getFirstLirInstructionId-2 (:allocator this), (LinearScan''blockForId-2 (:allocator this), opId))
                        ]
                            (LinearScanLifetimeAnalysisPhase''addUse-6 this, operand, blockFrom, (inc opId), p, (#_"Value" .getValueKind operand))
                            (LinearScanLifetimeAnalysisPhase''addRegisterHint-6 this, op, operand, mode, flags, false)
                        )
                    )
                )
            )
            #_"InstructionValueConsumer" inputConsumer (ß (op, operand, mode, flags) ->
                (§ fun
                    (when (LinearScan'isVariableOrRegister-1 operand)
                        (let [
                            #_"int" opId (LIRInstruction''id-1 op)
                            #_"int" blockFrom (LinearScan''getFirstLirInstructionId-2 (:allocator this), (LinearScan''blockForId-2 (:allocator this), opId))
                            #_"RegisterPriority" p (LinearScanLifetimeAnalysisPhase'registerPriorityOfInputOperand-1 flags)
                        ]
                            (LinearScanLifetimeAnalysisPhase''addUse-6 this, operand, blockFrom, opId, p, (#_"Value" .getValueKind operand))
                            (LinearScanLifetimeAnalysisPhase''addRegisterHint-6 this, op, operand, mode, flags, false)
                        )
                    )
                )
            )
            ;; create a list with all caller-save registers
            #_"RegisterArray" callerSaveRegs (#_"RegisterConfig" .getCallerSaveRegisters HotSpot'registerConfig)
        ]
            ;; iterate all blocks in reverse order
            (loop-when-recur [#_"int" i (dec (LinearScan''blockCount-1 (:allocator this)))] (<= 0 i) [(dec i)]
                (let [
                    #_"Block" block (LinearScan''blockAt-2 (:allocator this), i)
                    #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)
                    #_"int" blockFrom (LinearScan''getFirstLirInstructionId-2 (:allocator this), block)
                    #_"int" blockTo (LinearScan''getLastLirInstructionId-2 (:allocator this), block)
                    ;; update intervals for operands live at the end of this block
                    #_"BitSet" live (:liveOut (LinearScan''getBlockData-2 (:allocator this), block))
                ]
                    (loop-when-recur [#_"int" operandNum (#_"BitSet" .nextSetBit live, 0)] (<= 0 operandNum) [(#_"BitSet" .nextSetBit live, (inc operandNum))]
                        (let [
                            #_"AllocatableValue" operand (:operand (LinearScan''intervalFor-2 (:allocator this), operandNum))
                        ]
                            (LinearScanLifetimeAnalysisPhase''addUse-6 this, operand, blockFrom, (+ blockTo 2), RegisterPriority'None, LIRKind'Illegal)

                            ;; Add special use positions for loop-end blocks when the interval is used anywhere inside this loop.
                            ;; It's possible that the block was part of a non-natural loop, so it might have an invalid loop index.
                            (when (and (Block''isLoopEnd-1 block) (some? (:loop block)) (LinearScanLifetimeAnalysisPhase''isIntervalInLoop-3 this, operandNum, (:index (:loop block))))
                                (Interval''addUsePos-3 (LinearScan''intervalFor-2 (:allocator this), operandNum), (inc blockTo), RegisterPriority'LiveAtLoopEnd)
                            )
                        )
                    )

                    ;; Iterate all instructions of the block in reverse order. Definitions of intervals are processed before uses.
                    (loop-when-recur [#_"int" j (dec (count ops))] (<= 0 j) [(dec j)]
                        (let [
                            #_"LIRInstruction" op (nth ops j)
                            #_"int" opId (LIRInstruction''id-1 op)
                        ]
                            ;; Add a temp range for each register if operation destroys caller-save registers.
                            (when (LIRInstruction''destroysCallerSavedRegisters-1 op)
                                (doseq [#_"Register" r callerSaveRegs]
                                    (when (#_"RegisterAttributes" .isAllocatable (LinearScan''attributes-2 (:allocator this), r))
                                        (LinearScanLifetimeAnalysisPhase''addTemp-5 this, (#_"Register" .asValue r), opId, RegisterPriority'None, LIRKind'Illegal)
                                    )
                                )
                            )

                            (LIRInstruction''visitEachOutput-2 op, outputConsumer)
                            (LIRInstruction''visitEachTemp-2 op, tempConsumer)
                            (LIRInstruction''visitEachAlive-2 op, aliveConsumer)
                            (LIRInstruction''visitEachInput-2 op, inputConsumer)

                            ;; special steps for some instructions (especially moves)
                            (LinearScanLifetimeAnalysisPhase''handleMethodArguments-2 this, op)
                        )
                    )
                )
            )

            ;; Add the range [0, 1] to all fixed intervals. The register allocator need not handle unhandled fixed intervals.
            (doseq [#_"Interval" interval (:intervals (:allocator this))]
                (when (and (some? interval) (instance? RegisterValue (:operand interval)))
                    (§ ass! interval (Interval''addRange-3 interval, 0, 1))
                )
            )
        )
        nil
    )

    #_unused
    (§ override #_"void" LinearScanLifetimeAnalysisPhase''run-3 [#_"LinearScanLifetimeAnalysisPhase" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context]
        (LinearScanLifetimeAnalysisPhase''numberInstructions-1 this)
        (§ ass! this (LinearScanLifetimeAnalysisPhase''computeLocalLiveSets-1 this))
        (LinearScanLifetimeAnalysisPhase''computeGlobalLiveSets-1 this)
        (LinearScanLifetimeAnalysisPhase''buildIntervals-1 this)
        nil
    )
)

(final-ns LinearScanOptimizeSpillPositionPhase (§ extends LinearScanAllocationPhase)
    (§ final #_"LinearScan" :allocator nil)

    (§ defn #_"LinearScanOptimizeSpillPositionPhase" LinearScanOptimizeSpillPositionPhase'new-1 [#_"LinearScan" allocator]
        (let [
            #_"LinearScanOptimizeSpillPositionPhase" this (LinearScanAllocationPhase'new-0)
            this (assoc this :allocator allocator)
        ]
            this
        )
    )

    (§ method- #_"Iterable<Block>" LinearScanOptimizeSpillPositionPhase''blocksForInterval-2 [#_"LinearScanOptimizeSpillPositionPhase" this, #_"Interval" interval]
        (let [
            #_"LinearScanOptimizeSpillPositionPhase" phase this
        ]
            (§ reify #_"Iterable<Block>" (Iterable.)
                (§ override! #_"Iterator<Block>" #_"Iterable" .iterator [#_"Iterable<Block>" this]
                    (IntervalBlockIterator'new-2 phase, interval)
                )
            )
        )
    )

    (§ defn- #_"Block" LinearScanOptimizeSpillPositionPhase'moveSpillOutOfLoop-2 [#_"Block" defBlock, #_"Block" spillBlock]
        (let [
            #_"int" defLoopDepth (Block''getLoopDepth-1 defBlock)
        ]
            (loop-when-recur [#_"Block" block (:dominator spillBlock)]
                             (and (not (= block defBlock)) (not (<= (Block''getLoopDepth-1 block) defLoopDepth)))
                             [(:dominator block)]
                          => block
            )
        )
    )

    (§ method- #_"void" LinearScanOptimizeSpillPositionPhase''optimizeInterval-4 [#_"LinearScanOptimizeSpillPositionPhase" this, #_"LIRInsertionBuffer[]" insertionBuffers, #_"Interval" interval, #_"LIRGenerationResult" res]
        (when (and (some? interval) (Interval''isSplitParent-1 interval) (= (Interval''spillState-1 interval) SpillState'SpillInDominator))
            (let [
                #_"Block" defBlock (LinearScan''blockForId-2 (:allocator this), (Interval''spillDefinitionPos-1 interval))
                [#_"Block" spillBlock #_"Interval" firstSpillChild]
                    (loop-when [spillBlock nil firstSpillChild nil #_"ISeq" s (seq (Interval''getSplitChildren-1 interval))] (some? s) => [spillBlock firstSpillChild]
                        (let [
                            #_"Interval" splitChild (first s)
                            [spillBlock firstSpillChild]
                                (when (LIRValueUtil'isStackSlotValue-1 (:location splitChild)) => [spillBlock firstSpillChild]
                                    (let [
                                        firstSpillChild
                                            (when (or (nil? firstSpillChild) (< (Interval''from-1 splitChild) (Interval''from-1 firstSpillChild))) => firstSpillChild
                                                splitChild
                                            )
                                        ;; iterate all blocks where the interval has use positions
                                        spillBlock
                                            (loop-when [spillBlock spillBlock #_"ISeq" s (seq (LinearScanOptimizeSpillPositionPhase''blocksForInterval-2 this, splitChild))] (some? s) => spillBlock
                                                (let [
                                                    #_"Block" splitBlock (first s)
                                                    spillBlock
                                                        (when (ControlFlowGraph'dominates-2 defBlock, splitBlock) => spillBlock
                                                            (if (some? spillBlock) (ControlFlowGraph'commonDominator-2 spillBlock, splitBlock) splitBlock)
                                                        )
                                                ]
                                                    (recur spillBlock (next s))
                                                )
                                            )
                                    ]
                                        [spillBlock firstSpillChild]
                                    )
                                )
                        ]
                            (recur spillBlock firstSpillChild (next s))
                        )
                    )
            ]
                (when (some? spillBlock) => (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition) ;; no spill interval
                    ;; move out of loops
                    (let [
                        spillBlock
                            (when (< (Block''getLoopDepth-1 defBlock) (Block''getLoopDepth-1 spillBlock)) => spillBlock
                                (LinearScanOptimizeSpillPositionPhase'moveSpillOutOfLoop-2 defBlock, spillBlock)
                            )
                        ;; The spill block is the begin of the first split child (aka the value is on the stack).
                        ;;
                        ;; The problem is that if spill block has more than one predecessor, the values at the
                        ;; end of the predecessors might differ. Therefore, we would need a spill move in all
                        ;; predecessors. To avoid this we spill in the dominator.
                        spillBlock
                            (when (and (not (= defBlock spillBlock)) (= spillBlock (LinearScan''blockForId-2 (:allocator this), (Interval''from-1 firstSpillChild)))) => spillBlock
                                (:dominator spillBlock)
                            )
                    ]
                        (cond
                            (= defBlock spillBlock)                                ;; definition is the best choice
                                (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition)
                            (<= (:probability defBlock) (:probability spillBlock)) ;; better spill block has the same probability -> do nothing
                                (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition)
                            :else
                                (let [
                                    #_"LIRInsertionBuffer" buffer
                                        (or (nth insertionBuffers (:id spillBlock))
                                            (let [
                                                buffer (LIRInsertionBuffer'new-0)
                                            ]
                                                (aset insertionBuffers (:id spillBlock) buffer)
                                                (§ ass! buffer (LIRInsertionBuffer''init-2 buffer, (LIR''getLIRforBlock-2 (:lir (:allocator this)), spillBlock)))
                                                buffer
                                            )
                                        )
                                    #_"int" spillOpId (LinearScan''getFirstLirInstructionId-2 (:allocator this), spillBlock)
                                    #_"AllocatableValue" from (:location (Interval''getSplitChildAtOpId-4 interval, spillOpId, OperandMode'DEF, (:allocator this)))
                                    #_"AllocatableValue" to (LinearScan'canonicalSpillOpr-1 interval)
                                    #_"LIRInstruction" move (MoveFactory''createMove-3 (:moveFactory (:allocator this)), to, from)
                                ]
                                    (§ ass! move (LIRInstruction''setId-2 move, LinearScan'DOMINATOR_SPILL_MOVE_ID))
                                    ;; We can use the insertion buffer directly because we always insert at position 1.
                                    (§ ass! buffer (LIRInsertionBuffer''append-3 buffer, 1, move))

                                    (Interval''setSpillDefinitionPos-2 interval, spillOpId)
                                )
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" LinearScanOptimizeSpillPositionPhase''run-3 [#_"LinearScanOptimizeSpillPositionPhase" this, #_"LIRGenerationResult" res, #_"AllocationContext" context]
        (let [
            #_"LIRInsertionBuffer[]" buffers (make-array LIRInsertionBuffer (count (:linearScanOrder (:lir (:allocator this)))))
        ]
            (doseq [#_"Interval" interval (:intervals (:allocator this))]
                (LinearScanOptimizeSpillPositionPhase''optimizeInterval-4 this, buffers, interval, res)
            )
            (doseq [#_"LIRInsertionBuffer" buffer buffers]
                (when (some? buffer)
                    (§ ass! buffer (LIRInsertionBuffer''finish-1 buffer))
                )
            )
        )
        nil
    )
)

;;;
 ; Iterate over all {@link Block blocks} of an interval.
 ;
 ; @anno LinearScanOptimizeSpillPositionPhase.IntervalBlockIterator
 ;;
(final-ns IntervalBlockIterator (§ implements Iterator #_"<Block>")
    (§ final #_"LinearScanOptimizeSpillPositionPhase" :phase nil)

    (§ mutable #_"Range" :range nil)
    (§ mutable #_"Block" :block nil)

    (§ defn #_"IntervalBlockIterator" IntervalBlockIterator'new-2 [#_"LinearScanOptimizeSpillPositionPhase" phase, #_"Interval" interval]
        (let [
            #_"IntervalBlockIterator" this (Object.)
            this (assoc this :phase phase)
            this (assoc this :range (:first interval))
            this (assoc this :block (LinearScan''blockForId-2 (:allocator (:phase this)), (:from (:range this))))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Block" IntervalBlockIterator''next-1 [#_"IntervalBlockIterator" this]
        (let [
            #_"Block" currentBlock (:block this)
            #_"int" nextBlockIndex (inc (:linearScanNumber (:block this)))
        ]
            (if (< nextBlockIndex (count (LinearScan''sortedBlocks-1 (:allocator (:phase this)))))
                (do
                    (§ ass! this (assoc this :block (nth (LinearScan''sortedBlocks-1 (:allocator (:phase this))) nextBlockIndex)))
                    (when (<= (:to (:range this)) (LinearScan''getFirstLirInstructionId-2 (:allocator (:phase this)), (:block this)))
                        (§ ass! this (assoc this :range (:next (:range this))))
                        (if (Range''isEndMarker-1 (:range this))
                            (§ ass! this (assoc this :block nil))
                            (§ ass! this (assoc this :block (LinearScan''blockForId-2 (:allocator (:phase this)), (:from (:range this)))))
                        )
                    )
                )
                (§ ass! this (assoc this :block nil))
            )
            currentBlock
        )
    )

    #_unused
    (§ override! #_"boolean" IntervalBlockIterator''hasNext-1 [#_"IntervalBlockIterator" this]
        (some? (:block this))
    )
)

(final-ns LinearScanPhase (§ extends RegisterAllocationPhase)
    (§ defn #_"LinearScanPhase" LinearScanPhase'new-0 []
        (RegisterAllocationPhase'new-0)
    )

    #_unused
    (§ override! #_"void" LinearScanPhase''run-3 [#_"LinearScanPhase" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context]
        (let [
            #_"LinearScan" allocator (SSALinearScan'new-5 lirGenRes, (:moveFactory context), (:registerAllocationConfig context), (:linearScanOrder (:lir lirGenRes)), (RegisterAllocationPhase''getNeverSpillConstants-1 this))
        ]
            (LinearScan''allocate-3 allocator, lirGenRes, context)
        )
        nil
    )
)

(final-ns LinearScanRegisterAllocationPhase (§ extends LinearScanAllocationPhase)
    (§ final #_"LinearScan" :allocator nil)

    (§ defn #_"LinearScanRegisterAllocationPhase" LinearScanRegisterAllocationPhase'new-1 [#_"LinearScan" allocator]
        (let [
            #_"LinearScanRegisterAllocationPhase" this (LinearScanAllocationPhase'new-0)
            this (assoc this :allocator allocator)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" LinearScanRegisterAllocationPhase''run-3 [#_"LinearScanRegisterAllocationPhase" this, #_"LIRGenerationResult" result, #_"AllocationContext" context]
        (let [
            #_"Pair<Interval, Interval>" result (LinearScan''createUnhandledLists-3 (:allocator this), LinearScan'IS_PRECOLORED_INTERVAL, LinearScan'IS_VARIABLE_INTERVAL)
            #_"Interval" precoloredIntervals (#_"Pair" .getLeft result)
            #_"Interval" notPrecoloredIntervals (#_"Pair" .getRight result)
            ;; allocate cpu registers
            #_"LinearScanWalker" lsw
                (if GraalOptions'lsraOptimization
                    (OptimizingLinearScanWalker'new-3 (:allocator this), precoloredIntervals, notPrecoloredIntervals)
                    (LinearScanWalker'new-3 (:allocator this), precoloredIntervals, notPrecoloredIntervals)
                )
        ]
            (IntervalWalker''walk-1 lsw)
            (LinearScanWalker''finishAllocation-1 lsw)
        )
        nil
    )
)

;;;
 ; Phase 6: resolve data flow
 ;
 ; Insert moves at edges between blocks if intervals have been split.
 ;;
(class-ns LinearScanResolveDataFlowPhase (§ extends LinearScanAllocationPhase)
    (§ final #_"LinearScan" :allocator nil)

    (§ defn #_"LinearScanResolveDataFlowPhase" LinearScanResolveDataFlowPhase'new-1 [#_"LinearScan" allocator]
        (let [
            #_"LinearScanResolveDataFlowPhase" this (LinearScanAllocationPhase'new-0)
            this (assoc this :allocator allocator)
        ]
            this
        )
    )

    (§ method #_"void" LinearScanResolveDataFlowPhase''resolveCollectMappings-5 [#_"LinearScanResolveDataFlowPhase" this, #_"Block" fromBlock, #_"Block" toBlock, #_"Block" midBlock, #_"MoveResolver" moveResolver]
        (let [
            #_"int" toBlockFirstInstructionId (LinearScan''getFirstLirInstructionId-2 (:allocator this), toBlock)
            #_"int" fromBlockLastInstructionId (inc (LinearScan''getLastLirInstructionId-2 (:allocator this), fromBlock))
            #_"int" numOperands (LinearScan''operandSize-1 (:allocator this))
            #_"BitSet" liveAtEdge (:liveIn (LinearScan''getBlockData-2 (:allocator this), toBlock))
        ]
            ;; visit all variables for which the liveAtEdge bit is set
            (loop-when-recur [#_"int" operandNum (#_"BitSet" .nextSetBit liveAtEdge, 0)] (<= 0 operandNum) [(#_"BitSet" .nextSetBit liveAtEdge, (inc operandNum))]
                (let [
                    #_"Interval" fromInterval (LinearScan''splitChildAtOpId-4 (:allocator this), (LinearScan''intervalFor-2 (:allocator this), operandNum), fromBlockLastInstructionId, OperandMode'DEF)
                    #_"Interval" toInterval (LinearScan''splitChildAtOpId-4 (:allocator this), (LinearScan''intervalFor-2 (:allocator this), operandNum), toBlockFirstInstructionId, OperandMode'DEF)
                ]
                    (when (and (not= fromInterval toInterval) (not (= (:location fromInterval) (:location toInterval))))
                        ;; need to insert move instruction
                        (MoveResolver''addMapping-3 moveResolver, fromInterval, toInterval)
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" LinearScanResolveDataFlowPhase''resolveFindInsertPos-4 [#_"LinearScanResolveDataFlowPhase" this, #_"Block" fromBlock, #_"Block" toBlock, #_"MoveResolver" moveResolver]
        (if (<= (count (:successors fromBlock)) 1)
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), fromBlock)
            ]
                (if (instance? JumpOp (nth ops (dec (count ops))))
                    (§ ass! moveResolver (MoveResolver''setInsertPosition-3 moveResolver, ops, (dec (count ops)))) ;; insert moves before branch
                    (§ ass! moveResolver (MoveResolver''setInsertPosition-3 moveResolver, ops, (count ops)))
                )
            )
            (§ ass! moveResolver (MoveResolver''setInsertPosition-3 moveResolver, (LIR''getLIRforBlock-2 (:lir (:allocator this)), toBlock), 1))
        )
        nil
    )

    (§ method! #_"void" LinearScanResolveDataFlowPhase''optimizeEmptyBlocks-3 [#_"LinearScanResolveDataFlowPhase" this, #_"MoveResolver" moveResolver, #_"BitSet" blockCompleted]
        (doseq [#_"Block" block (LinearScan''sortedBlocks-1 (:allocator this))]
            ;; check if block has only one predecessor and only one successor
            (when (and (= (count (:predecessors block)) 1) (= (count (:successors block)) 1))
                (let [
                    #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), block)
                ]
                    ;; check if block is empty (only label and branch)
                    (when (= (count ops) 2)
                        (let [
                            #_"Block" pred (nth (:predecessors block) 0)
                            #_"Block" sux (nth (:successors block) 0)
                        ]
                            ;; prevent optimization of two consecutive blocks
                            (when (and (not (#_"BitSet" .get blockCompleted, (:linearScanNumber pred))) (not (#_"BitSet" .get blockCompleted, (:linearScanNumber sux))))
                                (#_"BitSet" .set blockCompleted, (:linearScanNumber block))

                                ;; Directly resolve between pred and sux (without looking at the empty block between).
                                (LinearScanResolveDataFlowPhase''resolveCollectMappings-5 this, pred, sux, block, moveResolver)
                                (when (MoveResolver''hasMappings-1 moveResolver)
                                    (§ ass! moveResolver (MoveResolver''setInsertPosition-3 moveResolver, ops, 1))
                                    (§ ass! moveResolver (MoveResolver''resolveAndAppendMoves-1 moveResolver))
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" LinearScanResolveDataFlowPhase''resolveDataFlow0-3 [#_"LinearScanResolveDataFlowPhase" this, #_"MoveResolver" moveResolver, #_"BitSet" blockCompleted]
        (let [
            #_"BitSet" alreadyResolved (BitSet. (LinearScan''blockCount-1 (:allocator this)))
        ]
            (doseq [#_"Block" fromBlock (LinearScan''sortedBlocks-1 (:allocator this))]
                (when-not (#_"BitSet" .get blockCompleted, (:linearScanNumber fromBlock))
                    (#_"BitSet" .clear alreadyResolved)
                    (#_"BitSet" .or alreadyResolved, blockCompleted)

                    (doseq [#_"Block" toBlock (:successors fromBlock)]
                        ;; Check for duplicate edges between the same blocks (can happen with switch blocks).
                        (when-not (#_"BitSet" .get alreadyResolved, (:linearScanNumber toBlock))
                            (#_"BitSet" .set alreadyResolved, (:linearScanNumber toBlock))

                            ;; collect all intervals that have been split between fromBlock and toBlock
                            (LinearScanResolveDataFlowPhase''resolveCollectMappings-5 this, fromBlock, toBlock, nil, moveResolver)
                            (when (MoveResolver''hasMappings-1 moveResolver)
                                (LinearScanResolveDataFlowPhase''resolveFindInsertPos-4 this, fromBlock, toBlock, moveResolver)
                                (§ ass! moveResolver (MoveResolver''resolveAndAppendMoves-1 moveResolver))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Inserts necessary moves (spilling or reloading) at edges between blocks for intervals that have been split.
     ;;
    (§ method! #_"void" LinearScanResolveDataFlowPhase''resolveDataFlow-1 [#_"LinearScanResolveDataFlowPhase" this]
        (let [
            #_"MoveResolver" moveResolver (LinearScan''createMoveResolver-1 (:allocator this))
            #_"BitSet" blockCompleted (BitSet. (LinearScan''blockCount-1 (:allocator this)))
        ]
            (LinearScanResolveDataFlowPhase''optimizeEmptyBlocks-3 this, moveResolver, blockCompleted)
            (LinearScanResolveDataFlowPhase''resolveDataFlow0-3 this, moveResolver, blockCompleted)
        )
        nil
    )

    #_unused
    (§ override #_"void" LinearScanResolveDataFlowPhase''run-3 [#_"LinearScanResolveDataFlowPhase" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context]
        (LinearScanResolveDataFlowPhase''resolveDataFlow-1 this)
        nil
    )
)

(class-ns LinearScanWalker (§ extends IntervalWalker)
    (§ mutable #_"Register[]" :availableRegs nil)

    (§ final #_"int[]" :usePos nil)
    (§ final #_"int[]" :blockPos nil)

    (§ mutable #_"List<Interval>[]" :spillIntervals nil)

    (§ mutable #_"MoveResolver" :moveResolver nil) ;; for ordering spill moves

    (§ mutable #_"int" :minReg 0)

    (§ mutable #_"int" :maxReg 0)

    ;;;
     ; Only 10% of the lists in #spillIntervals are actually used. But when they are used,
     ; they can grow quite long. The maximum length observed was 45 (all numbers taken from a
     ; bootstrap run of Graal). Therefore, we initialize #spillIntervals with this marker
     ; value, and allocate a "real" list only on demand in #setUsePos.
     ;;
    (§ def- #_"List<Interval>" LinearScanWalker'EMPTY_LIST (Collections/emptyList))

    ;; accessors mapped to same functions in class LinearScan
    #_unused
    (§ method #_"int" LinearScanWalker''blockCount-1 [#_"LinearScanWalker" this]
        (LinearScan''blockCount-1 (:allocator this))
    )

    (§ method #_"Block" LinearScanWalker''blockAt-2 [#_"LinearScanWalker" this, #_"int" idx]
        (LinearScan''blockAt-2 (:allocator this), idx)
    )

    #_unused
    (§ method! #_"Block" LinearScanWalker''blockOfOpWithId-2 [#_"LinearScanWalker" this, #_"int" opId]
        (LinearScan''blockForId-2 (:allocator this), opId)
    )

    (§ defn #_"LinearScanWalker" LinearScanWalker'new-3 [#_"LinearScan" allocator, #_"Interval" unhandledFixedFirst, #_"Interval" unhandledAnyFirst]
        (let [
            #_"LinearScanWalker" this (IntervalWalker'new-3 allocator, unhandledFixedFirst, unhandledAnyFirst)
            this (assoc this :moveResolver (LinearScan''createMoveResolver-1 allocator))
            this (assoc this :spillIntervals (make-array List (#_"RegisterArray" .size (LinearScan''getRegisters-1 allocator))))
            _
                (dotimes [#_"int" i (#_"RegisterArray" .size (LinearScan''getRegisters-1 allocator))]
                    (aset (:spillIntervals this) i LinearScanWalker'EMPTY_LIST)
                )
            this (assoc this :usePos (int-array (#_"RegisterArray" .size (LinearScan''getRegisters-1 allocator))))
            this (assoc this :blockPos (int-array (#_"RegisterArray" .size (LinearScan''getRegisters-1 allocator))))
        ]
            this
        )
    )

    (§ method! #_"void" LinearScanWalker''initUseLists-2 [#_"LinearScanWalker" this, #_"boolean" onlyProcessUsePos]
        (doseq [#_"Register" register (:availableRegs this)]
            (let [
                #_"int" i (.number register)
            ]
                (aset (:usePos this) i Integer/MAX_VALUE)

                (when-not onlyProcessUsePos
                    (aset (:blockPos this) i Integer/MAX_VALUE)
                    (#_"List" .clear (nth (:spillIntervals this) i))
                )
            )
        )
        nil
    )

    (§ method #_"int" LinearScanWalker''maxRegisterNumber-1 [#_"LinearScanWalker" this]
        (:maxReg this)
    )

    (§ method! #_"int" LinearScanWalker''minRegisterNumber-1 [#_"LinearScanWalker" this]
        (:minReg this)
    )

    (§ method! #_"boolean" LinearScanWalker''isRegisterInRange-2 [#_"LinearScanWalker" this, #_"int" reg]
        (<= (LinearScanWalker''minRegisterNumber-1 this) reg (LinearScanWalker''maxRegisterNumber-1 this))
    )

    (§ method! #_"void" LinearScanWalker''excludeFromUse-2 [#_"LinearScanWalker" this, #_"Interval" i]
        (let [
            #_"Value" location (:location i)
            #_"int" i1 (.number (#_"RegisterValue" .getRegister location))
        ]
            (when (LinearScanWalker''isRegisterInRange-2 this, i1)
                (aset (:usePos this) i1 0)
            )
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''setUsePos-4 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" usePos, #_"boolean" onlyProcessUsePos]
        (when-not (= usePos -1)
            (let [
                #_"int" i (.number (#_"RegisterValue" .getRegister (:location interval)))
            ]
                (when (LinearScanWalker''isRegisterInRange-2 this, i)
                    (when (< usePos (nth (:usePos this) i))
                        (aset (:usePos this) i usePos)
                    )
                    (when-not onlyProcessUsePos
                        (let [
                            #_"List<Interval>" list (nth (:spillIntervals this) i)
                        ]
                            (when (= list LinearScanWalker'EMPTY_LIST)
                                (§ ass list (ArrayList.))
                                (aset (:spillIntervals this) i list)
                            )
                            (#_"List" .add list, interval)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''setBlockPos-3 [#_"LinearScanWalker" this, #_"Interval" i, #_"int" blockPos]
        (when-not (= blockPos -1)
            (let [
                #_"int" reg (.number (#_"RegisterValue" .getRegister (:location i)))
            ]
                (when (LinearScanWalker''isRegisterInRange-2 this, reg)
                    (when (< blockPos (nth (:blockPos this) reg))
                        (aset (:blockPos this) reg blockPos)
                    )
                    (when (< blockPos (nth (:usePos this) reg))
                        (aset (:usePos this) reg blockPos)
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''freeExcludeActiveFixed-1 [#_"LinearScanWalker" this]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Fixed)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''excludeFromUse-2 this, interval)
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''freeExcludeActiveAny-1 [#_"LinearScanWalker" this]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''excludeFromUse-2 this, interval)
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''freeCollectInactiveFixed-2 [#_"LinearScanWalker" this, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:inactiveLists this), RegisterBinding'Fixed)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (if (<= (Interval''to-1 current) (Interval''currentFrom-1 interval))
                (LinearScanWalker''setUsePos-4 this, interval, (Interval''currentFrom-1 interval), true)
                (LinearScanWalker''setUsePos-4 this, interval, (Interval''currentIntersectsAt-2 interval, current), true)
            )
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''freeCollectInactiveAny-2 [#_"LinearScanWalker" this, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:inactiveLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''setUsePos-4 this, interval, (Interval''currentIntersectsAt-2 interval, current), true)
        )
        nil
    )

    #_unused
    (§ method! #_"void" LinearScanWalker''freeCollectUnhandled-3 [#_"LinearScanWalker" this, #_"RegisterBinding" kind, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:unhandledLists this), kind)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''setUsePos-4 this, interval, (Interval''intersectsAt-2 interval, current), true)
            (when (and (= kind RegisterBinding'Fixed) (<= (Interval''to-1 current) (Interval''from-1 interval)))
                (LinearScanWalker''setUsePos-4 this, interval, (Interval''from-1 interval), true)
            )
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''spillExcludeActiveFixed-1 [#_"LinearScanWalker" this]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Fixed)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''excludeFromUse-2 this, interval)
        )
        nil
    )

    #_unused
    (§ method! #_"void" LinearScanWalker''spillBlockUnhandledFixed-2 [#_"LinearScanWalker" this, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:unhandledLists this), RegisterBinding'Fixed)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''setBlockPos-3 this, interval, (Interval''intersectsAt-2 interval, current))
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''spillBlockInactiveFixed-2 [#_"LinearScanWalker" this, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:inactiveLists this), RegisterBinding'Fixed)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (when (< (Interval''currentFrom-1 interval) (Interval''to-1 current))
                (LinearScanWalker''setBlockPos-3 this, interval, (Interval''currentIntersectsAt-2 interval, current))
            )
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''spillCollectActiveAny-2 [#_"LinearScanWalker" this, #_"RegisterPriority" registerPriority]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (LinearScanWalker''setUsePos-4 this, interval, (min (Interval''nextUsage-3 interval, registerPriority, (:currentPosition this)) (Interval''to-1 interval)), false)
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''spillCollectInactiveAny-2 [#_"LinearScanWalker" this, #_"Interval" current]
        (loop-when-recur [#_"Interval" interval (RegisterBindingLists''get-2 (:inactiveLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 interval)) [(:next interval)]
            (when (Interval''currentIntersects-2 interval, current)
                (LinearScanWalker''setUsePos-4 this, interval, (min (Interval''nextUsage-3 interval, RegisterPriority'LiveAtLoopEnd, (:currentPosition this)) (Interval''to-1 interval)), false)
            )
        )
        nil
    )

    (§ method #_"void" LinearScanWalker''insertMove-4 [#_"LinearScanWalker" this, #_"int" operandId, #_"Interval" srcIt, #_"Interval" dstIt]
        ;; Output all moves here. When source and target are equal, the move is optimized away later in assignRegNums.
        (let [
            #_"int" opId (& (inc operandId) (bit-not 1))
            #_"Block" opBlock (LinearScan''blockForId-2 (:allocator this), opId)
            ;; Calculate index of instruction inside instruction list of current block. The minimal index
            ;; (for a block with no spill moves) can be calculated, because the numbering of instructions is known.
            ;; When the block already contains spill moves, the index must be increased until the correct index is reached.
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), opBlock)
            #_"int" i
                (loop-when-recur [i (>> (- opId (LIRInstruction''id-1 (nth ops 0))) 1)]
                                   (not (= opId (LIRInstruction''id-1 (nth ops i))))
                                 (inc i)
                              => i
                )
        ]
            ;; insert new instruction before instruction at position index
            (§ ass! (:moveResolver this) (MoveResolver''moveInsertPosition-3 (:moveResolver this), ops, i))
            (MoveResolver''addMapping-3 (:moveResolver this), srcIt, dstIt)
        )
        nil
    )

    (§ method! #_"int" LinearScanWalker''findOptimalSplitPos-4 [#_"LinearScanWalker" this, #_"Block" minBlock, #_"Block" maxBlock, #_"int" maxSplitPos]
        (let [
            #_"int" fromBlockNr (:linearScanNumber minBlock)
            #_"int" toBlockNr (:linearScanNumber maxBlock)
            ;; Try to split at end of maxBlock. If this would be after maxSplitPos, then use the begin of maxBlock.
            #_"int" optimalSplitPos (+ (LinearScan''getLastLirInstructionId-2 (:allocator this), maxBlock) 2)
            optimalSplitPos
                (when (< maxSplitPos optimalSplitPos) => optimalSplitPos
                    (LinearScan''getFirstLirInstructionId-2 (:allocator this), maxBlock)
                )
        ]
            (loop-when [#_"int" minLoopDepth (Block''getLoopDepth-1 maxBlock) optimalSplitPos optimalSplitPos #_"int" i (dec toBlockNr)] (and (pos? minLoopDepth) (<= fromBlockNr i)) => optimalSplitPos
                (let [
                    #_"Block" block (LinearScanWalker''blockAt-2 this, i)
                    [minLoopDepth optimalSplitPos]
                        (when (< (Block''getLoopDepth-1 block) minLoopDepth) => [minLoopDepth optimalSplitPos]
                            ;; block with lower loop-depth found . split at the end of this block
                            [(Block''getLoopDepth-1 block) (+ (LinearScan''getLastLirInstructionId-2 (:allocator this), block) 2)]
                        )
                ]
                    (recur minLoopDepth optimalSplitPos (dec i))
                )
            )
        )
    )

    (§ method! #_"int" LinearScanWalker''findOptimalSplitPos-5 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" minSplitPos, #_"int" maxSplitPos, #_"boolean" doLoopOptimization]
        ;; => Trivial case, no optimization of split position possible.
        (when-not (= minSplitPos maxSplitPos) => minSplitPos
            ;; Reason for using minSplitPos - 1: when the minimal split pos is exactly at the beginning of a block,
            ;; then minSplitPos is also a possible split position.
            ;; Use the block before as minBlock, because then minBlock.lastLirInstructionId() + 2 == minSplitPos.
            (let [
                #_"Block" minBlock (LinearScan''blockForId-2 (:allocator this), (dec minSplitPos))
                ;; Reason for using maxSplitPos - 1: otherwise there would be an assert on failure when an interval
                ;; ends at the end of the last block of the method
                ;; (in this case, maxSplitPos == allocator().maxLirOpId() + 2, and there is no block at this opId).
                #_"Block" maxBlock (LinearScan''blockForId-2 (:allocator this), (dec maxSplitPos))
            ]
                ;; => Split position cannot be moved to block boundary, so split as late as possible.
                (when-not (= minBlock maxBlock) => maxSplitPos
                    ;; => Do not move split position if the interval has a hole before maxSplitPos.
                    ;; Intervals resulting from Phi-functions have more than one definition (marked
                    ;; as mustHaveRegister) with a hole before each definition. When the register
                    ;; is needed for the second definition, an earlier reloading is unnecessary.
                    (when-not (and (Interval''hasHoleBetween-3 interval, (dec maxSplitPos), maxSplitPos) (not (LinearScan''isBlockBegin-2 (:allocator this), maxSplitPos))) => maxSplitPos
                        ;; Seach optimal block boundary between minSplitPos and maxSplitPos.
                        (let [
                            #_"int" optimalSplitPos
                                (when doLoopOptimization => -1
                                    ;; Loop optimization: if a loop-end marker is found between min- and max-position,
                                    ;; then split before this loop.
                                    (let [
                                        #_"int" loopEndPos (Interval''nextUsageExact-3 interval, RegisterPriority'LiveAtLoopEnd, (+ (LinearScan''getLastLirInstructionId-2 (:allocator this), minBlock) 2))
                                    ]
                                        (when (< loopEndPos maxSplitPos) => -1
                                            ;; Loop-end marker found between min- and max-position. If it is not the end marker
                                            ;; for the same loop as the min-position, move the max-position to this loop block.
                                            ;; Desired result: uses tagged as shouldHaveRegister inside a loop cause a reloading
                                            ;; of the interval (normally, only mustHaveRegister causes a reloading).
                                            (let [
                                                #_"Block" loopBlock (LinearScan''blockForId-2 (:allocator this), loopEndPos)
                                                #_"int" maxSpillPos (+ (LinearScan''getLastLirInstructionId-2 (:allocator this), loopBlock) 2)
                                                optimalSplitPos (LinearScanWalker''findOptimalSplitPos-4 this, minBlock, loopBlock, maxSpillPos)
                                            ]
                                                (when-not (= optimalSplitPos maxSpillPos) => -1
                                                    optimalSplitPos
                                                )
                                            )
                                        )
                                    )
                                )
                        ]
                            (when (= optimalSplitPos -1) => optimalSplitPos
                                ;; not calculated by loop optimization
                                (LinearScanWalker''findOptimalSplitPos-4 this, minBlock, maxBlock, maxSplitPos)
                            )
                        )
                    )
                )
            )
        )
    )

    ;; Split an interval at the optimal position between minSplitPos and maxSplitPos in two parts:
    ;; 1) the left part has already a location assigned,
    (§ method! #_"void" LinearScanWalker''splitBeforeUsage-4 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" minSplitPos, #_"int" maxSplitPos]
        (let [
            #_"int" optimalSplitPos (LinearScanWalker''findOptimalSplitPos-5 this, interval, minSplitPos, maxSplitPos, true)
        ]
            ;; => the split position would be just before the end of the interval, so no split necessary at all
            (when-not (and (= optimalSplitPos (Interval''to-1 interval)) (= (Interval''nextUsage-3 interval, RegisterPriority'MustHaveRegister, minSplitPos) Integer/MAX_VALUE))
                ;; must calculate this before the actual split is performed and before split position is moved to odd opId
                (let [
                    #_"boolean" moveNecessary (and (not (LinearScan''isBlockBegin-2 (:allocator this), optimalSplitPos)) (not (Interval''hasHoleBetween-3 interval, (dec optimalSplitPos), optimalSplitPos)))
                    optimalSplitPos
                        (when-not (LinearScan''isBlockBegin-2 (:allocator this), optimalSplitPos) => optimalSplitPos
                            ;; move position before actual instruction (odd opId)
                            (| (dec optimalSplitPos) 1)
                        )
                    #_"Interval" splitPart (Interval''split-3 interval, optimalSplitPos, (:allocator this))
                ]
                    (§ ass! splitPart (Interval''setInsertMoveWhenActivated-2 splitPart, moveNecessary))
                    (§ ass! (:unhandledLists this) (RegisterBindingLists''addToListSortedByStartAndUsePositions-3 (:unhandledLists this), RegisterBinding'Any, splitPart))
                )
            )
        )
        nil
    )

    ;; split an interval at the optimal position between minSplitPos and maxSplitPos in two parts:
    ;;
    ;; (1) the left part has already a location assigned
    ;; (2) the right part is always on the stack and therefore ignored in further processing
    (§ method! #_"void" LinearScanWalker''splitForSpilling-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        ;; calculate allowed range of splitting position
        (let [
            #_"int" maxSplitPos (:currentPosition this)
            #_"int" previousUsage (Interval''previousUsage-3 interval, RegisterPriority'ShouldHaveRegister, maxSplitPos)
            previousUsage
                (when (= previousUsage (:currentPosition this)) => previousUsage
                    ;; If there is a usage with ShouldHaveRegister priority at the current position
                    ;; fall back to MustHaveRegister priority. This only happens if register priority
                    ;; was downgraded to MustHaveRegister in #allocLockedRegister.
                    (Interval''previousUsage-3 interval, RegisterPriority'MustHaveRegister, maxSplitPos)
                )
            #_"int" minSplitPos (max (inc previousUsage) (Interval''from-1 interval))
        ]
            (if (= minSplitPos (Interval''from-1 interval))
                (do
                    ;; the whole interval is never used, so spill it entirely to memory
                    (LinearScan''assignSpillSlot-2 (:allocator this), interval)
                    (LinearScanWalker''handleSpillSlot-2 this, interval)
                    (LinearScanWalker''changeSpillState-3 this, interval, minSplitPos)

                    ;; Also kick parent intervals out of register to memory when they have no use position.
                    ;; This avoids short interval in register surrounded by intervals in memory.
                    ;; Avoid useless moves from memory to register and back.
                    (loop-when [#_"Interval" parent interval] (and (some? parent) (Interval''isSplitChild-1 parent))
                        (let [
                            parent (Interval''getSplitChildBeforeOpId-2 parent, (Interval''from-1 parent))
                            parent
                                (when (instance? RegisterValue (:location parent)) => parent
                                    ;; => do not go further back, because the register is actually used by the interval
                                    (when (= (Interval''firstUsage-2 parent, RegisterPriority'ShouldHaveRegister) Integer/MAX_VALUE)
                                        ;; parent is never used, so kick it out of its assigned register
                                        (LinearScan''assignSpillSlot-2 (:allocator this), parent)
                                        (LinearScanWalker''handleSpillSlot-2 this, parent)
                                        parent
                                    )
                                )
                        ]
                            (recur parent)
                        )
                    )
                )
                ;; search optimal split pos, split interval and spill only the right hand part
                (let [
                    #_"int" optimalSplitPos (LinearScanWalker''findOptimalSplitPos-5 this, interval, minSplitPos, maxSplitPos, false)
                    optimalSplitPos
                        (when-not (LinearScan''isBlockBegin-2 (:allocator this), optimalSplitPos) => optimalSplitPos
                            ;; move position before actual instruction (odd opId)
                            (| (dec optimalSplitPos) 1)
                        )
                    #_"Interval" spilledPart (Interval''split-3 interval, optimalSplitPos, (:allocator this))
                ]
                    (LinearScan''assignSpillSlot-2 (:allocator this), spilledPart)
                    (LinearScanWalker''handleSpillSlot-2 this, spilledPart)
                    (LinearScanWalker''changeSpillState-3 this, spilledPart, optimalSplitPos)

                    (when-not (LinearScan''isBlockBegin-2 (:allocator this), optimalSplitPos)
                        (LinearScanWalker''insertMove-4 this, optimalSplitPos, interval, spilledPart)
                    )

                    ;; the currentSplitChild is needed later when moves are inserted for reloading
                    (Interval''makeCurrentSplitChild-1 spilledPart)
                )
            )
        )
        nil
    )

    ;; called during register allocation
    (§ method- #_"void" LinearScanWalker''changeSpillState-3 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" spillPos]
        (condp = (Interval''spillState-1 interval)
            SpillState'NoSpillStore
            (let [
                #_"int" defLoopDepth (Block''getLoopDepth-1 (LinearScan''blockForId-2 (:allocator this), (Interval''spillDefinitionPos-1 interval)))
                #_"int" spillLoopDepth (Block''getLoopDepth-1 (LinearScan''blockForId-2 (:allocator this), spillPos))
            ]
                (if (< defLoopDepth spillLoopDepth)
                    ;; The loop depth of the spilling position is higher then the loop depth at
                    ;; the definition of the interval. Move write to memory out of loop.
                    (if GraalOptions'lirOptLSRAOptimizeSpillPosition
                        (Interval''setSpillState-2 interval, SpillState'SpillInDominator)  ;; find best spill position in the dominator tree
                        (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition) ;; store at definition of the interval
                    )
                    ;; The interval is currently spilled only once, so for now there is no reason
                    ;; to store the interval at the definition.
                    (Interval''setSpillState-2 interval, SpillState'OneSpillStore)
                )
            )
            SpillState'OneSpillStore
            (let [
                #_"int" defLoopDepth (Block''getLoopDepth-1 (LinearScan''blockForId-2 (:allocator this), (Interval''spillDefinitionPos-1 interval)))
                #_"int" spillLoopDepth (Block''getLoopDepth-1 (LinearScan''blockForId-2 (:allocator this), spillPos))
            ]
                (when (<= defLoopDepth spillLoopDepth)
                    (if GraalOptions'lirOptLSRAOptimizeSpillPosition
                        (Interval''setSpillState-2 interval, SpillState'SpillInDominator)  ;; the interval is spilled more then once
                        (Interval''setSpillState-2 interval, SpillState'StoreAtDefinition) ;; it is better to store it to memory at the definition
                    )
                )
            )
            nil
        )
        nil
    )

    ;;;
     ; This is called for every interval that is assigned to a stack slot.
     ;;
    (§ method #_"void" LinearScanWalker''handleSpillSlot-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        ;; Do nothing. Stack slots are not processed in this implementation.
        nil
    )

    (§ method! #_"void" LinearScanWalker''splitStackInterval-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (let [
            #_"int" minSplitPos (inc (:currentPosition this))
            #_"int" maxSplitPos (min (Interval''firstUsage-2 interval, RegisterPriority'ShouldHaveRegister) (Interval''to-1 interval))
        ]
            (LinearScanWalker''splitBeforeUsage-4 this, interval, minSplitPos, maxSplitPos)
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''splitWhenPartialRegisterAvailable-3 [#_"LinearScanWalker" this, #_"Interval" interval, #_"int" registerAvailableUntil]
        (let [
            #_"int" minSplitPos (max (Interval''previousUsage-3 interval, RegisterPriority'ShouldHaveRegister, registerAvailableUntil) (inc (Interval''from-1 interval)))
        ]
            (LinearScanWalker''splitBeforeUsage-4 this, interval, minSplitPos, registerAvailableUntil)
        )
        nil
    )

    (§ method! #_"void" LinearScanWalker''splitAndSpillInterval-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (let [
            #_"int" currentPos (:currentPosition this)
        ]
            (if (= (:state interval) IntervalState'Inactive)
                (do
                    ;; The interval is currently inactive, so no spill slot is needed for now.
                    ;; When the split part is activated, the interval has a new chance to get a register,
                    ;; so in the best case no stack slot is necessary.
                    (LinearScanWalker''splitBeforeUsage-4 this, interval, (inc currentPos), (inc currentPos))
                )
                ;; Search the position where the interval must have a register and split at the optimal position before.
                ;; The new created part is added to the unhandled list and will get a register when it is activated.
                (let [
                    #_"int" minSplitPos (inc currentPos)
                    #_"int" maxSplitPos (min (Interval''nextUsage-3 interval, RegisterPriority'MustHaveRegister, minSplitPos) (Interval''to-1 interval))
                ]
                    (LinearScanWalker''splitBeforeUsage-4 this, interval, minSplitPos, maxSplitPos)

                    (LinearScanWalker''splitForSpilling-2 this, interval)
                )
            )
        )
        nil
    )

    (§ method! #_"boolean" LinearScanWalker''allocFreeRegister-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (LinearScanWalker''initUseLists-2 this, true)
        (LinearScanWalker''freeExcludeActiveFixed-1 this)
        (LinearScanWalker''freeExcludeActiveAny-1 this)
        (LinearScanWalker''freeCollectInactiveFixed-2 this, interval)
        (LinearScanWalker''freeCollectInactiveAny-2 this, interval)
        ;; freeCollectUnhandled(fixedKind, cur);

        ;; usePos contains the start of the next interval that has this register assigned
        ;; (either as a fixed register or a normal allocated register in the past)
        ;; only intervals overlapping with cur are processed, non-overlapping invervals can be ignored safely

        (let [
            #_"Interval" locationHint (Interval''locationHint-2 interval, true)
            #_"Register" hint
                (when (and (some? locationHint) (some? (:location locationHint)) (instance? RegisterValue (:location locationHint)))
                    (#_"RegisterValue" .getRegister (:location locationHint))
                )
            ;; the register must be free at least until this position
            #_"int" regNeededUntil (inc (Interval''from-1 interval))
            #_"int" intervalTo (Interval''to-1 interval)
            [#_"Register" minFullReg #_"Register" maxPartialReg]
                (loop-when [minFullReg nil maxPartialReg nil #_"ISeq" s (seq (:availableRegs this))] (some? s) => [minFullReg maxPartialReg]
                    (let [
                        #_"Register" availableReg (first s)
                        #_"int" number (.number availableReg)
                        [minFullReg maxPartialReg]
                            (cond
                                (<= intervalTo (nth (:usePos this) number))
                                    ;; this register is free for the full interval
                                    (when (or (nil? minFullReg) (= availableReg hint) (and (< (nth (:usePos this) number) (nth (:usePos this) (.number minFullReg))) (not (= minFullReg hint)))) => [minFullReg maxPartialReg]
                                        [availableReg maxPartialReg]
                                    )
                                (< regNeededUntil (nth (:usePos this) number))
                                    ;; this register is at least free until regNeededUntil
                                    (when (or (nil? maxPartialReg) (= availableReg hint) (and (< (nth (:usePos this) (.number maxPartialReg)) (nth (:usePos this) number)) (not (= maxPartialReg hint)))) => [minFullReg maxPartialReg]
                                        [minFullReg availableReg]
                                    )
                                :else
                                    [minFullReg maxPartialReg]
                            )
                    ]
                        (recur minFullReg maxPartialReg (next s))
                    )
                )
            [#_"Register" reg #_"boolean" needSplit]
                (cond
                    (some? minFullReg)    [minFullReg false]
                    (some? maxPartialReg) [maxPartialReg true]
                    :else                 (§ return false)
                )
            #_"int" splitPos (nth (:usePos this) (.number reg))
        ]
            (§ ass! interval (Interval''assignLocation-2 interval, (#_"Register" .asValue reg, (:kind interval))))
            (when needSplit
                ;; register not available for full interval, so split it
                (LinearScanWalker''splitWhenPartialRegisterAvailable-3 this, interval, splitPos)
            )
            ;; only return true if interval is completely assigned
            true
        )
    )

    (§ method! #_"void" LinearScanWalker''splitAndSpillIntersectingIntervals-2 [#_"LinearScanWalker" this, #_"Register" reg]
        (dotimes [#_"int" i (count (nth (:spillIntervals this) (.number reg)))]
            (let [
                #_"Interval" interval (nth (nth (:spillIntervals this) (.number reg)) i)
            ]
                (IntervalWalker''removeFromList-2 this, interval)
                (LinearScanWalker''splitAndSpillInterval-2 this, interval)
            )
        )
        nil
    )

    ;; split an Interval and spill it to memory so that cur can be placed in a register
    (§ method! #_"void" LinearScanWalker''allocLockedRegister-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        ;; the register must be free at least until this position
        (let [
            #_"int" firstUsage (Interval''firstUsage-2 interval, RegisterPriority'MustHaveRegister)
            #_"int" firstShouldHaveUsage (Interval''firstUsage-2 interval, RegisterPriority'ShouldHaveRegister)
            #_"int" regNeededUntil (min firstUsage (inc (Interval''from-1 interval)))
            #_"int" intervalTo (Interval''to-1 interval)
        ]
            ;; In the common case we don't spill registers that have _any_ use position that is
            ;; closer than the next use of the current interval, but if we can't spill the current
            ;; interval we weaken this strategy and also allow spilling of intervals that have a
            ;; non-mandatory requirements (no MustHaveRegister use position).
            (loop [#_"RegisterPriority" registerPriority RegisterPriority'LiveAtLoopEnd]
                ;; collect current usage of registers
                (LinearScanWalker''initUseLists-2 this, false)
                (LinearScanWalker''spillExcludeActiveFixed-1 this)
                ;; spillBlockUnhandledFixed(cur);
                (LinearScanWalker''spillBlockInactiveFixed-2 this, interval)
                (LinearScanWalker''spillCollectActiveAny-2 this, registerPriority)
                (LinearScanWalker''spillCollectInactiveAny-2 this, interval)

                (let [
                    #_"Register" ignore (when (and (some? (:location interval)) (instance? RegisterValue (:location interval))) (#_"RegisterValue" .getRegister (:location interval)))
                    #_"Register" reg
                        (loop-when [reg nil #_"ISeq" s (seq (:availableRegs this))] (some? s) => reg
                            (let [
                                #_"Register" available (first s)
                                reg (if (and (not= available ignore) (< regNeededUntil (nth (:usePos this) (.number available))) (or (nil? reg) (< (nth (:usePos this) (.number reg)) (nth (:usePos this) (.number available))))) available reg)
                            ]
                                (recur reg (next s))
                            )
                        )
                    #_"int" regUsePos (if (some? reg) (nth (:usePos this) (.number reg)) 0)
                ]
                    (if (<= regUsePos firstShouldHaveUsage)
                        (if (<= firstUsage (inc (Interval''from-1 interval)))
                            (if (= registerPriority RegisterPriority'LiveAtLoopEnd)
                                ;; Tool of last resort: we can not spill the current interval so we try
                                ;; to spill an active interval that has a usage but do not require a register.
                                (recur RegisterPriority'MustHaveRegister)
                                (do
                                    ;; assign a reasonable register and do a bailout in product mode to avoid errors
                                    (LinearScan''assignSpillSlot-2 (:allocator this), interval)
                                    (throw! "linear scan: no register found") ;; OutOfRegistersException
                                )
                            )
                            (LinearScanWalker''splitAndSpillInterval-2 this, interval)
                        )
                        (let [
                            #_"boolean" needSplit (<= (nth (:blockPos this) (.number reg)) intervalTo)
                            #_"int" splitPos (nth (:blockPos this) (.number reg))
                        ]
                            (§ ass! interval (Interval''assignLocation-2 interval, (#_"Register" .asValue reg, (:kind interval))))
                            (when needSplit
                                ;; register not available for full interval : so split it
                                (LinearScanWalker''splitWhenPartialRegisterAvailable-3 this, interval, splitPos)
                            )
                            ;; perform splitting and spilling for all affected intervals
                            (LinearScanWalker''splitAndSpillIntersectingIntervals-2 this, reg)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"boolean" LinearScanWalker''noAllocationPossible-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (and (LinearScan''callKillsRegisters-1 (:allocator this))
            ;; fast calculation of intervals that can never get a register because
            ;; the next instruction is a call that blocks all registers
            ;; note: this only works if a call kills all registers

            ;; check if this interval is the result of a split operation (an interval got a register until this position)
            (let [
                #_"int" pos (Interval''from-1 interval)
            ]
                (and (CodeUtil/isOdd pos)
                    ;; the current instruction is a call that blocks all registers
                    (< pos (LinearScan''maxOpId-1 (:allocator this))) (LinearScan''hasCall-2 (:allocator this), (inc pos)) (< (inc pos) (Interval''to-1 interval))
                )
            )
        )
    )

    (§ method! #_"LinearScanWalker" LinearScanWalker''initVarsForAlloc-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (let [
            #_"AllocatableRegisters" r (RegisterAllocationConfig''getAllocatableRegisters-2 (LinearScan''getRegisterAllocationConfig-1 (:allocator this)), (#_"ValueKind" .getPlatformKind (:kind interval)))
            this (assoc this :availableRegs (:allocatableRegisters r))
            this (assoc this :minReg (:minRegisterNumber r))
            this (assoc this :maxReg (:maxRegisterNumber r))
        ]
            this
        )
    )

    (§ defn #_"boolean" LinearScanWalker'isMove-3 [#_"LIRInstruction" op, #_"Interval" from, #_"Interval" to]
        (and (LIRInstruction''isValueMoveOp-1 op)
            (instance? Variable (ValueMoveOp''getInput-1 op)) (= (ValueMoveOp''getInput-1 op) (:operand from))
            (instance? Variable (MoveOp''getResult-1 op)) (= (MoveOp''getResult-1 op) (:operand to))
        )
    )

    ;; optimization (especially for phi functions of nested loops)
    ;; assign same spill slot to non-intersecting intervals
    (§ method! #_"void" LinearScanWalker''combineSpilledIntervals-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        ;; => optimization is only suitable for split parents
        (when-not (Interval''isSplitChild-1 interval)
            (let [
                #_"Interval" registerHint (Interval''locationHint-2 interval, false)
            ]
                ;; => 'interval' is not the target of a move, else registerHint would be set
                (when (some? registerHint)
                    ;; => combining the stack slots for intervals where spill move optimization is applied is not beneficial and would cause problems
                    (when (and (= (Interval''spillState-1 interval) SpillState'NoOptimization) (= (Interval''spillState-1 registerHint) SpillState'NoOptimization))
                        (let [
                            #_"int" beginPos (Interval''from-1 interval)
                            #_"int" endPos (Interval''to-1 interval)
                        ]
                            ;; => safety check that lirOpWithId is allowed
                            (when-not (or (< (LinearScan''maxOpId-1 (:allocator this)) endPos) (CodeUtil/isOdd beginPos) (CodeUtil/isOdd endPos))
                                ;; => 'interval' and registerHint are not connected with two moves
                                (when (and (LinearScanWalker'isMove-3 (LinearScan''instructionForId-2 (:allocator this), beginPos), registerHint, interval) (LinearScanWalker'isMove-3 (LinearScan''instructionForId-2 (:allocator this), endPos), interval, registerHint))
                                    (let [
                                        #_"Interval" beginHint (Interval''getSplitChildAtOpId-4 registerHint, beginPos, OperandMode'USE, (:allocator this))
                                        #_"Interval" endHint (Interval''getSplitChildAtOpId-4 registerHint, endPos, OperandMode'DEF, (:allocator this))
                                    ]
                                        ;; => registerHint must be split : otherwise the re-writing of use positions does not work
                                        (when (and (not (= beginHint endHint)) (= (Interval''to-1 beginHint) beginPos) (= (Interval''from-1 endHint) endPos))
                                            ;; => registerHint is not spilled at beginPos, so it would not be beneficial to immediately spill 'interval'
                                            (when-not (instance? RegisterValue (:location beginHint))
                                                ;; modify intervals such that 'interval' gets the same stack slot as registerHint
                                                ;; delete use positions to prevent the intervals to get a register at beginning
                                                (Interval''setSpillSlot-2 interval, (Interval''spillSlot-1 registerHint))
                                                (Interval''removeFirstUsePos-1 interval)
                                                (Interval''removeFirstUsePos-1 endHint)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;; allocate a physical register or memory location to an interval
    #_unused
    (§ override #_"boolean" LinearScanWalker''activateCurrent-2 [#_"LinearScanWalker" this, #_"Interval" interval]
        (let [
            #_"Value" operand (:operand interval)
            #_"boolean" result
                (if (and (some? (:location interval)) (LIRValueUtil'isStackSlotValue-1 (:location interval)))
                    (do
                        ;; activating an interval that has a stack slot assigned
                        ;; split it at first use position used for method parameters
                        (LinearScanWalker''splitStackInterval-2 this, interval)
                        false
                    )
                    (or (some? (:location interval))
                        (do
                            ;; interval has not assigned register
                            ;; normal allocation (the normal case for most intervals)

                            ;; assign same spill slot to non-intersecting intervals
                            (LinearScanWalker''combineSpilledIntervals-2 this, interval)

                            (§ ass! this (LinearScanWalker''initVarsForAlloc-2 this, interval))
                            (when (or (LinearScanWalker''noAllocationPossible-2 this, interval) (not (LinearScanWalker''allocFreeRegister-2 this, interval)))
                                ;; no empty register available
                                ;; split and spill another interval so that this interval gets a register
                                (LinearScanWalker''allocLockedRegister-2 this, interval)
                            )

                            ;; spilled intervals need not be move to active-list
                            (instance? RegisterValue (:location interval))
                        )
                    )
                )
        ]
            ;; load spilled values that become active from stack slot to register
            (when (:insertMoveWhenActivated interval)
                (LinearScanWalker''insertMove-4 this, (Interval''from-1 interval), (Interval''currentSplitChild-1 interval), interval)
            )
            (Interval''makeCurrentSplitChild-1 interval)

            result ;; true = interval is moved to active list
        )
    )

    (§ method! #_"void" LinearScanWalker''finishAllocation-1 [#_"LinearScanWalker" this]
        ;; must be called when all intervals are allocated
        (§ ass! (:moveResolver this) (MoveResolver''resolveAndAppendMoves-1 (:moveResolver this)))
        nil
    )
)

(class-ns MoveResolver
    (§ final #_"LinearScan" :allocator nil)

    (§ mutable #_"int" :insertIdx 0)
    (§ mutable #_"LIRInsertionBuffer" :insertionBuffer nil) ;; buffer where moves are inserted

    (§ final #_"ArrayList<Interval>" :mappingFrom nil)
    (§ final #_"ArrayList<Constant>" :mappingFromOpr nil)
    (§ final #_"ArrayList<Interval>" :mappingTo nil)
    (§ mutable #_"boolean" :multipleReadsAllowed false)
    (§ final #_"int[]" :registerBlocked nil)

    (§ method #_"void" MoveResolver''setValueBlocked-3 [#_"MoveResolver" this, #_"Value" location, #_"int" direction]
        (when (instance? RegisterValue location) => (throw! (str "unhandled value " location))
            (aswap (:registerBlocked this) (.number (#_"RegisterValue" .getRegister location)) + direction)
        )
        nil
    )

    (§ method! #_"Interval" MoveResolver''getMappingFrom-2 [#_"MoveResolver" this, #_"int" i]
        (nth (:mappingFrom this) i)
    )

    #_unused
    (§ method! #_"int" MoveResolver''mappingFromSize-1 [#_"MoveResolver" this]
        (count (:mappingFrom this))
    )

    (§ method #_"int" MoveResolver''valueBlocked-2 [#_"MoveResolver" this, #_"Value" location]
        (when (instance? RegisterValue location) => (throw! (str "unhandled value " location))
            (nth (:registerBlocked this) (.number (#_"RegisterValue" .getRegister location)))
        )
    )

    #_unused
    (§ method! #_"MoveResolver" MoveResolver''setMultipleReadsAllowed-1 [#_"MoveResolver" this]
        (assoc this :multipleReadsAllowed true)
    )

    #_unused
    (§ method #_"boolean" MoveResolver''areMultipleReadsAllowed-1 [#_"MoveResolver" this]
        (:multipleReadsAllowed this)
    )

    (§ method! #_"boolean" MoveResolver''hasMappings-1 [#_"MoveResolver" this]
        (seq (:mappingFrom this))
    )

    (§ method! #_"LinearScan" MoveResolver''getAllocator-1 [#_"MoveResolver" this]
        (:allocator this)
    )

    (§ defn #_"MoveResolver" MoveResolver'new-1 [#_"LinearScan" allocator]
        (let [
            #_"MoveResolver" this (Object.)
            this (assoc this :allocator allocator)
            this (assoc this :multipleReadsAllowed false)
            this (assoc this :mappingFrom (ArrayList.))
            this (assoc this :mappingFromOpr (ArrayList.))
            this (assoc this :mappingTo (ArrayList.))
            this (assoc this :insertIdx -1)
            this (assoc this :insertionBuffer (LIRInsertionBuffer'new-0))
            this (assoc this :registerBlocked (int-array (#_"RegisterArray" .size (LinearScan''getRegisters-1 allocator))))
        ]
            this
        )
    )

    ;; mark assignedReg and assignedRegHi of the interval as blocked
    (§ method- #_"void" MoveResolver''blockRegisters-2 [#_"MoveResolver" this, #_"Interval" interval]
        (let [
            #_"Value" location (:location interval)
        ]
            (when (MoveResolver''mightBeBlocked-2 this, location)
                (let [
                    #_"int" direction 1
                ]
                    (MoveResolver''setValueBlocked-3 this, location, direction)
                )
            )
        )
        nil
    )

    ;; mark assignedReg and assignedRegHi of the interval as unblocked
    (§ method- #_"void" MoveResolver''unblockRegisters-2 [#_"MoveResolver" this, #_"Interval" interval]
        (let [
            #_"Value" location (:location interval)
        ]
            (when (MoveResolver''mightBeBlocked-2 this, location)
                (MoveResolver''setValueBlocked-3 this, location, -1)
            )
        )
        nil
    )

    ;;;
     ; Checks if the {@linkplain Interval#location() location} of {@code to} is not blocked or is only blocked by {@code from}.
     ;;
    (§ method- #_"boolean" MoveResolver''safeToProcessMove-3 [#_"MoveResolver" this, #_"Interval" from, #_"Interval" to]
        (let [
            #_"Value" fromReg (when (some? from) (:location from))
            #_"Value" location (:location to)
        ]
            (not (and (MoveResolver''mightBeBlocked-2 this, location)
                      (or (< 1 (MoveResolver''valueBlocked-2 this, location))
                          (and (= (MoveResolver''valueBlocked-2 this, location) 1)
                               (not (MoveResolver''isMoveToSelf-3 this, fromReg, location))
                          )
                      )
                 )
            )
        )
    )

    (§ method! #_"boolean" MoveResolver''isMoveToSelf-3 [#_"MoveResolver" this, #_"Value" from, #_"Value" to]
        (or (= to from)
            (and (some? from)
                (instance? RegisterValue from) (instance? RegisterValue to)
                (= (#_"RegisterValue" .getRegister from) (#_"RegisterValue" .getRegister to))
            )
        )
    )

    (§ method #_"boolean" MoveResolver''mightBeBlocked-2 [#_"MoveResolver" this, #_"Value" location]
        (instance? RegisterValue location)
    )

    (§ method- #_"void" MoveResolver''createInsertionBuffer-2 [#_"MoveResolver" this, #_"List<LIRInstruction>" list]
        (§ ass! (:insertionBuffer this) (LIRInsertionBuffer''init-2 (:insertionBuffer this), list))
        nil
    )

    (§ method- #_"MoveResolver" MoveResolver''appendInsertionBuffer-1 [#_"MoveResolver" this]
        (let [
            _
                (when (LIRInsertionBuffer''initialized-1 (:insertionBuffer this))
                    (§ ass! (:insertionBuffer this) (LIRInsertionBuffer''finish-1 (:insertionBuffer this)))
                )
        ]
            (assoc this :insertIdx -1)
        )
    )

    (§ method- #_"LIRInstruction" MoveResolver''insertMove-3 [#_"MoveResolver" this, #_"Interval" fromInterval, #_"Interval" toInterval]
        (let [
            #_"LIRInstruction" move (MoveResolver''createMove-5 this, (:operand fromInterval), (:operand toInterval), (:location fromInterval), (:location toInterval))
        ]
            (§ ass! (:insertionBuffer this) (LIRInsertionBuffer''append-3 (:insertionBuffer this), (:insertIdx this), move))

            move
        )
    )

    ;;;
     ; @param fromOpr {@link Interval#operand operand} of the {@code from} interval
     ; @param toOpr {@link Interval#operand operand} of the {@code to} interval
     ; @param fromLocation {@link Interval#location() location} of the {@code to} interval
     ; @param toLocation {@link Interval#location() location} of the {@code to} interval
     ;;
    (§ method #_"LIRInstruction" MoveResolver''createMove-5 [#_"MoveResolver" this, #_"AllocatableValue" fromOpr, #_"AllocatableValue" toOpr, #_"AllocatableValue" fromLocation, #_"AllocatableValue" toLocation]
        (MoveFactory''createMove-3 (:moveFactory (MoveResolver''getAllocator-1 this)), toOpr, fromOpr)
    )

    (§ method- #_"LIRInstruction" MoveResolver''insertMove-3 [#_"MoveResolver" this, #_"Constant" fromOpr, #_"Interval" toInterval]
        (let [
            #_"AllocatableValue" toOpr (:operand toInterval)
            #_"LIRInstruction" move
                (if (LIRValueUtil'isStackSlotValue-1 (:location toInterval))
                    (MoveFactory''createStackLoad-3 (:moveFactory (MoveResolver''getAllocator-1 this)), toOpr, fromOpr)
                    (MoveFactory''createLoad-3 (:moveFactory (MoveResolver''getAllocator-1 this)), toOpr, fromOpr)
                )
        ]
            (§ ass! (:insertionBuffer this) (LIRInsertionBuffer''append-3 (:insertionBuffer this), (:insertIdx this), move))
            move
        )
    )

    (§ method- #_"MoveResolver" MoveResolver''resolveMappings-1 [#_"MoveResolver" this]
        ;; Block all registers that are used as input operands of a move.
        ;; When a register is blocked, no move to this register is emitted.
        ;; This is necessary for detecting cycles in moves.
        (loop-when-recur [#_"int" i (dec (count (:mappingFrom this)))] (<= 0 i) [(dec i)]
            (let [
                #_"Interval" fromInterval (nth (:mappingFrom this) i)
            ]
                (when (some? fromInterval)
                    (MoveResolver''blockRegisters-2 this, fromInterval)
                )
            )
        )

        (loop-when [#_"ArrayList<AllocatableValue>" busySpillSlots nil] (seq (:mappingFrom this))
            (let [
                [busySpillSlots #_"boolean" processed? #_"int" spillCandidate]
                    (loop-when [busySpillSlots busySpillSlots processed? false spillCandidate -1 #_"int" i (dec (count (:mappingFrom this)))] (<= 0 i) => [busySpillSlots processed? spillCandidate]
                        (let [
                            #_"Interval" fromInterval (nth (:mappingFrom this) i)
                            #_"Interval" toInterval (nth (:mappingTo this) i)
                            [busySpillSlots processed? spillCandidate]
                                (when (MoveResolver''safeToProcessMove-3 this, fromInterval, toInterval) => [busySpillSlots processed? (if (and (some? fromInterval) (instance? RegisterValue (:location fromInterval)) (not (and (some? busySpillSlots) (#_"ArrayList" .contains busySpillSlots, (Interval''spillSlot-1 fromInterval))))) i spillCandidate)]
                                    (let [
                                        #_"LIRInstruction" move
                                            (when (some? fromInterval) => (MoveResolver''insertMove-3 this, (nth (:mappingFromOpr this) i), toInterval)
                                                (let [
                                                    move (MoveResolver''insertMove-3 this, fromInterval, toInterval)
                                                ]
                                                    (MoveResolver''unblockRegisters-2 this, fromInterval)
                                                    move
                                                )
                                            )
                                        busySpillSlots
                                            (when (LIRValueUtil'isStackSlotValue-1 (:location toInterval)) => busySpillSlots
                                                (let [
                                                    busySpillSlots (or busySpillSlots (ArrayList.))
                                                ]
                                                    (#_"ArrayList" .add busySpillSlots, (:location toInterval))
                                                    busySpillSlots
                                                )
                                            )
                                    ]
                                        (#_"ArrayList" .remove (:mappingFrom this), i)
                                        (#_"ArrayList" .remove (:mappingFromOpr this), i)
                                        (#_"ArrayList" .remove (:mappingTo this), i)

                                        [busySpillSlots true spillCandidate]
                                    )
                                )
                        ]
                            (recur busySpillSlots processed? spillCandidate (dec i))
                        )
                    )
            ]
                (when-not processed?
                    (MoveResolver''breakCycle-2 this, spillCandidate)
                )
                (recur busySpillSlots)
            )
        )

        ;; reset to default value
        (assoc this :multipleReadsAllowed false)
    )

    (§ method #_"void" MoveResolver''breakCycle-2 [#_"MoveResolver" this, #_"int" spillCandidate]
        ;; no move could be processed because there is a cycle in the move list
        ;; (e.g. r1 . r2, r2 . r1), so one interval must be spilled to memory

        ;; create a new spill interval and assign a stack slot to it
        (let [
            #_"Interval" fromInterval (nth (:mappingFrom this) spillCandidate)
            ;; do not allocate a new spill slot for temporary interval, but
            ;; use spill slot assigned to fromInterval. Otherwise moves from
            ;; one stack slot to another can happen (not allowed by LIRAssembler)
            #_"AllocatableValue" spillSlot (Interval''spillSlot-1 fromInterval)
        ]
            (when (nil? spillSlot)
                (§ ass spillSlot (FrameMapBuilder''allocateSpillSlot-2 (LinearScan''getFrameMapBuilder-1 (MoveResolver''getAllocator-1 this)), (:kind fromInterval)))
                (Interval''setSpillSlot-2 fromInterval, spillSlot)
            )
            (MoveResolver''spillInterval-4 this, spillCandidate, fromInterval, spillSlot)
        )
        nil
    )

    (§ method! #_"void" MoveResolver''spillInterval-4 [#_"MoveResolver" this, #_"int" spillCandidate, #_"Interval" fromInterval, #_"AllocatableValue" spillSlot]
        (let [
            #_"Interval" spillInterval (LinearScan''createDerivedInterval-2 (MoveResolver''getAllocator-1 this), fromInterval)
        ]
            (§ ass! spillInterval (Interval''setKind-2 spillInterval, (:kind fromInterval)))

            ;; add a dummy range because real position is difficult to calculate
            ;; note: this range is a special case when the integrity of the allocation is checked
            (§ ass! spillInterval (Interval''addRange-3 spillInterval, 1, 2))

            (§ ass! spillInterval (Interval''assignLocation-2 spillInterval, spillSlot))

            (MoveResolver''blockRegisters-2 this, spillInterval)

            ;; insert a move from register to stack and update the mapping
            (let [
                #_"LIRInstruction" move (MoveResolver''insertMove-3 this, fromInterval, spillInterval)
            ]
                (#_"ArrayList" .set (:mappingFrom this), spillCandidate, spillInterval)
                (MoveResolver''unblockRegisters-2 this, fromInterval)
            )
        )
        nil
    )

    (§ method! #_"MoveResolver" MoveResolver''setInsertPosition-3 [#_"MoveResolver" this, #_"List<LIRInstruction>" insertList, #_"int" insertIdx]
        (MoveResolver''createInsertionBuffer-2 this, insertList)
        (assoc this :insertIdx insertIdx)
    )

    (§ method! #_"MoveResolver" MoveResolver''moveInsertPosition-3 [#_"MoveResolver" this, #_"List<LIRInstruction>" newInsertList, #_"int" newInsertIdx]
        (let [
            this
                (when (and (some? (:lir (:insertionBuffer this))) (or (not= (:lir (:insertionBuffer this)) newInsertList) (not= (:insertIdx this) newInsertIdx))) => this
                    ;; insert position changed . resolve current mappings
                    (MoveResolver''resolveMappings-1 this)
                )
            this
                (when-not (= (:lir (:insertionBuffer this)) newInsertList) => this
                    ;; block changed . append insertionBuffer because it is
                    ;; bound to a specific block and create a new insertionBuffer
                    (let [
                        this (MoveResolver''appendInsertionBuffer-1 this)
                    ]
                        (MoveResolver''createInsertionBuffer-2 this, newInsertList)
                        this
                    )
                )
        ]
            (assoc this :insertIdx newInsertIdx)
        )
    )

    (§ method! #_"void" MoveResolver''addMapping-3 [#_"MoveResolver" this, #_"Interval" fromInterval, #_"Interval" toInterval]
        (when-not (and (= (:location toInterval) Value/ILLEGAL) (Interval''canMaterialize-1 toInterval))
            (if (and (= (:location fromInterval) Value/ILLEGAL) (Interval''canMaterialize-1 fromInterval))
                ;; instead of a reload, re-materialize the value
                (MoveResolver''addMapping-3 this, (Interval''getMaterializedValue-1 fromInterval), toInterval)
                (do
                    (#_"ArrayList" .add (:mappingFrom this), fromInterval)
                    (#_"ArrayList" .add (:mappingFromOpr this), nil)
                    (#_"ArrayList" .add (:mappingTo this), toInterval)
                )
            )
        )
        nil
    )

    (§ method! #_"void" MoveResolver''addMapping-3 [#_"MoveResolver" this, #_"Constant" fromOpr, #_"Interval" toInterval]
        (#_"ArrayList" .add (:mappingFrom this), nil)
        (#_"ArrayList" .add (:mappingFromOpr this), fromOpr)
        (#_"ArrayList" .add (:mappingTo this), toInterval)
        nil
    )

    (§ method! #_"MoveResolver" MoveResolver''resolveAndAppendMoves-1 [#_"MoveResolver" this]
        (let [
            this
                (when (MoveResolver''hasMappings-1 this) => this
                    (MoveResolver''resolveMappings-1 this)
                )
        ]
            (MoveResolver''appendInsertionBuffer-1 this)
        )
    )
)

(final-ns OptimizingLinearScanWalker (§ extends LinearScanWalker)
    (§ defn #_"OptimizingLinearScanWalker" OptimizingLinearScanWalker'new-3 [#_"LinearScan" allocator, #_"Interval" unhandledFixedFirst, #_"Interval" unhandledAnyFirst]
        (LinearScanWalker'new-3 allocator, unhandledFixedFirst, unhandledAnyFirst)
    )

    #_unused
    (§ override! #_"void" OptimizingLinearScanWalker''handleSpillSlot-2 [#_"OptimizingLinearScanWalker" this, #_"Interval" interval]
        (when-not (Interval''canMaterialize-1 interval)
            (§ ass! (:unhandledLists this) (RegisterBindingLists''addToListSortedByStartAndUsePositions-3 (:unhandledLists this), RegisterBinding'Stack, interval))
        )
        nil
    )

    #_unused
    (§ override! #_"void" OptimizingLinearScanWalker''walk-1 [#_"OptimizingLinearScanWalker" this]
        (doseq [#_"Block" block (LinearScan''sortedBlocks-1 (:allocator this))]
            (OptimizingLinearScanWalker''optimizeBlock-2 this, block)
        )
        (IntervalWalker''walk-1 (§ super ))
        nil
    )

    (§ method- #_"void" OptimizingLinearScanWalker''optimizeBlock-2 [#_"OptimizingLinearScanWalker" this, #_"Block" block]
        (when (= (count (:predecessors block)) 1)
            (let [
                #_"int" nextBlock (LinearScan''getFirstLirInstructionId-2 (:allocator this), block)
            ]
                (§ ass! this (IntervalWalker''walkTo-2 this, nextBlock))
                ;; we need to do this because the active lists might change
                (loop []
                    (or
                        (loop-when [#_"Interval" active (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Any)] (not (Interval''isEndMarker-1 active))
                            (or (OptimizingLinearScanWalker''optimize-5 this, nextBlock, block, active, RegisterBinding'Any)
                                (recur (:next active))
                            )
                        )
                        (loop-when [#_"Interval" active (RegisterBindingLists''get-2 (:activeLists this), RegisterBinding'Stack)] (not (Interval''isEndMarker-1 active))
                            (or (OptimizingLinearScanWalker''optimize-5 this, nextBlock, block, active, RegisterBinding'Stack)
                                (recur (:next active))
                            )
                        )
                        (recur)
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"boolean" OptimizingLinearScanWalker''optimize-5 [#_"OptimizingLinearScanWalker" this, #_"int" currentPos, #_"Block" currentBlock, #_"Interval" currentInterval, #_"RegisterBinding" binding]
        (cond
            (not (Interval''isSplitChild-1 currentInterval))  false ;; interval is not a split child -> no need for optimization
            (= (Interval''from-1 currentInterval) currentPos) false ;; the interval starts at the current position so no need for splitting
            :else
                (let [
                    #_"AllocatableValue" currentLocation (:location currentInterval)
                    #_"Block" predecessorBlock (nth (:predecessors currentBlock) 0)
                    #_"int" predEndId (LinearScan''getLastLirInstructionId-2 (:allocator this), predecessorBlock)
                    #_"Interval" predecessorInterval (Interval''getIntervalCoveringOpId-2 currentInterval, predEndId)
                    #_"AllocatableValue" predecessorLocation (:location predecessorInterval)
                ]
                    (cond
                        (= currentLocation predecessorLocation)
                            false ;; locations are already equal -> nothing to optimize
                        (and (not (LIRValueUtil'isStackSlotValue-1 predecessorLocation)) (not (instance? RegisterValue predecessorLocation)))
                            false ;; value is materialized -> no need for optimization
                        :else
                            ;; split current interval at current position
                            (let [
                                #_"Interval" splitPart (Interval''split-3 currentInterval, currentPos, (:allocator this))
                            ]
                                (§ ass! (:activeLists this) (RegisterBindingLists''remove-3 (:activeLists this), binding, currentInterval))
                                ;; the currentSplitChild is needed later when moves are inserted for reloading
                                (Interval''makeCurrentSplitChild-1 splitPart)
                                (cond
                                    GraalOptions'lsraOptSplitOnly
                                        ;; just add the split interval to the unhandled list
                                        (§ ass! (:unhandledLists this) (RegisterBindingLists''addToListSortedByStartAndUsePositions-3 (:unhandledLists this), RegisterBinding'Any, splitPart))
                                    (instance? RegisterValue predecessorLocation)
                                        (OptimizingLinearScanWalker''splitRegisterInterval-3 this, splitPart, (#_"RegisterValue" .getRegister predecessorLocation))
                                    :else
                                    (do
                                        (§ ass! splitPart (Interval''assignLocation-2 splitPart, predecessorLocation))
                                        ;; activate interval
                                        (§ ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), RegisterBinding'Stack, splitPart))
                                        (§ ass! splitPart (assoc splitPart :state IntervalState'Active))
                                        (LinearScanWalker''splitStackInterval-2 this, splitPart)
                                    )
                                )
                                true
                            )
                    )
                )
        )
    )

    (§ method- #_"void" OptimizingLinearScanWalker''splitRegisterInterval-3 [#_"OptimizingLinearScanWalker" this, #_"Interval" interval, #_"Register" reg]
        ;; collect current usage of registers
        (§ ass! this (LinearScanWalker''initVarsForAlloc-2 this, interval))
        (LinearScanWalker''initUseLists-2 this, false)
        (LinearScanWalker''spillExcludeActiveFixed-1 this)
        ;; spillBlockUnhandledFixed(cur);
        (LinearScanWalker''spillBlockInactiveFixed-2 this, interval)
        (LinearScanWalker''spillCollectActiveAny-2 this, RegisterPriority'LiveAtLoopEnd)
        (LinearScanWalker''spillCollectInactiveAny-2 this, interval)

        ;; the register must be free at least until this position
        (let [
            #_"boolean" needSplit (<= (nth (:blockPos this) (.number reg)) (Interval''to-1 interval))
            #_"int" splitPos (nth (:blockPos this) (.number reg))
        ]
            (§ ass! interval (Interval''assignLocation-2 interval, (#_"Register" .asValue reg, (:kind interval))))
            (when needSplit
                ;; register not available for full interval : so split it
                (LinearScanWalker''splitWhenPartialRegisterAvailable-3 this, interval, splitPos)
            )

            ;; perform splitting and spilling for all affected intervals
            (LinearScanWalker''splitAndSpillIntersectingIntervals-2 this, reg)

            ;; activate interval
            (§ ass! (:activeLists this) (RegisterBindingLists''addToListSortedByCurrentFromPositions-3 (:activeLists this), RegisterBinding'Any, interval))
            (§ ass interval (assoc interval :state IntervalState'Active))
        )
        nil
    )
)

;;;
 ; Represents a range of integers from a start (inclusive) to an end (exclusive).
 ;;
(final-ns Range
    ;;;
     ; The start of the range, inclusive.
     ;;
    (§ mutable #_"int" :from 0)

    ;;;
     ; The end of the range, exclusive.
     ;;
    (§ mutable #_"int" :to 0)

    ;;;
     ; A link to allow the range to be put into a singly linked list.
     ;;
    (§ mutable #_"Range" :next nil)

    (§ method! #_"boolean" Range''intersects-2 [#_"Range" this, #_"Range" r]
        (not= (Range''intersectsAt-2 this, r) -1)
    )

    ;;;
     ; Creates a new range.
     ;
     ; @param from the start of the range, inclusive
     ; @param to the end of the range, exclusive
     ; @param next link to the next range in a linked list
     ;;
    (§ defn #_"Range" Range'new-3 [#_"int" from, #_"int" to, #_"Range" next]
        (let [
            #_"Range" this (Object.)
            this (assoc this :from from)
            this (assoc this :to to)
            this (assoc this :next next)
        ]
            this
        )
    )

    (§ method! #_"boolean" Range''isEndMarker-1 [#_"Range" this]
        (= (:from this) Integer/MAX_VALUE)
    )

    (§ method! #_"int" Range''intersectsAt-2 [#_"Range" this, #_"Range" other]
        (loop [#_"Range" r1 this #_"Range" r2 other]
            (if (< (:from r1) (:from r2))
                (if (<= (:to r1) (:from r2))
                    (let [
                        r1 (:next r1)
                    ]
                        (if (Range''isEndMarker-1 r1) -1 (recur r1 r2))
                    )
                    (:from r2)
                )
                (if (< (:from r2) (:from r1))
                    (if (<= (:to r2) (:from r1))
                        (let [
                            r2 (:next r2)
                        ]
                            (if (Range''isEndMarker-1 r2) -1 (recur r1 r2))
                        )
                        (:from r1)
                    )
                    ;; r1.from() == r2.from()
                    (if (= (:from r1) (:to r1))
                        (let [
                            r1 (:next r1)
                        ]
                            (if (Range''isEndMarker-1 r1) -1 (recur r1 r2))
                        )
                        (if (= (:from r2) (:to r2))
                            (let [
                                r2 (:next r2)
                            ]
                                (if (Range''isEndMarker-1 r2) -1 (recur r1 r2))
                            )
                            (:from r1)
                        )
                    )
                )
            )
        )
    )
)

(final-ns SSALinearScan (§ extends LinearScan)
    (§ defn #_"SSALinearScan" SSALinearScan'new-5 [#_"LIRGenerationResult" res, #_"MoveFactory" moveFactory, #_"RegisterAllocationConfig" regAllocConfig, #_"Block[]" sortedBlocks, #_"boolean" neverSpillConstants]
        (LinearScan'new-5 res, moveFactory, regAllocConfig, sortedBlocks, neverSpillConstants)
    )

    #_unused
    (§ override! #_"MoveResolver" SSALinearScan''createMoveResolver-1 [#_"SSALinearScan" this]
        (SSAMoveResolver'new-1 this)
    )

    #_unused
    (§ override! #_"LinearScanLifetimeAnalysisPhase" SSALinearScan''createLifetimeAnalysisPhase-1 [#_"SSALinearScan" this]
        (SSALinearScanLifetimeAnalysisPhase'new-1 this)
    )

    #_unused
    (§ override! #_"LinearScanResolveDataFlowPhase" SSALinearScan''createResolveDataFlowPhase-1 [#_"SSALinearScan" this]
        (SSALinearScanResolveDataFlowPhase'new-1 this)
    )

    #_unused
    (§ override! #_"LinearScanEliminateSpillMovePhase" SSALinearScan''createSpillMoveEliminationPhase-1 [#_"SSALinearScan" this]
        (SSALinearScanEliminateSpillMovePhase'new-1 this)
    )

    #_unused
    (§ override! #_"void" SSALinearScan''beforeSpillMoveElimination-1 [#_"SSALinearScan" this]
        ;; PHIs where the Out and In value matches (i.e. there is no resolution move) are falsely detected as errors.
        (doseq [#_"Block" toBlock (LinearScan''sortedBlocks-1 this)]
            (when (< 1 (count (:predecessors toBlock)))
                (SSAUtil'removePhiIn-2 (:lir this), toBlock)
            )
        )
        nil
    )
)

(final-ns SSALinearScanEliminateSpillMovePhase (§ extends LinearScanEliminateSpillMovePhase)
    (§ defn #_"SSALinearScanEliminateSpillMovePhase" SSALinearScanEliminateSpillMovePhase'new-1 [#_"LinearScan" allocator]
        (LinearScanEliminateSpillMovePhase'new-1 allocator)
    )

    #_unused
    (§ override! #_"int" SSALinearScanEliminateSpillMovePhase''firstInstructionOfInterest-1 [#_"SSALinearScanEliminateSpillMovePhase" this]
        ;; also look at Labels as they define PHI values
        0
    )

    #_unused
    (§ override! #_"boolean" SSALinearScanEliminateSpillMovePhase''canEliminateSpillMove-3 [#_"SSALinearScanEliminateSpillMovePhase" this, #_"Block" block, #_"MoveOp" move]
        (and (LinearScanEliminateSpillMovePhase''canEliminateSpillMove-3 (§ super ), block, move)
            ;; SSA Linear Scan might introduce moves to stack slots
            (not (SSALinearScanEliminateSpillMovePhase''isPhiResolutionMove-4 this, block, move, (LinearScan''intervalFor-2 (:allocator this), (MoveOp''getResult-1 move))))
        )
    )

    (§ method- #_"boolean" SSALinearScanEliminateSpillMovePhase''isPhiResolutionMove-4 [#_"SSALinearScanEliminateSpillMovePhase" this, #_"Block" block, #_"MoveOp" move, #_"Interval" to]
        (and (Interval''isSplitParent-1 to)
             (zero? (& (Interval''from-1 to) 1))
             (= (count (:successors block)) 1)
             (instance? LabelOp (LinearScan''instructionForId-2 (:allocator this), (Interval''from-1 to)))
             (= (nth (:successors block) 0) (LinearScan''blockForId-2 (:allocator this), (Interval''from-1 to)))
        )
    )
)

(final-ns SSALinearScanLifetimeAnalysisPhase (§ extends LinearScanLifetimeAnalysisPhase)
    (§ defn #_"SSALinearScanLifetimeAnalysisPhase" SSALinearScanLifetimeAnalysisPhase'new-1 [#_"LinearScan" linearScan]
        (LinearScanLifetimeAnalysisPhase'new-1 linearScan)
    )

    #_unused
    (§ override! #_"void" SSALinearScanLifetimeAnalysisPhase''addRegisterHint-6 [#_"SSALinearScanLifetimeAnalysisPhase" this, #_"LIRInstruction" op, #_"Value" targetValue, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags, #_"boolean" hintAtDef]
        (LinearScanLifetimeAnalysisPhase''addRegisterHint-6 (§ super ), op, targetValue, mode, flags, hintAtDef)

        (when (and hintAtDef (instance? LabelOp op))
            (let [
                #_"Interval" to (LinearScan''getOrCreateInterval-2 (:allocator this), targetValue)
            ]
                (SSAUtil'forEachPhiRegisterHint-6 (:lir (:allocator this)), (LinearScan''blockForId-2 (:allocator this), (LIRInstruction''id-1 op)), op, targetValue, mode, (§ cast #_"ValueConsumer" (ß (registerHint, valueMode, valueFlags) ->
                    (§ fun
                        (when (LinearScan'isVariableOrRegister-1 registerHint)
                            (let [
                                #_"Interval" from (LinearScan''getOrCreateInterval-2 (:allocator this), registerHint)
                            ]
                                (SSALinearScanLifetimeAnalysisPhase'setHint-3 op, to, from)
                                (SSALinearScanLifetimeAnalysisPhase'setHint-3 op, from, to)
                            )
                        )
                    )))
                )
            )
        )
        nil
    )

    (§ defn #_"void" SSALinearScanLifetimeAnalysisPhase'setHint-3 [#_"LIRInstruction" op, #_"Interval" target, #_"Interval" source]
        (let [
            #_"Interval" hint (Interval''locationHint-2 target, false)
        ]
            (when (or (nil? hint) (< (Interval''from-1 target) (Interval''from-1 hint)))
                ;; Update hint if there was none or if the hint interval starts after the hinted interval.
                (§ ass! target (Interval''setLocationHint-2 target, source))
            )
        )
        nil
    )

    #_unused
    (§ override! #_"RegisterPriority" SSALinearScanLifetimeAnalysisPhase''registerPriorityOfOutputOperand-2 [#_"SSALinearScanLifetimeAnalysisPhase" this, #_"LIRInstruction" op]
        (when-not (and (instance? LabelOp op) (LabelOp''isPhiIn-1 op)) => RegisterPriority'None
            (LinearScanLifetimeAnalysisPhase''registerPriorityOfOutputOperand-2 (§ super ), op)
        )
    )
)

(final-ns SSALinearScanResolveDataFlowPhase (§ extends LinearScanResolveDataFlowPhase)
    (§ defn #_"SSALinearScanResolveDataFlowPhase" SSALinearScanResolveDataFlowPhase'new-1 [#_"LinearScan" allocator]
        (LinearScanResolveDataFlowPhase'new-1 allocator)
    )

    #_unused
    (§ override! #_"void" SSALinearScanResolveDataFlowPhase''resolveCollectMappings-5 [#_"SSALinearScanResolveDataFlowPhase" this, #_"Block" fromBlock, #_"Block" toBlock, #_"Block" midBlock, #_"MoveResolver" moveResolver]
        (LinearScanResolveDataFlowPhase''resolveCollectMappings-5 (§ super ), fromBlock, toBlock, midBlock, moveResolver)

        (when (< 1 (count (:predecessors toBlock)))
            (let [
                #_"int" toBlockFirstInstructionId (LinearScan''getFirstLirInstructionId-2 (:allocator this), toBlock)
                #_"int" fromBlockLastInstructionId (inc (LinearScan''getLastLirInstructionId-2 (:allocator this), fromBlock))
                #_"Block" phiOutBlock (if (some? midBlock) midBlock fromBlock)
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:allocator this)), phiOutBlock)
                #_"int" phiOutIdx (SSAUtil'phiOutIndex-2 (:lir (:allocator this)), phiOutBlock)
                #_"int" phiOutId (if (some? midBlock) fromBlockLastInstructionId (LIRInstruction''id-1 (nth ops phiOutIdx)))
                #_"SSALinearScanResolveDataFlowPhase" phase this
                #_"PhiValueVisitor" visitor
                    (§ reify #_"PhiValueVisitor" (PhiValueVisitor'reify-0)
                        (§ override! #_"void" PhiValueVisitor''visit-3 [#_"PhiValueVisitor" this, #_"Value" phiIn, #_"Value" phiOut]
                            (let [
                                #_"Interval" toInterval (LinearScan''splitChildAtOpId-4 (:allocator phase), (LinearScan''intervalFor-2 (:allocator phase), phiIn), toBlockFirstInstructionId, OperandMode'DEF)
                            ]
                                (if (instance? ConstantValue phiOut)
                                    (MoveResolver''addMapping-3 moveResolver, (:constant phiOut), toInterval)
                                    (let [
                                        #_"Interval" fromInterval (LinearScan''splitChildAtOpId-4 (:allocator phase), (LinearScan''intervalFor-2 (:allocator phase), phiOut), phiOutId, OperandMode'DEF)
                                    ]
                                        (when (and (not= fromInterval toInterval) (not (= (:location fromInterval) (:location toInterval))))
                                            (if (not (and (LIRValueUtil'isStackSlotValue-1 (:location toInterval)) (LIRValueUtil'isStackSlotValue-1 (:location fromInterval))))
                                                (MoveResolver''addMapping-3 moveResolver, fromInterval, toInterval)
                                                (MoveResolver''addMapping-3 moveResolver, fromInterval, toInterval)
                                            )
                                        )
                                    )
                                )
                            )
                            nil
                        )
                    )
            ]
                (SSAUtil'forEachPhiValuePair-4 (:lir (:allocator this)), toBlock, phiOutBlock, visitor)
                (SSAUtil'removePhiOut-2 (:lir (:allocator this)), phiOutBlock)
            )
        )
        nil
    )
)

(final-ns SSAMoveResolver (§ extends MoveResolver)
    (def- #_"int" SSAMoveResolver'STACK_SLOT_IN_CALLER_FRAME_IDX -1)

    (§ mutable #_"int[]" :stackBlocked nil)

    (§ final #_"int" :firstVirtualStackIndex 0)

    (§ defn #_"SSAMoveResolver" SSAMoveResolver'new-1 [#_"LinearScan" allocator]
        (let [
            #_"FrameMapBuilderTool" frameMapBuilderTool (LinearScan''getFrameMapBuilder-1 allocator)
            #_"FrameMap" frameMap (FrameMapBuilderTool''getFrameMap-1 frameMapBuilderTool)
            #_"SSAMoveResolver" this (MoveResolver'new-1 allocator)
            this (assoc this :stackBlocked (int-array (FrameMapBuilderTool''getNumberOfStackSlots-1 frameMapBuilderTool)))
            this (assoc this :firstVirtualStackIndex (if (not (FrameMap''frameNeedsAllocating-1 frameMap)) 0 (inc (FrameMap''currentFrameSize-1 frameMap))))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" SSAMoveResolver''areMultipleReadsAllowed-1 [#_"SSAMoveResolver" this]
        true
    )

    #_unused
    (§ override! #_"boolean" SSAMoveResolver''mightBeBlocked-2 [#_"SSAMoveResolver" this, #_"Value" location]
        (or (MoveResolver''mightBeBlocked-2 (§ super ), location) (LIRValueUtil'isStackSlotValue-1 location))
    )

    (§ method- #_"int" SSAMoveResolver''getStackArrayIndex-2 [#_"SSAMoveResolver" this, #_"Value" stackSlotValue]
        (condp instance? stackSlotValue
            StackSlot        (SSAMoveResolver''getStackArrayIndex-2 this, stackSlotValue)
            VirtualStackSlot (SSAMoveResolver''getStackArrayIndex-2 this, stackSlotValue)
        )
    )

    (§ method- #_"int" SSAMoveResolver''getStackArrayIndex-2 [#_"SSAMoveResolver" this, #_"StackSlot" stackSlot]
        ;; incoming stack arguments can be ignored
        (if (#_"StackSlot" .isInCallerFrame stackSlot) SSAMoveResolver'STACK_SLOT_IN_CALLER_FRAME_IDX (- (#_"StackSlot" .getRawOffset stackSlot)))
    )

    (§ method- #_"int" SSAMoveResolver''getStackArrayIndex-2 [#_"SSAMoveResolver" this, #_"VirtualStackSlot" virtualStackSlot]
        (+ (:firstVirtualStackIndex this) (:id virtualStackSlot))
    )

    #_unused
    (§ override! #_"void" SSAMoveResolver''setValueBlocked-3 [#_"SSAMoveResolver" this, #_"Value" location, #_"int" direction]
        (when (LIRValueUtil'isStackSlotValue-1 location) => (MoveResolver''setValueBlocked-3 (§ super ), location, direction)
            (let [
                #_"int" i (SSAMoveResolver''getStackArrayIndex-2 this, location)
            ]
                (when-not (= i SSAMoveResolver'STACK_SLOT_IN_CALLER_FRAME_IDX) ;; => incoming stack arguments can be ignored
                    (when (<= (count (:stackBlocked this)) i)
                        (§ ass! this (assoc this :stackBlocked (Arrays/copyOf (:stackBlocked this), (inc i))))
                    )
                    (aswap (:stackBlocked this) i + direction)
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"int" SSAMoveResolver''valueBlocked-2 [#_"SSAMoveResolver" this, #_"Value" location]
        (when (LIRValueUtil'isStackSlotValue-1 location) => (MoveResolver''valueBlocked-2 (§ super ), location)
            (let [
                #_"int" i (SSAMoveResolver''getStackArrayIndex-2 this, location)
            ]
                (cond
                    ;; incoming stack arguments are always blocked (aka they can not be written)
                    (= i SSAMoveResolver'STACK_SLOT_IN_CALLER_FRAME_IDX) 1
                    (<= (count (:stackBlocked this)) i)                  0
                    :else                                                (nth (:stackBlocked this) i)
                )
            )
        )
    )

    #_unused
    (§ override! #_"LIRInstruction" SSAMoveResolver''createMove-5 [#_"SSAMoveResolver" this, #_"AllocatableValue" fromOpr, #_"AllocatableValue" toOpr, #_"AllocatableValue" fromLocation, #_"AllocatableValue" toLocation]
        (if (and (LIRValueUtil'isStackSlotValue-1 toLocation) (LIRValueUtil'isStackSlotValue-1 fromLocation))
            (MoveFactory''createStackMove-3 (:moveFactory (MoveResolver''getAllocator-1 this)), toOpr, fromOpr)
            (MoveResolver''createMove-5 (§ super ), fromOpr, toOpr, fromLocation, toLocation)
        )
    )

    #_unused
    (§ override! #_"void" SSAMoveResolver''breakCycle-2 [#_"SSAMoveResolver" this, #_"int" spillCandidate]
        (when (= spillCandidate -1) => (MoveResolver''breakCycle-2 (§ super ), spillCandidate)
            ;; Arbitrarily select the first entry for spilling.
            (let [
                #_"int" stackSpillCandidate 0
                #_"Interval" fromInterval (MoveResolver''getMappingFrom-2 this, stackSpillCandidate)
                ;; allocate new stack slot
                #_"VirtualStackSlot" spillSlot (FrameMapBuilder''allocateSpillSlot-2 (LinearScan''getFrameMapBuilder-1 (MoveResolver''getAllocator-1 this)), (:kind fromInterval))
            ]
                (MoveResolver''spillInterval-4 this, stackSpillCandidate, fromInterval, spillSlot)
            )
        )
        nil
    )
)

;;;
 ; Marker class for register allocation phases.
 ;;
(class-ns RegisterAllocationPhase (§ extends AllocationPhase)
    (§ mutable #_"boolean" :neverSpillConstants false)

    (§ defn #_"RegisterAllocationPhase" RegisterAllocationPhase'new-0 []
        (AllocationPhase'new-0)
    )

    #_unused
    (§ method! #_"RegisterAllocationPhase" RegisterAllocationPhase''setNeverSpillConstants-2 [#_"RegisterAllocationPhase" this, #_"boolean" neverSpillConstants]
        (assoc this :neverSpillConstants neverSpillConstants)
    )

    (§ method! #_"boolean" RegisterAllocationPhase''getNeverSpillConstants-1 [#_"RegisterAllocationPhase" this]
        (:neverSpillConstants this)
    )
)

(final-ns SaveCalleeSaveRegisters (§ extends PreAllocationOptimizationPhase)
    (§ defn #_"SaveCalleeSaveRegisters" SaveCalleeSaveRegisters'new-0 []
        (PreAllocationOptimizationPhase'new-0)
    )

    (§ defn- #_"RegisterMap<Variable>" SaveCalleeSaveRegisters'saveAtEntry-5 [#_"LIR" lir, #_"LIRGenerator" lirGen, #_"LIRGenerationResult" lirGenRes, #_"RegisterArray" calleeSaveRegisters, #_"Architecture" arch]
        (let [
            #_"Block" startBlock (ControlFlowGraph''getStartBlock-1 (:cfg lir))
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, startBlock)
            #_"LIRInsertionBuffer" buffer (LIRInsertionBuffer''init-2 (LIRInsertionBuffer'new-0), ops)
            #_"LabelOp" entry (nth ops 0)
            #_"RegisterValue[]" savedRegisterValues (make-array RegisterValue (#_"RegisterArray" .size calleeSaveRegisters))
            #_"RegisterMap<Variable>" saveMap (RegisterMap'new-1 arch)
        ]
            (loop-when [#_"int" i 0 #_"ISeq" s (seq calleeSaveRegisters)] (some? s)
                (let [
                    #_"Register" register (first s)
                    #_"PlatformKind" registerPlatformKind (#_"Architecture" .getLargestStorableKind arch, (#_"Register" .getRegisterCategory register))
                    #_"LIRKind" lirKind (LIRKind'value-1 registerPlatformKind)
                    #_"RegisterValue" registerValue (#_"Register" .asValue register, lirKind)
                    #_"Variable" saveVariable (LIRGenerator''newVariable-2 lirGen, lirKind)
                    #_"LIRInstruction" save (MoveFactory''createMove-3 (:moveFactory lirGen), saveVariable, registerValue)
                ]
                    (§ ass! buffer (LIRInsertionBuffer''append-3 buffer, 1, save))
                    (RegisterMap''put-3 saveMap, register, saveVariable)
                    (aset savedRegisterValues i registerValue)
                    (recur (inc i) (next s))
                )
            )
            (§ ass! entry (LabelOp''addIncomingValues-2 entry, savedRegisterValues))
            (§ ass! buffer (LIRInsertionBuffer''finish-1 buffer))
            saveMap
        )
    )

    (§ defn- #_"void" SaveCalleeSaveRegisters'restoreAtExit-5 [#_"LIR" lir, #_"MoveFactory" moveFactory, #_"LIRGenerationResult" lirGenRes, #_"RegisterMap<Variable>" calleeSaveRegisters, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
            #_"int" i (dec (count ops))
            #_"LIRInsertionBuffer" buffer (LIRInsertionBuffer'new-0)
        ]
            (§ ass! buffer (LIRInsertionBuffer''init-2 buffer, ops))
            (RegisterMap''forEach-2 calleeSaveRegisters, (ß (Register register, Variable saved) ->
                (§ fun
                    (§ ass! buffer (LIRInsertionBuffer''append-3 buffer, i, (MoveFactory''createMove-3 moveFactory, (#_"Register" .asValue register, (#_"Value" .getValueKind saved)), saved)))
                ))
            )
            (§ ass! buffer (LIRInsertionBuffer''finish-1 buffer))
        )
        nil
    )

    #_unused
    (§ override! #_"void" SaveCalleeSaveRegisters''run-3 [#_"SaveCalleeSaveRegisters" this, #_"LIRGenerationResult" lirGenRes, #_"PreAllocationOptimizationContext" context]
        (let [
            #_"RegisterArray" calleeSaveRegisters (#_"RegisterConfig" .getCalleeSaveRegisters HotSpot'registerConfig)
        ]
            (when (and (some? calleeSaveRegisters) (not (zero? (#_"RegisterArray" .size calleeSaveRegisters))))
                (let [
                    #_"LIR" lir (:lir lirGenRes)
                    #_"RegisterMap<Variable>" savedRegisters (SaveCalleeSaveRegisters'saveAtEntry-5 lir, (:lirGen context), lirGenRes, calleeSaveRegisters, (.arch HotSpot'target))
                ]
                    (doseq [#_"Block" block (:codeEmittingOrder lir)]
                        (when (and (some? block) (empty? (:successors block)))
                            (SaveCalleeSaveRegisters'restoreAtExit-5 lir, (:moveFactory (:lirGen context)), lirGenRes, savedRegisters, block)
                        )
                    )
                )
            )
        )
        nil
    )
)

(final-ns AMD64AddressValue (§ extends CompositeValue)
    ; @Component({OperandFlag'REG, OperandFlag'ILLEGAL})
    (§ mutable #_"AllocatableValue" :base nil)
    ; @Component({OperandFlag'REG, OperandFlag'ILLEGAL})
    (§ mutable #_"AllocatableValue" :index nil)
    (§ final #_"Scale" :scale nil)
    (§ final #_"int" :displacement 0)

    (§ def- #_"EnumSet<OperandFlag>" AMD64AddressValue'flags (EnumSet/of OperandFlag'REG, OperandFlag'ILLEGAL))

    (§ defn #_"AMD64AddressValue" AMD64AddressValue'new-3 [#_"ValueKind" kind, #_"AllocatableValue" base, #_"int" displacement]
        (AMD64AddressValue'new-5 kind, base, Value/ILLEGAL, Scale'Times1, displacement)
    )

    (§ defn #_"AMD64AddressValue" AMD64AddressValue'new-5 [#_"ValueKind" kind, #_"AllocatableValue" base, #_"AllocatableValue" index, #_"Scale" scale, #_"int" displacement]
        (let [
            #_"AMD64AddressValue" this (CompositeValue'new-1 kind)
            this (assoc this :base base)
            this (assoc this :index index)
            this (assoc this :scale scale)
            this (assoc this :displacement displacement)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"CompositeValue" AMD64AddressValue''forEachComponent-4 [#_"AMD64AddressValue" this, #_"LIRInstruction" op, #_"OperandMode" mode, #_"InstructionValueProcedure" proc]
        (let [
            #_"AllocatableValue" base (InstructionValueProcedure''doValue-5 proc, op, (:base this), mode, AMD64AddressValue'flags)
            #_"AllocatableValue" index (InstructionValueProcedure''doValue-5 proc, op, (:index this), mode, AMD64AddressValue'flags)
        ]
            (if (and (#_"AllocatableValue" .identityEquals (:base this), base) (#_"AllocatableValue" .identityEquals (:index this), index))
                this
                (AMD64AddressValue'new-5 (#_"Value" .getValueKind this), base, index, (:scale this), (:displacement this))
            )
        )
    )

    #_unused
    (§ override! #_"void" AMD64AddressValue''visitEachComponent-4 [#_"AMD64AddressValue" this, #_"LIRInstruction" op, #_"OperandMode" mode, #_"InstructionValueConsumer" proc]
        (InstructionValueConsumer''visitValue-5 proc, op, (:base this), mode, AMD64AddressValue'flags)
        (InstructionValueConsumer''visitValue-5 proc, op, (:index this), mode, AMD64AddressValue'flags)
        nil
    )

    #_unused
    (§ method! #_"AMD64AddressValue" AMD64AddressValue''withKind-2 [#_"AMD64AddressValue" this, #_"ValueKind" newKind]
        (AMD64AddressValue'new-5 newKind, (:base this), (:index this), (:scale this), (:displacement this))
    )

    (§ defn- #_"Register" AMD64AddressValue'toRegister-1 [#_"AllocatableValue" value]
        (if (= value Value/ILLEGAL) Register/None (#_"RegisterValue" .getRegister value))
    )

    (§ method! #_"AMD64Address" AMD64AddressValue''toAddress-1 [#_"AMD64AddressValue" this]
        (AMD64Address'new-4 (AMD64AddressValue'toRegister-1 (:base this)), (AMD64AddressValue'toRegister-1 (:index this)), (:scale this), (:displacement this))
    )

    (§ method! #_"boolean" AMD64AddressValue''isValidImplicitNullCheckFor-3 [#_"AMD64AddressValue" this, #_"Value" value, #_"int" implicitNullCheckLimit]
        (and (= value (:base this)) (= (:index this) Value/ILLEGAL) (< -1 (:displacement this) implicitNullCheckLimit))
    )
)

;;;
 ; AMD64 LIR instructions that have two inputs and one output.
 ;;
(value-ns AMD64Binary
)

;;;
 ; Instruction that has two AllocatableValue operands.
 ;
 ; @anno AMD64Binary.TwoOp
 ;;
(final-ns TwoOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<TwoOp>" TwoOp'TYPE (LIRInstructionClass'new-1 TwoOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :x nil)
    ;;;
     ; This argument must be Alive to ensure that result and y are not assigned
     ; to the same register, which would break the code generation by destroying y too early.
     ;;
    ; @Alive({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :y nil)

    (§ defn #_"TwoOp" TwoOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (let [
            #_"TwoOp" this (LIRInstruction'new-1 TwoOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" TwoOp''emitCode-2 [#_"TwoOp" this, #_"Assembler" asm]
        (AMD64Move'move-3 asm, (:result this), (:x this))
        (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (if (instance? RegisterValue (:y this)) (#_"RegisterValue" .getRegister (:y this)) (Assembler''asAddress-2 asm, (:y this))))
        nil
    )
)

;;;
 ; Commutative instruction that has two AllocatableValue operands.
 ;
 ; @anno AMD64Binary.CommutativeTwoOp
 ;;
(final-ns CommutativeTwoOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<CommutativeTwoOp>" CommutativeTwoOp'TYPE (LIRInstructionClass'new-1 CommutativeTwoOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :x nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :y nil)

    (§ defn #_"CommutativeTwoOp" CommutativeTwoOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (let [
            #_"CommutativeTwoOp" this (LIRInstruction'new-1 CommutativeTwoOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" CommutativeTwoOp''emitCode-2 [#_"CommutativeTwoOp" this, #_"Assembler" asm]
        (let [
            #_"AllocatableValue" input
                (when-not (LIRValueUtil'sameRegister-2 (:result this), (:y this)) => (:x this)
                    (AMD64Move'move-3 asm, (:result this), (:x this))
                    (:y this)
                )
        ]
            (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (if (instance? RegisterValue input) (#_"RegisterValue" .getRegister input) (Assembler''asAddress-2 asm, input)))
        )
        nil
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one 32-bit immediate operand.
 ;
 ; @anno AMD64Binary.ConstOp
 ;;
(final-ns ConstOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<ConstOp>" ConstOp'TYPE (LIRInstructionClass'new-1 ConstOp))

    ; @LIROpcode
    (§ final #_"AMD64MIOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :x nil)
    (§ final #_"int" :y 0)

    (§ defn #_"ConstOp" ConstOp'new-5 [#_"BinaryArithmetic" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"int" y]
        (ConstOp'new-5 (BinaryArithmetic''getMIOpcode-3 opcode, size, (NumUtil'isByte-1 y)), size, result, x, y)
    )

    (§ defn #_"ConstOp" ConstOp'new-5 [#_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"int" y]
        (let [
            #_"ConstOp" this (LIRInstruction'new-1 ConstOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ConstOp''emitCode-2 [#_"ConstOp" this, #_"Assembler" asm]
        (AMD64Move'move-3 asm, (:result this), (:x this))
        (AMD64MIOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (:y this))
        nil
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one
 ; DataSectionReference operand.
 ;
 ; @anno AMD64Binary.DataTwoOp
 ;;
(final-ns DataTwoOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<DataTwoOp>" DataTwoOp'TYPE (LIRInstructionClass'new-1 DataTwoOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :x nil)
    (§ final #_"JavaConstant" :y nil)

    (§ final #_"int" :alignment 0)

    (§ defn #_"DataTwoOp" DataTwoOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"JavaConstant" y]
        (DataTwoOp'new-6 opcode, size, result, x, y, (#_"JavaKind" .getByteCount (#_"JavaConstant" .getJavaKind y)))
    )

    (§ defn #_"DataTwoOp" DataTwoOp'new-6 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"JavaConstant" y, #_"int" alignment]
        (let [
            #_"DataTwoOp" this (LIRInstruction'new-1 DataTwoOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :x x)
            this (assoc this :y y)
            this (assoc this :alignment alignment)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" DataTwoOp''emitCode-2 [#_"DataTwoOp" this, #_"Assembler" asm]
        (AMD64Move'move-3 asm, (:result this), (:x this))
        (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (Assembler''recordDataReferenceInCode-3 asm, (:y this), (:alignment this)))
        nil
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one {@link AMD64AddressValue
 ; memory} operand.
 ;
 ; @anno AMD64Binary.MemoryTwoOp
 ;;
(final-ns MemoryTwoOp (§ extends LIRInstruction) (§ implements ImplicitNullCheck)
    (§ def #_"LIRInstructionClass<MemoryTwoOp>" MemoryTwoOp'TYPE (LIRInstructionClass'new-1 MemoryTwoOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :x nil)
    ; @Alive({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :y nil)

    (§ defn #_"MemoryTwoOp" MemoryTwoOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"AMD64AddressValue" y]
        (let [
            #_"MemoryTwoOp" this (LIRInstruction'new-1 MemoryTwoOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MemoryTwoOp''emitCode-2 [#_"MemoryTwoOp" this, #_"Assembler" asm]
        (AMD64Move'move-3 asm, (:result this), (:x this))
        (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:y this)))
        nil
    )

    #_unused
    (§ override! #_"boolean" MemoryTwoOp''makeNullCheckFor-3 [#_"MemoryTwoOp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
        (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:y this), value, implicitNullCheckLimit)
    )
)

;;;
 ; Instruction with a separate result operand, one AllocatableValue input and one 32-bit
 ; immediate input.
 ;
 ; @anno AMD64Binary.RMIOp
 ;;
(final-ns RMIOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<RMIOp>" RMIOp'TYPE (LIRInstructionClass'new-1 RMIOp))

    ; @LIROpcode
    (§ final #_"AMD64RMIOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :x nil)
    (§ final #_"int" :y 0)

    (§ defn #_"RMIOp" RMIOp'new-5 [#_"AMD64RMIOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"int" y]
        (let [
            #_"RMIOp" this (LIRInstruction'new-1 RMIOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" RMIOp''emitCode-2 [#_"RMIOp" this, #_"Assembler" asm]
        (AMD64RMIOp''emit-6 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (if (instance? RegisterValue (:x this)) (#_"RegisterValue" .getRegister (:x this)) (Assembler''asAddress-2 asm, (:x this))), (:y this))
        nil
    )
)

;;;
 ; AMD64 LIR instructions that have two input operands, but no output operand.
 ;;
(value-ns AMD64BinaryConsumer
)

;;;
 ; Instruction that has two AllocatableValue operands.
 ;
 ; @anno AMD64BinaryConsumer.ConsumerOp
 ;;
(final-ns ConsumerOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<ConsumerOp>" ConsumerOp'TYPE (LIRInstructionClass'new-1 ConsumerOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :x nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :y nil)

    (§ defn #_"ConsumerOp" ConsumerOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (let [
            #_"ConsumerOp" this (LIRInstruction'new-1 ConsumerOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ConsumerOp''emitCode-2 [#_"ConsumerOp" this, #_"Assembler" asm]
        (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:x this)), (if (instance? RegisterValue (:y this)) (#_"RegisterValue" .getRegister (:y this)) (Assembler''asAddress-2 asm, (:y this))))
        nil
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one 32-bit immediate operand.
 ;
 ; @anno AMD64BinaryConsumer.ConsumerConstOp
 ;;
(class-ns ConsumerConstOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<ConsumerConstOp>" ConsumerConstOp'TYPE (LIRInstructionClass'new-1 ConsumerConstOp))

    ; @LIROpcode
    (§ final #_"AMD64MIOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :x nil)
    (§ final #_"int" :y 0)

    (§ defn #_"ConsumerConstOp" ConsumerConstOp'new-4 [#_"BinaryArithmetic" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"int" y]
        (ConsumerConstOp'new-4 (BinaryArithmetic''getMIOpcode-3 opcode, size, (NumUtil'isByte-1 y)), size, x, y)
    )

    (§ defn #_"ConsumerConstOp" ConsumerConstOp'new-4 [#_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"int" y]
        (ConsumerConstOp'new-5 ConsumerConstOp'TYPE, opcode, size, x, y)
    )

    (§ defn #_"ConsumerConstOp" ConsumerConstOp'new-5 [#_"LIRInstructionClass<? extends ConsumerConstOp>" c, #_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"int" y]
        (let [
            #_"ConsumerConstOp" this (LIRInstruction'new-1 c)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    (§ override #_"void" ConsumerConstOp''emitCode-2 [#_"ConsumerConstOp" this, #_"Assembler" asm]
        (AMD64MIOp''emit-5 (:opcode this), asm, (:size this), (if (instance? RegisterValue (:x this)) (#_"RegisterValue" .getRegister (:x this)) (Assembler''asAddress-2 asm, (:x this))), (:y this))
        nil
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one 32-bit immediate operand
 ; that needs to be patched at runtime.
 ;
 ; @anno AMD64BinaryConsumer.VMConstOp
 ;;
(final-ns VMConstOp (§ extends ConsumerConstOp)
    (§ def #_"LIRInstructionClass<VMConstOp>" VMConstOp'TYPE (LIRInstructionClass'new-1 VMConstOp))

    (§ final #_"VMConstant" :c nil)

    (§ defn #_"VMConstOp" VMConstOp'new-3 [#_"AMD64MIOp" opcode, #_"AllocatableValue" x, #_"VMConstant" c]
        (let [
            #_"VMConstOp" this (ConsumerConstOp'new-5 VMConstOp'TYPE, opcode, OperandSize'DWORD, x, 0xdeaddead)
            this (assoc this :c c)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" VMConstOp''emitCode-2 [#_"VMConstOp" this, #_"Assembler" asm]
        (Assembler''recordInlineDataInCode-2 asm, (:c this))
        (ConsumerConstOp''emitCode-2 (§ super ), asm)
        nil
    )
)

;;;
 ; Instruction that has one AllocatableValue operand and one
 ; DataSectionReference operand.
 ;
 ; @anno AMD64BinaryConsumer.DataOp
 ;;
(final-ns DataOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<DataOp>" DataOp'TYPE (LIRInstructionClass'new-1 DataOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :x nil)
    (§ final #_"Constant" :y nil)

    (§ final #_"int" :alignment 0)

    (§ defn #_"DataOp" DataOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"Constant" y]
        (DataOp'new-5 opcode, size, x, y, (:bytes size))
    )

    (§ defn #_"DataOp" DataOp'new-5 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"Constant" y, #_"int" alignment]
        (let [
            #_"DataOp" this (LIRInstruction'new-1 DataOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :x x)
            this (assoc this :y y)
            this (assoc this :alignment alignment)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" DataOp''emitCode-2 [#_"DataOp" this, #_"Assembler" asm]
        (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:x this)), (Assembler''recordDataReferenceInCode-3 asm, (:y this), (:alignment this)))
        nil
    )
)

;;;
 ; Instruction that has an AllocatableValue as first input and a
 ; {@link AMD64AddressValue memory} operand as second input.
 ;
 ; @anno AMD64BinaryConsumer.MemoryRMOp
 ;;
(final-ns MemoryRMOp (§ extends LIRInstruction) (§ implements ImplicitNullCheck)
    (§ def #_"LIRInstructionClass<MemoryRMOp>" MemoryRMOp'TYPE (LIRInstructionClass'new-1 MemoryRMOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :x nil)
    ; @Use({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :y nil)

    #_unused
    (§ defn #_"MemoryRMOp" MemoryRMOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" x, #_"AMD64AddressValue" y]
        (let [
            #_"MemoryRMOp" this (LIRInstruction'new-1 MemoryRMOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MemoryRMOp''emitCode-2 [#_"MemoryRMOp" this, #_"Assembler" asm]
        (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:x this)), (AMD64AddressValue''toAddress-1 (:y this)))
        nil
    )

    #_unused
    (§ override! #_"boolean" MemoryRMOp''makeNullCheckFor-3 [#_"MemoryRMOp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
        (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:y this), value, implicitNullCheckLimit)
    )
)

;;;
 ; Instruction that has a {@link AMD64AddressValue memory} operand as first input and an
 ; AllocatableValue as second input.
 ;
 ; @anno AMD64BinaryConsumer.MemoryMROp
 ;;
(final-ns MemoryMROp (§ extends LIRInstruction) (§ implements ImplicitNullCheck)
    (§ def #_"LIRInstructionClass<MemoryMROp>" MemoryMROp'TYPE (LIRInstructionClass'new-1 MemoryMROp))

    ; @LIROpcode
    (§ final #_"AMD64MROp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Use({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :x nil)
    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :y nil)

    (§ defn #_"MemoryMROp" MemoryMROp'new-4 [#_"AMD64MROp" opcode, #_"OperandSize" size, #_"AMD64AddressValue" x, #_"AllocatableValue" y]
        (let [
            #_"MemoryMROp" this (LIRInstruction'new-1 MemoryMROp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MemoryMROp''emitCode-2 [#_"MemoryMROp" this, #_"Assembler" asm]
        (AMD64MROp''emit-5 (:opcode this), asm, (:size this), (AMD64AddressValue''toAddress-1 (:x this)), (#_"RegisterValue" .getRegister (:y this)))
        nil
    )

    #_unused
    (§ override! #_"boolean" MemoryMROp''makeNullCheckFor-3 [#_"MemoryMROp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
        (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:x this), value, implicitNullCheckLimit)
    )
)

;;;
 ; Instruction that has one {@link AMD64AddressValue memory} operand and one 32-bit immediate operand.
 ;
 ; @anno AMD64BinaryConsumer.MemoryConstOp
 ;;
(class-ns MemoryConstOp (§ extends LIRInstruction) (§ implements ImplicitNullCheck)
    (§ def #_"LIRInstructionClass<MemoryConstOp>" MemoryConstOp'TYPE (LIRInstructionClass'new-1 MemoryConstOp))

    ; @LIROpcode
    (§ final #_"AMD64MIOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Use({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :x nil)
    (§ final #_"int" :y 0)

    (§ defn #_"MemoryConstOp" MemoryConstOp'new-4 [#_"BinaryArithmetic" opcode, #_"OperandSize" size, #_"AMD64AddressValue" x, #_"int" y]
        (MemoryConstOp'new-4 (BinaryArithmetic''getMIOpcode-3 opcode, size, (NumUtil'isByte-1 y)), size, x, y)
    )

    (§ defn #_"MemoryConstOp" MemoryConstOp'new-4 [#_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AMD64AddressValue" x, #_"int" y]
        (MemoryConstOp'new-5 MemoryConstOp'TYPE, opcode, size, x, y)
    )

    (§ defn #_"MemoryConstOp" MemoryConstOp'new-5 [#_"LIRInstructionClass<? extends MemoryConstOp>" c, #_"AMD64MIOp" opcode, #_"OperandSize" size, #_"AMD64AddressValue" x, #_"int" y]
        (let [
            #_"MemoryConstOp" this (LIRInstruction'new-1 c)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    (§ override #_"void" MemoryConstOp''emitCode-2 [#_"MemoryConstOp" this, #_"Assembler" asm]
        (AMD64MIOp''emit-5 (:opcode this), asm, (:size this), (AMD64AddressValue''toAddress-1 (:x this)), (:y this))
        nil
    )

    #_unused
    (§ override #_"boolean" MemoryConstOp''makeNullCheckFor-3 [#_"MemoryConstOp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
        (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:x this), value, implicitNullCheckLimit)
    )

    #_unused
    (§ method #_"AMD64MIOp" MemoryConstOp''getOpcode-1 [#_"MemoryConstOp" this]
        (:opcode this)
    )
)

;;;
 ; Instruction that has one {@link AMD64AddressValue memory} operand and one 32-bit immediate
 ; operand that needs to be patched at runtime.
 ;
 ; @anno AMD64BinaryConsumer.MemoryVMConstOp
 ;;
(final-ns MemoryVMConstOp (§ extends MemoryConstOp)
    (§ def #_"LIRInstructionClass<MemoryVMConstOp>" MemoryVMConstOp'TYPE (LIRInstructionClass'new-1 MemoryVMConstOp))

    (§ final #_"VMConstant" :c nil)

    (§ defn #_"MemoryVMConstOp" MemoryVMConstOp'new-3 [#_"AMD64MIOp" opcode, #_"AMD64AddressValue" x, #_"VMConstant" c]
        (let [
            #_"MemoryVMConstOp" this (MemoryConstOp'new-5 MemoryVMConstOp'TYPE, opcode, OperandSize'DWORD, x, 0xdeaddead)
            this (assoc this :c c)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MemoryVMConstOp''emitCode-2 [#_"MemoryVMConstOp" this, #_"Assembler" asm]
        (Assembler''recordInlineDataInCode-2 asm, (:c this))
        (MemoryConstOp''emitCode-2 (§ super ), asm)
        nil
    )
)

; @LIROpcode
(final-ns AMD64ByteSwapOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64ByteSwapOp>" AMD64ByteSwapOp'TYPE (LIRInstructionClass'new-1 AMD64ByteSwapOp))

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"Value" :result nil)
    ; @Use
    (§ mutable #_"Value" :input nil)

    (§ defn #_"AMD64ByteSwapOp" AMD64ByteSwapOp'new-2 [#_"Value" result, #_"Value" input]
        (let [
            #_"AMD64ByteSwapOp" this (LIRInstruction'new-1 AMD64ByteSwapOp'TYPE)
            this (assoc this :result result)
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64ByteSwapOp''emitCode-2 [#_"AMD64ByteSwapOp" this, #_"Assembler" asm]
        (AMD64Move'move-3 asm, (:result this), (:input this))
        (condp = (#_"Value" .getPlatformKind (:input this))
            AMD64Kind/DWORD (Assembler''bswapl-2 asm, (#_"RegisterValue" .getRegister (:result this)))
            AMD64Kind/QWORD (Assembler''bswapq-2 asm, (#_"RegisterValue" .getRegister (:result this)))
        )
        nil
    )
)

(value-ns AMD64Call
    (§ defn- #_"void" AMD64Call'emitAlignmentForDirectCall-1 [#_"Assembler" asm]
        ;; make sure that the displacement word of the call ends up word aligned
        (let [
            #_"int" offset (+ (Assembler''position-1 asm) (#_"Architecture" .getMachineCodeCallDisplacementOffset (.arch HotSpot'target)))
            #_"int" modulus (.wordSize HotSpot'target)
        ]
            (when-not (zero? (% offset modulus))
                (Assembler''nop-2 asm, (- modulus (% offset modulus)))
            )
        )
        nil
    )

    (§ defn #_"int" AMD64Call'directCall-4 [#_"Assembler" asm, #_"InvokeTarget" callTarget, #_"Register" scratch, #_"boolean" align?]
        (when align?
            (AMD64Call'emitAlignmentForDirectCall-1 asm)
        )
        (let [
            #_"int" callPCOffset
                (if (some? scratch)
                    (do
                        ;; offset might not fit a 32-bit immediate, generate an indirect call with a 64-bit immediate
                        (Assembler''movq-3 asm, scratch, 0)
                        (let [
                            callPCOffset (Assembler''position-1 asm)
                        ]
                            (Assembler''call-2 asm, scratch)
                            callPCOffset
                        )
                    )
                    (let [
                        callPCOffset (Assembler''position-1 asm)
                    ]
                        (Assembler''call-1 asm)
                        callPCOffset
                    )
                )
        ]
            (Assembler''ensureUniquePC-1 asm)
            callPCOffset
        )
    )

    (§ defn #_"void" AMD64Call'directJmp-2 [#_"Assembler" asm, #_"InvokeTarget" target]
        (Assembler''jmp-3 asm, 0, true)
        (Assembler''ensureUniquePC-1 asm)
        nil
    )

    #_unused
    (§ defn #_"void" AMD64Call'directConditionalJmp-3 [#_"Assembler" asm, #_"InvokeTarget" target, #_"ConditionFlag" cond]
        (Assembler''jcc-4 asm, cond, 0, true)
        (Assembler''ensureUniquePC-1 asm)
        nil
    )

    (§ defn #_"int" AMD64Call'indirectCall-3 [#_"Assembler" asm, #_"Register" dst, #_"InvokeTarget" callTarget]
        (let [
            #_"int" before (Assembler''position-1 asm)
        ]
            (Assembler''call-2 asm, dst)
            (Assembler''ensureUniquePC-1 asm)
            before
        )
    )
)

;;;
 ; @anno AMD64Call.CallOp
 ;;
(class-ns CallOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<CallOp>" CallOp'TYPE (LIRInstructionClass'new-1 CallOp))

    ; @Def({OperandFlag'REG, OperandFlag'ILLEGAL})
    (§ mutable #_"Value" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"Value[]" :parameters nil)
    ; @Temp({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"Value[]" :temporaries nil)

    (§ defn #_"CallOp" CallOp'new-4 [#_"LIRInstructionClass<? extends CallOp>" c, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temporaries]
        (let [
            #_"CallOp" this (LIRInstruction'new-1 c)
            this (assoc this :result result)
            this (assoc this :parameters parameters)
            this (assoc this :temporaries (LIRInstruction'addStackSlotsToTemporaries-2 parameters, temporaries))
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" CallOp''destroysCallerSavedRegisters-1 [#_"CallOp" this]
        true
    )
)

;;;
 ; @anno AMD64Call.MethodCallOp
 ;;
(class-ns MethodCallOp (§ extends CallOp)
    (§ def #_"LIRInstructionClass<MethodCallOp>" MethodCallOp'TYPE (LIRInstructionClass'new-1 MethodCallOp))

    (§ final #_"ResolvedJavaMethod" :callTarget nil)

    (§ defn #_"MethodCallOp" MethodCallOp'new-5 [#_"LIRInstructionClass<? extends MethodCallOp>" c, #_"ResolvedJavaMethod" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (let [
            #_"MethodCallOp" this (CallOp'new-4 c, result, parameters, temps)
            this (assoc this :callTarget callTarget)
        ]
            this
        )
    )
)

;;;
 ; @anno AMD64Call.DirectCallOp
 ;;
; @LIROpcode
(class-ns DirectCallOp (§ extends MethodCallOp)
    (§ def #_"LIRInstructionClass<DirectCallOp>" DirectCallOp'TYPE (LIRInstructionClass'new-1 DirectCallOp))

    #_unused
    (§ defn #_"DirectCallOp" DirectCallOp'new-4 [#_"ResolvedJavaMethod" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (DirectCallOp'new-5 DirectCallOp'TYPE, callTarget, result, parameters, temps)
    )

    (§ defn #_"DirectCallOp" DirectCallOp'new-5 [#_"LIRInstructionClass<? extends DirectCallOp>" c, #_"ResolvedJavaMethod" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (MethodCallOp'new-5 c, callTarget, result, parameters, temps)
    )

    (§ override #_"void" DirectCallOp''emitCode-2 [#_"DirectCallOp" this, #_"Assembler" asm]
        (AMD64Call'directCall-4 asm, (:callTarget this), nil, true)
        nil
    )

    (§ method! #_"int" DirectCallOp''emitCall-2 [#_"DirectCallOp" this, #_"Assembler" asm]
        (AMD64Call'directCall-4 asm, (:callTarget this), nil, true)
    )
)

;;;
 ; @anno AMD64Call.IndirectCallOp
 ;;
; @LIROpcode
(class-ns IndirectCallOp (§ extends MethodCallOp)
    (§ def #_"LIRInstructionClass<IndirectCallOp>" IndirectCallOp'TYPE (LIRInstructionClass'new-1 IndirectCallOp))

    ; @Use({OperandFlag'REG})
    (§ mutable #_"Value" :targetAddress nil)

    (§ defn #_"IndirectCallOp" IndirectCallOp'new-5 [#_"ResolvedJavaMethod" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps, #_"Value" targetAddress]
        (IndirectCallOp'new-6 IndirectCallOp'TYPE, callTarget, result, parameters, temps, targetAddress)
    )

    (§ defn #_"IndirectCallOp" IndirectCallOp'new-6 [#_"LIRInstructionClass<? extends IndirectCallOp>" c, #_"ResolvedJavaMethod" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps, #_"Value" targetAddress]
        (let [
            #_"IndirectCallOp" this (MethodCallOp'new-5 c, callTarget, result, parameters, temps)
            this (assoc this :targetAddress targetAddress)
        ]
            this
        )
    )

    #_unused
    (§ override #_"void" IndirectCallOp''emitCode-2 [#_"IndirectCallOp" this, #_"Assembler" asm]
        (AMD64Call'indirectCall-3 asm, (#_"RegisterValue" .getRegister (:targetAddress this)), (:callTarget this))
        nil
    )
)

;;;
 ; @anno AMD64Call.ForeignCallOp
 ;;
(class-ns ForeignCallOp (§ extends CallOp)
    (§ def #_"LIRInstructionClass<ForeignCallOp>" ForeignCallOp'TYPE (LIRInstructionClass'new-1 ForeignCallOp))

    (§ final #_"ForeignCallLinkage" :callTarget nil)

    (§ defn #_"ForeignCallOp" ForeignCallOp'new-5 [#_"LIRInstructionClass<? extends ForeignCallOp>" c, #_"ForeignCallLinkage" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (let [
            #_"ForeignCallOp" this (CallOp'new-4 c, result, parameters, temps)
            this (assoc this :callTarget callTarget)
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" ForeignCallOp''destroysCallerSavedRegisters-1 [#_"ForeignCallOp" this]
        (ForeignCallLinkage''destroysRegisters-1 (:callTarget this))
    )
)

;;;
 ; @anno AMD64Call.DirectNearForeignCallOp
 ;;
; @LIROpcode
(final-ns DirectNearForeignCallOp (§ extends ForeignCallOp)
    (§ def #_"LIRInstructionClass<DirectNearForeignCallOp>" DirectNearForeignCallOp'TYPE (LIRInstructionClass'new-1 DirectNearForeignCallOp))

    (§ defn #_"DirectNearForeignCallOp" DirectNearForeignCallOp'new-4 [#_"ForeignCallLinkage" linkage, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (ForeignCallOp'new-5 DirectNearForeignCallOp'TYPE, linkage, result, parameters, temps)
    )

    #_unused
    (§ override! #_"void" DirectNearForeignCallOp''emitCode-2 [#_"DirectNearForeignCallOp" this, #_"Assembler" asm]
        (AMD64Call'directCall-4 asm, (:callTarget this), nil, false)
        nil
    )
)

;;;
 ; @anno AMD64Call.DirectFarForeignCallOp
 ;;
; @LIROpcode
(final-ns DirectFarForeignCallOp (§ extends ForeignCallOp)
    (§ def #_"LIRInstructionClass<DirectFarForeignCallOp>" DirectFarForeignCallOp'TYPE (LIRInstructionClass'new-1 DirectFarForeignCallOp))

    ; @Temp({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :callTemp nil)

    (§ defn #_"DirectFarForeignCallOp" DirectFarForeignCallOp'new-4 [#_"ForeignCallLinkage" callTarget, #_"Value" result, #_"Value[]" parameters, #_"Value[]" temps]
        (let [
            #_"DirectFarForeignCallOp" this (ForeignCallOp'new-5 DirectFarForeignCallOp'TYPE, callTarget, result, parameters, temps)
            ;; The register allocator does not support virtual registers that are used at the call site, so use a fixed register.
            this (assoc this :callTemp (#_"Register" .asValue AMD64/rax, (LIRKind'value-1 AMD64Kind/QWORD)))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" DirectFarForeignCallOp''emitCode-2 [#_"DirectFarForeignCallOp" this, #_"Assembler" asm]
        (AMD64Call'directCall-4 asm, (:callTarget this), (#_"RegisterValue" .getRegister (:callTemp this)), false)
        nil
    )
)

(final-ns AMD64CCall (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64CCall>" AMD64CCall'TYPE (LIRInstructionClass'new-1 AMD64CCall))

    ; @Def({OperandFlag'REG, OperandFlag'ILLEGAL})
    (§ mutable #_"Value" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"Value[]" :parameters nil)
    ; @Use({OperandFlag'REG})
    (§ mutable #_"Value" :functionPtr nil)

    (§ defn #_"AMD64CCall" AMD64CCall'new-3 [#_"Value" result, #_"Value" functionPtr, #_"Value[]" parameters]
        (let [
            #_"AMD64CCall" this (LIRInstruction'new-1 AMD64CCall'TYPE)
            this (assoc this :result result)
            this (assoc this :functionPtr functionPtr)
            this (assoc this :parameters parameters)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64CCall''emitCode-2 [#_"AMD64CCall" this, #_"Assembler" asm]
        (let [
            #_"Register" reg (#_"RegisterValue" .getRegister (:functionPtr this))
        ]
            (Assembler''call-2 asm, reg)
            (Assembler''ensureUniquePC-1 asm)
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" AMD64CCall''destroysCallerSavedRegisters-1 [#_"AMD64CCall" this]
        true
    )
)

(final-ns AMD64ClearRegisterOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64ClearRegisterOp>" AMD64ClearRegisterOp'TYPE (LIRInstructionClass'new-1 AMD64ClearRegisterOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :op nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :result nil)

    (§ defn #_"AMD64ClearRegisterOp" AMD64ClearRegisterOp'new-2 [#_"OperandSize" size, #_"AllocatableValue" result]
        (let [
            #_"AMD64ClearRegisterOp" this (LIRInstruction'new-1 AMD64ClearRegisterOp'TYPE)
            this (assoc this :op (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'XOR, size))
            this (assoc this :size size)
            this (assoc this :result result)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64ClearRegisterOp''emitCode-2 [#_"AMD64ClearRegisterOp" this, #_"Assembler" asm]
        (AMD64RMOp''emit-5 (:op this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (#_"RegisterValue" .getRegister (:result this)))
        nil
    )
)

(value-ns AMD64ControlFlow
    (§ defn #_"void" AMD64ControlFlow'cmove-4 [#_"Assembler" asm, #_"Value" result, #_"ConditionFlag" cond, #_"Value" other]
        (if (instance? RegisterValue other)
            (condp =? (#_"Value" .getPlatformKind other)
               [AMD64Kind/BYTE AMD64Kind/WORD AMD64Kind/DWORD]
                    (Assembler''cmovl-4 asm, cond, (#_"RegisterValue" .getRegister result), (#_"RegisterValue" .getRegister other))
                AMD64Kind/QWORD
                    (Assembler''cmovq-4 asm, cond, (#_"RegisterValue" .getRegister result), (#_"RegisterValue" .getRegister other))
            )
            (let [
                #_"AMD64Address" addr (Assembler''asAddress-2 asm, other)
            ]
                (condp =? (#_"Value" .getPlatformKind other)
                   [AMD64Kind/BYTE AMD64Kind/WORD AMD64Kind/DWORD]
                        (Assembler''cmovl-4 asm, cond, (#_"RegisterValue" .getRegister result), addr)
                    AMD64Kind/QWORD
                        (Assembler''cmovq-4 asm, cond, (#_"RegisterValue" .getRegister result), addr)
                )
            )
        )
        nil
    )

    (§ defn #_"void" AMD64ControlFlow'setcc-3 [#_"Assembler" asm, #_"Value" result, #_"ConditionFlag" cond]
        (condp =? (#_"Value" .getPlatformKind result)
           [AMD64Kind/BYTE AMD64Kind/WORD AMD64Kind/DWORD]
                (Assembler''setl-3 asm, cond, (#_"RegisterValue" .getRegister result))
            AMD64Kind/QWORD
                (Assembler''setq-3 asm, cond, (#_"RegisterValue" .getRegister result))
        )
        nil
    )

    (§ defn #_"ConditionFlag" AMD64ControlFlow'intCond-1 [#_"Condition" cond]
        (condp = cond
            Condition'EQ ConditionFlag'Equal
            Condition'NE ConditionFlag'NotEqual
            Condition'LT ConditionFlag'Less
            Condition'LE ConditionFlag'LessEqual
            Condition'GE ConditionFlag'GreaterEqual
            Condition'GT ConditionFlag'Greater
            Condition'BE ConditionFlag'BelowEqual
            Condition'AE ConditionFlag'AboveEqual
            Condition'AT ConditionFlag'Above
            Condition'BT ConditionFlag'Below
        )
    )
)

;;;
 ; @anno AMD64ControlFlow.ReturnOp
 ;;
(final-ns ReturnOp (§ extends LIRInstruction) (§ implements BlockEndOp)
    (§ def #_"LIRInstructionClass<ReturnOp>" ReturnOp'TYPE (LIRInstructionClass'new-1 ReturnOp))

    ; @Use({OperandFlag'REG, OperandFlag'ILLEGAL})
    (§ mutable #_"Value" :x nil)

    #_unused
    (§ defn #_"ReturnOp" ReturnOp'new-1 [#_"Value" x]
        (let [
            #_"ReturnOp" this (LIRInstruction'new-1 ReturnOp'TYPE)
            this (assoc this :x x)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ReturnOp''emitCode-2 [#_"ReturnOp" this, #_"Assembler" asm]
        (FrameContext''leave-2 (:frameContext asm), asm)
        (Assembler''ret-2 asm, 0)
        nil
    )
)

;;;
 ; @anno AMD64ControlFlow.BranchOp
 ;;
(final-ns BranchOp (§ extends LIRInstruction) (§ implements StandardBranchOp)
    (§ def #_"LIRInstructionClass<BranchOp>" BranchOp'TYPE (LIRInstructionClass'new-1 BranchOp))

    (§ final #_"ConditionFlag" :condition nil)
    (§ final #_"LabelRef" :trueDestination nil)
    (§ final #_"LabelRef" :falseDestination nil)

    (§ final #_"double" :trueDestinationProbability 0.0)

    (§ defn #_"BranchOp" BranchOp'new-4 [#_"Condition" condition, #_"LabelRef" trueDestination, #_"LabelRef" falseDestination, #_"double" trueDestinationProbability]
        (BranchOp'new-4 (AMD64ControlFlow'intCond-1 condition), trueDestination, falseDestination, trueDestinationProbability)
    )

    (§ defn #_"BranchOp" BranchOp'new-4 [#_"ConditionFlag" condition, #_"LabelRef" trueDestination, #_"LabelRef" falseDestination, #_"double" trueDestinationProbability]
        (BranchOp'new-5 BranchOp'TYPE, condition, trueDestination, falseDestination, trueDestinationProbability)
    )

    (§ defn #_"BranchOp" BranchOp'new-5 [#_"LIRInstructionClass<? extends BranchOp>" c, #_"ConditionFlag" condition, #_"LabelRef" trueDestination, #_"LabelRef" falseDestination, #_"double" trueDestinationProbability]
        (let [
            #_"BranchOp" this (LIRInstruction'new-1 c)
            this (assoc this :condition condition)
            this (assoc this :trueDestination trueDestination)
            this (assoc this :falseDestination falseDestination)
            this (assoc this :trueDestinationProbability trueDestinationProbability)
        ]
            this
        )
    )

    ;;;
     ; The strategy for emitting jumps is: If either trueDestination or falseDestination is the successor block,
     ; assume the block scheduler did the correct thing and jcc to the other. Otherwise, we need a jcc followed
     ; by a jmp. Use the branch probability to make sure it is more likely to branch on the jcc
     ; (= less likely to execute both the jcc and the jmp instead of just the jcc).
     ; In the case of loops, that means the jcc is the back-edge.
     ;;
    #_unused
    (§ override! #_"void" BranchOp''emitCode-2 [#_"BranchOp" this, #_"Assembler" asm]
        (cond
            (Assembler''isSuccessorEdge-2 asm, (:trueDestination this))  (BranchOp''jcc-4 this, asm, true, (:falseDestination this))
            (Assembler''isSuccessorEdge-2 asm, (:falseDestination this)) (BranchOp''jcc-4 this, asm, false, (:trueDestination this))
            :else
                (if (< (:trueDestinationProbability this) 0.5)
                    (do
                        (BranchOp''jcc-4 this, asm, true, (:falseDestination this))
                        (Assembler''jmp-2 asm, (LabelRef''label-1 (:trueDestination this)))
                    )
                    (do
                        (BranchOp''jcc-4 this, asm, false, (:trueDestination this))
                        (Assembler''jmp-2 asm, (LabelRef''label-1 (:falseDestination this)))
                    )
                )
        )
        nil
    )

    (§ method! #_"void" BranchOp''jcc-4 [#_"BranchOp" this, #_"Assembler" asm, #_"boolean" negate?, #_"LabelRef" target]
        (Assembler''jcc-3 asm, (if negate? (ConditionFlag''negate-1 (:condition this)) (:condition this)), (LabelRef''label-1 target))
        nil
    )
)

;;;
 ; @anno AMD64ControlFlow.StrategySwitchOp
 ;;
(class-ns StrategySwitchOp (§ extends LIRInstruction) (§ implements BlockEndOp)
    (§ def #_"LIRInstructionClass<StrategySwitchOp>" StrategySwitchOp'TYPE (LIRInstructionClass'new-1 StrategySwitchOp))

    (§ final #_"Constant[]" :keyConstants nil)
    (§ final #_"LabelRef[]" :keyTargets nil)
    (§ mutable #_"LabelRef" :defaultTarget nil)
    ; @Alive({OperandFlag'REG})
    (§ mutable #_"Value" :key nil)
    ; @Temp({OperandFlag'REG, OperandFlag'ILLEGAL})
    (§ mutable #_"Value" :scratch nil)
    (§ final #_"SwitchStrategy" :strategy nil)

    #_unused
    (§ defn #_"StrategySwitchOp" StrategySwitchOp'new-5 [#_"SwitchStrategy" strategy, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget, #_"Value" key, #_"Value" scratch]
        (StrategySwitchOp'new-6 StrategySwitchOp'TYPE, strategy, keyTargets, defaultTarget, key, scratch)
    )

    (§ defn #_"StrategySwitchOp" StrategySwitchOp'new-6 [#_"LIRInstructionClass<? extends StrategySwitchOp>" c, #_"SwitchStrategy" strategy, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget, #_"Value" key, #_"Value" scratch]
        (let [
            #_"StrategySwitchOp" this (LIRInstruction'new-1 c)
            this (assoc this :strategy strategy)
            this (assoc this :keyConstants (:keyConstants strategy))
            this (assoc this :keyTargets keyTargets)
            this (assoc this :defaultTarget defaultTarget)
            this (assoc this :key key)
            this (assoc this :scratch scratch)
        ]
            this
        )
    )

    #_unused
    (§ override #_"void" StrategySwitchOp''emitCode-2 [#_"StrategySwitchOp" this, #_"Assembler" asm]
        (SwitchStrategy''run-2 (:strategy this), (AMD64SwitchClosure'new-3 this, (#_"RegisterValue" .getRegister (:key this)), asm))
        nil
    )
)

;;;
 ; @anno AMD64ControlFlow.StrategySwitchOp.AMD64SwitchClosure
 ;;
(class-ns AMD64SwitchClosure (§ extends BaseSwitchClosure)
    (§ final #_"StrategySwitchOp" :op nil)

    (§ final #_"Register" :keyRegister nil)
    (§ final #_"Assembler" :asm nil)

    (§ defn #_"AMD64SwitchClosure" AMD64SwitchClosure'new-3 [#_"StrategySwitchOp" op, #_"Register" keyRegister, #_"Assembler" asm]
        (let [
            #_"AMD64SwitchClosure" this (BaseSwitchClosure'new-3 asm, (:keyTargets op), (:defaultTarget op))
            this (assoc this :op op)
            this (assoc this :keyRegister keyRegister)
            this (assoc this :asm asm)
        ]
            this
        )
    )

    (§ method #_"void" AMD64SwitchClosure''emitComparison-2 [#_"AMD64SwitchClosure" this, #_"Constant" c]
        (condp = (#_"JavaConstant" .getJavaKind c)
            JavaKind/Int  (Assembler''cmpl-3 (:asm this), (:keyRegister this), (int (#_"JavaConstant" .asLong c)))
            JavaKind/Long (Assembler''cmpq-3 (:asm this), (:keyRegister this), (Assembler''asLongConstRef-2 (:asm this), c))
            JavaKind/Object
                (do
                    (AMD64Move'const2reg-3 (:asm this), (#_"RegisterValue" .getRegister (:scratch (:op this))), c)
                    (Assembler''cmpptr-3 (:asm this), (:keyRegister this), (#_"RegisterValue" .getRegister (:scratch (:op this))))
                )
        )
        nil
    )

    #_unused
    (§ override #_"void" AMD64SwitchClosure''conditionalJump-4 [#_"AMD64SwitchClosure" this, #_"int" index, #_"Condition" condition, #_"Label" target]
        (AMD64SwitchClosure''emitComparison-2 this, (nth (:keyConstants (:op this)) index))
        (Assembler''jcc-3 (:asm this), (AMD64ControlFlow'intCond-1 condition), target)
        nil
    )
)

;;;
 ; @anno AMD64ControlFlow.TableSwitchOp
 ;;
(final-ns TableSwitchOp (§ extends LIRInstruction) (§ implements BlockEndOp)
    (§ def #_"LIRInstructionClass<TableSwitchOp>" TableSwitchOp'TYPE (LIRInstructionClass'new-1 TableSwitchOp))

    (§ final #_"int" :lowKey 0)
    (§ final #_"LabelRef" :defaultTarget nil)
    (§ final #_"LabelRef[]" :targets nil)
    ; @Use
    (§ mutable #_"Value" :index nil)
    ; @Temp({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"Value" :idxScratch nil)
    ; @Temp
    (§ mutable #_"Value" :scratch nil)

    (§ defn #_"TableSwitchOp" TableSwitchOp'new-6 [#_"int" lowKey, #_"LabelRef" defaultTarget, #_"LabelRef[]" targets, #_"Value" index, #_"Variable" scratch, #_"Variable" idxScratch]
        (let [
            #_"TableSwitchOp" this (LIRInstruction'new-1 TableSwitchOp'TYPE)
            this (assoc this :lowKey lowKey)
            this (assoc this :defaultTarget defaultTarget)
            this (assoc this :targets targets)
            this (assoc this :index index)
            this (assoc this :scratch scratch)
            this (assoc this :idxScratch idxScratch)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" TableSwitchOp''emitCode-2 [#_"TableSwitchOp" this, #_"Assembler" asm]
        (let [
            #_"Register" indexReg (#_"RegisterValue" .getRegister (:index this))
            #_"Register" idxScratchReg (#_"RegisterValue" .getRegister (:idxScratch this))
            #_"Register" scratchReg (#_"RegisterValue" .getRegister (:scratch this))
        ]
            (when-not (= indexReg idxScratchReg)
                (Assembler''movl-3 asm, idxScratchReg, indexReg)
            )

            ;; compare index against jump table bounds
            (let [
                #_"int" highKey (dec (+ (:lowKey this) (count (:targets this))))
            ]
                (if (not= (:lowKey this) 0)
                    (do
                        ;; subtract the low value from the switch value
                        (Assembler''subl-3 asm, idxScratchReg, (:lowKey this))
                        (Assembler''cmpl-3 asm, idxScratchReg, (- highKey (:lowKey this)))
                    )
                    (Assembler''cmpl-3 asm, idxScratchReg, highKey)
                )

                ;; jump to default target if index is not within the jump table
                (when (some? (:defaultTarget this))
                    (Assembler''jcc-3 asm, ConditionFlag'Above, (LabelRef''label-1 (:defaultTarget this)))
                )

                ;; set scratch to address of jump table
                (Assembler''leaq-3 asm, scratchReg, (AMD64Address'new-2 AMD64/rip, 0))
                (let [
                    #_"int" afterLea (Assembler''position-1 asm)
                ]
                    ;; load jump table entry into scratch and jump to it
                    (Assembler''movslq-3 asm, idxScratchReg, (AMD64Address'new-4 scratchReg, idxScratchReg, Scale'Times4, 0))
                    (Assembler''addq-3 asm, scratchReg, idxScratchReg)
                    (Assembler''jmp-2 asm, scratchReg)

                    ;; inserting padding, so that jump table address is 4-byte aligned
                    (when-not (zero? (& (Assembler''position-1 asm) 0x3))
                        (Assembler''nop-2 asm, (- 4 (& (Assembler''position-1 asm) 0x3)))
                    )

                    ;; patch LEA instruction above now that we know the position of the jump table
                    ;; TODO this is ugly and should be done differently
                    (let [
                        #_"int" jumpTablePos (Assembler''position-1 asm)
                        #_"int" leaDisplacementPosition (- afterLea 4)
                    ]
                        (Assembler''emitInt-3 asm, (- jumpTablePos afterLea), leaDisplacementPosition)

                        ;; emit jump table entries
                        (doseq [#_"LabelRef" target (:targets this)]
                            (let [
                                #_"Label" label (LabelRef''label-1 target)
                                #_"int" offsetToJumpTableBase (- (Assembler''position-1 asm) jumpTablePos)
                            ]
                                (if (Label''isBound-1 label)
                                    (Assembler''emitInt-2 asm, (- (:position label) jumpTablePos))
                                    (do
                                        (§ ass! label (Label''addPatchAt-2 label, (Assembler''position-1 asm)))

                                        (Assembler''emitByte-2 asm, 0) ;; pseudo-opcode for jump table entry
                                        (Assembler''emitShort-2 asm, offsetToJumpTableBase)
                                        (Assembler''emitByte-2 asm, 0) ;; padding to make jump table entry 4 bytes wide
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; @anno AMD64ControlFlow.CondSetOp
 ;;
; @LIROpcode
(final-ns CondSetOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<CondSetOp>" CondSetOp'TYPE (LIRInstructionClass'new-1 CondSetOp))

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"Value" :result nil)
    (§ final #_"ConditionFlag" :condition nil)

    (§ defn #_"CondSetOp" CondSetOp'new-2 [#_"Variable" result, #_"Condition" condition]
        (let [
            #_"CondSetOp" this (LIRInstruction'new-1 CondSetOp'TYPE)
            this (assoc this :result result)
            this (assoc this :condition (AMD64ControlFlow'intCond-1 condition))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" CondSetOp''emitCode-2 [#_"CondSetOp" this, #_"Assembler" asm]
        (AMD64ControlFlow'setcc-3 asm, (:result this), (:condition this))
        nil
    )
)

;;;
 ; @anno AMD64ControlFlow.CondMoveOp
 ;;
; @LIROpcode
(final-ns CondMoveOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<CondMoveOp>" CondMoveOp'TYPE (LIRInstructionClass'new-1 CondMoveOp))

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"Value" :result nil)
    ; @Alive({OperandFlag'REG})
    (§ mutable #_"Value" :trueValue nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK, OperandFlag'CONST})
    (§ mutable #_"Value" :falseValue nil)
    (§ final #_"ConditionFlag" :condition nil)

    (§ defn #_"CondMoveOp" CondMoveOp'new-4 [#_"Variable" result, #_"Condition" condition, #_"AllocatableValue" trueValue, #_"Value" falseValue]
        (let [
            #_"CondMoveOp" this (LIRInstruction'new-1 CondMoveOp'TYPE)
            this (assoc this :result result)
            this (assoc this :condition (AMD64ControlFlow'intCond-1 condition))
            this (assoc this :trueValue trueValue)
            this (assoc this :falseValue falseValue)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" CondMoveOp''emitCode-2 [#_"CondMoveOp" this, #_"Assembler" asm]
        (AMD64Move'move-3 asm, (:result this), (:falseValue this))
        (AMD64ControlFlow'cmove-4 asm, (:result this), (:condition this), (:trueValue this))
        nil
    )
)

;;;
 ; AMD64 specific frame map.
 ;
 ; This is the format of an AMD64 stack frame:
 ;
 ;   Base       Contents
 ;
 ;            :                                :  -----
 ;   caller   | incoming overflow argument n   |    ^
 ;   frame    :     ...                        :    | positive
 ;            | incoming overflow argument 0   |    | offsets
 ;   ---------+--------------------------------+---------------------
 ;            | return address                 |    |            ^
 ;   current  +--------------------------------+    |            |    -----
 ;   frame    |                                |    |            |      ^
 ;            : callee save area               :    |            |      |
 ;            |                                |    |            |      |
 ;            +--------------------------------+    |            |      |
 ;            | spill slot 0                   |    | negative   |      |
 ;            :     ...                        :    v offsets    |      |
 ;            | spill slot n                   |  -----        total  frame
 ;            +--------------------------------+               frame  size
 ;            | alignment padding              |               size     |
 ;            +--------------------------------+  -----          |      |
 ;            | outgoing overflow argument n   |    ^            |      |
 ;            :     ...                        :    | positive   |      |
 ;            | outgoing overflow argument 0   |    | offsets    v      v
 ;    %sp-->  +--------------------------------+---------------------------
 ;
 ; The spill slot area also includes stack allocated memory blocks (ALLOCA blocks). The size of such
 ; a block may be greater than the size of a normal spill slot or the word size.
 ;
 ; A runtime can reserve space at the beginning of the overflow argument area. The calling
 ; convention can specify that the first overflow stack argument is not at offset 0, but at a
 ; specified offset. Use CodeCacheProvider#getMinimumOutgoingSize() to make sure that
 ; call-free methods also have this space reserved. Then the VM can use the memory at offset 0
 ; relative to the stack pointer.
 ;;
(final-ns AMD64FrameMap (§ extends FrameMap)
    (§ mutable #_"StackSlot" :rbpSpillSlot nil)

    (§ defn #_"AMD64FrameMap" AMD64FrameMap'new-0 []
        (let [
            #_"AMD64FrameMap" this (FrameMap'new-0)
            ;; (negative) offset relative to sp + total frame size
            this (assoc this :initialSpillSize (FrameMap''returnAddressSize-1 this))
            this (assoc this :spillSize (:initialSpillSize this))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"int" AMD64FrameMap''totalFrameSize-1 [#_"AMD64FrameMap" this]
        (+ (FrameMap''frameSize-1 this) (FrameMap''returnAddressSize-1 this))
    )

    #_unused
    (§ override! #_"int" AMD64FrameMap''currentFrameSize-1 [#_"AMD64FrameMap" this]
        (AMD64FrameMap''alignFrameSize-2 this, (- (+ (:outgoingSize this) (:spillSize this)) (FrameMap''returnAddressSize-1 this)))
    )

    (§ override! #_"int" AMD64FrameMap''alignFrameSize-2 [#_"AMD64FrameMap" this, #_"int" size]
        (- (NumUtil'roundUp-2 (+ size (FrameMap''returnAddressSize-1 this)), (.stackAlignment HotSpot'target)) (FrameMap''returnAddressSize-1 this))
    )

    ;;;
     ; For non-leaf methods, RBP is preserved in the special stack slot required by the HotSpot
     ; runtime for walking/inspecting frames of such methods.
     ;;
    (§ method! #_"StackSlot" AMD64FrameMap''allocateRBPSpillSlot-1 [#_"AMD64FrameMap" this]
        (§ ass! this (assoc this :rbpSpillSlot (FrameMap''allocateSpillSlot-2 this, (LIRKind'value-1 AMD64Kind/QWORD))))
        (:rbpSpillSlot this)
    )

    (§ method! #_"AMD64FrameMap" AMD64FrameMap''freeRBPSpillSlot-1 [#_"AMD64FrameMap" this]
        (assoc this :spillSize (:initialSpillSize this))
    )
)

(final-ns AMD64FrameMapBuilder (§ extends FrameMapBuilderImpl)
    (§ defn #_"AMD64FrameMapBuilder" AMD64FrameMapBuilder'new-1 [#_"FrameMap" frameMap]
        (FrameMapBuilderImpl'new-1 frameMap)
    )

    ;;;
     ; For non-leaf methods, RBP is preserved in the special stack slot required by the HotSpot
     ; runtime for walking/inspecting frames of such methods.
     ;;
    (§ method! #_"StackSlot" AMD64FrameMapBuilder''allocateRBPSpillSlot-1 [#_"AMD64FrameMapBuilder" this]
        (AMD64FrameMap''allocateRBPSpillSlot-1 (FrameMapBuilderTool''getFrameMap-1 this))
    )

    (§ method! #_"void" AMD64FrameMapBuilder''freeRBPSpillSlot-1 [#_"AMD64FrameMapBuilder" this]
        (§ ass! (FrameMapBuilderTool''getFrameMap-1 this) (AMD64FrameMap''freeRBPSpillSlot-1 (FrameMapBuilderTool''getFrameMap-1 this)))
        nil
    )
)

; @LIROpcode
(final-ns AMD64LFenceOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64LFenceOp>" AMD64LFenceOp'TYPE (LIRInstructionClass'new-1 AMD64LFenceOp))

    (§ defn #_"AMD64LFenceOp" AMD64LFenceOp'new-0 []
        (LIRInstruction'new-1 AMD64LFenceOp'TYPE)
    )

    #_unused
    (§ override! #_"void" AMD64LFenceOp''emitCode-2 [#_"AMD64LFenceOp" this, #_"Assembler" asm]
        (Assembler''lfence-1 asm)
        nil
    )
)

(value-ns AMD64Move
    (§ defn #_"void" AMD64Move'move-3 [#_"Assembler" asm, #_"Value" result, #_"Value" input]
        (AMD64Move'move-4 (#_"Value" .getPlatformKind result), asm, result, input)
        nil
    )

    (§ defn- #_"void" AMD64Move'reg2reg-4 [#_"AMD64Kind" kind, #_"Assembler" asm, #_"Value" result, #_"Value" input]
        (when-not (= (#_"RegisterValue" .getRegister input) (#_"RegisterValue" .getRegister result))
            (condp =? kind
               [AMD64Kind/BYTE AMD64Kind/WORD AMD64Kind/DWORD]
                    (Assembler''movl-3 asm, (#_"RegisterValue" .getRegister result), (#_"RegisterValue" .getRegister input))
                AMD64Kind/QWORD
                    (Assembler''movq-3 asm, (#_"RegisterValue" .getRegister result), (#_"RegisterValue" .getRegister input))
            )
        )
        nil
    )

    (§ defn #_"void" AMD64Move'move-4 [#_"AMD64Kind" moveKind, #_"Assembler" asm, #_"Value" result, #_"Value" input]
        (cond
            (instance? RegisterValue input)
                (condp instance? result
                    RegisterValue (AMD64Move'reg2reg-4 moveKind, asm, result, input)
                    StackSlot     (AMD64Move'reg2stack-4 moveKind, asm, result, (#_"RegisterValue" .getRegister input))
                )
            (instance? StackSlot input)
                (condp instance? result
                    RegisterValue (AMD64Move'stack2reg-4 moveKind, asm, (#_"RegisterValue" .getRegister result), input)
                )
            (LIRValueUtil'isJavaConstant-1 input)
                (condp instance? result
                    RegisterValue (AMD64Move'const2reg-3 asm, (#_"RegisterValue" .getRegister result), (:constant input))
                    StackSlot     (AMD64Move'const2stack-3 asm, result, (:constant input))
                )
            :else                 (throw! "should not reach here")
        )
        nil
    )

    (§ defn #_"void" AMD64Move'reg2stack-4 [#_"AMD64Kind" kind, #_"Assembler" asm, #_"Value" result, #_"Register" input]
        (let [
            #_"AMD64Address" dst (Assembler''asAddress-2 asm, result)
        ]
            (condp = kind
                AMD64Kind/BYTE  (Assembler''movb-3 asm, dst, input)
                AMD64Kind/WORD  (Assembler''movw-3 asm, dst, input)
                AMD64Kind/DWORD (Assembler''movl-3 asm, dst, input)
                AMD64Kind/QWORD (Assembler''movq-3 asm, dst, input)
            )
        )
        nil
    )

    (§ defn #_"void" AMD64Move'stack2reg-4 [#_"AMD64Kind" kind, #_"Assembler" asm, #_"Register" result, #_"Value" input]
        (let [
            #_"AMD64Address" src (Assembler''asAddress-2 asm, input)
        ]
            (condp = kind
                AMD64Kind/BYTE  (Assembler''movsbl-3 asm, result, src)
                AMD64Kind/WORD  (Assembler''movswl-3 asm, result, src)
                AMD64Kind/DWORD (Assembler''movl-3 asm, result, src)
                AMD64Kind/QWORD (Assembler''movq-3 asm, result, src)
            )
        )
        nil
    )

    (§ defn #_"void" AMD64Move'const2reg-3 [#_"Assembler" asm, #_"Register" result, #_"JavaConstant" input]
        ;; Note: we use the kind of the input operand (and not the kind of the result operand),
        ;; because they don't match in all cases. For example, an object constant can be loaded to
        ;; a long register when unsafe casts occurred (e.g. for a write barrier where arithmetic
        ;; operations are then performed on the pointer).
        (condp = (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind input))
            JavaKind/Int
                ;; Do not optimize with an XOR, as this instruction may be between a CMP and a Jcc,
                ;; in which case the XOR will modify the condition flags and interfere with the Jcc.
                (Assembler''movl-3 asm, result, (#_"JavaConstant" .asInt input))
            JavaKind/Long
                ;; Do not optimize with an XOR, as this instruction may be between a CMP and a Jcc,
                ;; in which case the XOR will modify the condition flags and interfere with the Jcc.
                (cond
                    (= (#_"JavaConstant" .asLong input) (int (#_"JavaConstant" .asLong input)))
                        ;; sign extended to long
                        (Assembler''movslq-3 asm, result, (int (#_"JavaConstant" .asLong input)))
                    (= (& (#_"JavaConstant" .asLong input) 0xffffffff) (#_"JavaConstant" .asLong input))
                        ;; zero extended to long
                        (Assembler''movl-3 asm, result, (int (#_"JavaConstant" .asLong input)))
                    :else
                        (Assembler''movq-3 asm, result, (#_"JavaConstant" .asLong input))
                )
            JavaKind/Object
                ;; Do not optimize with an XOR, as this instruction may be between a CMP and a Jcc,
                ;; in which case the XOR will modify the condition flags and interfere with the Jcc.
                (cond
                    (#_"JavaConstant" .isNull input)
                        (Assembler''movq-3 asm, result, 0)
                    (.inlineObjects HotSpot'target)
                    (do
                        (Assembler''recordInlineDataInCode-2 asm, input)
                        (Assembler''movq-3 asm, result, 0xdeaddeaddeaddead)
                    )
                    :else
                        (Assembler''movq-3 asm, result, (Assembler''recordDataReferenceInCode-3 asm, input, 0))
                )
        )
        nil
    )

    (§ defn #_"boolean" AMD64Move'canMoveConst2Stack-1 [#_"JavaConstant" input]
        (condp = (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind input))
            JavaKind/Int    true
            JavaKind/Long   true
            JavaKind/Object (#_"JavaConstant" .isNull input)
                            false
        )
    )

    (§ defn #_"void" AMD64Move'const2stack-3 [#_"Assembler" asm, #_"Value" result, #_"JavaConstant" input]
        (let [
            #_"AMD64Address" dest (Assembler''asAddress-2 asm, result)
            #_"long" imm
                (condp = (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind input))
                    JavaKind/Int  (#_"JavaConstant" .asInt input)
                    JavaKind/Long (#_"JavaConstant" .asLong input)
                    JavaKind/Object
                        (when (#_"JavaConstant" .isNull input) => (throw! "non-nil object constants must be in register")
                            0
                        )
                )
        ]
            (condp = (#_"Value" .getPlatformKind result)
                AMD64Kind/BYTE  (AMD64MIOp''emit-5 AMD64MIOp'MOVB, asm, OperandSize'BYTE, dest, (int imm))
                AMD64Kind/WORD  (AMD64MIOp''emit-5 AMD64MIOp'MOV, asm, OperandSize'WORD, dest, (int imm))
                AMD64Kind/DWORD (Assembler''movl-3 asm, dest, (int imm))
                AMD64Kind/QWORD (Assembler''movlong-3 asm, dest, imm)
            )
        )
        nil
    )
)

;;;
 ; @anno AMD64Move.AbstractMoveOp
 ;;
(class-ns AbstractMoveOp (§ extends LIRInstruction) (§ implements ValueMoveOp)
    (§ def #_"LIRInstructionClass<AbstractMoveOp>" AbstractMoveOp'TYPE (LIRInstructionClass'new-1 AbstractMoveOp))

    (§ mutable #_"AMD64Kind" :moveKind nil)

    (§ defn #_"AbstractMoveOp" AbstractMoveOp'new-2 [#_"LIRInstructionClass<? extends AbstractMoveOp>" c, #_"AMD64Kind" moveKind]
        (let [
            #_"AbstractMoveOp" this (LIRInstruction'new-1 c)
            this (assoc this :moveKind moveKind)
        ]
            this
        )
    )

    #_unused
    (§ override #_"void" AbstractMoveOp''emitCode-2 [#_"AbstractMoveOp" this, #_"Assembler" asm]
        (AMD64Move'move-4 (:moveKind this), asm, (LIRInstruction''getResult-1 this), (LIRInstruction''getInput-1 this))
        nil
    )
)

;;;
 ; @anno AMD64Move.MoveToRegOp
 ;;
; @LIROpcode
(final-ns MoveToRegOp (§ extends AbstractMoveOp)
    (§ def #_"LIRInstructionClass<MoveToRegOp>" MoveToRegOp'TYPE (LIRInstructionClass'new-1 MoveToRegOp))

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :input nil)

    (§ defn #_"MoveToRegOp" MoveToRegOp'new-3 [#_"AMD64Kind" moveKind, #_"AllocatableValue" result, #_"AllocatableValue" input]
        (let [
            #_"MoveToRegOp" this (AbstractMoveOp'new-2 MoveToRegOp'TYPE, moveKind)
            this (assoc this :result result)
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"AllocatableValue" MoveToRegOp''getInput-1 [#_"MoveToRegOp" this]
        (:input this)
    )

    #_unused
    (§ override! #_"AllocatableValue" MoveToRegOp''getResult-1 [#_"MoveToRegOp" this]
        (:result this)
    )
)

;;;
 ; @anno AMD64Move.MoveFromRegOp
 ;;
; @LIROpcode
(final-ns MoveFromRegOp (§ extends AbstractMoveOp)
    (§ def #_"LIRInstructionClass<MoveFromRegOp>" MoveFromRegOp'TYPE (LIRInstructionClass'new-1 MoveFromRegOp))

    ; @Def({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :input nil)

    (§ defn #_"MoveFromRegOp" MoveFromRegOp'new-3 [#_"AMD64Kind" moveKind, #_"AllocatableValue" result, #_"AllocatableValue" input]
        (let [
            #_"MoveFromRegOp" this (AbstractMoveOp'new-2 MoveFromRegOp'TYPE, moveKind)
            this (assoc this :result result)
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"AllocatableValue" MoveFromRegOp''getInput-1 [#_"MoveFromRegOp" this]
        (:input this)
    )

    #_unused
    (§ override! #_"AllocatableValue" MoveFromRegOp''getResult-1 [#_"MoveFromRegOp" this]
        (:result this)
    )
)

;;;
 ; @anno AMD64Move.MoveFromConstOp
 ;;
; @LIROpcode
(final-ns MoveFromConstOp (§ extends LIRInstruction) (§ implements LoadConstantOp)
    (§ def #_"LIRInstructionClass<MoveFromConstOp>" MoveFromConstOp'TYPE (LIRInstructionClass'new-1 MoveFromConstOp))

    ; @Def({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :result nil)
    (§ final #_"JavaConstant" :input nil)

    (§ defn #_"MoveFromConstOp" MoveFromConstOp'new-2 [#_"AllocatableValue" result, #_"JavaConstant" input]
        (let [
            #_"MoveFromConstOp" this (LIRInstruction'new-1 MoveFromConstOp'TYPE)
            this (assoc this :result result)
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MoveFromConstOp''emitCode-2 [#_"MoveFromConstOp" this, #_"Assembler" asm]
        (if (instance? RegisterValue (:result this))
            (AMD64Move'const2reg-3 asm, (#_"RegisterValue" .getRegister (:result this)), (:input this))
            (AMD64Move'const2stack-3 asm, (:result this), (:input this))
        )
        nil
    )

    #_unused
    (§ override! #_"Constant" MoveFromConstOp''getConstant-1 [#_"MoveFromConstOp" this]
        (:input this)
    )

    #_unused
    (§ override! #_"AllocatableValue" MoveFromConstOp''getResult-1 [#_"MoveFromConstOp" this]
        (:result this)
    )
)

;;;
 ; @anno AMD64Move.AMD64StackMove
 ;;
; @LIROpcode
(final-ns AMD64StackMove (§ extends LIRInstruction) (§ implements ValueMoveOp)
    (§ def #_"LIRInstructionClass<AMD64StackMove>" AMD64StackMove'TYPE (LIRInstructionClass'new-1 AMD64StackMove))

    ; @Def({OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'STACK, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :input nil)
    ; @Alive({OperandFlag'STACK, OperandFlag'UNINITIALIZED})
    (§ mutable #_"AllocatableValue" :backupSlot nil)

    (§ mutable #_"Register" :scratch nil)

    (§ defn #_"AMD64StackMove" AMD64StackMove'new-4 [#_"AllocatableValue" result, #_"AllocatableValue" input, #_"Register" scratch, #_"AllocatableValue" backupSlot]
        (let [
            #_"AMD64StackMove" this (LIRInstruction'new-1 AMD64StackMove'TYPE)
            this (assoc this :result result)
            this (assoc this :input input)
            this (assoc this :backupSlot backupSlot)
            this (assoc this :scratch scratch)
        ]
            this
        )
    )

    (§ override! #_"AllocatableValue" AMD64StackMove''getInput-1 [#_"AMD64StackMove" this]
        (:input this)
    )

    (§ override! #_"AllocatableValue" AMD64StackMove''getResult-1 [#_"AMD64StackMove" this]
        (:result this)
    )

    #_unused
    (§ override! #_"void" AMD64StackMove''emitCode-2 [#_"AMD64StackMove" this, #_"Assembler" asm]
        (let [
            #_"AMD64Kind" backupKind (#_"AllocatableValue" .getPlatformKind (:backupSlot this))
        ]
            ;; backup scratch register
            (AMD64Move'reg2stack-4 backupKind, asm, (:backupSlot this), (:scratch this))
            ;; move stack slot
            (AMD64Move'stack2reg-4 (#_"AllocatableValue" .getPlatformKind (AMD64StackMove''getInput-1 this)), asm, (:scratch this), (AMD64StackMove''getInput-1 this))
            (AMD64Move'reg2stack-4 (#_"AllocatableValue" .getPlatformKind (AMD64StackMove''getResult-1 this)), asm, (AMD64StackMove''getResult-1 this), (:scratch this))
            ;; restore scratch register
            (AMD64Move'stack2reg-4 backupKind, asm, (:scratch this), (:backupSlot this))
        )
        nil
    )
)

;;;
 ; @anno AMD64Move.AMD64MultiStackMove
 ;;
; @LIROpcode
(final-ns AMD64MultiStackMove (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64MultiStackMove>" AMD64MultiStackMove'TYPE (LIRInstructionClass'new-1 AMD64MultiStackMove))

    ; @Def({OperandFlag'STACK})
    (§ mutable #_"AllocatableValue[]" :results nil)
    ; @Use({OperandFlag'STACK})
    (§ mutable #_"Value[]" :inputs nil)
    ; @Alive({OperandFlag'STACK, OperandFlag'UNINITIALIZED})
    (§ mutable #_"AllocatableValue" :backupSlot nil)

    (§ mutable #_"Register" :scratch nil)

    (§ defn #_"AMD64MultiStackMove" AMD64MultiStackMove'new-4 [#_"AllocatableValue[]" results, #_"Value[]" inputs, #_"Register" scratch, #_"AllocatableValue" backupSlot]
        (let [
            #_"AMD64MultiStackMove" this (LIRInstruction'new-1 AMD64MultiStackMove'TYPE)
            this (assoc this :results results)
            this (assoc this :inputs inputs)
            this (assoc this :backupSlot backupSlot)
            this (assoc this :scratch scratch)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64MultiStackMove''emitCode-2 [#_"AMD64MultiStackMove" this, #_"Assembler" asm]
        (let [
            #_"AMD64Kind" backupKind (#_"AllocatableValue" .getPlatformKind (:backupSlot this))
        ]
            ;; backup scratch register
            (AMD64Move'move-4 backupKind, asm, (:backupSlot this), (#_"Register" .asValue (:scratch this), (#_"AllocatableValue" .getValueKind (:backupSlot this))))
            (dotimes [#_"int" i (count (:results this))]
                (let [
                    #_"Value" input (nth (:inputs this) i)
                    #_"AllocatableValue" result (nth (:results this) i)
                ]
                    ;; move stack slot
                    (AMD64Move'move-4 (#_"Value" .getPlatformKind input), asm, (#_"Register" .asValue (:scratch this), (#_"Value" .getValueKind input)), input)
                    (AMD64Move'move-4 (#_"AllocatableValue" .getPlatformKind result), asm, result, (#_"Register" .asValue (:scratch this), (#_"AllocatableValue" .getValueKind result)))
                )
            )
            ;; restore scratch register
            (AMD64Move'move-4 backupKind, asm, (#_"Register" .asValue (:scratch this), (#_"AllocatableValue" .getValueKind (:backupSlot this))), (:backupSlot this))
        )
        nil
    )
)

;;;
 ; @anno AMD64Move.AMD64PushPopStackMove
 ;;
; @LIROpcode
(final-ns AMD64PushPopStackMove (§ extends LIRInstruction) (§ implements ValueMoveOp)
    (§ def #_"LIRInstructionClass<AMD64PushPopStackMove>" AMD64PushPopStackMove'TYPE (LIRInstructionClass'new-1 AMD64PushPopStackMove))

    ; @Def({OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'STACK, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :input nil)
    (§ final #_"OperandSize" :size nil)

    (§ defn #_"AMD64PushPopStackMove" AMD64PushPopStackMove'new-3 [#_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" input]
        (let [
            #_"AMD64PushPopStackMove" this (LIRInstruction'new-1 AMD64PushPopStackMove'TYPE)
            this (assoc this :result result)
            this (assoc this :input input)
            this (assoc this :size size)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"AllocatableValue" AMD64PushPopStackMove''getInput-1 [#_"AMD64PushPopStackMove" this]
        (:input this)
    )

    #_unused
    (§ override! #_"AllocatableValue" AMD64PushPopStackMove''getResult-1 [#_"AMD64PushPopStackMove" this]
        (:result this)
    )

    #_unused
    (§ override! #_"void" AMD64PushPopStackMove''emitCode-2 [#_"AMD64PushPopStackMove" this, #_"Assembler" asm]
        (AMD64MOp''emit-4 AMD64MOp'PUSH, asm, (:size this), (Assembler''asAddress-2 asm, (:input this)))
        (AMD64MOp''emit-4 AMD64MOp'POP, asm, (:size this), (Assembler''asAddress-2 asm, (:result this)))
        nil
    )
)

;;;
 ; @anno AMD64Move.LeaOp
 ;;
(final-ns LeaOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<LeaOp>" LeaOp'TYPE (LIRInstructionClass'new-1 LeaOp))

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'COMPOSITE, OperandFlag'UNINITIALIZED})
    (§ mutable #_"AMD64AddressValue" :address nil)
    (§ final #_"OperandSize" :size nil)

    (§ defn #_"LeaOp" LeaOp'new-3 [#_"AllocatableValue" result, #_"AMD64AddressValue" address, #_"OperandSize" size]
        (let [
            #_"LeaOp" this (LIRInstruction'new-1 LeaOp'TYPE)
            this (assoc this :result result)
            this (assoc this :address address)
            this (assoc this :size size)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" LeaOp''emitCode-2 [#_"LeaOp" this, #_"Assembler" asm]
        (if (= (:size this) OperandSize'QWORD)
            (Assembler''leaq-3 asm, (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:address this)))
            (Assembler''lead-3 asm, (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:address this)))
        )
        nil
    )
)

;;;
 ; @anno AMD64Move.LeaDataOp
 ;;
(final-ns LeaDataOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<LeaDataOp>" LeaDataOp'TYPE (LIRInstructionClass'new-1 LeaDataOp))

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :result nil)
    (§ final #_"DataPointerConstant" :data nil)

    (§ defn #_"LeaDataOp" LeaDataOp'new-2 [#_"AllocatableValue" result, #_"DataPointerConstant" data]
        (let [
            #_"LeaDataOp" this (LIRInstruction'new-1 LeaDataOp'TYPE)
            this (assoc this :result result)
            this (assoc this :data data)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" LeaDataOp''emitCode-2 [#_"LeaDataOp" this, #_"Assembler" asm]
        (Assembler''leaq-3 asm, (#_"RegisterValue" .getRegister (:result this)), (Assembler''recordDataReferenceInCode-2 asm, (:data this)))
        nil
    )
)

;;;
 ; @anno AMD64Move.StackLeaOp
 ;;
(final-ns StackLeaOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<StackLeaOp>" StackLeaOp'TYPE (LIRInstructionClass'new-1 StackLeaOp))

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'STACK, OperandFlag'UNINITIALIZED})
    (§ mutable #_"AllocatableValue" :slot nil)

    (§ defn #_"StackLeaOp" StackLeaOp'new-2 [#_"AllocatableValue" result, #_"AllocatableValue" slot]
        (let [
            #_"StackLeaOp" this (LIRInstruction'new-1 StackLeaOp'TYPE)
            this (assoc this :result result)
            this (assoc this :slot slot)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" StackLeaOp''emitCode-2 [#_"StackLeaOp" this, #_"Assembler" asm]
        (Assembler''leaq-3 asm, (#_"RegisterValue" .getRegister (:result this)), (Assembler''asAddress-2 asm, (:slot this)))
        nil
    )
)

;;;
 ; @anno AMD64Move.MembarOp
 ;;
(final-ns MembarOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<MembarOp>" MembarOp'TYPE (LIRInstructionClass'new-1 MembarOp))

    (§ final #_"int" :barriers 0)

    (§ defn #_"MembarOp" MembarOp'new-1 [#_"int" barriers]
        (let [
            #_"MembarOp" this (LIRInstruction'new-1 MembarOp'TYPE)
            this (assoc this :barriers barriers)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MembarOp''emitCode-2 [#_"MembarOp" this, #_"Assembler" asm]
        (Assembler''membar-2 asm, (:barriers this))
        nil
    )
)

;;;
 ; @anno AMD64Move.NullCheckOp
 ;;
(final-ns NullCheckOp (§ extends LIRInstruction) (§ implements NullCheck)
    (§ def #_"LIRInstructionClass<NullCheckOp>" NullCheckOp'TYPE (LIRInstructionClass'new-1 NullCheckOp))

    ; @Use({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :address nil)

    (§ defn #_"NullCheckOp" NullCheckOp'new-1 [#_"AMD64AddressValue" address]
        (let [
            #_"NullCheckOp" this (LIRInstruction'new-1 NullCheckOp'TYPE)
            this (assoc this :address address)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" NullCheckOp''emitCode-2 [#_"NullCheckOp" this, #_"Assembler" asm]
        (Assembler''nullCheck-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
        nil
    )

    #_unused
    (§ override! #_"Value" NullCheckOp''getCheckedValue-1 [#_"NullCheckOp" this]
        (:base (:address this))
    )
)

;;;
 ; @anno AMD64Move.CompareAndSwapOp
 ;;
; @LIROpcode
(final-ns CompareAndSwapOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<CompareAndSwapOp>" CompareAndSwapOp'TYPE (LIRInstructionClass'new-1 CompareAndSwapOp))

    (§ final #_"AMD64Kind" :accessKind nil)

    ; @Def
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :address nil)
    ; @Use
    (§ mutable #_"AllocatableValue" :cmpValue nil)
    ; @Use
    (§ mutable #_"AllocatableValue" :newValue nil)

    (§ defn #_"CompareAndSwapOp" CompareAndSwapOp'new-5 [#_"AMD64Kind" accessKind, #_"AllocatableValue" result, #_"AMD64AddressValue" address, #_"AllocatableValue" cmpValue, #_"AllocatableValue" newValue]
        (let [
            #_"CompareAndSwapOp" this (LIRInstruction'new-1 CompareAndSwapOp'TYPE)
            this (assoc this :accessKind accessKind)
            this (assoc this :result result)
            this (assoc this :address address)
            this (assoc this :cmpValue cmpValue)
            this (assoc this :newValue newValue)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" CompareAndSwapOp''emitCode-2 [#_"CompareAndSwapOp" this, #_"Assembler" asm]
        (when (.isMP HotSpot'target)
            (Assembler''lock-1 asm)
        )
        (condp = (:accessKind this)
            AMD64Kind/DWORD (Assembler''cmpxchgl-3 asm, (#_"RegisterValue" .getRegister (:newValue this)), (AMD64AddressValue''toAddress-1 (:address this)))
            AMD64Kind/QWORD (Assembler''cmpxchgq-3 asm, (#_"RegisterValue" .getRegister (:newValue this)), (AMD64AddressValue''toAddress-1 (:address this)))
        )
        nil
    )
)

;;;
 ; @anno AMD64Move.AtomicReadAndAddOp
 ;;
; @LIROpcode
(final-ns AtomicReadAndAddOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AtomicReadAndAddOp>" AtomicReadAndAddOp'TYPE (LIRInstructionClass'new-1 AtomicReadAndAddOp))

    (§ final #_"AMD64Kind" :accessKind nil)

    ; @Def
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Alive({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :address nil)
    ; @Use
    (§ mutable #_"AllocatableValue" :delta nil)

    (§ defn #_"AtomicReadAndAddOp" AtomicReadAndAddOp'new-4 [#_"AMD64Kind" accessKind, #_"AllocatableValue" result, #_"AMD64AddressValue" address, #_"AllocatableValue" delta]
        (let [
            #_"AtomicReadAndAddOp" this (LIRInstruction'new-1 AtomicReadAndAddOp'TYPE)
            this (assoc this :accessKind accessKind)
            this (assoc this :result result)
            this (assoc this :address address)
            this (assoc this :delta delta)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AtomicReadAndAddOp''emitCode-2 [#_"AtomicReadAndAddOp" this, #_"Assembler" asm]
        (AMD64Move'move-4 (:accessKind this), asm, (:result this), (:delta this))
        (when (.isMP HotSpot'target)
            (Assembler''lock-1 asm)
        )
        (condp = (:accessKind this)
            AMD64Kind/DWORD (Assembler''xaddl-3 asm, (AMD64AddressValue''toAddress-1 (:address this)), (#_"RegisterValue" .getRegister (:result this)))
            AMD64Kind/QWORD (Assembler''xaddq-3 asm, (AMD64AddressValue''toAddress-1 (:address this)), (#_"RegisterValue" .getRegister (:result this)))
        )
        nil
    )
)

;;;
 ; @anno AMD64Move.AtomicReadAndWriteOp
 ;;
; @LIROpcode
(final-ns AtomicReadAndWriteOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AtomicReadAndWriteOp>" AtomicReadAndWriteOp'TYPE (LIRInstructionClass'new-1 AtomicReadAndWriteOp))

    (§ final #_"AMD64Kind" :accessKind nil)

    ; @Def
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Alive({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :address nil)
    ; @Use
    (§ mutable #_"AllocatableValue" :newValue nil)

    (§ defn #_"AtomicReadAndWriteOp" AtomicReadAndWriteOp'new-4 [#_"AMD64Kind" accessKind, #_"AllocatableValue" result, #_"AMD64AddressValue" address, #_"AllocatableValue" newValue]
        (let [
            #_"AtomicReadAndWriteOp" this (LIRInstruction'new-1 AtomicReadAndWriteOp'TYPE)
            this (assoc this :accessKind accessKind)
            this (assoc this :result result)
            this (assoc this :address address)
            this (assoc this :newValue newValue)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AtomicReadAndWriteOp''emitCode-2 [#_"AtomicReadAndWriteOp" this, #_"Assembler" asm]
        (AMD64Move'move-4 (:accessKind this), asm, (:result this), (:newValue this))
        (condp = (:accessKind this)
            AMD64Kind/DWORD (Assembler''xchgl-3 asm, (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:address this)))
            AMD64Kind/QWORD (Assembler''xchgq-3 asm, (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:address this)))
        )
        nil
    )
)

;;;
 ; @anno AMD64Move.PointerCompressionOp
 ;;
(class-ns PointerCompressionOp (§ extends LIRInstruction)
    (§ final #_"CompressEncoding" :encoding nil)
    (§ final #_"boolean" :never-nil? false)

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'CONST})
    (§ mutable #_"Value" :input nil)
    ; @Alive({OperandFlag'REG, OperandFlag'ILLEGAL, OperandFlag'UNINITIALIZED})
    (§ mutable #_"AllocatableValue" :baseRegister nil)

    (§ defn #_"PointerCompressionOp" PointerCompressionOp'new-6 [#_"LIRInstructionClass<? extends PointerCompressionOp>" type, #_"AllocatableValue" result, #_"Value" input, #_"AllocatableValue" baseRegister, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (let [
            #_"PointerCompressionOp" this (LIRInstruction'new-1 type)
            this (assoc this :result result)
            this (assoc this :input input)
            this (assoc this :baseRegister baseRegister)
            this (assoc this :encoding encoding)
            this (assoc this :never-nil? never-nil?)
        ]
            this
        )
    )

    (§ defn #_"boolean" PointerCompressionOp'hasBase-1 [#_"CompressEncoding" encoding]
        (CompressEncoding''hasBase-1 encoding)
    )

    #_unused
    (§ method! #_"Value" PointerCompressionOp''getInput-1 [#_"PointerCompressionOp" this]
        (:input this)
    )

    (§ method! #_"AllocatableValue" PointerCompressionOp''getResult-1 [#_"PointerCompressionOp" this]
        (:result this)
    )

    (§ method! #_"Register" PointerCompressionOp''getBaseRegister-1 [#_"PointerCompressionOp" this]
        (#_"RegisterValue" .getRegister (:baseRegister this))
    )

    (§ method! #_"int" PointerCompressionOp''getShift-1 [#_"PointerCompressionOp" this]
        (:shift (:encoding this))
    )

    (§ method! #_"void" PointerCompressionOp''move-3 [#_"PointerCompressionOp" this, #_"LIRKind" kind, #_"Assembler" asm]
        (AMD64Move'move-4 (#_"ValueKind" .getPlatformKind kind), asm, (:result this), (:input this))
        nil
    )
)

;;;
 ; @anno AMD64Move.CompressPointerOp
 ;;
(final-ns CompressPointerOp (§ extends PointerCompressionOp)
    (§ def #_"LIRInstructionClass<CompressPointerOp>" CompressPointerOp'TYPE (LIRInstructionClass'new-1 CompressPointerOp))

    (§ defn #_"CompressPointerOp" CompressPointerOp'new-5 [#_"AllocatableValue" result, #_"Value" input, #_"AllocatableValue" baseRegister, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (PointerCompressionOp'new-6 CompressPointerOp'TYPE, result, input, baseRegister, encoding, never-nil?)
    )

    #_unused
    (§ override! #_"void" CompressPointerOp''emitCode-2 [#_"CompressPointerOp" this, #_"Assembler" asm]
        (PointerCompressionOp''move-3 this, (LIRKindTool'getObjectKind-0), asm)

        (let [
            #_"Register" resReg (#_"RegisterValue" .getRegister (PointerCompressionOp''getResult-1 this))
        ]
            (when (PointerCompressionOp'hasBase-1 (:encoding this))
                (let [
                    #_"Register" baseReg (PointerCompressionOp''getBaseRegister-1 this)
                ]
                    (when-not (:never-nil? this)
                        (Assembler''testq-3 asm, resReg, resReg)
                        (Assembler''cmovq-4 asm, ConditionFlag'Equal, resReg, baseReg)
                    )
                    (Assembler''subq-3 asm, resReg, baseReg)
                )
            )

            (let [
                #_"int" shift (PointerCompressionOp''getShift-1 this)
            ]
                (when-not (zero? shift)
                    (Assembler''shrq-3 asm, resReg, shift)
                )
            )
        )
        nil
    )
)

;;;
 ; @anno AMD64Move.UncompressPointerOp
 ;;
(final-ns UncompressPointerOp (§ extends PointerCompressionOp)
    (§ def #_"LIRInstructionClass<UncompressPointerOp>" UncompressPointerOp'TYPE (LIRInstructionClass'new-1 UncompressPointerOp))

    (§ defn #_"UncompressPointerOp" UncompressPointerOp'new-5 [#_"AllocatableValue" result, #_"Value" input, #_"AllocatableValue" baseRegister, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (PointerCompressionOp'new-6 UncompressPointerOp'TYPE, result, input, baseRegister, encoding, never-nil?)
    )

    #_unused
    (§ override! #_"void" UncompressPointerOp''emitCode-2 [#_"UncompressPointerOp" this, #_"Assembler" asm]
        (PointerCompressionOp''move-3 this, (LIRKindTool'getNarrowOopKind-0), asm)

        (let [
            #_"Register" resReg (#_"RegisterValue" .getRegister (PointerCompressionOp''getResult-1 this))
            #_"int" shift (PointerCompressionOp''getShift-1 this)
        ]
            (when-not (zero? shift)
                (Assembler''shlq-3 asm, resReg, shift)
            )

            (let [
                #_"Register" baseReg (when (PointerCompressionOp'hasBase-1 (:encoding this)) (PointerCompressionOp''getBaseRegister-1 this))
            ]
                (when (some? baseReg)
                    (when-not (:never-nil? this) => (Assembler''addq-3 asm, resReg, baseReg)
                        (when (zero? shift)
                            ;; if encoding.shift != 0, the flags are already set by the shlq
                            (Assembler''testq-3 asm, resReg, resReg)
                        )
                        (let [
                            #_"Label" done (Label'new-0)
                        ]
                            (Assembler''jccb-3 asm, ConditionFlag'Equal, done)
                            (Assembler''addq-3 asm, resReg, baseReg)
                            (Assembler''bind-2 asm, done)
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; AMD64 mul/div operation. This operation has a single operand for the second input. The first
 ; input must be in RAX for mul and in RDX:RAX for div. The result is in RDX:RAX.
 ;;
(final-ns AMD64MulDivOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64MulDivOp>" AMD64MulDivOp'TYPE (LIRInstructionClass'new-1 AMD64MulDivOp))

    ; @LIROpcode
    (§ final #_"AMD64MOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :highResult nil)
    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :lowResult nil)

    ; @Use({OperandFlag'REG, OperandFlag'ILLEGAL})
    (§ mutable #_"AllocatableValue" :highX nil)
    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :lowX nil)

    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :y nil)

    (§ defn #_"AMD64MulDivOp" AMD64MulDivOp'new-5 [#_"AMD64MOp" opcode, #_"OperandSize" size, #_"LIRKind" resultKind, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (AMD64MulDivOp'new-6 opcode, size, resultKind, Value/ILLEGAL, x, y)
    )

    (§ defn #_"AMD64MulDivOp" AMD64MulDivOp'new-6 [#_"AMD64MOp" opcode, #_"OperandSize" size, #_"LIRKind" resultKind, #_"AllocatableValue" highX, #_"AllocatableValue" lowX, #_"AllocatableValue" y]
        (let [
            #_"AMD64MulDivOp" this (LIRInstruction'new-1 AMD64MulDivOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :highResult (#_"Register" .asValue AMD64/rdx, resultKind))
            this (assoc this :lowResult (#_"Register" .asValue AMD64/rax, resultKind))
            this (assoc this :highX highX)
            this (assoc this :lowX lowX)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64MulDivOp''emitCode-2 [#_"AMD64MulDivOp" this, #_"Assembler" asm]
        (AMD64MOp''emit-4 (:opcode this), asm, (:size this), (if (instance? RegisterValue (:y this)) (#_"RegisterValue" .getRegister (:y this)) (Assembler''asAddress-2 asm, (:y this))))
        nil
    )
)

(final-ns AMD64PrefetchOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64PrefetchOp>" AMD64PrefetchOp'TYPE (LIRInstructionClass'new-1 AMD64PrefetchOp))

    (§ final #_"int" :instr 0) ;; AllocatePrefetchInstr
    ; @Alive({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :address nil)

    (§ defn #_"AMD64PrefetchOp" AMD64PrefetchOp'new-2 [#_"AMD64AddressValue" address, #_"int" instr]
        (let [
            #_"AMD64PrefetchOp" this (LIRInstruction'new-1 AMD64PrefetchOp'TYPE)
            this (assoc this :address address)
            this (assoc this :instr instr)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64PrefetchOp''emitCode-2 [#_"AMD64PrefetchOp" this, #_"Assembler" asm]
        (case (:instr this)
            0 (Assembler''prefetchnta-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
            1 (Assembler''prefetcht0-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
            2 (Assembler''prefetcht2-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
            3 (Assembler''prefetchw-2 asm, (AMD64AddressValue''toAddress-1 (:address this)))
        )
        nil
    )
)

;;;
 ; AMD64 rdtsc operation. The result is in EDX:EAX.
 ;;
; @LIROpcode
(final-ns AMD64ReadTimestampCounter (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64ReadTimestampCounter>" AMD64ReadTimestampCounter'TYPE (LIRInstructionClass'new-1 AMD64ReadTimestampCounter))

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :highResult nil)
    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :lowResult nil)

    (§ defn #_"AMD64ReadTimestampCounter" AMD64ReadTimestampCounter'new-0 []
        (let [
            #_"AMD64ReadTimestampCounter" this (LIRInstruction'new-1 AMD64ReadTimestampCounter'TYPE)
            this (assoc this :highResult (#_"Register" .asValue AMD64/rdx, (LIRKind'value-1 AMD64Kind/DWORD)))
            this (assoc this :lowResult (#_"Register" .asValue AMD64/rax, (LIRKind'value-1 AMD64Kind/DWORD)))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64ReadTimestampCounter''emitCode-2 [#_"AMD64ReadTimestampCounter" this, #_"Assembler" asm]
        (Assembler''rdtsc-1 asm)
        nil
    )
)

;;;
 ; Restores registers from stack slots.
 ;;
; @LIROpcode
(final-ns AMD64RestoreRegistersOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64RestoreRegistersOp>" AMD64RestoreRegistersOp'TYPE (LIRInstructionClass'new-1 AMD64RestoreRegistersOp))

    ;;;
     ; The slots from which the registers are restored.
     ;;
    ; @Use(OperandFlag'STACK)
    (§ final #_"AllocatableValue[]" :slots nil)

    ;;;
     ; The operation that saved the registers restored by this operation.
     ;;
    (§ final #_"AMD64SaveRegistersOp" :save nil)

    (§ defn #_"AMD64RestoreRegistersOp" AMD64RestoreRegistersOp'new-2 [#_"AllocatableValue[]" values, #_"AMD64SaveRegistersOp" save]
        (AMD64RestoreRegistersOp'new-3 AMD64RestoreRegistersOp'TYPE, values, save)
    )

    (§ defn #_"AMD64RestoreRegistersOp" AMD64RestoreRegistersOp'new-3 [#_"LIRInstructionClass<? extends AMD64RestoreRegistersOp>" c, #_"AllocatableValue[]" values, #_"AMD64SaveRegistersOp" save]
        (let [
            #_"AMD64RestoreRegistersOp" this (LIRInstruction'new-1 c)
            this (assoc this :slots values)
            this (assoc this :save save)
        ]
            this
        )
    )

    (§ method! #_"Register[]" AMD64RestoreRegistersOp''getSavedRegisters-1 [#_"AMD64RestoreRegistersOp" this]
        (:savedRegisters (:save this))
    )

    (§ defn- #_"void" AMD64RestoreRegistersOp'restoreRegister-3 [#_"Assembler" asm, #_"Register" result, #_"StackSlot" input]
        (AMD64Move'stack2reg-4 (#_"StackSlot" .getPlatformKind input), asm, result, input)
        nil
    )

    #_unused
    (§ override! #_"void" AMD64RestoreRegistersOp''emitCode-2 [#_"AMD64RestoreRegistersOp" this, #_"Assembler" asm]
        (let [
            #_"Register[]" savedRegisters (AMD64RestoreRegistersOp''getSavedRegisters-1 this)
        ]
            (dotimes [#_"int" i (count savedRegisters)]
                (when (some? (nth savedRegisters i))
                    (AMD64RestoreRegistersOp'restoreRegister-3 asm, (nth savedRegisters i), (nth (:slots this) i))
                )
            )
        )
        nil
    )
)

;;;
 ; Saves registers to stack slots.
 ;;
; @LIROpcode
(final-ns AMD64SaveRegistersOp (§ extends LIRInstruction) (§ implements SaveRegistersOp)
    (§ def #_"LIRInstructionClass<AMD64SaveRegistersOp>" AMD64SaveRegistersOp'TYPE (LIRInstructionClass'new-1 AMD64SaveRegistersOp))

    ;;;
     ; The registers (potentially) saved by this operation.
     ;;
    (§ final #_"Register[]" :savedRegisters nil)

    ;;;
     ; The slots to which the registers are saved.
     ;;
    ; @Def(OperandFlag'STACK)
    (§ final #_"AllocatableValue[]" :slots nil)

    ;;;
     ; @param savedRegisters the registers saved by this operation which may be subject to {@linkplain #remove(EconomicSet) pruning}
     ; @param savedRegisterLocations the slots to which the registers are saved
     ;;
    (§ defn #_"AMD64SaveRegistersOp" AMD64SaveRegistersOp'new-2 [#_"Register[]" savedRegisters, #_"AllocatableValue[]" savedRegisterLocations]
        (AMD64SaveRegistersOp'new-3 AMD64SaveRegistersOp'TYPE, savedRegisters, savedRegisterLocations)
    )

    (§ defn #_"AMD64SaveRegistersOp" AMD64SaveRegistersOp'new-3 [#_"LIRInstructionClass<? extends AMD64SaveRegistersOp>" c, #_"Register[]" savedRegisters, #_"AllocatableValue[]" savedRegisterLocations]
        (let [
            #_"AMD64SaveRegistersOp" this (LIRInstruction'new-1 c)
            this (assoc this :savedRegisters savedRegisters)
            this (assoc this :slots savedRegisterLocations)
        ]
            this
        )
    )

    (§ defn- #_"void" AMD64SaveRegistersOp'saveRegister-3 [#_"Assembler" asm, #_"StackSlot" result, #_"Register" input]
        (AMD64Move'reg2stack-4 (#_"StackSlot" .getPlatformKind result), asm, result, input)
        nil
    )

    #_unused
    (§ override! #_"void" AMD64SaveRegistersOp''emitCode-2 [#_"AMD64SaveRegistersOp" this, #_"Assembler" asm]
        (dotimes [#_"int" i (count (:savedRegisters this))]
            (when (some? (nth (:savedRegisters this) i))
                (AMD64SaveRegistersOp'saveRegister-3 asm, (nth (:slots this) i), (nth (:savedRegisters this) i))
            )
        )
        nil
    )

    #_unused
    (§ override! #_"RegisterSaveLayout" AMD64SaveRegistersOp''getMap-2 [#_"AMD64SaveRegistersOp" this, #_"FrameMap" frameMap]
        (let [
            #_"int" n
                (loop-when-recur [n 0 #_"int" i 0]
                                 (< i (count (:savedRegisters this)))
                                 [(if (some? (nth (:savedRegisters this) i)) (inc n) n) (inc i)]
                              => n
                )
            #_"Register[]" keys (make-array Register n)
            #_"int[]" values (int-array n)
        ]
            (when (pos? n)
                (loop-when [#_"int" j 0 #_"int" i 0] (< i (count (:savedRegisters this)))
                    (when (some? (nth (:savedRegisters this) i)) => (recur j (inc i))
                        (aset keys j (nth (:savedRegisters this) i))
                        (aset values j (AMD64SaveRegistersOp'indexForStackSlot-2 frameMap, (nth (:slots this) i)))
                        (recur (inc j) (inc i))
                    )
                )
            )
            (RegisterSaveLayout. keys, values)
        )
    )

    ;;;
     ; Computes the index of a stack slot relative to slot 0. This is also the bit index of stack
     ; slots in the reference map.
     ;
     ; @param slot a stack slot
     ; @return the index of the stack slot
     ;;
    (§ defn- #_"int" AMD64SaveRegistersOp'indexForStackSlot-2 [#_"FrameMap" frameMap, #_"StackSlot" slot]
        (quot (FrameMap''offsetForStackSlot-2 frameMap, slot) (.wordSize HotSpot'target))
    )
)

;;;
 ; AMD64 shift/rotate operation. This operation has a single operand for the first input and output.
 ; The second input must be in the RCX register.
 ;;
(final-ns AMD64ShiftOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64ShiftOp>" AMD64ShiftOp'TYPE (LIRInstructionClass'new-1 AMD64ShiftOp))

    ; @LIROpcode
    (§ final #_"AMD64MOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :x nil)
    ; @Alive({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :y nil)

    (§ defn #_"AMD64ShiftOp" AMD64ShiftOp'new-5 [#_"AMD64MOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" x, #_"AllocatableValue" y]
        (let [
            #_"AMD64ShiftOp" this (LIRInstruction'new-1 AMD64ShiftOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64ShiftOp''emitCode-2 [#_"AMD64ShiftOp" this, #_"Assembler" asm]
        (AMD64Move'move-3 asm, (:result this), (:x this))
        (AMD64MOp''emit-4 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)))
        nil
    )
)

; @LIROpcode
(final-ns AMD64SignExtendOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<AMD64SignExtendOp>" AMD64SignExtendOp'TYPE (LIRInstructionClass'new-1 AMD64SignExtendOp))

    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :highResult nil)
    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :lowResult nil)

    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :input nil)

    (§ defn #_"AMD64SignExtendOp" AMD64SignExtendOp'new-3 [#_"OperandSize" size, #_"LIRKind" resultKind, #_"AllocatableValue" input]
        (let [
            #_"AMD64SignExtendOp" this (LIRInstruction'new-1 AMD64SignExtendOp'TYPE)
            this (assoc this :size size)
            this (assoc this :highResult (#_"Register" .asValue AMD64/rdx, resultKind))
            this (assoc this :lowResult (#_"Register" .asValue AMD64/rax, resultKind))
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64SignExtendOp''emitCode-2 [#_"AMD64SignExtendOp" this, #_"Assembler" asm]
        (if (= (:size this) OperandSize'DWORD)
            (Assembler''cdql-1 asm)
            (Assembler''cdqq-1 asm)
        )
        nil
    )
)

;;;
 ; AMD64 LIR instructions that have one input and one output.
 ;;
(value-ns AMD64Unary
)

;;;
 ; Instruction with a single operand that is both input and output.
 ;
 ; @anno AMD64Unary.MOp
 ;;
(final-ns MOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<MOp>" MOp'TYPE (LIRInstructionClass'new-1 MOp))

    ; @LIROpcode
    (§ final #_"AMD64MOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :value nil)

    (§ defn #_"MOp" MOp'new-4 [#_"AMD64MOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" value]
        (let [
            #_"MOp" this (LIRInstruction'new-1 MOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MOp''emitCode-2 [#_"MOp" this, #_"Assembler" asm]
        (AMD64Move'move-3 asm, (:result this), (:value this))
        (AMD64MOp''emit-4 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)))
        nil
    )
)

;;;
 ; Instruction with separate input and output operands, and an operand encoding of RM.
 ;
 ; @anno AMD64Unary.RMOp
 ;;
(final-ns RMOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<RMOp>" RMOp'TYPE (LIRInstructionClass'new-1 RMOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :value nil)

    (§ defn #_"RMOp" RMOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" value]
        (let [
            #_"RMOp" this (LIRInstruction'new-1 RMOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" RMOp''emitCode-2 [#_"RMOp" this, #_"Assembler" asm]
        (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (if (instance? RegisterValue (:value this)) (#_"RegisterValue" .getRegister (:value this)) (Assembler''asAddress-2 asm, (:value this))))
        nil
    )
)

;;;
 ; Instruction with separate input and output operands, and an operand encoding of MR.
 ;
 ; @anno AMD64Unary.MROp
 ;;
(final-ns MROp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<MROp>" MROp'TYPE (LIRInstructionClass'new-1 MROp))

    ; @LIROpcode
    (§ final #_"AMD64MROp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :value nil)

    (§ defn #_"MROp" MROp'new-4 [#_"AMD64MROp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AllocatableValue" value]
        (let [
            #_"MROp" this (LIRInstruction'new-1 MROp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MROp''emitCode-2 [#_"MROp" this, #_"Assembler" asm]
        (AMD64MROp''emit-5 (:opcode this), asm, (:size this), (if (instance? RegisterValue (:result this)) (#_"RegisterValue" .getRegister (:result this)) (Assembler''asAddress-2 asm, (:result this))), (#_"RegisterValue" .getRegister (:value this)))
        nil
    )
)

;;;
 ; Instruction with a {@link AMD64AddressValue memory} operand.
 ;
 ; @anno AMD64Unary.MemoryOp
 ;;
(final-ns MemoryOp (§ extends LIRInstruction) (§ implements ImplicitNullCheck)
    (§ def #_"LIRInstructionClass<MemoryOp>" MemoryOp'TYPE (LIRInstructionClass'new-1 MemoryOp))

    ; @LIROpcode
    (§ final #_"AMD64RMOp" :opcode nil)
    (§ final #_"OperandSize" :size nil)

    ; @Def({OperandFlag'REG})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'COMPOSITE})
    (§ mutable #_"AMD64AddressValue" :input nil)

    (§ defn #_"MemoryOp" MemoryOp'new-4 [#_"AMD64RMOp" opcode, #_"OperandSize" size, #_"AllocatableValue" result, #_"AMD64AddressValue" input]
        (let [
            #_"MemoryOp" this (LIRInstruction'new-1 MemoryOp'TYPE)
            this (assoc this :opcode opcode)
            this (assoc this :size size)
            this (assoc this :result result)
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MemoryOp''emitCode-2 [#_"MemoryOp" this, #_"Assembler" asm]
        (AMD64RMOp''emit-5 (:opcode this), asm, (:size this), (#_"RegisterValue" .getRegister (:result this)), (AMD64AddressValue''toAddress-1 (:input this)))
        nil
    )

    #_unused
    (§ override! #_"boolean" MemoryOp''makeNullCheckFor-3 [#_"MemoryOp" this, #_"Value" value, #_"int" implicitNullCheckLimit]
        (AMD64AddressValue''isValidImplicitNullCheckFor-3 (:input this), value, implicitNullCheckLimit)
    )
)

;;;
 ; Replaces sequential AMD64StackMoves of the same type with a single
 ; AMD64MultiStackMove to avoid storing/restoring the scratch register multiple times.
 ;
 ; Note: this phase must be inserted <b>after</b> RedundantMoveElimination phase because
 ; AMD64MultiStackMove are not probably detected.
 ;;
(final-ns StackMoveOptimizationPhase (§ extends PostAllocationOptimizationPhase)
    (§ defn #_"StackMoveOptimizationPhase" StackMoveOptimizationPhase'new-0 []
        (PostAllocationOptimizationPhase'new-0)
    )

    #_unused
    (§ override! #_"void" StackMoveOptimizationPhase''run-3 [#_"StackMoveOptimizationPhase" this, #_"LIRGenerationResult" lirGenRes, #_"PostAllocationOptimizationContext" context]
        (let [
            #_"LIR" lir (:lir lirGenRes)
        ]
            (doseq [#_"Block" block (:reversePostOrder (:cfg lir))]
                (§ ass! (Closure0'new-0) (Closure0''process-2 (Closure0'new-0), (LIR''getLIRforBlock-2 lir, block)))
            )
        )
        nil
    )
)

;;;
 ; @anno StackMoveOptimizationPhase.Closure0
 ;;
(final-ns Closure0
    (§ defn #_"Closure0" Closure0'new-0 []
        (Object.)
    )

    (def- #_"int" Closure0'NONE -1)

    (§ mutable #_"int" :begin Closure0'NONE)
    (§ mutable #_"Register" :reg nil)
    (§ mutable #_"List<AllocatableValue>" :dst nil)
    (§ mutable #_"List<Value>" :src nil)
    (§ mutable #_"AllocatableValue" :slot nil)
    (§ mutable #_"boolean" :removed false)

    (§ method! #_"Closure0" Closure0''process-2 [#_"Closure0" this, #_"List<LIRInstruction>" ops]
        (let [
            this
                (loop-when [this this #_"int" i 0] (< i (count ops)) => this
                    (let [
                        #_"LIRInstruction" op (nth ops i)
                        this
                            (if (instance? AMD64StackMove op)
                                (let [
                                    this
                                        (when (and (some? (:reg this)) (not (= (:reg this) (:scratch op)))) => this
                                            ;; end of trace & start of new
                                            (Closure0''replaceStackMoves-2 this, ops)
                                        )
                                    ;; lazy initialize
                                    this
                                        (when (nil? (:dst this)) => this
                                            (let [
                                                this (assoc this :dst (ArrayList.))
                                                this (assoc this :src (ArrayList.))
                                            ]
                                                this
                                            )
                                        )
                                    _ (#_"List" .add (:dst this), (AMD64StackMove''getResult-1 op))
                                    _ (#_"List" .add (:src this), (AMD64StackMove''getInput-1 op))
                                ]
                                    (when (= (:begin this) Closure0'NONE) => this
                                        ;; trace begin
                                        (let [
                                            this (assoc this :begin i)
                                            this (assoc this :reg (:scratch op))
                                            this (assoc this :slot (:backupSlot op))
                                        ]
                                            this
                                        )
                                    )
                                )
                                (when-not (= (:begin this) Closure0'NONE) => this
                                    ;; end of trace
                                    (Closure0''replaceStackMoves-2 this, ops)
                                )
                            )
                    ]
                        (recur this (inc i))
                    )
                )
        ]
            ;; remove instructions
            (when (:removed this)
                (#_"List" .removeAll ops, (Collections/singleton nil))
            )
            this
        )
    )

    (§ method- #_"Closure0" Closure0''replaceStackMoves-2 [#_"Closure0" this, #_"List<LIRInstruction>" ops]
        (let [
            #_"int" size (count (:dst this))
            this
                (when (< 1 size) => this
                    (let [
                        #_"AMD64MultiStackMove" multiMove (AMD64MultiStackMove'new-4 (#_"List" .toArray (:dst this), (make-array AllocatableValue size)), (#_"List" .toArray (:src this), (make-array AllocatableValue size)), (:reg this), (:slot this))
                    ]
                        ;; replace first instruction
                        (#_"List" .set ops, (:begin this), multiMove)
                        ;; and nil out others
                        (Collections/fill (#_"List" .subList ops, (inc (:begin this)), (+ (:begin this) size)), nil)
                        ;; removed
                        (assoc this :removed true)
                    )
                )
            ;; reset
            _ (#_"List" .clear (:dst this))
            _ (#_"List" .clear (:src this))
            this (assoc this :begin Closure0'NONE)
            this (assoc this :reg nil)
            this (assoc this :slot nil)
        ]
            this
        )
    )
)

;;;
 ; Class for chunks of data that go into the data section.
 ;;
(final-ns ArrayDataPointerConstant (§ extends DataPointerConstant)
    (§ final #_"byte[]" :data nil)

    #_unused
    (§ defn #_"ArrayDataPointerConstant" ArrayDataPointerConstant'new-2 [#_"byte[]" array, #_"int" alignment]
        (let [
            #_"ArrayDataPointerConstant" this (DataPointerConstant'new-1 alignment)
            this (assoc this :data (#_"Object" .clone array))
        ]
            this
        )
    )

    #_unused
    (§ defn #_"ArrayDataPointerConstant" ArrayDataPointerConstant'new-2 [#_"short[]" array, #_"int" alignment]
        (let [
            #_"ByteBuffer" byteBuffer (ByteBuffer/allocate (* (count array) 2))
        ]
            (#_"ByteBuffer" .order byteBuffer, (ByteOrder/nativeOrder))
            (#_"ShortBuffer" .put (#_"ByteBuffer" .asShortBuffer byteBuffer), array)
            (let [
                #_"ArrayDataPointerConstant" this (DataPointerConstant'new-1 alignment)
                this (assoc this :data (#_"ByteBuffer" .array byteBuffer))
            ]
                this
            )
        )
    )

    #_unused
    (§ defn #_"ArrayDataPointerConstant" ArrayDataPointerConstant'new-2 [#_"int[]" array, #_"int" alignment]
        (let [
            #_"ByteBuffer" byteBuffer (ByteBuffer/allocate (* (count array) 4))
        ]
            (#_"ByteBuffer" .order byteBuffer, (ByteOrder/nativeOrder))
            (#_"IntBuffer" .put (#_"ByteBuffer" .asIntBuffer byteBuffer), array)
            (let [
                #_"ArrayDataPointerConstant" this (DataPointerConstant'new-1 alignment)
                this (assoc this :data (#_"ByteBuffer" .array byteBuffer))
            ]
                this
            )
        )
    )

    #_unused
    (§ defn #_"ArrayDataPointerConstant" ArrayDataPointerConstant'new-2 [#_"float[]" array, #_"int" alignment]
        (let [
            #_"ByteBuffer" byteBuffer (ByteBuffer/allocate (* (count array) 4))
        ]
            (#_"ByteBuffer" .order byteBuffer, (ByteOrder/nativeOrder))
            (#_"FloatBuffer" .put (#_"ByteBuffer" .asFloatBuffer byteBuffer), array)
            (let [
                #_"ArrayDataPointerConstant" this (DataPointerConstant'new-1 alignment)
                this (assoc this :data (#_"ByteBuffer" .array byteBuffer))
            ]
                this
            )
        )
    )

    #_unused
    (§ defn #_"ArrayDataPointerConstant" ArrayDataPointerConstant'new-2 [#_"double[]" array, #_"int" alignment]
        (let [
            #_"ByteBuffer" byteBuffer (ByteBuffer/allocate (* (count array) 8))
        ]
            (#_"ByteBuffer" .order byteBuffer, (ByteOrder/nativeOrder))
            (#_"DoubleBuffer" .put (#_"ByteBuffer" .asDoubleBuffer byteBuffer), array)
            (let [
                #_"ArrayDataPointerConstant" this (DataPointerConstant'new-1 alignment)
                this (assoc this :data (#_"ByteBuffer" .array byteBuffer))
            ]
                this
            )
        )
    )

    #_unused
    (§ defn #_"ArrayDataPointerConstant" ArrayDataPointerConstant'new-2 [#_"long[]" array, #_"int" alignment]
        (let [
            #_"ByteBuffer" byteBuffer (ByteBuffer/allocate (* (count array) 8))
        ]
            (#_"ByteBuffer" .order byteBuffer, (ByteOrder/nativeOrder))
            (#_"LongBuffer" .put (#_"ByteBuffer" .asLongBuffer byteBuffer), array)
            (let [
                #_"ArrayDataPointerConstant" this (DataPointerConstant'new-1 alignment)
                this (assoc this :data (#_"ByteBuffer" .array byteBuffer))
            ]
                this
            )
        )
    )

    (§ override! #_"boolean" ArrayDataPointerConstant''isDefaultForKind-1 [#_"ArrayDataPointerConstant" this]
        false
    )

    (§ override! #_"void" ArrayDataPointerConstant''serialize-2 [#_"ArrayDataPointerConstant" this, #_"ByteBuffer" buffer]
        (#_"ByteBuffer" .put buffer, (:data this))
        nil
    )

    (§ override! #_"int" ArrayDataPointerConstant''getSerializedSize-1 [#_"ArrayDataPointerConstant" this]
        (count (:data this))
    )

    (§ override! #_"String" ArrayDataPointerConstant''toValueString-1 [#_"ArrayDataPointerConstant" this]
        (str "ArrayDataPointerConstant" (Arrays/toString (:data this)))
    )
)

(value-ns DataBuilder
    (§ defn #_"Data" DataBuilder'createDataItem-1 [#_"Constant" constant]
        (cond
            (JavaConstant/isNull constant)
                (let [
                    #_"int" size (if (= HotSpotCompressedNullConstant/COMPRESSED_NULL constant) 4 (.wordSize HotSpot'target))
                ]
                    (ZeroData'create-2 size, size)
                )
            (instance? VMConstant constant)
                (when (instance? HotSpotConstant constant) => (throw! (str constant))
                    (let [
                        #_"int" size (if (#_"HotSpotConstant" .isCompressed constant) 4 (.wordSize HotSpot'target))
                    ]
                        (§ reify #_"Data" (Data'new-2 size, size)
                            (§ override! #_"void" Data''emit-3 [#_"Data" this, #_"ByteBuffer" buffer, #_"Patches" patches]
                                (let [
                                    #_"int" position (#_"ByteBuffer" .position buffer)
                                ]
                                    (if (= (:size this) Integer/BYTES)
                                        (#_"ByteBuffer" .putInt buffer, 0xdeaddead)
                                        (#_"ByteBuffer" .putLong buffer, 0xdeaddeaddeaddead)
                                    )
                                    (Patches''registerPatch-3 patches, position, constant)
                                )
                                nil
                            )
                        )
                    )
                )
            (instance? SerializableConstant constant)
                (SerializableData'new-1 constant)
            :else
                (throw! (str constant))
        )
    )
)

;;;
 ; Base class to represent values that need to be stored in more than one register. This is mainly
 ; intended to support addresses and not general arbitrary nesting of composite values. Because of
 ; the possibility of sharing of CompositeValues they should be immutable.
 ;;
(class-ns CompositeValue (§ extends Value)
    (§ defn #_"CompositeValue" CompositeValue'new-1 [#_"ValueKind" kind]
        (Value. kind)
    )

    ;;;
     ; Invoke {@code proc} on each Value element of this CompositeValue.
     ; If {@code proc} replaces any value then a new CompositeValue should be returned.
     ;
     ; @return the original CompositeValue or a copy with any modified values
     ;;
    (§ abstract #_"CompositeValue" CompositeValue''forEachComponent-4 [#_"CompositeValue" this, #_"LIRInstruction" op, #_"OperandMode" mode, #_"InstructionValueProcedure" proc])

    (§ abstract #_"void" CompositeValue''visitEachComponent-4 [#_"CompositeValue" this, #_"LIRInstruction" op, #_"OperandMode" mode, #_"InstructionValueConsumer" proc])
)

;;;
 ; @anno CompositeValue.Component
 ; @target ElementType.FIELD
 ;;
(§ annotation Component
    (§ value #_"OperandFlag[]" value OperandFlag'REG)
)

;;;
 ; Lazily associated metadata for every CompositeValue type. The metadata includes
 ; the offsets of fields annotated with Component as well as methods for iterating
 ; over such fields.
 ;;
(final-ns CompositeValueClass #_"<T>" (§ extends FieldIntrospection #_"<T>")
    ;;;
     ; The CompositeValueClass is only used for formatting for the most part so cache it as a ClassValue.
     ;;
    (§ def- #_"ClassValue<CompositeValueClass>" CompositeValueClass'compositeClass
        (§ reify #_"ClassValue<CompositeValueClass>" (ClassValue'new-0)
            (§ override! #_"CompositeValueClass" ClassValue''computeValue-2 [#_"ClassValue<CompositeValueClass>" this, #_"Class" type]
                (CompositeValueClass'new-1 type)
            )
        )
    )

    (§ defn #_"<T> CompositeValueClass<T>" CompositeValueClass'get-1 [#_"Class<T>" type]
        (ClassValue''get-2 CompositeValueClass'compositeClass, type)
    )

    (§ final #_"Values" :values nil)

    (§ defn- #_"CompositeValueClass" CompositeValueClass'new-1 [#_"Class<T>" clazz]
        (let [
            #_"CompositeValueFieldsScanner" vfs (CompositeValueFieldsScanner'new-0)
        ]
            (FieldsScanner''scan-4 vfs, clazz, CompositeValue, false)
            (let [
                #_"CompositeValueClass" this (FieldIntrospection'new-1 clazz)
                this (assoc this :values (Values'new-1 (get (:valueAnnotations vfs) Component)))
                this (assoc this :data (Fields'new-1 (:data vfs)))
            ]
                this
            )
        )
    )

    (§ override! #_"Fields[]" CompositeValueClass''getAllFields-1 [#_"CompositeValueClass<T>" this]
        (into-array Fields [ (:data this), (:values this) ])
    )
)

;;;
 ; @anno CompositeValueClass.CompositeValueFieldsScanner
 ;;
(final-ns CompositeValueFieldsScanner (§ extends LIRFieldsScanner)
    (§ defn #_"CompositeValueFieldsScanner" CompositeValueFieldsScanner'new-0 []
        (let [
            #_"CompositeValueFieldsScanner" this (LIRFieldsScanner'new-0)
        ]
            (#_"EconomicMap" .put (:valueAnnotations this), Component, (OperandModeAnnotation'new-0))
            this
        )
    )

    (§ override! #_"EnumSet<OperandFlag>" CompositeValueFieldsScanner''getFlags-2 [#_"CompositeValueFieldsScanner" this, #_"Field" field]
        (let [
            #_"EnumSet<OperandFlag>" result (EnumSet/noneOf OperandFlag)
        ]
            (when (#_"Field" .isAnnotationPresent field, Component) => (throw! "should not reach here")
                (#_"EnumSet" .addAll result, (Arrays/asList (Component''value-1 (#_"Field" .getAnnotation field, Component))))
            )
            result
        )
    )
)

;;;
 ; Represents an inlined Constant value.
 ;;
(final-ns ConstantValue (§ extends Value)
    (§ final #_"Constant" :constant nil)

    (§ defn #_"ConstantValue" ConstantValue'new-2 [#_"ValueKind" kind, #_"Constant" constant]
        (let [
            #_"ConstantValue" this (Value. kind)
            this (assoc this :constant constant)
        ]
            this
        )
    )
)

;;;
 ; This optimization tries to improve the handling of constants by replacing a single definition of
 ; a constant, which is potentially scheduled into a block with high probability, with one or more
 ; definitions in blocks with a lower probability.
 ;;
(final-ns ConstantLoadOptimization (§ extends PreAllocationOptimizationPhase)
    (§ defn #_"ConstantLoadOptimization" ConstantLoadOptimization'new-0 []
        (PreAllocationOptimizationPhase'new-0)
    )

    #_unused
    (§ override! #_"void" ConstantLoadOptimization''run-3 [#_"ConstantLoadOptimization" this, #_"LIRGenerationResult" lirGenRes, #_"PreAllocationOptimizationContext" context]
        (CLOptimization''apply-1 (CLOptimization'new-2 (:lir lirGenRes), (:lirGen context)))
        nil
    )
)

;;;
 ; @anno ConstantLoadOptimization.CLOptimization
 ;;
(final-ns CLOptimization
    (§ final #_"LIR" :lir nil)
    (§ final #_"LIRGenerator" :lirGen nil)
    (§ final #_"VariableMap<DefUseTree>" :map nil)
    (§ final #_"BitSet" :phiConstants nil)
    (§ final #_"BitSet" :defined nil)
    (§ final #_"BlockMap<List<UseEntry>>" :blockMap nil)
    (§ final #_"BlockMap<LIRInsertionBuffer>" :insertionBuffers nil)

    (§ defn- #_"CLOptimization" CLOptimization'new-2 [#_"LIR" lir, #_"LIRGenerator" lirGen]
        (let [
            #_"CLOptimization" this (Object.)
            this (assoc this :lir lir)
            this (assoc this :lirGen lirGen)
            this (assoc this :map (VariableMap'new-0))
            this (assoc this :phiConstants (BitSet.))
            this (assoc this :defined (BitSet.))
            this (assoc this :insertionBuffers (BlockMap'new-1 (:cfg lir)))
            this (assoc this :blockMap (BlockMap'new-1 (:cfg lir)))
        ]
            this
        )
    )

    (§ method- #_"void" CLOptimization''apply-1 [#_"CLOptimization" this]
        ;; build DefUseTree
        (doseq [#_"Block" b (:reversePostOrder (:cfg (:lir this)))]
            (CLOptimization''analyzeBlock-2 this, b)
        )
        ;; remove all with only one use
        (VariableMap''filter-2 (:map this), (ß t -> (§ fun (< 1 (DefUseTree''usageCount-1 t)))))
        ;; collect block map
        (VariableMap''forEach-2 (:map this), (ß tree -> (§ fun (VariableMap''forEach-2 tree, (§ ffun CLOptimization''addUsageToBlockMap-2)))))

        ;; create ConstantTree
        (VariableMap''forEach-2 (:map this), (§ ffun CLOptimization''createConstantTree-2))

        ;; insert moves, delete nil instructions and reset instruction ids
        (doseq [#_"Block" b (:reversePostOrder (:cfg (:lir this)))]
            (CLOptimization''rewriteBlock-2 this, b)
        )
        nil
    )

    (§ defn- #_"boolean" CLOptimization'isConstantLoad-1 [#_"LIRInstruction" op]
        (and (LIRInstruction''isLoadConstantOp-1 op) (instance? Variable (MoveOp''getResult-1 op)))
    )

    (§ method- #_"void" CLOptimization''addUsageToBlockMap-2 [#_"CLOptimization" this, #_"UseEntry" entry]
        (let [
            #_"Block" block (:block entry)
            #_"List<UseEntry>" list (BlockMap''get-2 (:blockMap this), block)
        ]
            (when (nil? list)
                (§ ass list (ArrayList.))
                (BlockMap''put-3 (:blockMap this), block, list)
            )
            (#_"List" .add list, entry)
        )
        nil
    )

    ;;;
     ; Collects def-use information for a {@code block}.
     ;;
    (§ method- #_"void" CLOptimization''analyzeBlock-2 [#_"CLOptimization" this, #_"Block" block]
        (let [
            #_"InstructionValueConsumer" loadConsumer (ß (instruction, value, mode, flags) ->
                (§ fun
                    (when (and (instance? Variable value) (not (#_"BitSet" .get (:phiConstants this), (:index value))))
                        (if (not (#_"BitSet" .get (:defined this), (:index value)))
                            (do
                                (#_"BitSet" .set (:defined this), (:index value))
                                (when (CLOptimization'isConstantLoad-1 instruction)
                                    (VariableMap''put-3 (:map this), value, (DefUseTree'new-2 instruction, block))
                                )
                            )
                            (do
                                ;; Variable is redefined, this only happens for constant loads
                                ;; introduced by phi resolution -> ignore.
                                (VariableMap''remove-2 (:map this), value)
                                (#_"BitSet" .set (:phiConstants this), (:index value))
                            )
                        )
                    )
                )
            )
            #_"InstructionValueConsumer" useConsumer (ß (instruction, value, mode, flags) ->
                (§ fun
                    (when (and (instance? Variable value) (not (#_"BitSet" .get (:phiConstants this), (:index value))))
                        (let [
                            #_"DefUseTree" tree (VariableMap''get-2 (:map this), value)
                        ]
                            (when (some? tree)
                                (DefUseTree''addUsage-4 tree, block, instruction, value)
                            )
                        )
                    )
                )
            )
        ]
            (loop-when-recur [#_"int" i 0 #_"ISeq" s (seq (LIR''getLIRforBlock-2 (:lir this), block))] (some? s) [(inc i) (next s)]
                (let [
                    #_"LIRInstruction" op (first s)
                ]
                    ;; set instruction id to the index in the lir instruction list
                    (§ ass! op (LIRInstruction''setId-2 op, i))
                    (LIRInstruction''visitEachOutput-2 op, loadConsumer)
                    (LIRInstruction''visitEachInput-2 op, useConsumer)
                    (LIRInstruction''visitEachAlive-2 op, useConsumer)
                )
            )
        )
        nil
    )

    ;;;
     ; Creates the dominator tree and searches for an solution.
     ;;
    (§ method- #_"void" CLOptimization''createConstantTree-2 [#_"CLOptimization" this, #_"DefUseTree" tree]
        (let [
            #_"ConstantTree" constTree (ConstantTree'new-2 (:cfg (:lir this)), tree)
        ]
            (DominatorOptimizationProblem''set-3 constTree, Flags'SUBTREE, (:block tree))
            (DefUseTree''forEach-2 tree, (ß u -> (§ fun (DominatorOptimizationProblem''set-3 constTree, Flags'USAGE, (:block u)))))

            (when-not (DominatorOptimizationProblem''get-3 constTree, Flags'USAGE, (:block tree)) ;; => usage in the definition block -> no optimization
                (ConstantTree''markBlocks-1 constTree)

                (let [
                    #_"NodeCost" cost (ConstantTreeAnalyzer'analyze-2 constTree, (:block tree))
                ]
                    (when (or (< 1 (:numMat cost)) (< (:bestCost cost) (:probability (:block tree)))) ;; => no better solution found
                        ;; mark original load for removal
                        (CLOptimization''deleteInstruction-2 this, tree)
                        ;; collect result
                        (CLOptimization''createLoads-4 this, tree, constTree, (:block tree))
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" CLOptimization''createLoads-4 [#_"CLOptimization" this, #_"DefUseTree" tree, #_"ConstantTree" constTree, #_"Block" startBlock]
        (let [
            #_"Deque<Block>" worklist (ArrayDeque.)
            _ (#_"Deque" .add worklist, startBlock)
        ]
            (while (seq worklist)
                (let [
                    #_"Block" block (#_"Deque" .pollLast worklist)
                ]
                    (if (DominatorOptimizationProblem''get-3 constTree, Flags'CANDIDATE, block)
                        (do
                            (DominatorOptimizationProblem''set-3 constTree, Flags'MATERIALIZE, block)
                            ;; create and insert load
                            (CLOptimization''insertLoad-5 this, (DefUseTree''getConstant-1 tree), (#_"Value" .getValueKind (DefUseTree''getVariable-1 tree)), block, (NodeCost''getUsages-1 (DominatorOptimizationProblem''getCost-2 constTree, block)))
                        )
                        (loop-when-recur [#_"Block" dominated (:firstDominated block)] (some? dominated) [(:dominatedSibling dominated)]
                            (when (ConstantTree''isMarked-2 constTree, dominated)
                                (#_"Deque" .addLast worklist, dominated)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" CLOptimization''insertLoad-5 [#_"CLOptimization" this, #_"Constant" constant, #_"ValueKind" kind, #_"Block" block, #_"List<UseEntry>" usages]
        ;; create variable
        (let [
            #_"Variable" variable (LIRGenerator''newVariable-2 (:lirGen this), kind)
            ;; create move
            #_"LIRInstruction" move (MoveFactory''createLoad-3 (:moveFactory (:lirGen this)), variable, constant)
        ]
            ;; insert instruction
            (§ ass! (CLOptimization''getInsertionBuffer-2 this, block) (LIRInsertionBuffer''append-3 (CLOptimization''getInsertionBuffer-2 this, block), 1, move))
            ;; update usages
            (doseq [#_"UseEntry" u usages]
                (UseEntry''setValue-2 u, variable)
            )
        )
        nil
    )

    ;;;
     ; Inserts the constant loads created in #createConstantTree and deletes the original definition.
     ;;
    (§ method- #_"void" CLOptimization''rewriteBlock-2 [#_"CLOptimization" this, #_"Block" block]
        ;; insert moves
        (let [
            #_"LIRInsertionBuffer" buffer (BlockMap''get-2 (:insertionBuffers this), block)
        ]
            (when (some? buffer)
                (§ ass! buffer (LIRInsertionBuffer''finish-1 buffer))
            )
            ;; delete instructions
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
                #_"boolean" hasDead
                    (loop-when [hasDead false #_"ISeq" s (seq ops)] (some? s) => hasDead
                        (let [
                            #_"LIRInstruction" op (first s)
                            hasDead
                                (when (some? op) => true
                                    (§ ass! op (LIRInstruction''setId-2 op, -1))
                                    hasDead
                                )
                        ]
                            (recur hasDead (next s))
                        )
                    )
            ]
                (when hasDead
                    ;; Remove nil values from the list.
                    (#_"ArrayList" .removeAll ops, (Collections/singleton nil))
                )
            )
        )
        nil
    )

    (§ method- #_"void" CLOptimization''deleteInstruction-2 [#_"CLOptimization" this, #_"DefUseTree" tree]
        (#_"ArrayList" .set (LIR''getLIRforBlock-2 (:lir this), (:block tree)), (LIRInstruction''id-1 (:instruction tree)), nil)
        nil
    )

    (§ method- #_"LIRInsertionBuffer" CLOptimization''getInsertionBuffer-2 [#_"CLOptimization" this, #_"Block" block]
        (or (BlockMap''get-2 (:insertionBuffers this), block)
            (let [
                #_"LIRInsertionBuffer" buffer (LIRInsertionBuffer'new-0)
            ]
                (BlockMap''put-3 (:insertionBuffers this), block, buffer)
                (§ ass! buffer (LIRInsertionBuffer''init-2 buffer, (LIR''getLIRforBlock-2 (:lir this), block)))
                buffer
            )
        )
    )
)

;;;
 ; Represents a dominator (sub-)tree for a constant definition.
 ;;
(final-ns ConstantTree (§ extends DominatorOptimizationProblem #_"<Flags, NodeCost>")
    (§ final #_"BlockMap<List<UseEntry>>" :blockMap nil)

    (§ defn #_"ConstantTree" ConstantTree'new-2 [#_"ControlFlowGraph" cfg, #_"DefUseTree" tree]
        (let [
            #_"ConstantTree" this (DominatorOptimizationProblem'new-2 Flags, cfg)
            this (assoc this :blockMap (BlockMap'new-1 cfg))
        ]
            (DefUseTree''forEach-2 tree, (ß u -> (§ fun (#_"List" .add (ConstantTree''getOrInitList-2 this, (:block u)), u))))
            this
        )
    )

    (§ method- #_"List<UseEntry>" ConstantTree''getOrInitList-2 [#_"ConstantTree" this, #_"Block" block]
        (or (BlockMap''get-2 (:blockMap this), block)
            (let [
                #_"List<UseEntry>" list (ArrayList.)
            ]
                (BlockMap''put-3 (:blockMap this), block, list)
                list
            )
        )
    )

    (§ method! #_"List<UseEntry>" ConstantTree''getUsages-2 [#_"ConstantTree" this, #_"Block" block]
        (let [
            #_"List<UseEntry>" list (BlockMap''get-2 (:blockMap this), block)
        ]
            (if (some? list) (Collections/unmodifiableList list) (Collections/emptyList))
        )
    )

    ;;;
     ; Returns the cost object associated with {@code block}. If there is none, a new cost object is created.
     ;;
    (§ method! #_"NodeCost" ConstantTree''getOrInitCost-2 [#_"ConstantTree" this, #_"Block" block]
        (or (DominatorOptimizationProblem''getCost-2 this, block)
            (let [
                #_"NodeCost" cost (NodeCost'new-3 (:probability block), (BlockMap''get-2 (:blockMap this), block), 1)
            ]
                (DominatorOptimizationProblem''setCost-3 this, block, cost)
                cost
            )
        )
    )

    #_unused
    (§ override! #_"String" ConstantTree''getName-2 [#_"ConstantTree" this, #_"Flags" type]
        (condp = type
            Flags'USAGE       "hasUsage"
            Flags'SUBTREE     "inSubtree"
            Flags'MATERIALIZE "materialize"
            Flags'CANDIDATE   "candidate"
                              (DominatorOptimizationProblem''getName-2 (§ super ), type)
        )
    )

    #_unused
    (§ method! #_"long" ConstantTree''subTreeSize-1 [#_"ConstantTree" this]
        (#_"Stream" .count (DominatorOptimizationProblem''stream-2 this, Flags'SUBTREE))
    )

    #_unused
    (§ method! #_"Block" ConstantTree''getStartBlock-1 [#_"ConstantTree" this]
        (-> (DominatorOptimizationProblem''stream-2 this, Flags'SUBTREE) (#_"Stream" .findFirst) (Optional''get-1))
    )

    (§ method! #_"void" ConstantTree''markBlocks-1 [#_"ConstantTree" this]
        (doseq [#_"Block" block (DominatorOptimizationProblem''getBlocks-1 this)]
            (when (DominatorOptimizationProblem''get-3 this, Flags'USAGE, block)
                (DominatorOptimizationProblem''setDominatorPath-3 this, Flags'SUBTREE, block)
            )
        )
        nil
    )

    (§ method! #_"boolean" ConstantTree''isMarked-2 [#_"ConstantTree" this, #_"Block" block]
        (DominatorOptimizationProblem''get-3 this, Flags'SUBTREE, block)
    )

    (§ method! #_"boolean" ConstantTree''isLeafBlock-2 [#_"ConstantTree" this, #_"Block" block]
        (loop-when [#_"Block" dom (:firstDominated block)] (some? dom) => true
            (and (not (ConstantTree''isMarked-2 this, dom))
                (recur (:dominatedSibling dom))
            )
        )
    )

    #_unused
    (§ method! #_"void" ConstantTree''setSolution-2 [#_"ConstantTree" this, #_"Block" block]
        (DominatorOptimizationProblem''set-3 this, Flags'MATERIALIZE, block)
        nil
    )

    (§ method! #_"int" ConstantTree''size-1 [#_"ConstantTree" this]
        (count (DominatorOptimizationProblem''getBlocks-1 this))
    )

    (§ method! #_"void" ConstantTree''traverseTreeWhileTrue-3 [#_"ConstantTree" this, #_"Block" block, #_"Predicate<Block>" action]
        (when (#_"Predicate" .test action, block)
            (loop-when-recur [#_"Block" dom (:firstDominated block)] (some? dom) [(:dominatedSibling dom)]
                (when (ConstantTree''isMarked-2 this, dom)
                    (ConstantTree''traverseTreeWhileTrue-3 this, dom, action)
                )
            )
        )
        nil
    )
)

;;;
 ; @anno ConstantTree.Flags
 ;;
(value-ns Flags
    (§ enum Flags'SUBTREE)
    (§ enum Flags'USAGE)
    (§ enum Flags'MATERIALIZE)
    (§ enum Flags'CANDIDATE)
)

;;;
 ; Costs associated with a block.
 ;
 ; @anno ConstantTree.NodeCost
 ;;
(final-ns NodeCost
    (§ mutable #_"List<UseEntry>" :usages nil)
    (§ mutable #_"double" :bestCost 0.0)
    (§ mutable #_"int" :numMat 0)

    (§ defn #_"NodeCost" NodeCost'new-3 [#_"double" bestCost, #_"List<UseEntry>" usages, #_"int" numMat]
        (let [
            #_"NodeCost" this (Object.)
            this (assoc this :bestCost bestCost)
            this (assoc this :usages usages)
            this (assoc this :numMat numMat)
        ]
            this
        )
    )

    #_unused
    (§ method! #_"NodeCost" NodeCost''addUsage-2 [#_"NodeCost" this, #_"UseEntry" usage]
        (let [
            this
                (when (nil? (:usages this)) => this
                    (assoc this :usages (ArrayList.))
                )
        ]
            (#_"List" .add (:usages this), usage)
            this
        )
    )

    (§ method! #_"List<UseEntry>" NodeCost''getUsages-1 [#_"NodeCost" this]
        (or (:usages this) (Collections/emptyList))
    )
)

;;;
 ; Analyzes a ConstantTree and marks potential materialization positions.
 ;;
(final-ns ConstantTreeAnalyzer
    (§ final #_"ConstantTree" :tree nil)
    (§ final #_"BitSet" :visited nil)

    (§ defn #_"NodeCost" ConstantTreeAnalyzer'analyze-2 [#_"ConstantTree" tree, #_"Block" startBlock]
        (let [
            #_"ConstantTreeAnalyzer" analyzer (ConstantTreeAnalyzer'new-1 tree)
        ]
            (ConstantTreeAnalyzer''analyzeBlocks-2 analyzer, startBlock)
            (DominatorOptimizationProblem''getCost-2 tree, startBlock)
        )
    )

    (§ defn- #_"ConstantTreeAnalyzer" ConstantTreeAnalyzer'new-1 [#_"ConstantTree" tree]
        (let [
            #_"ConstantTreeAnalyzer" this (Object.)
            this (assoc this :tree tree)
            this (assoc this :visited (BitSet. (ConstantTree''size-1 tree)))
        ]
            this
        )
    )

    ;;;
     ; Queues all relevant blocks for {@linkplain #process processing}.
     ;
     ; This is a worklist-style algorithm because a (more elegant) recursive implementation may
     ; cause stack overflows on larger graphs.
     ;
     ; @param startBlock The start block of the dominator subtree.
     ;;
    (§ method- #_"void" ConstantTreeAnalyzer''analyzeBlocks-2 [#_"ConstantTreeAnalyzer" this, #_"Block" startBlock]
        (let [
            #_"Deque<Block>" worklist (ArrayDeque.)
        ]
            (loop-when-recur [#_"Block" block startBlock] (some? block) [(#_"Deque" .pollLast worklist)]
                (cond
                    (ConstantTreeAnalyzer''isLeafBlock-2 this, block) (ConstantTreeAnalyzer''leafCost-2 this, block)
                    (#_"BitSet" .get (:visited this), (:id block))      (ConstantTreeAnalyzer''process-2 this, block)
                    :else
                        (do ;; If not yet visited (and not a leaf block), process all children first!
                            (#_"Deque" .offerLast worklist, block)
                            (loop-when-recur [#_"Block" dominated (:firstDominated block)] (some? dominated) [(:dominatedSibling dominated)]
                                (ConstantTreeAnalyzer''filteredPush-3 this, worklist, dominated)
                            )
                            (#_"BitSet" .set (:visited this), (:id block))
                        )
                )
            )
        )
        nil
    )

    ;;;
     ; Calculates the cost of a {@code block}. It is assumed that all {@code children} have already
     ; been {@linkplain #process processed}
     ;
     ; @param block The block to be processed.
     ;;
    (§ method- #_"void" ConstantTreeAnalyzer''process-2 [#_"ConstantTreeAnalyzer" this, #_"Block" block]
        (let [
            #_"List<UseEntry>" usages (ArrayList.)
            ;; collect children costs
            [#_"double" bestCost #_"int" numMat]
                (loop-when [bestCost 0.0 numMat 0 #_"Block" child (:firstDominated block)] (some? child) => [bestCost numMat]
                    (let [
                        [bestCost numMat]
                            (when (ConstantTreeAnalyzer''isMarked-2 this, child) => [bestCost numMat]
                                (let [
                                    #_"NodeCost" cost (DominatorOptimizationProblem''getCost-2 (:tree this), child)
                                ]
                                    (#_"List" .addAll usages, (NodeCost''getUsages-1 cost))
                                    [(+ bestCost (:bestCost cost)) (+ numMat (:numMat cost))]
                                )
                            )
                    ]
                        (recur bestCost numMat (:dominatedSibling child))
                    )
                )
            ;; choose block
            #_"List<UseEntry>" usagesBlock (ConstantTree''getUsages-2 (:tree this), block)
            [bestCost numMat]
                (if (or (seq usagesBlock) (ConstantTreeAnalyzer'shouldMaterializerInCurrentBlock-3 (:probability block), bestCost, numMat))
                    (do
                        ;; mark current block as potential materialization position
                        (#_"List" .addAll usages, usagesBlock)
                        (DominatorOptimizationProblem''set-3 (:tree this), Flags'CANDIDATE, block)
                        [(:probability block) 1]
                    )
                    [bestCost numMat] ;; stick with the current solution
                )
        ]
            (DominatorOptimizationProblem''setCost-3 (:tree this), block, (NodeCost'new-3 bestCost, usages, numMat))
        )
        nil
    )

    ;;;
     ; This is the cost function that decides whether a materialization should be inserted in the
     ; current block.
     ;
     ; Note that this function does not take into account if a materialization is required despite
     ; the probabilities (e.g. there are usages in the current block).
     ;
     ; @param probabilityBlock Probability of the current block.
     ; @param probabilityChildren Accumulated probability of the children.
     ; @param numMat Number of materializations along the subtrees. We use {@code numMat - 1} to
     ;            insert materializations as late as possible if the probabilities are the same.
     ;;
    (§ defn- #_"boolean" ConstantTreeAnalyzer'shouldMaterializerInCurrentBlock-3 [#_"double" probabilityBlock, #_"double" probabilityChildren, #_"int" numMat]
        (< (* probabilityBlock (Math/pow 0.9, (dec numMat))) probabilityChildren)
    )

    (§ method- #_"void" ConstantTreeAnalyzer''filteredPush-3 [#_"ConstantTreeAnalyzer" this, #_"Deque<Block>" worklist, #_"Block" block]
        (when (ConstantTreeAnalyzer''isMarked-2 this, block)
            (#_"Deque" .offerLast worklist, block)
        )
        nil
    )

    (§ method- #_"void" ConstantTreeAnalyzer''leafCost-2 [#_"ConstantTreeAnalyzer" this, #_"Block" block]
        (DominatorOptimizationProblem''set-3 (:tree this), Flags'CANDIDATE, block)
        (ConstantTree''getOrInitCost-2 (:tree this), block)
        nil
    )

    (§ method- #_"boolean" ConstantTreeAnalyzer''isMarked-2 [#_"ConstantTreeAnalyzer" this, #_"Block" block]
        (ConstantTree''isMarked-2 (:tree this), block)
    )

    (§ method- #_"boolean" ConstantTreeAnalyzer''isLeafBlock-2 [#_"ConstantTreeAnalyzer" this, #_"Block" block]
        (ConstantTree''isLeafBlock-2 (:tree this), block)
    )
)

;;;
 ; Represents def-use tree of a constant.
 ;;
(final-ns DefUseTree
    (§ final #_"LoadConstantOp" :instruction nil)
    (§ final #_"Block" :block nil)
    (§ final #_"List<UseEntry>" :uses nil)

    (§ defn #_"DefUseTree" DefUseTree'new-2 [#_"LIRInstruction" instruction, #_"Block" block]
        (let [
            #_"DefUseTree" this (Object.)
            this (assoc this :instruction instruction)
            this (assoc this :block block)
            this (assoc this :uses (ArrayList.))
        ]
            this
        )
    )

    (§ method! #_"Variable" DefUseTree''getVariable-1 [#_"DefUseTree" this]
        (MoveOp''getResult-1 (:instruction this))
    )

    (§ method! #_"Constant" DefUseTree''getConstant-1 [#_"DefUseTree" this]
        (LoadConstantOp''getConstant-1 (:instruction this))
    )

    (§ method! #_"void" DefUseTree''addUsage-4 [#_"DefUseTree" this, #_"Block" b, #_"LIRInstruction" op, #_"Value" value]
        (#_"List" .add (:uses this), (UseEntry'new-3 b, op, value))
        nil
    )

    (§ method! #_"int" DefUseTree''usageCount-1 [#_"DefUseTree" this]
        (count (:uses this))
    )

    (§ method! #_"void" DefUseTree''forEach-2 [#_"DefUseTree" this, #_"Consumer<? super UseEntry>" action]
        (#_"List" .forEach (:uses this), action)
        nil
    )
)

;;;
 ; Represents a usage of a constant.
 ;;
(final-ns UseEntry
    (§ final #_"Block" :block nil)
    (§ final #_"LIRInstruction" :instruction nil)
    (§ final #_"Value" :value nil)

    (§ defn #_"UseEntry" UseEntry'new-3 [#_"Block" block, #_"LIRInstruction" instruction, #_"Value" value]
        (let [
            #_"UseEntry" this (Object.)
            this (assoc this :block block)
            this (assoc this :instruction instruction)
            this (assoc this :value value)
        ]
            this
        )
    )

    (§ method! #_"void" UseEntry''setValue-2 [#_"UseEntry" this, #_"Value" newValue]
        (UseEntry'replaceValue-3 (:instruction this), (:value this), newValue)
        nil
    )

    (§ defn- #_"void" UseEntry'replaceValue-3 [#_"LIRInstruction" op, #_"Value" oldValue, #_"Value" newValue]
        (let [
            #_"ValueProcedure" proc (ß (value, mode, flags) -> (§ fun (if (#_"Value" .identityEquals value, oldValue) newValue value)))
        ]
            (LIRInstruction''forEachAlive-2 op, proc)
            (LIRInstruction''forEachInput-2 op, proc)
            (LIRInstruction''forEachOutput-2 op, proc)
            (LIRInstruction''forEachTemp-2 op, proc)
        )
        nil
    )
)

;;;
 ; Maps variables to a generic type.
 ;
 ; TODO evaluate data structure
 ;;
(final-ns VariableMap #_"<T>"
    (§ final #_"ArrayList<T>" :content nil)

    (§ defn #_"VariableMap" VariableMap'new-0 []
        (let [
            #_"VariableMap" this (Object.)
            this (assoc this :content (ArrayList.))
        ]
            this
        )
    )

    (§ method! #_"T" VariableMap''get-2 [#_"VariableMap<T>" this, #_"Variable" key]
        (when (and (some? key) (< (:index key) (count (:content this))))
            (nth (:content this) (:index key))
        )
    )

    (§ method! #_"T" VariableMap''put-3 [#_"VariableMap<T>" this, #_"Variable" key, #_"T" value]
        (while (<= (count (:content this)) (:index key))
            (#_"ArrayList" .add (:content this), nil)
        )
        (#_"ArrayList" .set (:content this), (:index key), value)
    )

    (§ method! #_"T" VariableMap''remove-2 [#_"VariableMap<T>" this, #_"Variable" key]
        (when (< (:index key) (count (:content this)))
            (#_"ArrayList" .set (:content this), (:index key), nil)
        )
    )

    (§ method! #_"void" VariableMap''forEach-2 [#_"VariableMap<T>" this, #_"Consumer<T>" action]
        (doseq [#_"T" e (:content this)]
            (when (some? e)
                (#_"Consumer" .accept action, e)
            )
        )
        nil
    )

    ;;;
     ; Keeps only keys which match the given predicate.
     ;;
    (§ method! #_"void" VariableMap''filter-2 [#_"VariableMap<T>" this, #_"Predicate<T>" predicate]
        (dotimes [#_"int" i (count (:content this))]
            (let [
                #_"T" e (nth (:content this) i)
            ]
                (when (and (some? e) (not (#_"Predicate" .test predicate, e)))
                    (#_"ArrayList" .set (:content this), i, nil)
                )
            )
        )
        nil
    )
)

;;;
 ; This class performs basic optimizations on the control flow graph after LIR generation.
 ;;
(final-ns ControlFlowOptimizer (§ extends PostAllocationOptimizationPhase)
    (§ defn #_"ControlFlowOptimizer" ControlFlowOptimizer'new-0 []
        (PostAllocationOptimizationPhase'new-0)
    )

    ;;;
     ; Performs control flow optimizations on the given LIR graph.
     ;;
    #_unused
    (§ override! #_"void" ControlFlowOptimizer''run-3 [#_"ControlFlowOptimizer" this, #_"LIRGenerationResult" lirGenRes, #_"PostAllocationOptimizationContext" context]
        (let [
            #_"LIR" lir (:lir lirGenRes)
        ]
            (CFOptimizer''deleteEmptyBlocks-2 (CFOptimizer'new-1 lir), (:codeEmittingOrder lir))
        )
        nil
    )
)

;;;
 ; @anno ControlFlowOptimizer.CFOptimizer
 ;;
(final-ns CFOptimizer
    (§ final #_"LIR" :lir nil)

    (§ defn- #_"CFOptimizer" CFOptimizer'new-1 [#_"LIR" lir]
        (let [
            #_"CFOptimizer" this (Object.)
            this (assoc this :lir lir)
        ]
            this
        )
    )

    ;;;
     ; Checks whether a block can be deleted. Only blocks with exactly one successor and an
     ; unconditional branch to this successor are eligable.
     ;
     ; @param block the block checked for deletion
     ; @return whether the block can be deleted
     ;;
    (§ method- #_"boolean" CFOptimizer''canDeleteBlock-2 [#_"CFOptimizer" this, #_"Block" block]
        ;; block must have exactly one successor
        (and (some? block) (= (count (:successors block)) 1) (not (= (nth (:successors block) 0) block)) (seq (:predecessors block))
            (= (count (LIR''getLIRforBlock-2 (:lir this), block)) 2)
        )
    )

    (§ method- #_"void" CFOptimizer''alignBlock-2 [#_"CFOptimizer" this, #_"Block" block]
        (when-not (:aligned? block)
            (§ ass! block (Block''setAlign-2 block, true))
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
            ]
                (#_"ArrayList" .set ops, 0, (LabelOp'new-2 (:label (nth ops 0)), true))
            )
        )
        nil
    )

    (§ method- #_"void" CFOptimizer''deleteEmptyBlocks-2 [#_"CFOptimizer" this, #_"Block[]" blocks]
        (loop-when-recur [#_"int" i 0] (< i (count blocks)) [(inc i)]
            (let [
                #_"Block" block (nth blocks i)
            ]
                (when (CFOptimizer''canDeleteBlock-2 this, block)
                    (Block''delete-1 block)
                    ;; adjust successor and predecessor lists
                    (when (:aligned? block)
                        (CFOptimizer''alignBlock-2 this, (nth (:successors block) 0))
                    )
                    (aset blocks i nil)
                )
            )
        )
        nil
    )
)

;;;
 ; This class optimizes moves, particularly those that result from eliminating SSA form.
 ;
 ; When a block has more than one predecessor, and all predecessors end with the
 ; {@linkplain EMOptimizer#same(LIRInstruction, LIRInstruction) same} sequence of
 ; move instructions, then these sequences can be replaced with a
 ; single copy of the sequence at the beginning of the block.
 ;
 ; Similarly, when a block has more than one successor, then same sequences of moves at the
 ; beginning of the successors can be placed once at the end of the block. But because the moves
 ; must be inserted before all branch instructions, this works only when there is exactly one
 ; conditional branch at the end of the block (because the moves must be inserted before all
 ; branches, but after all compares).
 ;
 ; This optimization affects all kind of moves (reg->reg, reg->stack and stack->reg).
 ; Because this optimization works best when a block contains only a few moves, it has a huge impact
 ; on the number of blocks that are totally empty.
 ;;
(final-ns EdgeMoveOptimizer (§ extends PostAllocationOptimizationPhase)
    (§ defn #_"EdgeMoveOptimizer" EdgeMoveOptimizer'new-0 []
        (PostAllocationOptimizationPhase'new-0)
    )

    #_unused
    (§ override! #_"void" EdgeMoveOptimizer''run-3 [#_"EdgeMoveOptimizer" this, #_"LIRGenerationResult" lirGenRes, #_"PostAllocationOptimizationContext" context]
        (let [
            #_"EMOptimizer" optimizer (EMOptimizer'new-1 (:lir lirGenRes))
            #_"Block[]" blockList (:linearScanOrder (:lir lirGenRes))
        ]
            ;; ignore the first block in the list (index 0 is not processed)
            (loop-when-recur [#_"int" i (dec (count blockList))] (<= 1 i) [(dec i)]
                (let [
                    #_"Block" block (nth blockList i)
                ]
                    (when (< 1 (count (:predecessors block)))
                        (EMOptimizer''optimizeMovesAtBlockEnd-2 optimizer, block)
                    )
                    (when (= (count (:successors block)) 2)
                        (EMOptimizer''optimizeMovesAtBlockBegin-2 optimizer, block)
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; @anno EdgeMoveOptimizer.EMOptimizer
 ;;
(final-ns EMOptimizer
    (§ final #_"LIR" :lir nil)
    (§ final #_"List<List<LIRInstruction>>" :edgeInstructionSeqences nil)

    (§ defn #_"EMOptimizer" EMOptimizer'new-1 [#_"LIR" lir]
        (let [
            #_"EMOptimizer" this (Object.)
            this (assoc this :lir lir)
            this (assoc this :edgeInstructionSeqences (ArrayList.))
        ]
            this
        )
    )

    ;;;
     ; Determines if two operations are both moves that have the
     ; same source and {@linkplain MoveOp#getResult() destination} operands.
     ;
     ; @param op1 the first instruction to compare
     ; @param op2 the second instruction to compare
     ; @return true if {@code op1} and {@code op2} are the same by the above algorithm
     ;;
    (§ defn- #_"boolean" EMOptimizer'same-2 [#_"LIRInstruction" op1, #_"LIRInstruction" op2]
        (cond
            (and (LIRInstruction''isValueMoveOp-1 op1) (LIRInstruction''isValueMoveOp-1 op2))
                ;; these moves are exactly equal and can be optimized
                (and (= (ValueMoveOp''getInput-1 op1) (ValueMoveOp''getInput-1 op2))
                     (= (MoveOp''getResult-1 op1) (MoveOp''getResult-1 op2))
                )
            (and (LIRInstruction''isLoadConstantOp-1 op1) (LIRInstruction''isLoadConstantOp-1 op2))
                ;; these moves are exactly equal and can be optimized
                (and (= (LoadConstantOp''getConstant-1 op1) (LoadConstantOp''getConstant-1 op2))
                     (= (MoveOp''getResult-1 op1) (MoveOp''getResult-1 op2))
                )
            :else
                false
        )
    )

    ;;;
     ; Move the longest common subsequence at the end of predecessors to the start of block.
     ;;
    (§ method- #_"void" EMOptimizer''optimizeMovesAtBlockEnd-2 [#_"EMOptimizer" this, #_"Block" block]
        ;; currently we can't handle this correctly.
        (when-not (loop [#_"ISeq" s (seq (:predecessors block))] (and (some? s) (or (= (first s) block) (recur (next s)))))
            ;; clear all internal data structures
            (#_"List" .clear (:edgeInstructionSeqences this))
            (let [
                #_"int" n (count (:predecessors block))
            ]
                (or
                    ;; setup a list with the LIR instructions of all predecessors
                    (loop-when [#_"ISeq" s (seq (:predecessors block))] (some? s)
                        (let [
                            #_"Block" b (first s)
                        ]
                            ;; => can happen with switch-statements where multiple edges are between the same blocks
                            (when (= (count (:successors b)) 1) => :abort
                                ;; ignore the unconditional branch at the end of the block
                                (let [
                                    #_"List<LIRInstruction>" l (LIR''getLIRforBlock-2 (:lir this), b)
                                ]
                                    (#_"List" .add (:edgeInstructionSeqences this), (#_"ArrayList" .subList l, 0, (dec (count l))))
                                    (recur (next s))
                                )
                            )
                        )
                    )
                    ;; process LIR instructions while all predecessors end with the same instruction
                    (loop []
                        (let [
                            #_"List<LIRInstruction>" s (nth (:edgeInstructionSeqences this) 0)
                        ]
                            (when (seq s)
                                (let [
                                    #_"LIRInstruction" op (nth s (dec (count s)))
                                ]
                                    (or
                                        (loop-when [#_"int" i 1] (< i n)
                                            (let [
                                                #_"List<LIRInstruction>" s' (nth (:edgeInstructionSeqences this) i)
                                            ]
                                                (when (and (seq s') (EMOptimizer'same-2 op, (nth s' (dec (count s'))))) => :abort
                                                    (recur (inc i))
                                                )
                                            )
                                        )
                                        (do
                                            ;; insert the instruction at the beginning of the current block
                                            (#_"ArrayList" .add (LIR''getLIRforBlock-2 (:lir this), block), 1, op)
                                            ;; delete the instructions at the end of all predecessors
                                            (dotimes [#_"int" i n]
                                                (#_"List" .remove (nth (:edgeInstructionSeqences this) i), (dec (count (nth (:edgeInstructionSeqences this) i))))
                                            )
                                            (recur)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Move the longest common subsequence at the start of successors to the end of block
     ; just prior to the branch instruction ending block.
     ;;
    (§ method- #_"void" EMOptimizer''optimizeMovesAtBlockBegin-2 [#_"EMOptimizer" this, #_"Block" block]
        (#_"List" .clear (:edgeInstructionSeqences this))
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
            #_"LIRInstruction" branch (nth ops (dec (count ops)))
        ]
            ;; Only blocks that end with a conditional branch are optimized. In addition,
            ;; a conditional branch with operands (including state) cannot be optimized.
            ;; Moving a successor instruction before such a branch may interfere with the operands.
            ;; For example, a successive move instruction may redefine an input operand.
            (when (and (instance? StandardBranchOp branch) (not (LIRInstruction''hasOperands-1 branch)))
                ;; Now it is guaranteed that the block ends with a conditional branch.
                ;; The instructions are inserted at the end of the block before the branch.
                (let [
                    #_"int" n (count (:successors block))
                ]
                    (or
                        ;; setup a list with the LIR instructions of all successors
                        (loop-when [#_"ISeq" s (seq (:successors block))] (some? s)
                            (let [
                                #_"Block" b (first s)
                            ]
                                ;; => can happen with switch-statements where multiple edges are between the same blocks
                                (when (= (count (:predecessors b)) 1) => :abort
                                    ;; ignore the label at the beginning of the block
                                    (let [
                                        #_"List<LIRInstruction>" l (LIR''getLIRforBlock-2 (:lir this), b)
                                    ]
                                        (#_"List" .add (:edgeInstructionSeqences this), (#_"ArrayList" .subList l, 1, (count l)))
                                        (recur (next s))
                                    )
                                )
                            )
                        )
                        ;; process LIR instructions while all successors begin with the same instruction
                        (loop [#_"int" insertAt (dec (count ops))]
                            (let [
                                #_"List<LIRInstruction>" s (nth (:edgeInstructionSeqences this) 0)
                            ]
                                (when (seq s)
                                    (let [
                                        #_"LIRInstruction" op (nth s 0)
                                    ]
                                        (or
                                            (loop-when [#_"int" i 1] (< i n)
                                                (let [
                                                    #_"List<LIRInstruction>" s' (nth (:edgeInstructionSeqences this) i)
                                                ]
                                                    ;; => these instructions are different and cannot be optimized
                                                    (when (and (seq s') (EMOptimizer'same-2 op, (nth s' 0))) => :abort
                                                        (recur (inc i))
                                                    )
                                                )
                                            )
                                            (do
                                                ;; insert the instruction at the end of the current block
                                                (#_"ArrayList" .add (LIR''getLIRforBlock-2 (:lir this), block), insertAt, op)
                                                ;; delete the instructions at the beginning of all successors
                                                (dotimes [#_"int" i n]
                                                    (#_"List" .remove (nth (:edgeInstructionSeqences this) i), 0)
                                                )
                                                (recur (inc insertAt))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; This class is used to build the stack frame layout for a compiled method. A StackSlot is
 ; used to index slots of the frame relative to the stack pointer. The frame size is only fixed
 ; after register allocation when all spill slots have been allocated. Both the outgoing argument
 ; area and the spill are can grow until then. Therefore, outgoing arguments are indexed from the
 ; stack pointer, while spill slots are indexed from the beginning of the frame (and the total frame
 ; size has to be added to get the actual offset from the stack pointer).
 ;;
(class-ns FrameMap
    ;;;
     ; The final frame size, not including the size of the
     ; {@link Architecture#getReturnAddressSize() return address slot}. The value is only set after
     ; register allocation is complete, i.e. after all spill slots have been allocated.
     ;;
    (§ mutable #_"int" :frameSize 0)

    ;;;
     ; Initial size of the area occupied by spill slots and other stack-allocated memory blocks.
     ;;
    (§ mutable #_"int" :initialSpillSize 0)

    ;;;
     ; Size of the area occupied by spill slots and other stack-allocated memory blocks.
     ;;
    (§ mutable #_"int" :spillSize 0)

    ;;;
     ; Size of the area occupied by outgoing overflow arguments. This value is adjusted as calling
     ; conventions for outgoing calls are retrieved. On some platforms, there is a minimum outgoing
     ; size even if no overflow arguments are on the stack.
     ;;
    (§ mutable #_"int" :outgoingSize 0)

    ;;;
     ; Determines if this frame has values on the stack for outgoing calls.
     ;;
    (§ mutable #_"boolean" :hasOutgoingStackArguments false)

    ;;;
     ; The list of stack slots allocated in this frame that are present in every reference map.
     ;;
    (§ final #_"List<StackSlot>" :objectStackSlots nil)

    ;;;
     ; Records whether an offset to an incoming stack argument was ever returned by
     ; #offsetForStackSlot(StackSlot).
     ;;
    (§ mutable #_"boolean" :accessesCallerFrame false)

    ;;;
     ; Creates a new frame map for the specified method.
     ;;
    (§ defn #_"FrameMap" FrameMap'new-0 []
        (let [
            #_"FrameMap" this (Object.)
            this (assoc this :frameSize -1)
            this (assoc this :outgoingSize (#_"CodeCacheProvider" .getMinimumOutgoingSize HotSpot'codeCache))
            this (assoc this :objectStackSlots (ArrayList.))
        ]
            this
        )
    )

    (§ method! #_"int" FrameMap''returnAddressSize-1 [#_"FrameMap" this]
        (#_"Architecture" .getReturnAddressSize (.arch HotSpot'target))
    )

    ;;;
     ; Determines if an offset to an incoming stack argument was ever returned by
     ; #offsetForStackSlot(StackSlot).
     ;;
    #_unused
    (§ method! #_"boolean" FrameMap''accessesCallerFrame-1 [#_"FrameMap" this]
        (:accessesCallerFrame this)
    )

    ;;;
     ; Gets the frame size of the compiled frame, not including the size of the
     ; {@link Architecture#getReturnAddressSize() return address slot}.
     ;
     ; @return the size of the frame (in bytes)
     ;;
    (§ method! #_"int" FrameMap''frameSize-1 [#_"FrameMap" this]
        (:frameSize this)
    )

    #_unused
    (§ method! #_"int" FrameMap''outgoingSize-1 [#_"FrameMap" this]
        (:outgoingSize this)
    )

    ;;;
     ; Determines if any space is used in the frame apart from the
     ; {@link Architecture#getReturnAddressSize() return address slot}.
     ;;
    (§ method! #_"boolean" FrameMap''frameNeedsAllocating-1 [#_"FrameMap" this]
        (let [
            #_"int" unalignedFrameSize (- (:spillSize this) (FrameMap''returnAddressSize-1 this))
        ]
            (or (:hasOutgoingStackArguments this) (not= unalignedFrameSize 0))
        )
    )

    ;;;
     ; Gets the total frame size of the compiled frame, including the size of the
     ; {@link Architecture#getReturnAddressSize() return address slot}.
     ;
     ; @return the total size of the frame (in bytes)
     ;;
    (§ abstract #_"int" FrameMap''totalFrameSize-1 [#_"FrameMap" this])

    ;;;
     ; Gets the current size of this frame. This is the size that would be returned by
     ; #frameSize() if #finish() were called now.
     ;;
    (§ abstract #_"int" FrameMap''currentFrameSize-1 [#_"FrameMap" this])

    ;;;
     ; Aligns the given frame size to the stack alignment size and return the aligned size.
     ;
     ; @param size the initial frame size to be aligned
     ; @return the aligned frame size
     ;;
    #_unused
    (§ method #_"int" FrameMap''alignFrameSize-2 [#_"FrameMap" this, #_"int" size]
        (NumUtil'roundUp-2 size, (.stackAlignment HotSpot'target))
    )

    ;;;
     ; Computes the final size of this frame. After this method has been called, methods that change
     ; the frame size cannot be called anymore, e.g. no more spill slots or outgoing arguments can
     ; be requested.
     ;;
    (§ method #_"void" FrameMap''finish-1 [#_"FrameMap" this]
        (§ ass! this (assoc this :frameSize (FrameMap''currentFrameSize-1 this)))
        (when (< (#_"RegisterConfig" .getMaximumFrameSize HotSpot'registerConfig) (:frameSize this))
            (throw! (str "frame size (" (:frameSize this) ") exceeded maximum allowed frame size (" (#_"RegisterConfig" .getMaximumFrameSize HotSpot'registerConfig) ")"))
        )
        nil
    )

    ;;;
     ; Computes the offset of a stack slot relative to the frame register.
     ;
     ; @param slot a stack slot
     ; @return the offset of the stack slot
     ;;
    (§ method #_"int" FrameMap''offsetForStackSlot-2 [#_"FrameMap" this, #_"StackSlot" slot]
        (when (#_"StackSlot" .isInCallerFrame slot)
            (§ ass! this (assoc this :accessesCallerFrame true))
        )
        (#_"StackSlot" .getOffset slot, (FrameMap''totalFrameSize-1 this))
    )

    ;;;
     ; Informs the frame map that the compiled code calls a particular method, which may need stack
     ; space for outgoing arguments.
     ;
     ; @param cc The calling convention for the called method.
     ;;
    (§ method #_"void" FrameMap''callsMethod-2 [#_"FrameMap" this, #_"CallingConvention" cc]
        (§ ass! this (FrameMap''reserveOutgoing-2 this, (#_"CallingConvention" .getStackSize cc)))
        nil
    )

    ;;;
     ; Reserves space for stack-based outgoing arguments.
     ;
     ; @param argsSize The amount of space (in bytes) to reserve for stack-based outgoing arguments.
     ;;
    (§ method! #_"FrameMap" FrameMap''reserveOutgoing-2 [#_"FrameMap" this, #_"int" argsSize]
        (let [
            this (assoc this :outgoingSize (max (:outgoingSize this) argsSize))
            this (assoc this :hasOutgoingStackArguments (or (:hasOutgoingStackArguments this) (pos? argsSize)))
        ]
            this
        )
    )

    ;;;
     ; Reserves a new spill slot in the frame of the method being compiled. The returned slot is
     ; aligned on its natural alignment, i.e. an 8-byte spill slot is aligned at an 8-byte boundary.
     ;
     ; @param kind The kind of the spill slot to be reserved.
     ; @return a spill slot denoting the reserved memory area
     ;;
    (§ method! #_"StackSlot" FrameMap''allocateNewSpillSlot-3 [#_"FrameMap" this, #_"ValueKind" kind, #_"int" additionalOffset]
        (StackSlot/get kind, (+ (- (:spillSize this)) additionalOffset), true)
    )

    ;;;
     ; Returns the spill slot size for the given ValueKind. The default value is the size in
     ; bytes for the target architecture.
     ;
     ; @param kind the ValueKind to be stored in the spill slot.
     ; @return the size in bytes
     ;;
    (§ method! #_"int" FrameMap''spillSlotSize-2 [#_"FrameMap" this, #_"ValueKind" kind]
        (#_"PlatformKind" .getSizeInBytes (#_"ValueKind" .getPlatformKind kind))
    )

    ;;;
     ; Reserves a spill slot in the frame of the method being compiled. The returned slot is aligned
     ; on its natural alignment, i.e. an 8-byte spill slot is aligned at an 8-byte boundary, unless
     ; overridden by a subclass.
     ;
     ; @param kind The kind of the spill slot to be reserved.
     ; @return a spill slot denoting the reserved memory area
     ;;
    (§ method #_"StackSlot" FrameMap''allocateSpillSlot-2 [#_"FrameMap" this, #_"ValueKind" kind]
        (let [
            #_"int" size (FrameMap''spillSlotSize-2 this, kind)
        ]
            (§ ass! this (assoc this :spillSize (NumUtil'roundUp-2 (+ (:spillSize this) size), size)))
            (FrameMap''allocateNewSpillSlot-3 this, kind, 0)
        )
    )

    ;;;
     ; Returns the size of the stack slot range for {@code slots} objects.
     ;
     ; @param slots The number of slots.
     ; @return the size in bytes
     ;;
    (§ method! #_"int" FrameMap''spillSlotRangeSize-2 [#_"FrameMap" this, #_"int" slots]
        (* slots (.wordSize HotSpot'target))
    )

    ;;;
     ; Reserves a number of contiguous slots in the frame of the method being compiled. If the
     ; requested number of slots is 0, this method returns nil.
     ;
     ; @param n the number of slots to reserve
     ; @param objects specifies the indexes of the object pointer slots. The caller is responsible
     ;            for guaranteeing that each such object pointer slot is initialized before any
     ;            instruction that uses a reference map. Without this guarantee, the garbage
     ;            collector could see garbage object values.
     ; @return the first reserved stack slot (i.e. at the lowest address)
     ;;
    (§ method #_"StackSlot" FrameMap''allocateStackSlots-3 [#_"FrameMap" this, #_"int" n, #_"BitSet" objects]
        (when (pos? n)
            (§ ass! this (assoc this :spillSize (+ (:spillSize this) (FrameMap''spillSlotRangeSize-2 this, n))))

            (when-not (#_"BitSet" .isEmpty objects) => (FrameMap''allocateNewSpillSlot-3 this, (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target))), 0)
                (loop-when [#_"StackSlot" slot nil #_"int" i 0] (< i n) => slot
                    (let [
                        #_"StackSlot" objectSlot
                            (when (#_"BitSet" .get objects, i)
                                (let [
                                    objectSlot (FrameMap''allocateNewSpillSlot-3 this, (LIRKind'reference-1 (#_"Architecture" .getWordKind (.arch HotSpot'target))), (* i (.wordSize HotSpot'target)))
                                ]
                                    (FrameMap''addObjectStackSlot-2 this, objectSlot)
                                    objectSlot
                                )
                            )
                        slot
                            (when (zero? i) => slot
                                (or objectSlot
                                    (FrameMap''allocateNewSpillSlot-3 this, (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target))), 0)
                                )
                            )
                    ]
                        (recur slot (inc i))
                    )
                )
            )
        )
    )

    (§ method! #_"void" FrameMap''addObjectStackSlot-2 [#_"FrameMap" this, #_"StackSlot" objectSlot]
        (#_"List" .add (:objectStackSlots this), objectSlot)
        nil
    )
)

;;;
 ; A FrameMapBuilder is used to collect all information necessary to
 ; {@linkplain #buildFrameMap create} a FrameMap.
 ;;
(class-ns FrameMapBuilder
    (§ defn #_"FrameMapBuilder" FrameMapBuilder'new-0 []
        (Object.)
    )

    ;;;
     ; Reserves a spill slot in the frame of the method being compiled. The returned slot is aligned
     ; on its natural alignment, i.e. an 8-byte spill slot is aligned at an 8-byte boundary, unless
     ; overridden by a subclass.
     ;
     ; @param kind The kind of the spill slot to be reserved.
     ; @return a spill slot denoting the reserved memory area
     ;;
    (§ abstract #_"VirtualStackSlot" FrameMapBuilder''allocateSpillSlot-2 [#_"FrameMapBuilder" this, #_"ValueKind" kind])

    ;;;
     ; Reserves a number of contiguous slots in the frame of the method being compiled. If the
     ; requested number of slots is 0, this method returns nil.
     ;
     ; @param slots the number of slots to reserve
     ; @param objects specifies the indexes of the object pointer slots. The caller is responsible
     ;            for guaranteeing that each such object pointer slot is initialized before any
     ;            instruction that uses a reference map. Without this guarantee, the garbage
     ;            collector could see garbage object values.
     ; @param outObjectStackSlots if non-nil, the object pointer slots allocated are added to this list
     ; @return the first reserved stack slot (i.e. at the lowest address)
     ;;
    (§ abstract #_"VirtualStackSlot" FrameMapBuilder''allocateStackSlots-4 [#_"FrameMapBuilder" this, #_"int" slots, #_"BitSet" objects, #_"List<VirtualStackSlot>" outObjectStackSlots])

    ;;;
     ; Informs the frame map that the compiled code calls a particular method, which may need stack
     ; space for outgoing arguments.
     ;
     ; @param cc The calling convention for the called method.
     ;;
    (§ abstract #_"void" FrameMapBuilder''callsMethod-2 [#_"FrameMapBuilder" this, #_"CallingConvention" cc])

    ;;;
     ; Creates a FrameMap based on the information collected by this FrameMapBuilder.
     ;;
    (§ abstract #_"FrameMap" FrameMapBuilder''buildFrameMap-2 [#_"FrameMapBuilder" this, #_"LIRGenerationResult" result])
)

;;;
 ; A FrameMapBuilder that records allocation.
 ;;
(class-ns FrameMapBuilderImpl (§ extends FrameMapBuilderTool)
    (§ final #_"FrameMap" :frameMap nil)
    (§ final #_"List<VirtualStackSlot>" :stackSlots nil)
    (§ final #_"List<CallingConvention>" :calls nil)
    (§ mutable #_"int" :numStackSlots 0)

    (§ defn #_"FrameMapBuilderImpl" FrameMapBuilderImpl'new-1 [#_"FrameMap" frameMap]
        (let [
            #_"FrameMapBuilderImpl" this (FrameMapBuilderTool'new-0)
            this (assoc this :frameMap frameMap)
            this (assoc this :stackSlots (ArrayList.))
            this (assoc this :calls (ArrayList.))
            this (assoc this :numStackSlots 0)
        ]
            this
        )
    )

    #_unused
    (§ override #_"VirtualStackSlot" FrameMapBuilderImpl''allocateSpillSlot-2 [#_"FrameMapBuilderImpl" this, #_"ValueKind" kind]
        (let [
            #_"SimpleVirtualStackSlot" slot (SimpleVirtualStackSlot'new-2 (:numStackSlots this), kind)
        ]
            (§ ass! this (update this :numStackSlots inc))
            (#_"List" .add (:stackSlots this), slot)
            slot
        )
    )

    #_unused
    (§ override #_"VirtualStackSlot" FrameMapBuilderImpl''allocateStackSlots-4 [#_"FrameMapBuilderImpl" this, #_"int" slots, #_"BitSet" objects, #_"List<VirtualStackSlot>" outObjectStackSlots]
        (cond
            (zero? slots)               nil
            (some? outObjectStackSlots) (throw! "unimplemented")
            :else
                (let [
                    #_"VirtualStackSlotRange" slot (VirtualStackSlotRange'new-4 (:numStackSlots this), slots, objects, (LIRKind'fromJavaKind-2 (.arch HotSpot'target), JavaKind/Object))
                ]
                    (§ ass! this (update this :numStackSlots inc))
                    (#_"List" .add (:stackSlots this), slot)
                    slot
                )
        )
    )

    #_unused
    (§ override #_"FrameMap" FrameMapBuilderImpl''getFrameMap-1 [#_"FrameMapBuilderImpl" this]
        (:frameMap this)
    )

    #_unused
    (§ override #_"int" FrameMapBuilderImpl''getNumberOfStackSlots-1 [#_"FrameMapBuilderImpl" this]
        (:numStackSlots this)
    )

    #_unused
    (§ override #_"void" FrameMapBuilderImpl''callsMethod-2 [#_"FrameMapBuilderImpl" this, #_"CallingConvention" cc]
        (#_"List" .add (:calls this), cc)
        nil
    )

    #_unused
    (§ override #_"FrameMap" FrameMapBuilderImpl''buildFrameMap-2 [#_"FrameMapBuilderImpl" this, #_"LIRGenerationResult" res]
        (doseq [#_"CallingConvention" cc (:calls this)]
            (FrameMap''callsMethod-2 (:frameMap this), cc)
        )
        (FrameMap''finish-1 (:frameMap this))
        (:frameMap this)
    )

    #_unused
    (§ override #_"List<VirtualStackSlot>" FrameMapBuilderImpl''getStackSlots-1 [#_"FrameMapBuilderImpl" this]
        (:stackSlots this)
    )
)

;;;
 ; A FrameMapBuilder that allows access to the underlying FrameMap.
 ;;
(class-ns FrameMapBuilderTool (§ extends FrameMapBuilder)
    (§ defn #_"FrameMapBuilderTool" FrameMapBuilderTool'new-0 []
        (FrameMapBuilder'new-0)
    )

    ;;;
     ; Returns the number of VirtualStackSlots created by this FrameMapBuilder.
     ; Can be used as an upper bound for an array indexed by VirtualStackSlot#getId().
     ;;
    (§ abstract #_"int" FrameMapBuilderTool''getNumberOfStackSlots-1 [#_"FrameMapBuilderTool" this])

    (§ abstract #_"List<VirtualStackSlot>" FrameMapBuilderTool''getStackSlots-1 [#_"FrameMapBuilderTool" this])

    (§ abstract #_"FrameMap" FrameMapBuilderTool''getFrameMap-1 [#_"FrameMapBuilderTool" this])
)

;;;
 ; Represents a {@link VirtualStackSlot virtual stack slot} for a specific {@link ValueKind kind}.
 ;;
(final-ns SimpleVirtualStackSlot (§ extends VirtualStackSlot)
    (§ defn #_"SimpleVirtualStackSlot" SimpleVirtualStackSlot'new-2 [#_"int" id, #_"ValueKind" kind]
        (VirtualStackSlot'new-2 id, kind)
    )
)

;;;
 ; Represents a {@link #getSlots() numbered} range of {@link VirtualStackSlot virtual stack slot}
 ; of size TargetDescription#wordSize.
 ;;
(final-ns VirtualStackSlotRange (§ extends VirtualStackSlot)
    (§ final #_"BitSet" :objects nil)
    (§ final #_"int" :slots 0)

    (§ defn #_"VirtualStackSlotRange" VirtualStackSlotRange'new-4 [#_"int" id, #_"int" slots, #_"BitSet" objects, #_"LIRKind" kind]
        (let [
            #_"VirtualStackSlotRange" this (VirtualStackSlot'new-2 id, kind)
            this (assoc this :slots slots)
            this (assoc this :objects (#_"Object" .clone objects))
        ]
            this
        )
    )

    (§ method! #_"BitSet" VirtualStackSlotRange''getObjects-1 [#_"VirtualStackSlotRange" this]
        (#_"Object" .clone (:objects this))
    )
)

(final-ns LIRGenerationResult
    (§ final #_"LIR" :lir nil)
    ;;;
     ; FrameMapBuilder for collecting the information to build a FrameMap.
     ;
     ; Valid only prior calling #buildFrameMap.
     ;;
    (§ final #_"FrameMapBuilder" :frameMapBuilder nil)
    ;;;
     ; FrameMap associated with this LIRGenerationResult.
     ;
     ; Valid only after calling #buildFrameMap.
     ;;
    (§ mutable #_"FrameMap" :frameMap nil)
    ;;;
     ; Incoming calling convention for the parameters of the method that is compiled.
     ;;
    (§ final #_"CallingConvention" :callingConvention nil)
    ;;;
     ; Records whether the code being generated makes at least one foreign call.
     ;;
    (§ mutable #_"boolean" :hasForeignCall false)

    (§ final #_"Object" :stub nil)

    (§ defn #_"LIRGenerationResult" LIRGenerationResult'new-4 [#_"LIR" lir, #_"FrameMapBuilder" frameMapBuilder, #_"CallingConvention" callingConvention, #_"Object" stub]
        (let [
            #_"LIRGenerationResult" this (Object.)
            this (assoc this :lir lir)
            this (assoc this :frameMapBuilder frameMapBuilder)
            this (assoc this :callingConvention callingConvention)
            this (assoc this :stub stub)
        ]
            this
        )
    )

    ;;;
     ; Creates a FrameMap out of the FrameMapBuilder. This method should only be
     ; called once. After calling it, #getFrameMapBuilder() can no longer be used.
     ;;
    (§ method! #_"LIRGenerationResult" LIRGenerationResult''buildFrameMap-1 [#_"LIRGenerationResult" this]
        (assoc this :frameMap (FrameMapBuilder''buildFrameMap-2 (:frameMapBuilder this), this))
    )

    (§ method! #_"LIRGenerationResult" LIRGenerationResult''setForeignCall-2 [#_"LIRGenerationResult" this, #_"boolean" hasForeignCall]
        (assoc this :hasForeignCall hasForeignCall)
    )
)

;;;
 ; This namespace traverses the HIR instructions and generates LIR instructions from them.
 ;;
(final-ns LIRGenerator
    (§ final #_"LIRGenerationResult" :res nil)
    ;;;
     ; Intended to be a special MoveFactory for spill moves.
     ;
     ; The instructions returned by this factory must only depend on the input values. References
     ; to values that require interaction with register allocation are strictly forbidden.
     ;;
    (§ final #_"MoveFactory" :moveFactory nil)

    (§ mutable #_"LockStackHolder" :lockStackHolder nil)
    (§ mutable #_"SaveRbp" :saveRbp nil)
    ;;;
     ; List of epilogue operations that need to restore RBP.
     ;;
    (§ mutable #_"List<AMD64HotSpotRestoreRbpOp>" :epilogueOps (ArrayList.))
    (§ mutable #_"Register" :pollOnReturnScratchRegister nil)

    (§ mutable #_"Block" :currentBlock nil)

    (§ defn #_"LIRGenerator" LIRGenerator'new-1 [#_"LIRGenerationResult" res]
        (let [
            #_"LIRGenerator" this (Object.)
            this (assoc this :res res)
            this (assoc this :moveFactory (MoveFactory'new-1 (BackupSlotProvider'new-1 (:frameMapBuilder res))))
        ]
            this
        )
    )

    (§ method! #_"LIRInstruction" LIRGenerator''append-2 [#_"LIRGenerator" this, #_"LIRInstruction" op]
        (#_"ArrayList" .add (LIR''getLIRforBlock-2 (:lir (:res this)), (:currentBlock this)), op)
        (when (instance? AMD64HotSpotRestoreRbpOp op)
            (#_"List" .add (:epilogueOps this), op)
        )
        op
    )

    ;;;
     ; Emit an atomic read-and-add instruction.
     ;
     ; @param address address of the value to be read and written
     ; @param delta the value to be added
     ;;
    (§ method! #_"Value" LIRGenerator''emitAtomicReadAndAdd-3 [#_"LIRGenerator" this, #_"Value" address, #_"Value" delta]
        (let [
            #_"ValueKind" kind (#_"Value" .getValueKind delta)
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
            #_"AMD64AddressValue" addressValue (LIRGenerator''asAddressValue-2 this, address)
        ]
            (LIRGenerator''append-2 this, (AtomicReadAndAddOp'new-4 (#_"ValueKind" .getPlatformKind kind), result, addressValue, (LIRGenerator''asAllocatable-2 this, delta)))
            result
        )
    )

    ;;;
     ; Emit an atomic read-and-write instruction.
     ;
     ; @param address address of the value to be read and written
     ; @param newValue the new value to be written
     ;;
    (§ method! #_"Value" LIRGenerator''emitAtomicReadAndWrite-3 [#_"LIRGenerator" this, #_"Value" address, #_"Value" newValue]
        (let [
            #_"ValueKind" kind (#_"Value" .getValueKind newValue)
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
            #_"AMD64AddressValue" addressValue (LIRGenerator''asAddressValue-2 this, address)
        ]
            (LIRGenerator''append-2 this, (AtomicReadAndWriteOp'new-4 (#_"ValueKind" .getPlatformKind kind), result, addressValue, (LIRGenerator''asAllocatable-2 this, newValue)))
            result
        )
    )

    ;;;
     ; Create a new Variable.
     ;
     ; @param kind The type of the value that will be stored in this Variable. See LIRKind for documentation
     ;            on what to pass here. Note that in most cases, simply passing Value#getValueKind() is wrong.
     ; @return a new Variable
     ;;
    (§ method! #_"Variable" LIRGenerator''newVariable-2 [#_"LIRGenerator" this, #_"ValueKind" valueKind]
        (Variable'new-2 valueKind, (LIR''nextVariable-1 (:lir (:res this))))
    )

    #_unused
    (§ method! #_"RegisterAttributes" LIRGenerator''attributes-2 [#_"LIRGenerator" this, #_"Register" register]
        (nth (#_"RegisterConfig" .getAttributesMap HotSpot'registerConfig) (.number register))
    )

    (§ method! #_"Variable" LIRGenerator''emitMove-2 [#_"LIRGenerator" this, #_"Value" input]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind input))
        ]
            (LIRGenerator''emitMove-3 this, result, input)
            result
        )
    )

    (§ method! #_"void" LIRGenerator''emitMove-3 [#_"LIRGenerator" this, #_"AllocatableValue" dst, #_"Value" src]
        (LIRGenerator''append-2 this, (MoveFactory''createMove-3 (:moveFactory this), dst, src))
        nil
    )

    (§ method! #_"void" LIRGenerator''emitMoveConstant-3 [#_"LIRGenerator" this, #_"AllocatableValue" dst, #_"Constant" src]
        (LIRGenerator''append-2 this, (MoveFactory''createLoad-3 (:moveFactory this), dst, src))
        nil
    )

    (§ method! #_"Value" LIRGenerator''emitConstant-3 [#_"LIRGenerator" this, #_"LIRKind" kind, #_"Constant" constant]
        (if (MoveFactory''canInlineConstant-2 (:moveFactory this), constant)
            (ConstantValue'new-2 (LIRGenerator''toRegisterKind-2 this, kind), constant)
            (LIRGenerator''emitLoadConstant-3 this, (LIRGenerator''toRegisterKind-2 this, kind), constant)
        )
    )

    (§ method! #_"Value" LIRGenerator''emitJavaConstant-2 [#_"LIRGenerator" this, #_"JavaConstant" constant]
        (LIRGenerator''emitConstant-3 this, (#_"ValueKindFactory" .getValueKind HotSpot'valueKindFactory, (#_"JavaConstant" .getJavaKind constant)), constant)
    )

    (§ method! #_"Variable" LIRGenerator''emitAddress-2 [#_"LIRGenerator" this, #_"AllocatableValue" stackslot]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target))))
        ]
            (LIRGenerator''append-2 this, (StackLeaOp'new-2 result, stackslot))
            result
        )
    )

    (§ method! #_"void" LIRGenerator''emitMembar-2 [#_"LIRGenerator" this, #_"int" barriers]
        (let [
            #_"int" necessaryBarriers (#_"Architecture" .requiredBarriers (.arch HotSpot'target), barriers)
        ]
            (when (and (.isMP HotSpot'target) (not (zero? necessaryBarriers)))
                (LIRGenerator''append-2 this, (MembarOp'new-1 necessaryBarriers))
            )
        )
        nil
    )

    ;;;
     ; Some backends need to convert sub-word kinds to a larger kind in LIRGenerator#emitLoad and #emitLoadConstant
     ; because sub-word registers can't be accessed. This method converts the
     ; LIRKind of a memory location or constant to the LIRKind that will be used when it is loaded into a register.
     ;
     ; The AMD64 backend only uses DWORD and QWORD values in registers because of a performance penalty
     ; when accessing WORD or BYTE registers. This function converts small integer kinds to DWORD.
     ;;
    (§ method! #_"<K extends ValueKind<K>> K" LIRGenerator''toRegisterKind-2 [#_"LIRGenerator" this, #_"K" kind]
        (when (any = (#_"ValueKind" .getPlatformKind kind) AMD64Kind/BYTE AMD64Kind/WORD) => kind
            (#_"ValueKind" .changeType kind, AMD64Kind/DWORD)
        )
    )

    (§ method! #_"AllocatableValue" LIRGenerator''emitLoadConstant-3 [#_"LIRGenerator" this, #_"ValueKind" kind, #_"Constant" constant]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
        ]
            (LIRGenerator''emitMoveConstant-3 this, result, constant)
            result
        )
    )

    (§ method! #_"void" LIRGenerator''emitNullCheck-2 [#_"LIRGenerator" this, #_"Value" address]
        (if (= (#_"ValueKind" .getPlatformKind (#_"Value" .getValueKind address)) (#_"ValueKind" .getPlatformKind (LIRKindTool'getNarrowOopKind-0)))
            (let [
                #_"CompressEncoding" encoding HotSpot'oopEncoding
                #_"Value" uncompressed
                    (if (<= (:shift encoding) 3)
                        (let [
                            #_"LIRKind" wordKind (LIRKind'unknownReference-1 (#_"Architecture" .getWordKind (.arch HotSpot'target)))
                        ]
                            (AMD64AddressValue'new-5 wordKind, (#_"Register" .asValue HotSpot'heapBaseRegister, wordKind), (LIRGenerator''asAllocatable-2 this, address), (Scale'fromInt-1 (<< 1 (:shift encoding))), 0)
                        )
                        (LIRGenerator''emitUncompress-4 this, address, encoding, false)
                    )
            ]
                (LIRGenerator''append-2 this, (NullCheckOp'new-1 (LIRGenerator''asAddressValue-2 this, uncompressed)))
            )
            (LIRGenerator''append-2 this, (NullCheckOp'new-1 (LIRGenerator''asAddressValue-2 this, address)))
        )
        nil
    )

    (§ method! #_"Variable" LIRGenerator''emitLogicCompareAndSwap-6 [#_"LIRGenerator" this, #_"Value" address, #_"Value" expectedValue, #_"Value" newValue, #_"Value" trueValue, #_"Value" falseValue]
        (let [
            #_"ValueKind" kind (#_"Value" .getValueKind newValue)
            #_"AMD64Kind" memKind (#_"ValueKind" .getPlatformKind kind)
            #_"AMD64AddressValue" addressValue (LIRGenerator''asAddressValue-2 this, address)
            #_"RegisterValue" raxRes (#_"Register" .asValue AMD64/rax, kind)
        ]
            (LIRGenerator''emitMove-3 this, raxRes, expectedValue)
            (LIRGenerator''append-2 this, (CompareAndSwapOp'new-5 memKind, raxRes, addressValue, raxRes, (LIRGenerator''asAllocatable-2 this, newValue)))

            (let [
                #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind trueValue))
            ]
                (LIRGenerator''append-2 this, (CondMoveOp'new-4 result, Condition'EQ, (LIRGenerator''asAllocatable-2 this, trueValue), falseValue))
                result
            )
        )
    )

    (§ method! #_"Value" LIRGenerator''emitValueCompareAndSwap-4 [#_"LIRGenerator" this, #_"Value" address, #_"Value" expectedValue, #_"Value" newValue]
        (let [
            #_"ValueKind" kind (#_"Value" .getValueKind newValue)
            #_"AMD64Kind" memKind (#_"ValueKind" .getPlatformKind kind)
            #_"AMD64AddressValue" addressValue (LIRGenerator''asAddressValue-2 this, address)
            #_"RegisterValue" raxRes (#_"Register" .asValue AMD64/rax, kind)
        ]
            (LIRGenerator''emitMove-3 this, raxRes, expectedValue)
            (LIRGenerator''append-2 this, (CompareAndSwapOp'new-5 memKind, raxRes, addressValue, raxRes, (LIRGenerator''asAllocatable-2 this, newValue)))
            (let [
                #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
            ]
                (LIRGenerator''emitMove-3 this, result, raxRes)
                result
            )
        )
    )

    #_unused
    (§ method! #_"void" LIRGenerator''emitCompareAndSwapBranch-9 [#_"LIRGenerator" this, #_"ValueKind" kind, #_"AMD64AddressValue" address, #_"Value" expectedValue, #_"Value" newValue, #_"Condition" condition, #_"LabelRef" trueLabel, #_"LabelRef" falseLabel, #_"double" trueLabelProbability]
        (let [
            #_"AMD64Kind" memKind (#_"ValueKind" .getPlatformKind kind)
            #_"RegisterValue" raxValue (#_"Register" .asValue AMD64/rax, kind)
        ]
            (LIRGenerator''emitMove-3 this, raxValue, expectedValue)
            (LIRGenerator''append-2 this, (CompareAndSwapOp'new-5 memKind, raxValue, address, raxValue, (LIRGenerator''asAllocatable-2 this, newValue)))
            (LIRGenerator''append-2 this, (BranchOp'new-4 condition, trueLabel, falseLabel, trueLabelProbability))
        )
        nil
    )

    (§ method- #_"void" LIRGenerator''moveValueToThread-3 [#_"LIRGenerator" this, #_"Value" value, #_"int" offset]
        (let [
            #_"LIRKind" wordKind (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target)))
            #_"RegisterValue" thread (#_"Register" .asValue HotSpot'threadRegister, wordKind)
            #_"AMD64AddressValue" address (AMD64AddressValue'new-3 wordKind, thread, offset)
        ]
            (LIRGenerator''emitStore-4 this, (#_"Value" .getValueKind value), address, value)
        )
        nil
    )

    (§ method- #_"void" LIRGenerator''moveDeoptValuesToThread-3 [#_"LIRGenerator" this, #_"Value" actionAndReason, #_"Value" speculation]
        (LIRGenerator''moveValueToThread-3 this, actionAndReason, HotSpot'pendingDeoptimizationOffset)
        (LIRGenerator''moveValueToThread-3 this, speculation, HotSpot'pendingFailedSpeculationOffset)
        nil
    )

    (§ method! #_"void" LIRGenerator''emitDeoptimize-3 [#_"LIRGenerator" this, #_"Value" actionAndReason, #_"Value" speculation]
        (LIRGenerator''moveDeoptValuesToThread-3 this, actionAndReason, speculation)
        (LIRGenerator''append-2 this, (AMD64DeoptimizeOp'new-0))
        nil
    )

    (§ method! #_"void" LIRGenerator''emitDeoptimizeCaller-3 [#_"LIRGenerator" this, #_"DeoptimizationAction" action, #_"DeoptimizationReason" reason]
        (let [
            #_"Value" actionAndReason (LIRGenerator''emitJavaConstant-2 this, (#_"MetaAccessProvider" .encodeDeoptActionAndReason HotSpot'metaAccess, action, reason, 0))
            #_"Value" nullValue (LIRGenerator''emitConstant-3 this, (LIRKind'reference-1 AMD64Kind/QWORD), JavaConstant/NULL_POINTER)
        ]
            (LIRGenerator''moveDeoptValuesToThread-3 this, actionAndReason, nullValue)
            (LIRGenerator''append-2 this, (DeoptimizeCallerOp'new-0))
        )
        nil
    )

    (§ method- #_"Register" LIRGenerator''findPollOnReturnScratchRegister-1 [#_"LIRGenerator" this]
        (loop-when [#_"ISeq" s (seq (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig))] (some? s) => (throw! "should not reach here")
            (let [
                #_"Register" r (first s)
            ]
                (when (and (not (= r (#_"RegisterConfig" .getReturnRegister HotSpot'registerConfig, JavaKind/Long))) (not (= r AMD64/rbp))) => (recur (next s))
                    r
                )
            )
        )
    )

    ;;;
     ; Emits a return instruction. Implementations need to insert a move if the input is not in the correct location.
     ;;
    (§ method! #_"LIRGenerator" LIRGenerator''emitReturn-3 [#_"LIRGenerator" this, #_"JavaKind" kind, #_"Value" input]
        (let [
            #_"AllocatableValue" operand
                (when (some? input) => Value/ILLEGAL
                    (let [
                        operand (LIRGenerator''resultOperandFor-3 this, kind, (#_"Value" .getValueKind input))
                    ]
                        (LIRGenerator''emitMove-3 this, operand, input)
                        operand
                    )
                )
            this
                (when (nil? (:pollOnReturnScratchRegister this)) => this
                    (assoc this :pollOnReturnScratchRegister (LIRGenerator''findPollOnReturnScratchRegister-1 this))
                )
        ]
            (LIRGenerator''append-2 this, (AMD64HotSpotReturnOp'new-4 operand, (some? (:stub (:res this))), HotSpot'threadRegister, (:pollOnReturnScratchRegister this)))
            this
        )
    )

    (§ method! #_"AllocatableValue" LIRGenerator''asAllocatable-2 [#_"LIRGenerator" this, #_"Value" value]
        (condp instance? value
            AllocatableValue value
            ConstantValue    (LIRGenerator''emitLoadConstant-3 this, (#_"Value" .getValueKind value), (:constant value))
                             (LIRGenerator''emitMove-2 this, value)
        )
    )

    (§ method! #_"Variable" LIRGenerator''load-2 [#_"LIRGenerator" this, #_"Value" value]
        (if (instance? Variable value) value (LIRGenerator''emitMove-2 this, value))
    )

    (§ method! #_"Value" LIRGenerator''loadNonConst-2 [#_"LIRGenerator" this, #_"Value" value]
        (if (and (instance? ConstantValue value) (not (MoveFactory''canInlineConstant-2 (:moveFactory this), (:constant value))))
            (LIRGenerator''emitMove-2 this, value)
            value
        )
    )

    ;;;
     ; Gets the ABI specific operand used to return a value of a given kind from a method.
     ;
     ; @param javaKind the kind of value being returned
     ; @param valueKind the backend type of the value being returned
     ; @return the operand representing the ABI defined location used return a value of kind {@code kind}
     ;;
    (§ method! #_"AllocatableValue" LIRGenerator''resultOperandFor-3 [#_"LIRGenerator" this, #_"JavaKind" javaKind, #_"ValueKind" valueKind]
        (#_"Register" .asValue (#_"RegisterConfig" .getReturnRegister HotSpot'registerConfig, javaKind), valueKind)
    )

    (§ method! #_"boolean" LIRGenerator''hasBlockEnd-2 [#_"LIRGenerator" this, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:res this)), block)
        ]
            (and (seq ops)
                (instance? BlockEndOp (nth ops (dec (count ops))))
            )
        )
    )

    (§ method! #_"BlockScope" LIRGenerator''getBlockScope-2 [#_"LIRGenerator" this, #_"Block" block]
        (let [
            #_"BlockScopeImpl" blockScope (BlockScopeImpl'new-2 this, block)
        ]
            (BlockScopeImpl''doBlockStart-1 blockScope)
            blockScope
        )
    )

    (§ method! #_"void" LIRGenerator''emitIncomingValues-2 [#_"LIRGenerator" this, #_"Value[]" params]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir (:res this)), (:currentBlock this))
        ]
            (§ ass! (nth ops 0) (LabelOp''setIncomingValues-2 (nth ops 0), params))
        )
        nil
    )

    (§ method! #_"void" LIRGenerator''emitJump-2 [#_"LIRGenerator" this, #_"LabelRef" label]
        (LIRGenerator''append-2 this, (JumpOp'new-1 label))
        nil
    )

    (§ method- #_"void" LIRGenerator''emitRawCompare-4 [#_"LIRGenerator" this, #_"PlatformKind" cmpKind, #_"Value" left, #_"Value" right]
        (LIRGenerator''emitCompareOp-4 this, cmpKind, (LIRGenerator''load-2 this, left), (LIRGenerator''loadNonConst-2 this, right))
        nil
    )

    ;;;
     ; This method emits the compare instruction, and may reorder the operands. It returns true if it did so.
     ;
     ; @param a the left operand of the comparison
     ; @param b the right operand of the comparison
     ; @param cond the condition of the comparison
     ; @return true if the left and right operands were switched, false otherwise
     ;;
    (§ method- #_"Condition" LIRGenerator''emitCompare-5 [#_"LIRGenerator" this, #_"PlatformKind" cmpKind, #_"Value" a, #_"Value" b, #_"Condition" condition]
        (if (instance? Variable b)
            (do
                (LIRGenerator''emitRawCompare-4 this, cmpKind, b, a)
                (Condition''mirror-1 condition)
            )
            (do
                (LIRGenerator''emitRawCompare-4 this, cmpKind, a, b)
                condition
            )
        )
    )

    (§ method! #_"void" LIRGenerator''emitCompareBranch-8 [#_"LIRGenerator" this, #_"PlatformKind" cmpKind, #_"Value" left, #_"Value" right, #_"Condition" cond, #_"LabelRef" trueLabel, #_"LabelRef" falseLabel, #_"double" trueLabelProbability]
        (§ ass cond (LIRGenerator''emitCompare-5 this, cmpKind, left, right, cond))
        (LIRGenerator''append-2 this, (BranchOp'new-4 cond, trueLabel, falseLabel, trueLabelProbability))
        nil
    )

    (§ method! #_"void" LIRGenerator''emitOverflowCheckBranch-5 [#_"LIRGenerator" this, #_"LabelRef" overflow, #_"LabelRef" noOverflow, #_"LIRKind" cmpLIRKind, #_"double" overflowProbability]
        (LIRGenerator''append-2 this, (BranchOp'new-4 ConditionFlag'Overflow, overflow, noOverflow, overflowProbability))
        nil
    )

    (§ method- #_"void" LIRGenerator''emitIntegerTest-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"OperandSize" size (if (= (#_"Value" .getPlatformKind a) AMD64Kind/QWORD) OperandSize'QWORD OperandSize'DWORD)
        ]
            (cond
                (and (LIRValueUtil'isJavaConstant-1 b) (NumUtil'is32bit-1 (#_"JavaConstant" .asLong (:constant b))))
                    (LIRGenerator''append-2 this, (ConsumerConstOp'new-4 AMD64MIOp'TEST, size, (LIRGenerator''asAllocatable-2 this, a), (int (#_"JavaConstant" .asLong (:constant b)))))
                (and (LIRValueUtil'isJavaConstant-1 a) (NumUtil'is32bit-1 (#_"JavaConstant" .asLong (:constant a))))
                    (LIRGenerator''append-2 this, (ConsumerConstOp'new-4 AMD64MIOp'TEST, size, (LIRGenerator''asAllocatable-2 this, b), (int (#_"JavaConstant" .asLong (:constant a)))))
                (instance? AllocatableValue b)
                    (LIRGenerator''append-2 this, (ConsumerOp'new-4 AMD64RMOp'TEST, size, (LIRGenerator''asAllocatable-2 this, b), (LIRGenerator''asAllocatable-2 this, a)))
                :else
                    (LIRGenerator''append-2 this, (ConsumerOp'new-4 AMD64RMOp'TEST, size, (LIRGenerator''asAllocatable-2 this, a), (LIRGenerator''asAllocatable-2 this, b)))
            )
        )
        nil
    )

    (§ method! #_"void" LIRGenerator''emitIntegerTestBranch-6 [#_"LIRGenerator" this, #_"Value" left, #_"Value" right, #_"LabelRef" trueDestination, #_"LabelRef" falseDestination, #_"double" trueDestinationProbability]
        (LIRGenerator''emitIntegerTest-3 this, left, right)
        (LIRGenerator''append-2 this, (BranchOp'new-4 Condition'EQ, trueDestination, falseDestination, trueDestinationProbability))
        nil
    )

    (§ method! #_"Variable" LIRGenerator''emitConditionalMove-7 [#_"LIRGenerator" this, #_"PlatformKind" cmpKind, #_"Value" left, #_"Value" right, #_"Condition" cond, #_"Value" trueValue, #_"Value" falseValue]
        (§ ass cond (LIRGenerator''emitCompare-5 this, cmpKind, left, right, cond))

        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind trueValue))
        ]
            (cond
                (and (LIRValueUtil'isIntConstant-2 trueValue, 1) (LIRValueUtil'isIntConstant-2 falseValue, 0))
                    (LIRGenerator''append-2 this, (CondSetOp'new-2 result, cond))
                (and (LIRValueUtil'isIntConstant-2 trueValue, 0) (LIRValueUtil'isIntConstant-2 falseValue, 1))
                    (LIRGenerator''append-2 this, (CondSetOp'new-2 result, (Condition''negate-1 cond)))
                :else
                    (LIRGenerator''append-2 this, (CondMoveOp'new-4 result, cond, (LIRGenerator''load-2 this, trueValue), (LIRGenerator''loadNonConst-2 this, falseValue)))
            )
            result
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitIntegerTestMove-5 [#_"LIRGenerator" this, #_"Value" left, #_"Value" right, #_"Value" trueValue, #_"Value" falseValue]
        (LIRGenerator''emitIntegerTest-3 this, left, right)
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind trueValue))
        ]
            (LIRGenerator''append-2 this, (CondMoveOp'new-4 result, Condition'EQ, (LIRGenerator''load-2 this, trueValue), (LIRGenerator''loadNonConst-2 this, falseValue)))
            result
        )
    )

    ;;;
     ; Emits the single call operation at the heart of generating LIR for a {@linkplain #emitForeignCall(ForeignCallLinkage, Value...) foreign call}.
     ;;
    (§ method! #_"void" LIRGenerator''emitForeignCallOp-5 [#_"LIRGenerator" this, #_"ForeignCallLinkage" linkage, #_"Value" result, #_"Value[]" arguments, #_"Value[]" temps]
        (let [
            #_"long" maxOffset (ForeignCallLinkage''getMaxCallTargetOffset-1 linkage)
        ]
            (if (= maxOffset (int maxOffset))
                (LIRGenerator''append-2 this, (DirectNearForeignCallOp'new-4 linkage, result, arguments, temps))
                (LIRGenerator''append-2 this, (DirectFarForeignCallOp'new-4 linkage, result, arguments, temps))
            )
        )
        nil
    )

    (§ method- #_"Variable" LIRGenerator''_emitForeignCall-3* [#_"LIRGenerator" this, #_"ForeignCallLinkage" linkage, #_"Value..." args]
        (let [
            #_"CallingConvention" linkageCc (:outgoingCallingConvention linkage)
        ]
            (FrameMapBuilder''callsMethod-2 (:frameMapBuilder (:res this)), linkageCc)
            (let [
                ;; move the arguments into the correct location
                #_"Value[]" argLocations (make-array Value (count args))
                _
                    (dotimes [#_"int" i (count args)]
                        (let [
                            #_"AllocatableValue" loc (#_"CallingConvention" .getArgument linkageCc, i)
                        ]
                            (LIRGenerator''emitMove-3 this, loc, (nth args i))
                            (aset argLocations i loc)
                        )
                    )
            ]
                (§ ass! (:res this) (LIRGenerationResult''setForeignCall-2 (:res this), true))
                (LIRGenerator''emitForeignCallOp-5 this, linkage, (#_"CallingConvention" .getReturn linkageCc), argLocations, (ForeignCallLinkage''getTemporaries-1 linkage))

                (when-not (= (#_"CallingConvention" .getReturn linkageCc) Value/ILLEGAL)
                    (LIRGenerator''emitMove-2 this, (#_"CallingConvention" .getReturn linkageCc))
                )
            )
        )
    )

    ;;;
     ; Allocate a stack slot for saving a register.
     ;;
    (§ method- #_"VirtualStackSlot" LIRGenerator''allocateSaveRegisterLocation-2 [#_"LIRGenerator" this, #_"Register" register]
        (let [
            #_"PlatformKind" kind (#_"Architecture" .getLargestStorableKind (.arch HotSpot'target), (#_"Register" .getRegisterCategory register))
            kind
                (when (< 1 (#_"PlatformKind" .getVectorLength kind)) => kind
                    ;; we don't use vector registers, so there is no need to save them
                    AMD64Kind/DOUBLE
                )
        ]
            (FrameMapBuilder''allocateSpillSlot-2 (:frameMapBuilder (:res this)), (LIRKind'value-1 kind))
        )
    )

    ;;;
     ; @param savedRegisters the registers saved by this operation which may be subject to pruning
     ; @param savedRegisterLocations the slots to which the registers are saved
     ;;
    (§ method- #_"AMD64SaveRegistersOp" LIRGenerator''emitSaveRegisters-3 [#_"LIRGenerator" this, #_"Register[]" savedRegisters, #_"AllocatableValue[]" savedRegisterLocations]
        (let [
            #_"AMD64SaveRegistersOp" save (AMD64SaveRegistersOp'new-2 savedRegisters, savedRegisterLocations)
        ]
            (LIRGenerator''append-2 this, save)
            save
        )
    )

    ;;;
     ; Adds a node to the graph that saves all allocatable registers to the stack.
     ;
     ; @return the register save node
     ;;
    (§ method- #_"AMD64SaveRegistersOp" LIRGenerator''emitSaveAllRegisters-2 [#_"LIRGenerator" this, #_"Register[]" savedRegisters]
        (let [
            #_"AllocatableValue[]" savedRegisterLocations (make-array AllocatableValue (count savedRegisters))
        ]
            (dotimes [#_"int" i (count savedRegisters)]
                (aset savedRegisterLocations i (LIRGenerator''allocateSaveRegisterLocation-2 this, (nth savedRegisters i)))
            )
            (LIRGenerator''emitSaveRegisters-3 this, savedRegisters, savedRegisterLocations)
        )
    )

    (§ method- #_"void" LIRGenerator''emitRestoreRegisters-2 [#_"LIRGenerator" this, #_"AMD64SaveRegistersOp" save]
        (LIRGenerator''append-2 this, (AMD64RestoreRegistersOp'new-2 (#_"Object" .clone (:slots save)), save))
        nil
    )

    (§ method! #_"Variable" LIRGenerator''emitForeignCall-3* [#_"LIRGenerator" this, #_"ForeignCallLinkage" linkage, #_"Value..." args]
        (let [
            #_"boolean" destroysRegisters (ForeignCallLinkage''destroysRegisters-1 linkage)
            #_"Stub" stub (:stub (:res this))
            #_"AMD64SaveRegistersOp" save
                (when (and destroysRegisters (some? stub) (Stub''preservesRegisters-1 stub))
                    (let [
                        #_"Register[]" savedRegisters (#_"RegisterArray" .toArray (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig))
                    ]
                        (LIRGenerator''emitSaveAllRegisters-2 this, savedRegisters)
                    )
                )
            #_"Variable" result
                (if (ForeignCallLinkage''needsJavaFrameAnchor-1 linkage)
                    (let [
                        #_"Register" thread HotSpot'threadRegister
                    ]
                        (LIRGenerator''append-2 this, (CRuntimeCallPrologueOp'new-2 HotSpot'threadLastJavaSpOffset, thread))
                        (let [
                            result (LIRGenerator''_emitForeignCall-3* this, linkage, args)
                        ]
                            (LIRGenerator''append-2 this, (CRuntimeCallEpilogueOp'new-4 HotSpot'threadLastJavaSpOffset, HotSpot'threadLastJavaFpOffset, HotSpot'threadLastJavaPcOffset, thread))
                            result
                        )
                    )
                    (LIRGenerator''_emitForeignCall-3* this, linkage, args)
                )
        ]
            (when (and destroysRegisters (some? stub) (Stub''preservesRegisters-1 stub))
                (LIRGenerator''emitRestoreRegisters-2 this, save)
            )
            result
        )
    )

    (§ method! #_"void" LIRGenerator''emitStrategySwitch-5 [#_"LIRGenerator" this, #_"SwitchStrategy" strategy, #_"Variable" key, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget]
        ;; a temp is needed for loading object constants
        (LIRGenerator''append-2 this, (AMD64HotSpotStrategySwitchOp'new-5 strategy, keyTargets, defaultTarget, key, (if-not (LIRKind'isValue-1 key) (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind key)) Value/ILLEGAL)))
        nil
    )

    (§ method! #_"void" LIRGenerator''emitTableSwitch-5 [#_"LIRGenerator" this, #_"int" lowKey, #_"LabelRef" defaultTarget, #_"LabelRef[]" targets, #_"Value" key]
        (LIRGenerator''append-2 this, (TableSwitchOp'new-6 lowKey, defaultTarget, targets, key, (LIRGenerator''newVariable-2 this, (LIRKind'value-1 (#_"Architecture" .getWordKind (.arch HotSpot'target)))), (LIRGenerator''newVariable-2 this, (#_"Value" .getValueKind key))))
        nil
    )

    (§ method! #_"void" LIRGenerator''emitStrategySwitch-6 [#_"LIRGenerator" this, #_"JavaConstant[]" keyConstants, #_"double[]" keyProbabilities, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget, #_"Variable" value]
        (let [
            #_"int" keyCount (count keyConstants)
            #_"SwitchStrategy" strategy (SwitchStrategy'getBestStrategy-3 keyProbabilities, keyConstants, keyTargets)
            #_"long" valueRange (inc (- (#_"JavaConstant" .asLong (nth keyConstants (dec keyCount))) (#_"JavaConstant" .asLong (nth keyConstants 0))))
            #_"double" tableSwitchDensity (/ keyCount (double valueRange))
        ]
            ;; This heuristic tries to find a compromise between the effort for the best switch strategy
            ;; and the density of a tableswitch. If the effort for the strategy is at least 4, then a
            ;; tableswitch is preferred if better than a certain value that starts at 0.5 and lowers
            ;; gradually with additional effort.
            (if (or (< (SwitchStrategy''getAverageEffort-1 strategy) 4) (< tableSwitchDensity (/ 1.0 (Math/sqrt (SwitchStrategy''getAverageEffort-1 strategy)))))
                (LIRGenerator''emitStrategySwitch-5 this, strategy, value, keyTargets, defaultTarget)
                (let [
                    #_"int" minValue (#_"JavaConstant" .asInt (nth keyConstants 0))
                    #_"LabelRef[]" targets (make-array LabelRef (int valueRange))
                ]
                    (dotimes [#_"int" i valueRange]
                        (aset targets i defaultTarget)
                    )
                    (dotimes [#_"int" i keyCount]
                        (aset targets (- (#_"JavaConstant" .asInt (nth keyConstants i)) minValue) (nth keyTargets i))
                    )
                    (LIRGenerator''emitTableSwitch-5 this, minValue, defaultTarget, targets, value)
                )
            )
        )
        nil
    )

    ;;;
     ; Called just before register allocation is performed on the LIR owned by this generator.
     ; Overriding implementations of this method must call the overridden method.
     ;;
    (§ method! #_"void" LIRGenerator''beforeRegisterAllocation-1 [#_"LIRGenerator" this]
        (let [
            #_"AllocatableValue" savedRbp (SaveRbp''finalize-2 (:saveRbp this), false)
        ]
            (doseq [#_"AMD64HotSpotRestoreRbpOp" op (:epilogueOps this)]
                (AMD64HotSpotRestoreRbpOp''setSavedRbp-2 op, savedRbp)
            )
        )
        nil
    )

    #_unused
    (§ method! #_"LIRKind" LIRGenerator''getAddressKind-4 [#_"LIRGenerator" this, #_"Value" base, #_"long" displacement, #_"Value" index]
        (let [
            #_"PlatformKind" wordKind (#_"Architecture" .getWordKind (.arch HotSpot'target))
        ]
            (cond
                (and (LIRKind'isValue-1 base) (or (= index Value/ILLEGAL) (LIRKind'isValue-1 index)))
                    (LIRKind'value-1 wordKind)
                (and (instance? LIRKind (#_"Value" .getValueKind base)) (LIRKind''isReference-2 (#_"Value" .getValueKind base, LIRKind), 0) (zero? displacement) (= index Value/ILLEGAL))
                    (LIRKind'reference-1 wordKind)
                :else
                    (LIRKind'unknownReference-1 wordKind)
            )
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitByteSwap-2 [#_"LIRGenerator" this, #_"Value" input]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* input))
        ]
            (LIRGenerator''append-2 this, (AMD64ByteSwapOp'new-2 result, input))
            result
        )
    )

    (§ method! #_"void" LIRGenerator''emitBlackhole-2 [#_"LIRGenerator" this, #_"Value" operand]
        (LIRGenerator''append-2 this, (BlackholeOp'new-1 operand))
        nil
    )

    (§ method! #_"void" LIRGenerator''emitPrefetchAllocate-2 [#_"LIRGenerator" this, #_"Value" address]
        (LIRGenerator''append-2 this, (AMD64PrefetchOp'new-2 (LIRGenerator''asAddressValue-2 this, address), HotSpot'allocatePrefetchInstr))
        nil
    )

    (§ method! #_"Value" LIRGenerator''emitCompress-4 [#_"LIRGenerator" this, #_"Value" pointer, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (let [
            #_"LIRKind" inputKind (#_"Value" .getValueKind pointer, LIRKind)
        ]
            (if (LIRKind''isReference-2 inputKind, 0)
                ;; oop
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKindTool'getNarrowOopKind-0))
                ]
                    (LIRGenerator''append-2 this, (CompressPointerOp'new-5 result, (LIRGenerator''asAllocatable-2 this, pointer), (#_"Register" .asValue HotSpot'heapBaseRegister), encoding, never-nil?))
                    result
                )
                ;; metaspace pointer
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKindTool'getNarrowPointerKind-0))
                    #_"AllocatableValue" base
                        (when (CompressEncoding''hasBase-1 encoding) => Value/ILLEGAL
                            (LIRGenerator''emitLoadConstant-3 this, (LIRKindTool'getWordKind-0), (JavaConstant/forLong (:base encoding)))
                        )
                ]
                    (LIRGenerator''append-2 this, (CompressPointerOp'new-5 result, (LIRGenerator''asAllocatable-2 this, pointer), base, encoding, never-nil?))
                    result
                )
            )
        )
    )

    (§ method! #_"Value" LIRGenerator''emitUncompress-4 [#_"LIRGenerator" this, #_"Value" pointer, #_"CompressEncoding" encoding, #_"boolean" never-nil?]
        (let [
            #_"LIRKind" inputKind (#_"Value" .getValueKind pointer, LIRKind)
        ]
            (if (LIRKind''isReference-2 inputKind, 0)
                ;; oop
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKindTool'getObjectKind-0))
                ]
                    (LIRGenerator''append-2 this, (UncompressPointerOp'new-5 result, (LIRGenerator''asAllocatable-2 this, pointer), (#_"Register" .asValue HotSpot'heapBaseRegister), encoding, never-nil?))
                    result
                )
                ;; metaspace pointer
                (let [
                    #_"LIRKind" uncompressedKind (LIRKindTool'getWordKind-0)
                    #_"Variable" result (LIRGenerator''newVariable-2 this, uncompressedKind)
                    #_"AllocatableValue" base
                        (when (CompressEncoding''hasBase-1 encoding) => Value/ILLEGAL
                            (LIRGenerator''emitLoadConstant-3 this, uncompressedKind, (JavaConstant/forLong (:base encoding)))
                        )
                ]
                    (LIRGenerator''append-2 this, (UncompressPointerOp'new-5 result, (LIRGenerator''asAllocatable-2 this, pointer), base, encoding, never-nil?))
                    result
                )
            )
        )
    )

    (§ method! #_"void" LIRGenerator''emitLFence-1 [#_"LIRGenerator" this]
        (LIRGenerator''append-2 this, (AMD64LFenceOp'new-0))
        nil
    )

    (§ method! #_"LIRGenerator" LIRGenerator''setLockStackHolder-2 [#_"LIRGenerator" this, #_"LockStackHolder" lockStackHolder]
        (assoc this :lockStackHolder lockStackHolder)
    )

    ;;;
     ; Gets a stack slot for a lock at a given lock nesting depth.
     ;;
    (§ method! #_"VirtualStackSlot" LIRGenerator''getLockSlot-2 [#_"LIRGenerator" this, #_"int" lockDepth]
        (LockStack''makeLockSlot-2 (:lockStack (:lockStackHolder this)), lockDepth)
    )

    (§ method! #_"AMD64AddressValue" LIRGenerator''asAddressValue-2 [#_"LIRGenerator" this, #_"Value" address]
        (when-not (instance? AMD64AddressValue address) => address
            (when (instance? JavaConstant address)
                (let [
                    #_"long" displacement (#_"JavaConstant" .asLong address)
                ]
                    (when (NumUtil'isInt-1 displacement)
                        (§ return (AMD64AddressValue'new-3 (#_"Value" .getValueKind address), Value/ILLEGAL, (int displacement)))
                    )
                )
            )
            (AMD64AddressValue'new-3 (#_"Value" .getValueKind address), (LIRGenerator''asAllocatable-2 this, address), 0)
        )
    )

    (§ method! #_"LIRGenerator" LIRGenerator''emitSaveRbp-1 [#_"LIRGenerator" this]
        (let [
            #_"NoOp" placeholder (NoOp'new-2 (:currentBlock this), (count (LIR''getLIRforBlock-2 (:lir (:res this)), (:currentBlock this))))
        ]
            (LIRGenerator''append-2 this, placeholder)
            (assoc this :saveRbp (SaveRbp'new-2 this, placeholder))
        )
    )

    ;;;
     ; Emits code for a GraalHotSpotVMConfigNode.
     ;
     ; @param markId id of the value to load
     ; @param kind type of the value to load
     ; @return value of loaded global in register
     ;;
    (§ method! #_"Value" LIRGenerator''emitLoadConfigValue-3 [#_"LIRGenerator" this, #_"int" markId, #_"LIRKind" kind]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
        ]
            (LIRGenerator''append-2 this, (LoadConfigValueOp'new-2 markId, result))
            result
        )
    )

    ;;;
     ; Emits code for a RandomSeedNode.
     ;
     ; @return value of the counter
     ;;
    (§ method! #_"Value" LIRGenerator''emitRandomSeed-1 [#_"LIRGenerator" this]
        (let [
            #_"AMD64ReadTimestampCounter" timestamp (AMD64ReadTimestampCounter'new-0)
        ]
            (LIRGenerator''append-2 this, timestamp)
            (LIRGenerator''emitMove-2 this, (:lowResult timestamp))
        )
    )

    ;;;
     ; Emits an operation to make a tail call.
     ;
     ; @param args the arguments of the call
     ; @param address the target address of the call
     ;;
    #_unused
    (§ method! #_"void" LIRGenerator''emitTailcall-3 [#_"LIRGenerator" this, #_"Value[]" args, #_"Value" address]
        (LIRGenerator''append-2 this, (AMD64TailcallOp'new-2 args, address))
        nil
    )

    #_unused
    (§ method! #_"void" LIRGenerator''emitCCall-4 [#_"LIRGenerator" this, #_"long" address, #_"CallingConvention" nativeCallingConvention, #_"Value[]" args]
        (let [
            #_"Value[]" argLocations (make-array Value (count args))
        ]
            (FrameMapBuilder''callsMethod-2 (:frameMapBuilder (:res this)), nativeCallingConvention)
            (LIRGenerator''emitMoveConstant-3 this, (#_"Register" .asValue AMD64/rax, (LIRKind'value-1 AMD64Kind/DWORD)), (JavaConstant/forInt 0))
            (dotimes [#_"int" i (count args)]
                (let [
                    #_"AllocatableValue" loc (#_"CallingConvention" .getArgument nativeCallingConvention, i)
                ]
                    (LIRGenerator''emitMove-3 this, loc, (nth args i))
                    (aset argLocations i loc)
                )
            )
            (let [
                #_"Value" ptr (LIRGenerator''emitLoadConstant-3 this, (LIRKind'value-1 AMD64Kind/QWORD), (JavaConstant/forLong address))
            ]
                (LIRGenerator''append-2 this, (AMD64CCall'new-3 (#_"CallingConvention" .getReturn nativeCallingConvention), ptr, argLocations))
            )
        )
        nil
    )

    ;;;
     ; This namespace can be used to generate LIR for arithmetic and simple memory access operations.
     ;
     ; The setFlags flag in emitAdd, emitSub and emitMul indicates, that the instruction must set the
     ; flags register to be used for a later branch. (On AMD64, the condition codes are set in every
     ; arithmetic instruction, but other architectures optionally set the flags register.) If setFlags
     ; is set, the instruction must set the flags register; if false, the instruction may or may not
     ; set the flags register.
     ;
     ; @anno ArithmeticLIRGenerator
     ;;
    (§ def- #_"RegisterValue" LIRGenerator'RCX_I (#_"Register" .asValue AMD64/rcx, (LIRKind'value-1 AMD64Kind/DWORD)))

    (§ method! #_"Variable" LIRGenerator''emitNegate-2 [#_"LIRGenerator" this, #_"Value" inputVal]
        (let [
            #_"AllocatableValue" input (LIRGenerator''asAllocatable-2 this, inputVal)
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* input))
        ]
            (condp = (#_"AllocatableValue" .getPlatformKind input)
                AMD64Kind/DWORD (LIRGenerator''append-2 this, (MOp'new-4 AMD64MOp'NEG, OperandSize'DWORD, result, input))
                AMD64Kind/QWORD (LIRGenerator''append-2 this, (MOp'new-4 AMD64MOp'NEG, OperandSize'QWORD, result, input))
            )
            result
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitNot-2 [#_"LIRGenerator" this, #_"Value" inputVal]
        (let [
            #_"AllocatableValue" input (LIRGenerator''asAllocatable-2 this, inputVal)
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* input))
        ]
            (condp = (#_"AllocatableValue" .getPlatformKind input)
                AMD64Kind/DWORD (LIRGenerator''append-2 this, (MOp'new-4 AMD64MOp'NOT, OperandSize'DWORD, result, input))
                AMD64Kind/QWORD (LIRGenerator''append-2 this, (MOp'new-4 AMD64MOp'NOT, OperandSize'QWORD, result, input))
            )
            result
        )
    )

    (§ method- #_"Variable" LIRGenerator''emitBinary-8 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"BinaryArithmetic" op, #_"OperandSize" size, #_"boolean" commutative?, #_"Value" a, #_"Value" b, #_"boolean" set-flags?]
        (cond
            (LIRValueUtil'isJavaConstant-1 b)                    (LIRGenerator''emitBinaryConst-8 this, resultKind, op, size, commutative?, (LIRGenerator''asAllocatable-2 this, a), b, set-flags?)
            (and commutative? (LIRValueUtil'isJavaConstant-1 a)) (LIRGenerator''emitBinaryConst-8 this, resultKind, op, size, commutative?, (LIRGenerator''asAllocatable-2 this, b), a, set-flags?)
            :else                                                (LIRGenerator''emitBinaryVar-7 this, resultKind, (BinaryArithmetic''getRMOpcode-2 op, size), size, commutative?, (LIRGenerator''asAllocatable-2 this, a), (LIRGenerator''asAllocatable-2 this, b))
        )
    )

    #_unused
    (§ method- #_"Variable" LIRGenerator''emitBinary-7 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"boolean" commutative?, #_"Value" a, #_"Value" b]
        (cond
            (LIRValueUtil'isJavaConstant-1 b)                    (LIRGenerator''emitBinaryConst-6 this, resultKind, op, size, (LIRGenerator''asAllocatable-2 this, a), (:constant b))
            (and commutative? (LIRValueUtil'isJavaConstant-1 a)) (LIRGenerator''emitBinaryConst-6 this, resultKind, op, size, (LIRGenerator''asAllocatable-2 this, b), (:constant a))
            :else                                                (LIRGenerator''emitBinaryVar-7 this, resultKind, op, size, commutative?, (LIRGenerator''asAllocatable-2 this, a), (LIRGenerator''asAllocatable-2 this, b))
        )
    )

    (§ method- #_"Variable" LIRGenerator''emitBinaryConst-8 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"BinaryArithmetic" op, #_"OperandSize" size, #_"boolean" commutative?, #_"AllocatableValue" a, #_"ConstantValue" b, #_"boolean" set-flags?]
        (let [
            #_"long" value (#_"JavaConstant" .asLong (:constant b))
        ]
            (if (NumUtil'isInt-1 value)
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
                    #_"int" constant (int value)
                ]
                    (when-not set-flags?
                        (let [
                            #_"AMD64MOp" mop (LIRGenerator'getMOp-2 op, constant)
                        ]
                            (when (some? mop)
                                (LIRGenerator''append-2 this, (MOp'new-4 mop, size, result, a))
                                (§ return result)
                            )
                        )
                    )

                    (LIRGenerator''append-2 this, (ConstOp'new-5 op, size, result, a, constant))
                    result
                )
                (LIRGenerator''emitBinaryVar-7 this, resultKind, (BinaryArithmetic''getRMOpcode-2 op, size), size, commutative?, a, (LIRGenerator''asAllocatable-2 this, b))
            )
        )
    )

    (§ defn- #_"AMD64MOp" LIRGenerator'getMOp-2 [#_"BinaryArithmetic" op, #_"int" constant]
        (case constant
            1   (condp = op
                    BinaryArithmetic'ADD AMD64MOp'INC
                    BinaryArithmetic'SUB AMD64MOp'DEC
                    nil
                )
            -1  (condp = op
                    BinaryArithmetic'ADD AMD64MOp'DEC
                    BinaryArithmetic'SUB AMD64MOp'INC
                    nil
                )
            nil
        )
    )

    (§ method- #_"Variable" LIRGenerator''emitBinaryConst-6 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"AllocatableValue" a, #_"JavaConstant" b]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
        ]
            (LIRGenerator''append-2 this, (DataTwoOp'new-5 op, size, result, a, b))
            result
        )
    )

    (§ method- #_"Variable" LIRGenerator''emitBinaryVar-7 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"boolean" commutative?, #_"AllocatableValue" a, #_"AllocatableValue" b]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
        ]
            (if commutative?
                (LIRGenerator''append-2 this, (CommutativeTwoOp'new-5 op, size, result, a, b))
                (LIRGenerator''append-2 this, (TwoOp'new-5 op, size, result, a, b))
            )
            result
        )
    )

    (§ method! #_"boolean" LIRGenerator''isNumericInteger-2 [#_"LIRGenerator" this, #_"PlatformKind" kind]
        (#_"AMD64Kind" .isInteger kind)
    )

    (§ method- #_"Variable" LIRGenerator''emitAddOrSub-5 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b, #_"boolean" set-flags?, #_"boolean" isAdd]
        (let [
            [a b #_"LIRKind" resultKind]
                (if (LIRGenerator''isNumericInteger-2 this, (#_"Value" .getPlatformKind a))
                    (let [
                        #_"LIRKind" aKind (#_"Value" .getValueKind a, LIRKind)
                        #_"LIRKind" bKind (#_"Value" .getValueKind b, LIRKind)
                    ]
                        (cond
                            (LIRKind''isUnknownReference-1 aKind)                       [a b aKind]
                            (LIRKind''isUnknownReference-1 bKind)                       [a b bKind]
                            (and (LIRKind''isValue-1 aKind) (LIRKind''isValue-1 bKind)) [a b aKind]
                            (LIRKind''isValue-1 aKind)
                                (if (LIRKind''isDerivedReference-1 bKind)
                                    [a b bKind]
                                    (let [
                                        #_"AllocatableValue" allocatable (LIRGenerator''asAllocatable-2 this, b)
                                    ]
                                        [a allocatable (LIRKind''makeDerivedReference-2 bKind, allocatable)]
                                    )
                                )
                            (LIRKind''isValue-1 bKind)
                                (if (LIRKind''isDerivedReference-1 aKind)
                                    [a b aKind]
                                    (let [
                                        #_"AllocatableValue" allocatable (LIRGenerator''asAllocatable-2 this, a)
                                    ]
                                        [allocatable b (LIRKind''makeDerivedReference-2 aKind, allocatable)]
                                    )
                                )
                            :else
                                [a b (LIRKind''makeUnknownReference-1 aKind)]
                        )
                    )
                    [a b (LIRKind'combine-1* a, b)]
                )
        ]
            (if isAdd
                (LIRGenerator''emitAdd-5 this, resultKind, a, b, set-flags?)
                (LIRGenerator''emitSub-5 this, resultKind, a, b, set-flags?)
            )
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitAdd-4 [#_"LIRGenerator" this, #_"Value" aVal, #_"Value" bVal, #_"boolean" set-flags?]
        (LIRGenerator''emitAddOrSub-5 this, aVal, bVal, set-flags?, true)
    )

    (§ method! #_"Variable" LIRGenerator''emitSub-4 [#_"LIRGenerator" this, #_"Value" aVal, #_"Value" bVal, #_"boolean" set-flags?]
        (LIRGenerator''emitAddOrSub-5 this, aVal, bVal, set-flags?, false)
    )

    (§ method- #_"Variable" LIRGenerator''emitBaseOffsetLea-5 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"Value" base, #_"int" offset, #_"OperandSize" size]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
            #_"AMD64AddressValue" address (AMD64AddressValue'new-3 resultKind, (LIRGenerator''asAllocatable-2 this, base), offset)
        ]
            (LIRGenerator''append-2 this, (LeaOp'new-3 result, address, size))
            result
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitAdd-5 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"Value" a, #_"Value" b, #_"boolean" set-flags?]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD
            (do
                (when (and (LIRValueUtil'isJavaConstant-1 b) (not set-flags?))
                    (let [
                        #_"long" displacement (#_"JavaConstant" .asLong (:constant b))
                    ]
                        (when (and (NumUtil'isInt-1 displacement) (not= displacement 1) (not= displacement -1))
                            (§ return (LIRGenerator''emitBaseOffsetLea-5 this, resultKind, a, (int displacement), OperandSize'DWORD))
                        )
                    )
                )
                (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'ADD, OperandSize'DWORD, true, a, b, set-flags?)
            )
            AMD64Kind/QWORD
            (do
                (when (and (LIRValueUtil'isJavaConstant-1 b) (not set-flags?))
                    (let [
                        #_"long" displacement (#_"JavaConstant" .asLong (:constant b))
                    ]
                        (when (and (NumUtil'isInt-1 displacement) (not= displacement 1) (not= displacement -1))
                            (§ return (LIRGenerator''emitBaseOffsetLea-5 this, resultKind, a, (int displacement), OperandSize'QWORD))
                        )
                    )
                )
                (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'ADD, OperandSize'QWORD, true, a, b, set-flags?)
            )
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitSub-5 [#_"LIRGenerator" this, #_"LIRKind" resultKind, #_"Value" a, #_"Value" b, #_"boolean" set-flags?]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'SUB, OperandSize'DWORD, false, a, b, set-flags?)
            AMD64Kind/QWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'SUB, OperandSize'QWORD, false, a, b, set-flags?)
        )
    )

    (§ method- #_"Variable" LIRGenerator''emitIMULConst-4 [#_"LIRGenerator" this, #_"OperandSize" size, #_"AllocatableValue" a, #_"ConstantValue" b]
        (let [
            #_"long" value (#_"JavaConstant" .asLong (:constant b))
        ]
            (if (NumUtil'isInt-1 value)
                (let [
                    #_"int" imm (int value)
                    #_"AMD64RMIOp" op (if (NumUtil'isByte-1 imm) AMD64RMIOp'IMUL_SX AMD64RMIOp'IMUL)
                    #_"Variable" ret (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* a, b))
                ]
                    (LIRGenerator''append-2 this, (RMIOp'new-5 op, size, ret, a, imm))
                    ret
                )
                (LIRGenerator''emitBinaryVar-7 this, (LIRKind'combine-1* a, b), AMD64RMOp'IMUL, size, true, a, (LIRGenerator''asAllocatable-2 this, b))
            )
        )
    )

    (§ method- #_"Variable" LIRGenerator''emitIMUL-4 [#_"LIRGenerator" this, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (cond
            (LIRValueUtil'isJavaConstant-1 b)
                (LIRGenerator''emitIMULConst-4 this, size, (LIRGenerator''asAllocatable-2 this, a), b)
            (LIRValueUtil'isJavaConstant-1 a)
                (LIRGenerator''emitIMULConst-4 this, size, (LIRGenerator''asAllocatable-2 this, b), a)
            :else
                (LIRGenerator''emitBinaryVar-7 this, (LIRKind'combine-1* a, b), AMD64RMOp'IMUL, size, true, (LIRGenerator''asAllocatable-2 this, a), (LIRGenerator''asAllocatable-2 this, b))
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitMul-4 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b, #_"boolean" set-flags?]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitIMUL-4 this, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitIMUL-4 this, OperandSize'QWORD, a, b)
        )
    )

    (§ method- #_"RegisterValue" LIRGenerator''moveToReg-3 [#_"LIRGenerator" this, #_"Register" reg, #_"Value" value]
        (let [
            #_"RegisterValue" ret (#_"Register" .asValue reg, (#_"Value" .getValueKind value))
        ]
            (LIRGenerator''emitMove-3 this, ret, value)
            ret
        )
    )

    (§ method- #_"Value" LIRGenerator''emitMulHigh-5 [#_"LIRGenerator" this, #_"AMD64MOp" opcode, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" mulHigh (LIRGenerator''append-2 this, (AMD64MulDivOp'new-5 opcode, size, (LIRKind'combine-1* a, b), (LIRGenerator''moveToReg-3 this, AMD64/rax, a), (LIRGenerator''asAllocatable-2 this, b)))
        ]
            (LIRGenerator''emitMove-2 this, (:highResult mulHigh))
        )
    )

    (§ method! #_"Value" LIRGenerator''emitMulHigh-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitMulHigh-5 this, AMD64MOp'IMUL, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitMulHigh-5 this, AMD64MOp'IMUL, OperandSize'QWORD, a, b)
        )
    )

    (§ method! #_"Value" LIRGenerator''emitUMulHigh-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitMulHigh-5 this, AMD64MOp'MUL, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitMulHigh-5 this, AMD64MOp'MUL, OperandSize'QWORD, a, b)
        )
    )

    #_unused
    (§ method! #_"Value" LIRGenerator''emitBinaryMemory-5 [#_"LIRGenerator" this, #_"AMD64RMOp" op, #_"OperandSize" size, #_"AllocatableValue" a, #_"AMD64AddressValue" location]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* a))
        ]
            (LIRGenerator''append-2 this, (MemoryTwoOp'new-5 op, size, result, a, location))
            result
        )
    )

    #_unused
    (§ method! #_"Value" LIRGenerator''emitConvertMemoryOp-5 [#_"LIRGenerator" this, #_"PlatformKind" kind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"AMD64AddressValue" address]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'value-1 kind))
        ]
            (LIRGenerator''append-2 this, (MemoryOp'new-4 op, size, result, address))
            result
        )
    )

    #_unused
    (§ method! #_"Value" LIRGenerator''emitZeroExtendMemory-4 [#_"LIRGenerator" this, #_"AMD64Kind" memoryKind, #_"int" resultBits, #_"AMD64AddressValue" address]
        ;; Issue a zero extending load of the proper bit size and set the result to the proper kind.
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'value-1 (if (<= resultBits 32) AMD64Kind/DWORD AMD64Kind/QWORD)))
        ]
            (condp = memoryKind
                AMD64Kind/BYTE  (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOVZXB, OperandSize'DWORD, result, address))
                AMD64Kind/WORD  (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOVZX, OperandSize'DWORD, result, address))
                AMD64Kind/DWORD (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOV, OperandSize'DWORD, result, address))
                AMD64Kind/QWORD (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOV, OperandSize'QWORD, result, address))
            )
            result
        )
    )

    (§ method- #_"AMD64MulDivOp" LIRGenerator''emitIDIV-4 [#_"LIRGenerator" this, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" kind (LIRKind'combine-1* a, b)
            #_"AMD64SignExtendOp" sx (LIRGenerator''append-2 this, (AMD64SignExtendOp'new-3 size, kind, (LIRGenerator''moveToReg-3 this, AMD64/rax, a)))
        ]
            (LIRGenerator''append-2 this, (AMD64MulDivOp'new-6 AMD64MOp'IDIV, size, kind, (:highResult sx), (:lowResult sx), (LIRGenerator''asAllocatable-2 this, b)))
        )
    )

    (§ method- #_"AMD64MulDivOp" LIRGenerator''emitDIV-4 [#_"LIRGenerator" this, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" kind (LIRKind'combine-1* a, b)
            #_"RegisterValue" rax (LIRGenerator''moveToReg-3 this, AMD64/rax, a)
            #_"RegisterValue" rdx (#_"Register" .asValue AMD64/rdx, kind)
        ]
            (LIRGenerator''append-2 this, (AMD64ClearRegisterOp'new-2 size, rdx))
            (LIRGenerator''append-2 this, (AMD64MulDivOp'new-6 AMD64MOp'DIV, size, kind, rdx, rax, (LIRGenerator''asAllocatable-2 this, b)))
        )
    )

    (§ method! #_"Value[]" LIRGenerator''emitSignedDivRem-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" op
                (condp = (#_"Value" .getPlatformKind a)
                    AMD64Kind/DWORD (LIRGenerator''emitIDIV-4 this, OperandSize'DWORD, a, b)
                    AMD64Kind/QWORD (LIRGenerator''emitIDIV-4 this, OperandSize'QWORD, a, b)
                )
        ]
            (into-array Value [ (LIRGenerator''emitMove-2 this, (:lowResult op)), (LIRGenerator''emitMove-2 this, (:highResult op)) ])
        )
    )

    (§ method! #_"Value[]" LIRGenerator''emitUnsignedDivRem-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" op
                (condp = (#_"Value" .getPlatformKind a)
                    AMD64Kind/DWORD (LIRGenerator''emitDIV-4 this, OperandSize'DWORD, a, b)
                    AMD64Kind/QWORD (LIRGenerator''emitDIV-4 this, OperandSize'QWORD, a, b)
                )
        ]
            (into-array Value [ (LIRGenerator''emitMove-2 this, (:lowResult op)), (LIRGenerator''emitMove-2 this, (:highResult op)) ])
        )
    )

    (§ method! #_"Value" LIRGenerator''emitDiv-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitMove-2 this, (:lowResult (LIRGenerator''emitIDIV-4 this, OperandSize'DWORD, a, b)))
            AMD64Kind/QWORD (LIRGenerator''emitMove-2 this, (:lowResult (LIRGenerator''emitIDIV-4 this, OperandSize'QWORD, a, b)))
        )
    )

    (§ method! #_"Value" LIRGenerator''emitRem-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitMove-2 this, (:highResult (LIRGenerator''emitIDIV-4 this, OperandSize'DWORD, a, b)))
            AMD64Kind/QWORD (LIRGenerator''emitMove-2 this, (:highResult (LIRGenerator''emitIDIV-4 this, OperandSize'QWORD, a, b)))
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitUDiv-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" op
                (condp = (#_"Value" .getPlatformKind a)
                    AMD64Kind/DWORD (LIRGenerator''emitDIV-4 this, OperandSize'DWORD, a, b)
                    AMD64Kind/QWORD (LIRGenerator''emitDIV-4 this, OperandSize'QWORD, a, b)
                )
        ]
            (LIRGenerator''emitMove-2 this, (:lowResult op))
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitURem-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"AMD64MulDivOp" op
                (condp = (#_"Value" .getPlatformKind a)
                    AMD64Kind/DWORD (LIRGenerator''emitDIV-4 this, OperandSize'DWORD, a, b)
                    AMD64Kind/QWORD (LIRGenerator''emitDIV-4 this, OperandSize'QWORD, a, b)
                )
        ]
            (LIRGenerator''emitMove-2 this, (:highResult op))
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitAnd-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" resultKind (LIRKind'combine-1* a, b)
        ]
            (condp = (#_"Value" .getPlatformKind a)
                AMD64Kind/DWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'AND, OperandSize'DWORD, true, a, b, false)
                AMD64Kind/QWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'AND, OperandSize'QWORD, true, a, b, false)
            )
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitOr-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" resultKind (LIRKind'combine-1* a, b)
        ]
            (condp = (#_"Value" .getPlatformKind a)
                AMD64Kind/DWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'OR, OperandSize'DWORD, true, a, b, false)
                AMD64Kind/QWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'OR, OperandSize'QWORD, true, a, b, false)
            )
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitXor-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (let [
            #_"LIRKind" resultKind (LIRKind'combine-1* a, b)
        ]
            (condp = (#_"Value" .getPlatformKind a)
                AMD64Kind/DWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'XOR, OperandSize'DWORD, true, a, b, false)
                AMD64Kind/QWORD (LIRGenerator''emitBinary-8 this, resultKind, BinaryArithmetic'XOR, OperandSize'QWORD, true, a, b, false)
            )
        )
    )

    (§ method- #_"Variable" LIRGenerator''emitShift-5 [#_"LIRGenerator" this, #_"AMD64Shift" op, #_"OperandSize" size, #_"Value" a, #_"Value" b]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind''changeType-2 (LIRKind'combine-1* a, b), (#_"Value" .getPlatformKind a)))
            #_"AllocatableValue" input (LIRGenerator''asAllocatable-2 this, a)
        ]
            (if (LIRValueUtil'isJavaConstant-1 b)
                (let [
                    #_"JavaConstant" c (:constant b)
                ]
                    (if (= (#_"JavaConstant" .asLong c) 1)
                        (LIRGenerator''append-2 this, (MOp'new-4 (:m1Op op), size, result, input))
                        ;; c is implicitly masked to 5 or 6 bits by the CPU, so casting it to (int)
                        ;; is always correct, even without the NumUtil.is32bit() test.
                        (LIRGenerator''append-2 this, (ConstOp'new-5 (:miOp op), size, result, input, (int (#_"JavaConstant" .asLong c))))
                    )
                )
                (do
                    (LIRGenerator''emitMove-3 this, LIRGenerator'RCX_I, b)
                    (LIRGenerator''append-2 this, (AMD64ShiftOp'new-5 (:mcOp op), size, result, input, LIRGenerator'RCX_I))
                )
            )
            result
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitShl-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SHL, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SHL, OperandSize'QWORD, a, b)
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitShr-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SAR, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SAR, OperandSize'QWORD, a, b)
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitUShr-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SHR, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'SHR, OperandSize'QWORD, a, b)
        )
    )

    #_unused
    (§ method! #_"Variable" LIRGenerator''emitRol-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'ROL, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'ROL, OperandSize'QWORD, a, b)
        )
    )

    #_unused
    (§ method! #_"Variable" LIRGenerator''emitRor-3 [#_"LIRGenerator" this, #_"Value" a, #_"Value" b]
        (condp = (#_"Value" .getPlatformKind a)
            AMD64Kind/DWORD (LIRGenerator''emitShift-5 this, AMD64Shift'ROR, OperandSize'DWORD, a, b)
            AMD64Kind/QWORD (LIRGenerator''emitShift-5 this, AMD64Shift'ROR, OperandSize'QWORD, a, b)
        )
    )

    (§ method- #_"AllocatableValue" LIRGenerator''emitConvertOp-5 [#_"LIRGenerator" this, #_"LIRKind" kind, #_"AMD64RMOp" op, #_"OperandSize" size, #_"Value" input]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
        ]
            (LIRGenerator''append-2 this, (RMOp'new-4 op, size, result, (LIRGenerator''asAllocatable-2 this, input)))
            result
        )
    )

    (§ method- #_"AllocatableValue" LIRGenerator''emitConvertOp-5 [#_"LIRGenerator" this, #_"LIRKind" kind, #_"AMD64MROp" op, #_"OperandSize" size, #_"Value" input]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, kind)
        ]
            (LIRGenerator''append-2 this, (MROp'new-4 op, size, result, (LIRGenerator''asAllocatable-2 this, input)))
            result
        )
    )

    (§ method! #_"Value" LIRGenerator''emitReinterpret-3 [#_"LIRGenerator" this, #_"LIRKind" to, #_"Value" inputVal]
        (when (= to (#_"Value" .getValueKind inputVal)) => (throw! "should not reach here")
            inputVal
        )
    )

    (§ method! #_"Value" LIRGenerator''emitNarrow-3 [#_"LIRGenerator" this, #_"Value" inputVal, #_"int" bits]
        (when (and (= (#_"Value" .getPlatformKind inputVal) AMD64Kind/QWORD) (<= bits 32)) => inputVal
            ;; TODO make it possible to reinterpret Long as Int in LIR without move
            (LIRGenerator''emitConvertOp-5 this, (LIRKind''changeType-2 (LIRKind'combine-1* inputVal), AMD64Kind/DWORD), AMD64RMOp'MOV, OperandSize'DWORD, inputVal)
        )
    )

    (§ method! #_"Value" LIRGenerator''emitSignExtend-4 [#_"LIRGenerator" this, #_"Value" inputVal, #_"int" fromBits, #_"int" toBits]
        (cond
            (= fromBits toBits)
                inputVal
            (< 32 toBits)
                ;; sign extend to 64 bits
                (case fromBits
                     8 (LIRGenerator''emitConvertOp-5 this, (LIRKind''changeType-2 AMD64Kind/QWORD (LIRKind'combine-1* inputVal)), AMD64RMOp'MOVSXB, OperandSize'QWORD, inputVal)
                    16 (LIRGenerator''emitConvertOp-5 this, (LIRKind''changeType-2 AMD64Kind/QWORD (LIRKind'combine-1* inputVal)), AMD64RMOp'MOVSX, OperandSize'QWORD, inputVal)
                    32 (LIRGenerator''emitConvertOp-5 this, (LIRKind''changeType-2 AMD64Kind/QWORD (LIRKind'combine-1* inputVal)), AMD64RMOp'MOVSXD, OperandSize'QWORD, inputVal)
                )
            :else
                ;; sign extend to 32 bits (smaller values are internally represented as 32 bit values)
                (case fromBits
                     8 (LIRGenerator''emitConvertOp-5 this, (LIRKind''changeType-2 AMD64Kind/DWORD (LIRKind'combine-1* inputVal)), AMD64RMOp'MOVSXB, OperandSize'DWORD, inputVal)
                    16 (LIRGenerator''emitConvertOp-5 this, (LIRKind''changeType-2 AMD64Kind/DWORD (LIRKind'combine-1* inputVal)), AMD64RMOp'MOVSX, OperandSize'DWORD, inputVal)
                    32 inputVal
                )
        )
    )

    (§ method! #_"Value" LIRGenerator''emitZeroExtend-4 [#_"LIRGenerator" this, #_"Value" inputVal, #_"int" fromBits, #_"int" toBits]
        (cond
            (= fromBits toBits)
                inputVal
            (< 32 fromBits)
                (let [
                    #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind'combine-1* inputVal))
                    #_"long" mask (CodeUtil/mask fromBits)
                ]
                    (LIRGenerator''append-2 this, (DataTwoOp'new-5 (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'AND, OperandSize'QWORD), OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, inputVal), (JavaConstant/forLong mask)))
                    result
                )
            :else
                (let [
                    #_"LIRKind" resultKind (LIRKind''changeType-2 (LIRKind'combine-1* inputVal), (if (< 32 toBits) AMD64Kind/QWORD AMD64Kind/DWORD))
                ]
                    ;; Always emit DWORD operations, even if the resultKind is Long. On AMD64, all DWORD operations
                    ;; implicitly set the upper half of the register to 0, which is what we want anyway. Compared to
                    ;; the QWORD operations, the encoding of the DWORD operations is sometimes one byte shorter.
                    (case fromBits
                         8 (LIRGenerator''emitConvertOp-5 this, resultKind, AMD64RMOp'MOVZXB, OperandSize'DWORD, inputVal)
                        16 (LIRGenerator''emitConvertOp-5 this, resultKind, AMD64RMOp'MOVZX, OperandSize'DWORD, inputVal)
                        32 (LIRGenerator''emitConvertOp-5 this, resultKind, AMD64RMOp'MOV, OperandSize'DWORD, inputVal)
                        ;; odd bit count, fall back on manual masking
                        (let [
                            #_"Variable" result (LIRGenerator''newVariable-2 this, resultKind)
                            #_"JavaConstant" mask (if (< 32 toBits) (JavaConstant/forLong (CodeUtil/mask fromBits)) (JavaConstant/forInt (int (CodeUtil/mask fromBits))))
                        ]
                            (LIRGenerator''append-2 this, (DataTwoOp'new-5 (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'AND, OperandSize'DWORD), OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, inputVal), mask))
                            result
                        )
                    )
                )
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitBitCount-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind''changeType-2 (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (if (= (#_"Value" .getPlatformKind value) AMD64Kind/QWORD)
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'POPCNT, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'POPCNT, OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            )
            result
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitBitScanForward-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind''changeType-2 (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'BSF, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            result
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitBitScanReverse-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind''changeType-2 (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (if (= (#_"Value" .getPlatformKind value) AMD64Kind/QWORD)
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'BSR, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'BSR, OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            )
            result
        )
    )

    (§ method! #_"Value" LIRGenerator''emitCountLeadingZeros-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind''changeType-2 (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (if (= (#_"Value" .getPlatformKind value) AMD64Kind/QWORD)
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'LZCNT, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'LZCNT, OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            )
            result
        )
    )

    (§ method! #_"Value" LIRGenerator''emitCountTrailingZeros-2 [#_"LIRGenerator" this, #_"Value" value]
        (let [
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRKind''changeType-2 (LIRKind'combine-1* value), AMD64Kind/DWORD))
        ]
            (if (= (#_"Value" .getPlatformKind value) AMD64Kind/QWORD)
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'TZCNT, OperandSize'QWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
                (LIRGenerator''append-2 this, (RMOp'new-4 AMD64RMOp'TZCNT, OperandSize'DWORD, result, (LIRGenerator''asAllocatable-2 this, value)))
            )
            result
        )
    )

    (§ method! #_"Variable" LIRGenerator''emitLoad-3 [#_"LIRGenerator" this, #_"LIRKind" kind, #_"Value" address]
        (let [
            #_"AMD64AddressValue" loadAddress (LIRGenerator''asAddressValue-2 this, address)
            #_"Variable" result (LIRGenerator''newVariable-2 this, (LIRGenerator''toRegisterKind-2 this, kind))
        ]
            (condp = (#_"ValueKind" .getPlatformKind kind)
                AMD64Kind/BYTE  (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOVSXB, OperandSize'DWORD, result, loadAddress))
                AMD64Kind/WORD  (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOVSX, OperandSize'DWORD, result, loadAddress))
                AMD64Kind/DWORD (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOV, OperandSize'DWORD, result, loadAddress))
                AMD64Kind/QWORD (LIRGenerator''append-2 this, (MemoryOp'new-4 AMD64RMOp'MOV, OperandSize'QWORD, result, loadAddress))
            )
            result
        )
    )

    (§ method! #_"void" LIRGenerator''emitStoreConst-4 [#_"LIRGenerator" this, #_"AMD64Kind" kind, #_"AMD64AddressValue" address, #_"ConstantValue" value]
        (let [
            #_"Constant" c (:constant value)
        ]
            (cond
                (JavaConstant/isNull c)
                    (let [
                        #_"OperandSize" size (if (= kind AMD64Kind/DWORD) OperandSize'DWORD OperandSize'QWORD)
                    ]
                        (LIRGenerator''append-2 this, (MemoryConstOp'new-4 AMD64MIOp'MOV, size, address, 0))
                        (§ return )
                    )
                (instance? VMConstant c)
                    ;; only 32-bit constants can be patched
                    (when (and (= kind AMD64Kind/DWORD) (or (.inlineObjects HotSpot'target) (not (instance? JavaConstant c))))
                        ;; if c is a JavaConstant, it's an oop, otherwise it's a metaspace constant
                        (LIRGenerator''append-2 this, (MemoryVMConstOp'new-3 AMD64MIOp'MOV, address, c))
                        (§ return )
                    )
                :else
                    (let [
                        [#_"AMD64MIOp" op #_"OperandSize" size #_"long" imm]
                            (condp = kind
                                AMD64Kind/BYTE  [AMD64MIOp'MOVB OperandSize'BYTE  (#_"JavaConstant" .asInt  c)]
                                AMD64Kind/WORD  [AMD64MIOp'MOV  OperandSize'WORD  (#_"JavaConstant" .asInt  c)]
                                AMD64Kind/DWORD [AMD64MIOp'MOV  OperandSize'DWORD (#_"JavaConstant" .asInt  c)]
                                AMD64Kind/QWORD [AMD64MIOp'MOV  OperandSize'QWORD (#_"JavaConstant" .asLong c)]
                            )
                    ]
                        (when (NumUtil'isInt-1 imm)
                            (LIRGenerator''append-2 this, (MemoryConstOp'new-4 op, size, address, (int imm)))
                            (§ return )
                        )
                    )
            )

            ;; fallback: load, then store
            (LIRGenerator''emitStore-4 this, kind, address, (LIRGenerator''asAllocatable-2 this, value))
        )
        nil
    )

    (§ method! #_"void" LIRGenerator''emitStore-4 [#_"LIRGenerator" this, #_"AMD64Kind" kind, #_"AMD64AddressValue" address, #_"AllocatableValue" value]
        (condp = kind
            AMD64Kind/BYTE  (LIRGenerator''append-2 this, (MemoryMROp'new-4 AMD64MROp'MOVB, OperandSize'BYTE, address, value))
            AMD64Kind/WORD  (LIRGenerator''append-2 this, (MemoryMROp'new-4 AMD64MROp'MOV, OperandSize'WORD, address, value))
            AMD64Kind/DWORD (LIRGenerator''append-2 this, (MemoryMROp'new-4 AMD64MROp'MOV, OperandSize'DWORD, address, value))
            AMD64Kind/QWORD (LIRGenerator''append-2 this, (MemoryMROp'new-4 AMD64MROp'MOV, OperandSize'QWORD, address, value))
        )
        nil
    )

    (§ method! #_"void" LIRGenerator''emitStore-4 [#_"LIRGenerator" this, #_"ValueKind" lirKind, #_"Value" address, #_"Value" input]
        (let [
            #_"AMD64AddressValue" storeAddress (LIRGenerator''asAddressValue-2 this, address)
            #_"AMD64Kind" kind (#_"ValueKind" .getPlatformKind lirKind)
        ]
            (if (instance? ConstantValue input)
                (LIRGenerator''emitStoreConst-4 this, kind, storeAddress, input)
                (LIRGenerator''emitStore-4 this, kind, storeAddress, (LIRGenerator''asAllocatable-2 this, input))
            )
        )
        nil
    )

    (§ method! #_"void" LIRGenerator''emitCompareOp-4 [#_"LIRGenerator" this, #_"AMD64Kind" cmpKind, #_"Variable" left, #_"Value" right]
        (let [
            #_"OperandSize" size
                (condp = cmpKind
                    AMD64Kind/BYTE  OperandSize'BYTE
                    AMD64Kind/WORD  OperandSize'WORD
                    AMD64Kind/DWORD OperandSize'DWORD
                    AMD64Kind/QWORD OperandSize'QWORD
                )
        ]
            (or
                (when (instance? ConstantValue right)
                    (let [
                        #_"Constant" c (:constant right)
                    ]
                        (cond
                            (JavaConstant/isNull c)
                                (do
                                    (LIRGenerator''append-2 this, (ConsumerOp'new-4 AMD64RMOp'TEST, size, left, left))
                                    :done
                                )
                            (instance? VMConstant c)
                                (do
                                    (if (= size OperandSize'DWORD)
                                        (LIRGenerator''append-2 this, (VMConstOp'new-3 (BinaryArithmetic''getMIOpcode-3 BinaryArithmetic'CMP, OperandSize'DWORD, false), left, c))
                                        (LIRGenerator''append-2 this, (DataOp'new-4 (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'CMP, size), size, left, c))
                                    )
                                    :done
                                )
                            (instance? JavaConstant c)
                                (cond
                                    (#_"JavaConstant" .isDefaultForKind c)
                                        (do
                                            (LIRGenerator''append-2 this, (ConsumerOp'new-4 (if (= size OperandSize'BYTE) AMD64RMOp'TESTB AMD64RMOp'TEST), size, left, left))
                                            :done
                                        )
                                    (NumUtil'is32bit-1 (#_"JavaConstant" .asLong c))
                                        (do
                                            (LIRGenerator''append-2 this, (ConsumerConstOp'new-4 BinaryArithmetic'CMP, size, left, (int (#_"JavaConstant" .asLong c))))
                                            :done
                                        )
                                )
                        )
                    )
                )
                ;; fallback: load, then compare
                (LIRGenerator''append-2 this, (ConsumerOp'new-4 (BinaryArithmetic''getRMOpcode-2 BinaryArithmetic'CMP, size), size, left, (LIRGenerator''asAllocatable-2 this, right)))
            )
        )
        nil
    )
)

;;;
 ; @anno LIRGenerator.BlockScopeImpl
 ;;
(final-ns BlockScopeImpl (§ implements BlockScope)
    (§ final #_"LIRGenerator" :gen nil)

    (§ defn- #_"BlockScopeImpl" BlockScopeImpl'new-2 [#_"LIRGenerator" gen, #_"Block" block]
        (let [
            #_"BlockScopeImpl" this (Object.)
            this (assoc this :gen gen)
        ]
            (§ ass! (:currentBlock (:gen this)) block)
            this
        )
    )

    (§ method- #_"void" BlockScopeImpl''doBlockStart-1 [#_"BlockScopeImpl" this]
        ;; set up the list of LIR instructions
        (LIR''setLIRforBlock-3 (:lir (:res (:gen this))), (:currentBlock (:gen this)), (ArrayList.))

        (LIRGenerator''append-2 (:gen this), (LabelOp'new-2 (Label'new-0), (:aligned? (:currentBlock (:gen this)))))
        nil
    )

    (§ method- #_"void" BlockScopeImpl''doBlockEnd-1 [#_"BlockScopeImpl" this]
        (§ ass! (:currentBlock (:gen this)) nil)
        nil
    )

    #_unused
    (§ override! #_"void" BlockScopeImpl''close-1 [#_"BlockScopeImpl" this]
        (BlockScopeImpl''doBlockEnd-1 this)
        nil
    )
)

;;;
 ; @anno LIRGenerator.BlockScope
 ;;
(§ interface BlockScope (§ extends AutoCloseable)
    #_unused
    (§ abstract #_"void" BlockScope''close-1 [#_"BlockScope" this])
)

;;;
 ; Functional interface for iterating over a list of values without modifying them.
 ; See InstructionValueProcedure for a version that can modify values.
 ;;
; @FunctionalInterface
(§ interface InstructionValueConsumer
    ;;;
     ; Iterator method to be overwritten.
     ;
     ; @param instruction The current instruction.
     ; @param value The value that is iterated.
     ; @param mode The operand mode for the value.
     ; @param flags A set of flags for the value.
     ;;
    (§ abstract #_"void" InstructionValueConsumer''visitValue-5 [#_"InstructionValueConsumer" this, #_"LIRInstruction" instruction, #_"Value" value, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags])
)

;;;
 ; Functional interface for iterating over a list of values, possibly returning a value to replace
 ; the old value.
 ;;
; @FunctionalInterface
(§ interface InstructionValueProcedure
    ;;;
     ; Iterator method to be overwritten.
     ;
     ; @param instruction The current instruction.
     ; @param value The value that is iterated.
     ; @param mode The operand mode for the value.
     ; @param flags A set of flags for the value.
     ; @return the new value to replace the value that was passed in
     ;;
    (§ abstract #_"Value" InstructionValueProcedure''doValue-5 [#_"InstructionValueProcedure" this, #_"LIRInstruction" instruction, #_"Value" value, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags])
)

;;;
 ; LIR instructions such as JumpOp and BranchOp need
 ; to reference their target Block. However, direct references are not possible
 ; since the control flow graph (and therefore successors lists) can be changed by optimizations -
 ; and fixing the instructions is error prone. Therefore, we represent an edge to block B from block
 ; A via the tuple {@code (A, successor-index-of-B)}. That is, indirectly by storing the index into
 ; the successor list of A. Note therefore that the successor list cannot be re-ordered.
 ;;
(final-ns LabelRef
    (§ final #_"LIR" :lir nil)
    (§ final #_"Block" :block nil)
    (§ final #_"int" :suxIndex 0)

    ;;;
     ; Returns a new reference to a successor of the given block.
     ;
     ; @param block The base block that contains the successor list.
     ; @param suxIndex The index of the successor.
     ; @return the newly created label reference
     ;;
    (§ defn #_"LabelRef" LabelRef'forSuccessor-3 [#_"LIR" lir, #_"Block" block, #_"int" suxIndex]
        (LabelRef'new-3 lir, block, suxIndex)
    )

    ;;;
     ; Returns a new reference to a successor of the given block.
     ;
     ; @param block The base block that contains the successor list.
     ; @param suxIndex The index of the successor.
     ;;
    (§ defn- #_"LabelRef" LabelRef'new-3 [#_"LIR" lir, #_"Block" block, #_"int" suxIndex]
        (let [
            #_"LabelRef" this (Object.)
            this (assoc this :lir lir)
            this (assoc this :block block)
            this (assoc this :suxIndex suxIndex)
        ]
            this
        )
    )

    (§ method! #_"Block" LabelRef''getTargetBlock-1 [#_"LabelRef" this]
        (nth (:successors (:block this)) (:suxIndex this))
    )

    (§ method! #_"Label" LabelRef''label-1 [#_"LabelRef" this]
        (:label (nth (LIR''getLIRforBlock-2 (:lir this), (LabelRef''getTargetBlock-1 this)) 0))
    )
)

;;;
 ; This class implements the overall container for the LIR graph and directs its construction,
 ; optimization, and finalization.
 ;;
(final-ns LIR
    (§ final #_"ControlFlowGraph" :cfg nil)
    ;;;
     ; The linear-scan ordered list of blocks.
     ;;
    (§ final #_"Block[]" :linearScanOrder nil)
    ;;;
     ; The order in which the code is emitted.
     ;;
    (§ final #_"Block[]" :codeEmittingOrder nil)
    ;;;
     ; Map from block to LIRInstructions.
     ; Note that we are using ArrayList instead of List to avoid interface dispatch.
     ;;
    (§ final #_"BlockMap<List<LIRInstruction>>" :lirInstructions nil)
    ;;;
     ; Determines if any of the parameters to the method are passed via the stack where the parameters
     ; are located in the caller's frame.
     ;;
    (§ mutable #_"boolean" :hasArgInCallerFrame false)

    (§ mutable #_"int" :numVariables 0)

    ;;;
     ; Creates a new LIR instance for the specified compilation.
     ;;
    (§ defn #_"LIR" LIR'new-3 [#_"ControlFlowGraph" cfg, #_"Block[]" linearScanOrder, #_"Block[]" codeEmittingOrder]
        (let [
            #_"LIR" this (Object.)
            this (assoc this :cfg cfg)
            this (assoc this :codeEmittingOrder codeEmittingOrder)
            this (assoc this :linearScanOrder linearScanOrder)
            this (assoc this :lirInstructions (BlockMap'new-1 cfg))
        ]
            this
        )
    )

    (§ method! #_"int" LIR''nextVariable-1 [#_"LIR" this]
        (§ ass! this (update this :numVariables inc))
        (:numVariables this)
    )

    (§ method! #_"List<LIRInstruction>" LIR''getLIRforBlock-2 [#_"LIR" this, #_"Block" block]
        (BlockMap''get-2 (:lirInstructions this), block)
    )

    (§ method! #_"void" LIR''setLIRforBlock-3 [#_"LIR" this, #_"Block" block, #_"List<LIRInstruction>" list]
        (BlockMap''put-3 (:lirInstructions this), block, list)
        nil
    )

    (§ method! #_"LIR" LIR''setHasArgInCallerFrame-1 [#_"LIR" this]
        (assoc this :hasArgInCallerFrame true)
    )

    ;;;
     ; Gets the next non-nil block in a list.
     ;
     ; @param blocks list of blocks
     ; @param i index of the current block
     ; @return the next block in the list that is none nil or nil if there is no such block
     ;;
    (§ defn #_"Block" LIR'getNextBlock-2 [#_"Block[]" blocks, #_"int" i]
        (loop-when [i (inc i)] (and (pos? i) (< i (count blocks))) (or (nth blocks i) (recur (inc i))))
    )
)

;;;
 ; A buffer to enqueue updates to a list. This avoids frequent re-sizing of the list and copying of
 ; list elements when insertions are done at multiple positions of the list. Additionally, it
 ; ensures that the list is not modified while it is, e.g. iterated, and instead only modified once
 ; after the iteration is done.
 ;
 ; The buffer uses internal data structures to store the enqueued updates. To avoid allocations, a
 ; buffer can be re-used. Call the methods in the following order: #init, #append,
 ; #append, ..., #finish(), #init, ...
 ;
 ; Note: This class does not depend on LIRInstruction, so we could make it a generic utility class.
 ;;
(final-ns LIRInsertionBuffer
    ;;;
     ; The lir list where ops of this buffer should be inserted later (nil when uninitialized).
     ;;
    (§ mutable #_"List<LIRInstruction>" :lir nil)

    ;;;
     ; List of insertion points. index and count are stored alternately: indexAndCount[i * 2]: the
     ; index into lir list where "count" ops should be inserted indexAndCount[i * 2 + 1]: the number
     ; of ops to be inserted at index
     ;;
    (§ mutable #_"int[]" :indexAndCount nil)
    (§ mutable #_"int" :indexAndCountSize 0)

    ;;;
     ; The LIROps to be inserted.
     ;;
    (§ final #_"List<LIRInstruction>" :ops nil)

    (§ defn #_"LIRInsertionBuffer" LIRInsertionBuffer'new-0 []
        (let [
            #_"LIRInsertionBuffer" this (Object.)
            this (assoc this :indexAndCount (int-array 8))
            this (assoc this :ops (ArrayList.))
        ]
            this
        )
    )

    ;;;
     ; Initialize this buffer. This method must be called before using #append.
     ;;
    (§ method! #_"LIRInsertionBuffer" LIRInsertionBuffer''init-2 [#_"LIRInsertionBuffer" this, #_"List<LIRInstruction>" lir]
        (assoc this :lir lir)
    )

    (§ method! #_"boolean" LIRInsertionBuffer''initialized-1 [#_"LIRInsertionBuffer" this]
        (some? (:lir this))
    )

    ;;;
     ; Enqueue a new instruction that will be appended to the instruction list when #finish() is called.
     ; The new instruction is added <b>before</b> the existing instruction with the given index.
     ; This method can only be called with increasing values of index, e.g. once an instruction was
     ; appended with index 4, subsequent instructions can only be appended with index 4 or higher.
     ;;
    (§ method! #_"LIRInsertionBuffer" LIRInsertionBuffer''append-3 [#_"LIRInsertionBuffer" this, #_"int" index, #_"LIRInstruction" op]
        (let [
            #_"int" i (dec (LIRInsertionBuffer''numberOfInsertionPoints-1 this))
            this
                (if (or (neg? i) (< (LIRInsertionBuffer''indexAt-2 this, i) index))
                    (LIRInsertionBuffer''appendNew-3 this, index, 1)
                    (do
                        (LIRInsertionBuffer''setCountAt-3 this, i, (inc (LIRInsertionBuffer''countAt-2 this, i)))
                        this
                    )
                )
        ]
            (#_"List" .add (:ops this), op)
            this
        )
    )

    ;;;
     ; Append all enqueued instructions to the instruction list. After that, #init(List) can
     ; be called again to re-use this buffer.
     ;;
    (§ method! #_"LIRInsertionBuffer" LIRInsertionBuffer''finish-1 [#_"LIRInsertionBuffer" this]
        (when (seq (:ops this)) => (assoc this :lir nil)
            (let [
                #_"int" n (count (:lir this))
            ]
                ;; increase size of instructions list
                (dotimes [#_"int" i (count (:ops this))]
                    (#_"List" .add (:lir this), nil)
                )
                ;; insert ops from buffer into instructions list
                (loop-when [#_"int" op (dec (count (:ops this))) #_"int" from (dec n) #_"int" to (dec (count (:lir this))) #_"int" ip (dec (LIRInsertionBuffer''numberOfInsertionPoints-1 this))] (<= 0 ip)
                    (let [
                        #_"int" index (LIRInsertionBuffer''indexAt-2 this, ip)
                        ;; make room after insertion point
                        [to from]
                            (loop-when [to to from from] (<= index from) => [to from]
                                (#_"List" .set (:lir this), to, (nth (:lir this) from))
                                (recur (dec to) (dec from))
                            )
                        ;; insert ops from buffer
                        [to op]
                            (loop-when [to to op op #_"int" i (LIRInsertionBuffer''countAt-2 this, ip)] (pos? i) => [to op]
                                (#_"List" .set (:lir this), to, (nth (:ops this) op))
                                (recur (dec to) (dec op) (dec i))
                            )
                    ]
                        (recur op from to (dec ip))
                    )
                )
                (let [
                    this (assoc this :indexAndCountSize 0)
                ]
                    (#_"List" .clear (:ops this))
                    (assoc this :lir nil)
                )
            )
        )
    )

    (§ method- #_"LIRInsertionBuffer" LIRInsertionBuffer''appendNew-3 [#_"LIRInsertionBuffer" this, #_"int" index, #_"int" count]
        (let [
            #_"int" oldSize (:indexAndCountSize this)
            #_"int" newSize (+ oldSize 2)
            this
                (when (< (count (:indexAndCount this)) newSize) => this
                    (assoc this :indexAndCount (Arrays/copyOf (:indexAndCount this), (* newSize 2)))
                )
        ]
            (aset (:indexAndCount this) oldSize index)
            (aset (:indexAndCount this) (inc oldSize) count)
            (assoc this :indexAndCountSize newSize)
        )
    )

    (§ method- #_"void" LIRInsertionBuffer''setCountAt-3 [#_"LIRInsertionBuffer" this, #_"int" i, #_"int" value]
        (aset (:indexAndCount this) (inc (<< i 1)) value)
        nil
    )

    (§ method- #_"int" LIRInsertionBuffer''numberOfInsertionPoints-1 [#_"LIRInsertionBuffer" this]
        (>> (:indexAndCountSize this) 1)
    )

    (§ method- #_"int" LIRInsertionBuffer''indexAt-2 [#_"LIRInsertionBuffer" this, #_"int" i]
        (nth (:indexAndCount this) (<< i 1))
    )

    (§ method- #_"int" LIRInsertionBuffer''countAt-2 [#_"LIRInsertionBuffer" this, #_"int" i]
        (nth (:indexAndCount this) (inc (<< i 1)))
    )
)

;;;
 ; The base class for an LIRInstruction.
 ;;
(class-ns LIRInstruction
    ;;;
     ; For validity checking of the operand flags defined by instruction subclasses.
     ;;
    (§ def #_"EnumMap<OperandMode, EnumSet<OperandFlag>>" LIRInstruction'ALLOWED_FLAGS (EnumMap. OperandMode))

    (§ init
        (#_"EnumMap" .put LIRInstruction'ALLOWED_FLAGS, OperandMode'USE, (EnumSet/of OperandFlag'REG, OperandFlag'STACK, OperandFlag'COMPOSITE, OperandFlag'CONST, OperandFlag'ILLEGAL, OperandFlag'HINT, OperandFlag'UNINITIALIZED))
        (#_"EnumMap" .put LIRInstruction'ALLOWED_FLAGS, OperandMode'ALIVE, (EnumSet/of OperandFlag'REG, OperandFlag'STACK, OperandFlag'COMPOSITE, OperandFlag'CONST, OperandFlag'ILLEGAL, OperandFlag'HINT, OperandFlag'UNINITIALIZED, OperandFlag'OUTGOING))
        (#_"EnumMap" .put LIRInstruction'ALLOWED_FLAGS, OperandMode'TEMP, (EnumSet/of OperandFlag'REG, OperandFlag'STACK, OperandFlag'COMPOSITE, OperandFlag'ILLEGAL, OperandFlag'HINT))
        (#_"EnumMap" .put LIRInstruction'ALLOWED_FLAGS, OperandMode'DEF, (EnumSet/of OperandFlag'REG, OperandFlag'STACK, OperandFlag'COMPOSITE, OperandFlag'ILLEGAL, OperandFlag'HINT))
    )

    ;;;
     ; The flags of the base and index value of an address.
     ;;
    (§ def #_"EnumSet<OperandFlag>" LIRInstruction'ADDRESS_FLAGS (EnumSet/of OperandFlag'REG, OperandFlag'ILLEGAL))

    (§ final #_"LIRInstructionClass" :instructionClass nil)

    ;;;
     ; Instruction id for register allocation.
     ;;
    (§ mutable #_"int" :id 0)

    ;;;
     ; Constructs a new LIR instruction.
     ;;
    (§ defn #_"LIRInstruction" LIRInstruction'new-1 [#_"LIRInstructionClass<? extends LIRInstruction>" c]
        (let [
            #_"LIRInstruction" this (Object.)
            this (assoc this :instructionClass c)
            this (assoc this :id -1)
        ]
            this
        )
    )

    (§ abstract #_"void" LIRInstruction''emitCode-2 [#_"LIRInstruction" this, #_"Assembler" asm])

    (§ method! #_"int" LIRInstruction''id-1 [#_"LIRInstruction" this]
        (:id this)
    )

    (§ method! #_"LIRInstruction" LIRInstruction''setId-2 [#_"LIRInstruction" this, #_"int" id]
        (assoc this :id id)
    )

    #_unused
    (§ method! #_"String" LIRInstruction''name-1 [#_"LIRInstruction" this]
        (LIRInstructionClass''getOpcode-2 (:instructionClass this), this)
    )

    (§ method! #_"boolean" LIRInstruction''hasOperands-1 [#_"LIRInstruction" this]
        (or (LIRInstructionClass''hasOperands-1 (:instructionClass this)) (LIRInstruction''destroysCallerSavedRegisters-1 this))
    )

    (§ method #_"boolean" LIRInstruction''destroysCallerSavedRegisters-1 [#_"LIRInstruction" this]
        false
    )

    ;; InstructionValueProcedures
    (§ method! #_"void" LIRInstruction''forEachInput-2 [#_"LIRInstruction" this, #_"InstructionValueProcedure" proc]
        (LIRInstructionClass''forEachUse-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''forEachAlive-2 [#_"LIRInstruction" this, #_"InstructionValueProcedure" proc]
        (LIRInstructionClass''forEachAlive-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''forEachTemp-2 [#_"LIRInstruction" this, #_"InstructionValueProcedure" proc]
        (LIRInstructionClass''forEachTemp-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''forEachOutput-2 [#_"LIRInstruction" this, #_"InstructionValueProcedure" proc]
        (LIRInstructionClass''forEachDef-3 (:instructionClass this), this, proc)
        nil
    )

    ;; ValueProcedures
    (§ method! #_"void" LIRInstruction''forEachInput-2 [#_"LIRInstruction" this, #_"ValueProcedure" proc]
        (LIRInstructionClass''forEachUse-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''forEachAlive-2 [#_"LIRInstruction" this, #_"ValueProcedure" proc]
        (LIRInstructionClass''forEachAlive-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''forEachTemp-2 [#_"LIRInstruction" this, #_"ValueProcedure" proc]
        (LIRInstructionClass''forEachTemp-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''forEachOutput-2 [#_"LIRInstruction" this, #_"ValueProcedure" proc]
        (LIRInstructionClass''forEachDef-3 (:instructionClass this), this, proc)
        nil
    )

    ;; InstructionValueConsumers
    (§ method! #_"void" LIRInstruction''visitEachInput-2 [#_"LIRInstruction" this, #_"InstructionValueConsumer" proc]
        (LIRInstructionClass''visitEachUse-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''visitEachAlive-2 [#_"LIRInstruction" this, #_"InstructionValueConsumer" proc]
        (LIRInstructionClass''visitEachAlive-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''visitEachTemp-2 [#_"LIRInstruction" this, #_"InstructionValueConsumer" proc]
        (LIRInstructionClass''visitEachTemp-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''visitEachOutput-2 [#_"LIRInstruction" this, #_"InstructionValueConsumer" proc]
        (LIRInstructionClass''visitEachDef-3 (:instructionClass this), this, proc)
        nil
    )

    ;; ValueConsumers
    (§ method! #_"void" LIRInstruction''visitEachInput-2 [#_"LIRInstruction" this, #_"ValueConsumer" proc]
        (LIRInstructionClass''visitEachUse-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''visitEachAlive-2 [#_"LIRInstruction" this, #_"ValueConsumer" proc]
        (LIRInstructionClass''visitEachAlive-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''visitEachTemp-2 [#_"LIRInstruction" this, #_"ValueConsumer" proc]
        (LIRInstructionClass''visitEachTemp-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"void" LIRInstruction''visitEachOutput-2 [#_"LIRInstruction" this, #_"ValueConsumer" proc]
        (LIRInstructionClass''visitEachDef-3 (:instructionClass this), this, proc)
        nil
    )

    (§ method! #_"Value" LIRInstruction''forEachRegisterHint-4 [#_"LIRInstruction" this, #_"Value" value, #_"OperandMode" mode, #_"InstructionValueProcedure" proc]
        (LIRInstructionClass''forEachRegisterHint-4 (:instructionClass this), this, mode, proc)
    )

    (§ method! #_"Value" LIRInstruction''forEachRegisterHint-4 [#_"LIRInstruction" this, #_"Value" value, #_"OperandMode" mode, #_"ValueProcedure" proc]
        (LIRInstructionClass''forEachRegisterHint-4 (:instructionClass this), this, mode, proc)
    )

    ;;;
     ; Returns true if the instruction is a MoveOp.
     ;
     ; This function is preferred to {@code instanceof MoveOp} since the type check is more
     ; expensive than reading a field from LIRInstructionClass.
     ;;
    (§ method! #_"boolean" LIRInstruction''isMoveOp-1 [#_"LIRInstruction" this]
        (:isMoveOp (:instructionClass this))
    )

    ;;;
     ; Returns true if the instruction is a ValueMoveOp.
     ;
     ; This function is preferred to {@code instanceof ValueMoveOp} since the type check is
     ; more expensive than reading a field from LIRInstructionClass.
     ;;
    (§ method! #_"boolean" LIRInstruction''isValueMoveOp-1 [#_"LIRInstruction" this]
        (:isValueMoveOp (:instructionClass this))
    )

    ;;;
     ; Returns true if the instruction is a LoadConstantOp.
     ;
     ; This function is preferred to {@code instanceof LoadConstantOp} since the type check is
     ; more expensive than reading a field from LIRInstructionClass.
     ;;
    (§ method! #_"boolean" LIRInstruction''isLoadConstantOp-1 [#_"LIRInstruction" this]
        (:isLoadConstantOp (:instructionClass this))
    )

    ;;;
     ; Utility method to add stack arguments to a list of temporaries. Useful for modeling calling
     ; conventions that kill outgoing argument space.
     ;
     ; @return additional temporaries
     ;;
    (§ defn #_"Value[]" LIRInstruction'addStackSlotsToTemporaries-2 [#_"Value[]" parameters, #_"Value[]" temporaries]
        (let [
            #_"int" n (count (filter #(instance? StackSlot %) parameters))
        ]
            (when (pos? n) => temporaries
                (let [
                    #_"Value[]" t (Arrays/copyOf temporaries, (+ (count temporaries) n))
                ]
                    (loop-when [#_"int" i (count temporaries) #_"ISeq" s (seq parameters)] (some? s)
                        (let [
                            #_"Value" p (first s)
                            i
                                (when (instance? StackSlot p) => i
                                    (aset t i p)
                                    (inc i)
                                )
                        ]
                            (recur i (next s))
                        )
                    )
                    t
                )
            )
        )
    )

    #_unused
    (§ method! #_"LIRInstructionClass" LIRInstruction''getLIRInstructionClass-1 [#_"LIRInstruction" this]
        (:instructionClass this)
    )
)

;;;
 ; Constants denoting how a LIR instruction uses an operand.
 ;
 ; @anno LIRInstruction.OperandMode
 ;;
(value-ns OperandMode
    ;;;
     ; The value must have been defined before. It is alive before the instruction until the
     ; beginning of the instruction, but not necessarily throughout the instruction. A register
     ; assigned to it can also be assigned to a #TEMP or #DEF operand. The value
     ; can be used again after the instruction, so the instruction must not modify the register.
     ;;
    (§ enum OperandMode'USE)
    ;;;
     ; The value must have been defined before. It is alive before the instruction and
     ; throughout the instruction. A register assigned to it cannot be assigned to a
     ; #TEMP or #DEF operand. The value can be used again after the instruction,
     ; so the instruction must not modify the register.
     ;;
    (§ enum OperandMode'ALIVE)
    ;;;
     ; The value must not have been defined before, and must not be used after the instruction.
     ; The instruction can do whatever it wants with the register assigned to it (or not use it
     ; at all).
     ;;
    (§ enum OperandMode'TEMP)
    ;;;
     ; The value must not have been defined before. The instruction has to assign a value to the
     ; register. The value can (and most likely will) be used after the instruction.
     ;;
    (§ enum OperandMode'DEF)
)

;;;
 ; @anno LIRInstruction.Use
 ; @target ElementType.FIELD
 ;;
(§ annotation Use
    (§ value #_"OperandFlag[]" value OperandFlag'REG)
)

;;;
 ; @anno LIRInstruction.Alive
 ; @target ElementType.FIELD
 ;;
(§ annotation Alive
    (§ value #_"OperandFlag[]" value OperandFlag'REG)
)

;;;
 ; @anno LIRInstruction.Temp
 ; @target ElementType.FIELD
 ;;
(§ annotation Temp
    (§ value #_"OperandFlag[]" value OperandFlag'REG)
)

;;;
 ; @anno LIRInstruction.Def
 ; @target ElementType.FIELD
 ;;
(§ annotation Def
    (§ value #_"OperandFlag[]" value OperandFlag'REG)
)

;;;
 ; Flags for an operand.
 ;
 ; @anno LIRInstruction.OperandFlag
 ;;
(value-ns OperandFlag
    ;;;
     ; The value can be a RegisterValue.
     ;;
    (§ enum OperandFlag'REG)
    ;;;
     ; The value can be a StackSlot.
     ;;
    (§ enum OperandFlag'STACK)
    ;;;
     ; The value can be a CompositeValue.
     ;;
    (§ enum OperandFlag'COMPOSITE)
    ;;;
     ; The value can be a JavaConstant.
     ;;
    (§ enum OperandFlag'CONST)
    ;;;
     ; The value can be Value#ILLEGAL.
     ;;
    (§ enum OperandFlag'ILLEGAL)
    ;;;
     ; The register allocator should try to assign a certain register to improve code quality.
     ; Use LIRInstruction#forEachRegisterHint to access the register hints.
     ;;
    (§ enum OperandFlag'HINT)
    ;;;
     ; The value can be uninitialized, e.g. a stack slot that has not written to before. This
     ; is only used to avoid false positives in verification code.
     ;;
    (§ enum OperandFlag'UNINITIALIZED)
    ;;;
     ; Outgoing block value.
     ;;
    (§ enum OperandFlag'OUTGOING)
)

(final-ns LIRInstructionClass #_"<T>" (§ extends LIRIntrospection #_"<T>")
    (§ final #_"Values" :uses nil)
    (§ final #_"Values" :alives nil)
    (§ final #_"Values" :temps nil)
    (§ final #_"Values" :defs nil)

    (§ final #_"boolean" :isMoveOp false)
    (§ final #_"boolean" :isValueMoveOp false)
    (§ final #_"boolean" :isLoadConstantOp false)

    (§ mutable #_"String" :opcodeConstant nil)
    (§ mutable #_"int" :opcodeIndex 0)

    (§ defn #_"LIRInstructionClass" LIRInstructionClass'new-1 [#_"Class<T>" clazz]
        (let [
            #_"LIRInstructionFieldsScanner" ifs (LIRInstructionFieldsScanner'new-0)
        ]
            (§ ass! ifs (LIRInstructionFieldsScanner''scan-2 ifs, clazz))
            (let [
                #_"LIRInstructionClass" this (LIRIntrospection'new-1 clazz)
                this (assoc this :uses (Values'new-1 (get (:valueAnnotations ifs) Use)))
                this (assoc this :alives (Values'new-1 (get (:valueAnnotations ifs) Alive)))
                this (assoc this :temps (Values'new-1 (get (:valueAnnotations ifs) Temp)))
                this (assoc this :defs (Values'new-1 (get (:valueAnnotations ifs) Def)))
                this (assoc this :data (Fields'new-1 (:data ifs)))
                this (assoc this :opcodeConstant (:opcodeConstant ifs))
                this (assoc this :opcodeIndex (if (some? (:opcodeField ifs)) (#_"ArrayList" .indexOf (:data ifs), (:opcodeField ifs)) -1))
                this (assoc this :isMoveOp (#_"Class" .isAssignableFrom MoveOp, clazz))
                this (assoc this :isValueMoveOp (#_"Class" .isAssignableFrom ValueMoveOp, clazz))
                this (assoc this :isLoadConstantOp (#_"Class" .isAssignableFrom LoadConstantOp, clazz))
            ]
                this
            )
        )
    )

    #_unused
    (§ defn #_"<T> LIRInstructionClass<T>" LIRInstructionClass'get-1 [#_"Class<T>" clazz]
        (let [
            #_"Field" field (#_"Class" .getDeclaredField clazz, "TYPE")
        ]
            (#_"Field" .setAccessible field, true)
            (or (#_"Field" .get field, nil)
                (throw! (str "TYPE field not initialized for class " (#_"Class" .getTypeName clazz)))
            )
        )
    )

    #_unused
    (§ override! #_"Fields[]" LIRInstructionClass''getAllFields-1 [#_"LIRInstructionClass<T>" this]
        (into-array Fields [ (:data this), (:uses this), (:alives this), (:temps this), (:defs this) ])
    )

    #_unused
    (§ method! #_"Values" LIRInstructionClass''getValues-2 [#_"LIRInstructionClass<T>" this, #_"OperandMode" mode]
        (condp = mode
            OperandMode'USE   (:uses this)
            OperandMode'ALIVE (:alives this)
            OperandMode'TEMP  (:temps this)
            OperandMode'DEF   (:defs this)
        )
    )

    (§ method! #_"String" LIRInstructionClass''getOpcode-2 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj]
        (or (:opcodeConstant this) (str (Fields''getObject-3 (:data this), obj, (:opcodeIndex this))))
    )

    (§ method! #_"boolean" LIRInstructionClass''hasOperands-1 [#_"LIRInstructionClass<T>" this]
        (or (seq (:offsets (:uses this))) (seq (:offsets (:alives this))) (seq (:offsets (:temps this))) (seq (:offsets (:defs this))))
    )

    (§ method! #_"void" LIRInstructionClass''forEachUse-3 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj, #_"InstructionValueProcedure" proc]
        (LIRIntrospection'forEach-4 obj, (:uses this), OperandMode'USE, proc)
        nil
    )

    (§ method! #_"void" LIRInstructionClass''forEachAlive-3 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj, #_"InstructionValueProcedure" proc]
        (LIRIntrospection'forEach-4 obj, (:alives this), OperandMode'ALIVE, proc)
        nil
    )

    (§ method! #_"void" LIRInstructionClass''forEachTemp-3 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj, #_"InstructionValueProcedure" proc]
        (LIRIntrospection'forEach-4 obj, (:temps this), OperandMode'TEMP, proc)
        nil
    )

    (§ method! #_"void" LIRInstructionClass''forEachDef-3 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj, #_"InstructionValueProcedure" proc]
        (LIRIntrospection'forEach-4 obj, (:defs this), OperandMode'DEF, proc)
        nil
    )

    (§ method! #_"void" LIRInstructionClass''visitEachUse-3 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj, #_"InstructionValueConsumer" proc]
        (LIRIntrospection'visitEach-4 obj, (:uses this), OperandMode'USE, proc)
        nil
    )

    (§ method! #_"void" LIRInstructionClass''visitEachAlive-3 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj, #_"InstructionValueConsumer" proc]
        (LIRIntrospection'visitEach-4 obj, (:alives this), OperandMode'ALIVE, proc)
        nil
    )

    (§ method! #_"void" LIRInstructionClass''visitEachTemp-3 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj, #_"InstructionValueConsumer" proc]
        (LIRIntrospection'visitEach-4 obj, (:temps this), OperandMode'TEMP, proc)
        nil
    )

    (§ method! #_"void" LIRInstructionClass''visitEachDef-3 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj, #_"InstructionValueConsumer" proc]
        (LIRIntrospection'visitEach-4 obj, (:defs this), OperandMode'DEF, proc)
        nil
    )

    (§ method! #_"Value" LIRInstructionClass''forEachRegisterHint-4 [#_"LIRInstructionClass<T>" this, #_"LIRInstruction" obj, #_"OperandMode" mode, #_"InstructionValueProcedure" proc]
        (let [
            #_"Values" hints
                (condp = mode
                    OperandMode'USE (:defs this)
                    OperandMode'DEF (:uses this)
                    nil
                )
        ]
            (when (some? hints)
                (loop-when [#_"int" i 0] (< i (count (:offsets hints)))
                    (or (when (<= (:directCount hints) i) => (InstructionValueProcedure''doValue-5 proc, obj, (Values''getValue-3 hints, obj, i), nil, nil)
                            (let [
                                #_"Value[]" hintValues (Values''getValueArray-3 hints, obj, i)
                            ]
                                (loop-when [#_"int" j 0] (< j (count hintValues))
                                    (or (InstructionValueProcedure''doValue-5 proc, obj, (nth hintValues j), nil, nil)
                                        (recur (inc j))
                                    )
                                )
                            )
                        )
                        (recur (inc i))
                    )
                )
            )
        )
    )
)

;;;
 ; @anno LIRInstructionClass.LIRInstructionFieldsScanner
 ;;
(final-ns LIRInstructionFieldsScanner (§ extends LIRFieldsScanner)
    (§ mutable #_"String" :opcodeConstant nil)

    ;;;
     ; Field (if any) annotated by LIROpcode.
     ;;
    (§ mutable #_"FieldInfo" :opcodeField nil)

    (§ defn #_"LIRInstructionFieldsScanner" LIRInstructionFieldsScanner'new-0 []
        (let [
            #_"LIRInstructionFieldsScanner" this (LIRFieldsScanner'new-0)
        ]
            (#_"EconomicMap" .put (:valueAnnotations this), Use, (OperandModeAnnotation'new-0))
            (#_"EconomicMap" .put (:valueAnnotations this), Alive, (OperandModeAnnotation'new-0))
            (#_"EconomicMap" .put (:valueAnnotations this), Temp, (OperandModeAnnotation'new-0))
            (#_"EconomicMap" .put (:valueAnnotations this), Def, (OperandModeAnnotation'new-0))
            this
        )
    )

    #_unused
    (§ override! #_"EnumSet<OperandFlag>" LIRInstructionFieldsScanner''getFlags-2 [#_"LIRInstructionFieldsScanner" this, #_"Field" field]
        (let [
            #_"EnumSet<OperandFlag>" result (EnumSet/noneOf OperandFlag)
        ]
            ;; Unfortunately, annotations cannot have class hierarchies or implement interfaces,
            ;; so we have to duplicate the code for every operand mode.
            ;; Unfortunately, annotations cannot have an EnumSet property, so we have to convert
            ;; from arrays to EnumSet manually.
            (cond
                (#_"Field" .isAnnotationPresent field, Use)
                    (#_"EnumSet" .addAll result, (Arrays/asList (#_"Annotation" .value (#_"Field" .getAnnotation field, Use))))
                (#_"Field" .isAnnotationPresent field, Alive)
                    (#_"EnumSet" .addAll result, (Arrays/asList (#_"Annotation" .value (#_"Field" .getAnnotation field, Alive))))
                (#_"Field" .isAnnotationPresent field, Temp)
                    (#_"EnumSet" .addAll result, (Arrays/asList (#_"Annotation" .value (#_"Field" .getAnnotation field, Temp))))
                (#_"Field" .isAnnotationPresent field, Def)
                    (#_"EnumSet" .addAll result, (Arrays/asList (#_"Annotation" .value (#_"Field" .getAnnotation field, Def))))
                :else
                    (throw! "should not reach here")
            )
            result
        )
    )

    (§ method! #_"LIRInstructionFieldsScanner" LIRInstructionFieldsScanner''scan-2 [#_"LIRInstructionFieldsScanner" this, #_"Class" clazz]
        (let [
            this
                (when (some? (#_"Class" .getAnnotation clazz, LIROpcode)) => this
                    (assoc this :opcodeConstant nil)
                )
            this (assoc this :opcodeField nil)
        ]
            (FieldsScanner''scan-4 (§ super ), clazz, LIRInstruction, false)

            (when (and (nil? (:opcodeConstant this)) (nil? (:opcodeField this))) => this
                (let [
                    this (assoc this :opcodeConstant (#_"Class" .getSimpleName clazz))
                ]
                    (when (#_"String" .endsWith (:opcodeConstant this), "Op") => this
                        (assoc this :opcodeConstant (#_"String" .substring (:opcodeConstant this), 0, (- (count (:opcodeConstant this)) 2)))
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" LIRInstructionFieldsScanner''scanField-3 [#_"LIRInstructionFieldsScanner" this, #_"Field" field, #_"long" offset]
        (LIRFieldsScanner''scanField-3 (§ super ), field, offset)

        (when (some? (#_"Field" .getAnnotation field, LIROpcode))
            (§ ass! this (assoc this :opcodeField (nth (:data this) (dec (count (:data this))))))
        )
        nil
    )
)

(class-ns LIRIntrospection #_"<T>" (§ extends FieldIntrospection #_"<T>")
    (§ def- #_"Class<Value>" LIRIntrospection'VALUE_CLASS Value)
    (§ def- #_"Class<ConstantValue>" LIRIntrospection'CONSTANT_VALUE_CLASS ConstantValue)
    (§ def- #_"Class<Variable>" LIRIntrospection'VARIABLE_CLASS Variable)
    (§ def- #_"Class<RegisterValue>" LIRIntrospection'REGISTER_VALUE_CLASS RegisterValue)
    (§ def- #_"Class<StackSlot>" LIRIntrospection'STACK_SLOT_CLASS StackSlot)
    (§ def- #_"Class<Value[]>" LIRIntrospection'VALUE_ARRAY_CLASS Value*'class)

    (§ defn #_"LIRIntrospection" LIRIntrospection'new-1 [#_"Class<T>" clazz]
        (FieldIntrospection'new-1 clazz)
    )

    ;;;
     ; The component values in an LIRInstruction or CompositeValue.
     ;;
    (§ mutable #_"Values" :values nil)

    (§ defn #_"void" LIRIntrospection'forEach-4 [#_"LIRInstruction" op, #_"Values" values, #_"OperandMode" mode, #_"InstructionValueProcedure" proc]
        (dotimes [#_"int" i (count (:offsets values))]
            (if (< i (:directCount values))
                (let [
                    #_"Value" value (Values''getValue-3 values, op, i)
                    #_"Value" newValue
                        (if (instance? CompositeValue value)
                            (CompositeValue''forEachComponent-4 value, op, mode, proc)
                            (InstructionValueProcedure''doValue-5 proc, op, value, mode, (Values''getFlags-2 values, i))
                        )
                ]
                    (when-not (#_"Value" .identityEquals value, newValue)
                        (Values''setValue-4 values, op, i, newValue)
                    )
                )
                (let [
                    #_"Value[]" valueArray (Values''getValueArray-3 values, op, i)
                ]
                    (dotimes [#_"int" j (count valueArray)]
                        (let [
                            #_"Value" value (nth valueArray j)
                            #_"Value" newValue
                                (if (instance? CompositeValue value)
                                    (CompositeValue''forEachComponent-4 value, op, mode, proc)
                                    (InstructionValueProcedure''doValue-5 proc, op, value, mode, (Values''getFlags-2 values, i))
                                )
                        ]
                            (when-not (#_"Value" .identityEquals value, newValue)
                                (aset valueArray j newValue)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"void" LIRIntrospection'visitEach-4 [#_"LIRInstruction" op, #_"Values" values, #_"OperandMode" mode, #_"InstructionValueConsumer" proc]
        (dotimes [#_"int" i (count (:offsets values))]
            (if (< i (:directCount values))
                (let [
                    #_"Value" value (Values''getValue-3 values, op, i)
                ]
                    (if (instance? CompositeValue value)
                        (CompositeValue''visitEachComponent-4 value, op, mode, proc)
                        (InstructionValueConsumer''visitValue-5 proc, op, value, mode, (Values''getFlags-2 values, i))
                    )
                )
                (let [
                    #_"Value[]" valueArray (Values''getValueArray-3 values, op, i)
                ]
                    (dotimes [#_"int" j (count valueArray)]
                        (let [
                            #_"Value" value (nth valueArray j)
                        ]
                            (if (instance? CompositeValue value)
                                (CompositeValue''visitEachComponent-4 value, op, mode, proc)
                                (InstructionValueConsumer''visitValue-5 proc, op, value, mode, (Values''getFlags-2 values, i))
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; @anno LIRIntrospection.Values
 ;;
(final-ns Values (§ extends Fields)
    (§ final #_"int" :directCount 0)
    (§ final #_"EnumSet<OperandFlag>[]" :flags nil)

    (§ defn #_"Values" Values'new-1 [#_"OperandModeAnnotation" mode]
        (Values'new-2 (:directCount mode), (:values mode))
    )

    (§ defn #_"Values" Values'new-2 [#_"int" directCount, #_"ArrayList<ValueFieldInfo>" fields]
        (let [
            #_"Values" this (Fields'new-1 fields)
            this (assoc this :directCount directCount)
            this (assoc this :flags (§ cast #_"EnumSet<OperandFlag>[]" (make-array EnumSet (count fields))))
        ]
            (dotimes [#_"int" i (count fields)]
                (aset (:flags this) i (:flags (nth fields i)))
            )
            this
        )
    )

    (§ method! #_"EnumSet<OperandFlag>" Values''getFlags-2 [#_"Values" this, #_"int" i]
        (nth (:flags this) i)
    )

    (§ method! #_"Value" Values''getValue-3 [#_"Values" this, #_"Object" obj, #_"int" index]
        (Fields''getObject-3 this, obj, index)
    )

    (§ method! #_"void" Values''setValue-4 [#_"Values" this, #_"Object" obj, #_"int" index, #_"Value" value]
        (Fields''putObject-4 this, obj, index, value)
        nil
    )

    (§ method! #_"Value[]" Values''getValueArray-3 [#_"Values" this, #_"Object" obj, #_"int" index]
        (Fields''getObject-3 this, obj, index)
    )

    #_unused
    (§ method! #_"void" Values''setValueArray-4 [#_"Values" this, #_"Object" obj, #_"int" index, #_"Value[]" valueArray]
        (Fields''putObject-4 this, obj, index, valueArray)
        nil
    )
)

;;;
 ; @anno LIRIntrospection.ValueFieldInfo
 ;;
(final-ns ValueFieldInfo (§ extends FieldInfo)
    (§ final #_"EnumSet<OperandFlag>" :flags nil)

    (§ defn #_"ValueFieldInfo" ValueFieldInfo'new-5 [#_"long" offset, #_"String" name, #_"Class" type, #_"Class" declaringClass, #_"EnumSet<OperandFlag>" flags]
        (let [
            #_"ValueFieldInfo" this (FieldInfo'new-4 offset, name, type, declaringClass)
            this (assoc this :flags flags)
        ]
            this
        )
    )

    ;;;
     ; Sorts non-array fields before array fields.
     ;;
    #_unused
    (§ override! #_"int" ValueFieldInfo''compareTo-2 [#_"ValueFieldInfo" this, #_"FieldInfo" o]
        (if (#_"Class" .isAssignableFrom LIRIntrospection'VALUE_ARRAY_CLASS, (:type o))
            (when-not (#_"Class" .isAssignableFrom LIRIntrospection'VALUE_ARRAY_CLASS, (:type this))
                (§ return -1)
            )
            (when (#_"Class" .isAssignableFrom LIRIntrospection'VALUE_ARRAY_CLASS, (:type this))
                (§ return 1)
            )
        )
        (FieldInfo''compareTo-2 (§ super ), o)
    )
)

;;;
 ; @anno LIRIntrospection.OperandModeAnnotation
 ;;
(final-ns OperandModeAnnotation
    (§ final #_"ArrayList<ValueFieldInfo>" :values (ArrayList.))
    ;;;
     ; Number of non-array fields in #values.
     ;;
    (§ mutable #_"int" :directCount 0)

    (§ defn #_"OperandModeAnnotation" OperandModeAnnotation'new-0 []
        (Object.)
    )
)

;;;
 ; @anno LIRIntrospection.LIRFieldsScanner
 ;;
(class-ns LIRFieldsScanner (§ extends FieldsScanner)
    (§ final #_"EconomicMap<Class<? extends Annotation>, OperandModeAnnotation>" :valueAnnotations nil)

    (§ defn #_"LIRFieldsScanner" LIRFieldsScanner'new-0 []
        (let [
            #_"LIRFieldsScanner" this (FieldsScanner'new-0)
            this (assoc this :valueAnnotations (EconomicMap/create Equivalence/DEFAULT))
        ]
            this
        )
    )

    (§ method! #_"OperandModeAnnotation" LIRFieldsScanner''getOperandModeAnnotation-2 [#_"LIRFieldsScanner" this, #_"Field" field]
        (let [
            #_"MapCursor<Class<? extends Annotation>, OperandModeAnnotation>" cursor (#_"EconomicMap" .getEntries (:valueAnnotations this))
        ]
            (loop-when [#_"OperandModeAnnotation" result nil] (#_"MapCursor" .advance cursor) => result
                (let [
                    result
                        (when (some? (#_"Field" .getAnnotation field, (#_"MapCursor" .getKey cursor))) => result
                            (#_"MapCursor" .getValue cursor)
                        )
                ]
                    (recur result)
                )
            )
        )
    )

    (§ abstract #_"EnumSet<OperandFlag>" LIRFieldsScanner''getFlags-2 [#_"LIRFieldsScanner" this, #_"Field" field])

    (§ override #_"void" LIRFieldsScanner''scanField-3 [#_"LIRFieldsScanner" this, #_"Field" field, #_"long" offset]
        (let [
            #_"Class" type (#_"Field" .getType field)
        ]
            (cond
                (and (#_"Class" .isAssignableFrom LIRIntrospection'VALUE_CLASS, type) (not (#_"Class" .isAssignableFrom LIRIntrospection'CONSTANT_VALUE_CLASS, type)))
                (let [
                    #_"OperandModeAnnotation" annotation (LIRFieldsScanner''getOperandModeAnnotation-2 this, field)
                    #_"EnumSet<OperandFlag>" flags (LIRFieldsScanner''getFlags-2 this, field)
                ]
                    (#_"ArrayList" .add (:values annotation), (ValueFieldInfo'new-5 offset, (#_"Field" .getName field), type, (#_"Field" .getDeclaringClass field), flags))
                    (§ ass annotation (update annotation :directCount inc))
                )
                (#_"Class" .isAssignableFrom LIRIntrospection'VALUE_ARRAY_CLASS, type)
                (let [
                    #_"OperandModeAnnotation" annotation (LIRFieldsScanner''getOperandModeAnnotation-2 this, field)
                    #_"EnumSet<OperandFlag>" flags (LIRFieldsScanner''getFlags-2 this, field)
                ]
                    (#_"ArrayList" .add (:values annotation), (ValueFieldInfo'new-5 offset, (#_"Field" .getName field), type, (#_"Field" .getDeclaringClass field), flags))
                )
                :else
                    (FieldsScanner''scanField-3 (§ super ), field, offset)
            )
        )
        nil
    )
)

(value-ns LIRValueUtil
    (§ defn #_"boolean" LIRValueUtil'isJavaConstant-1 [#_"Value" value]
        (and (instance? ConstantValue value) (instance? JavaConstant (:constant value)))
    )

    (§ defn #_"boolean" LIRValueUtil'isIntConstant-2 [#_"Value" value, #_"long" expected]
        (and (LIRValueUtil'isJavaConstant-1 value)
            (let [
                #_"JavaConstant" jc (:constant value)
            ]
                (and (some? jc) (#_"JavaKind" .isNumericInteger (#_"JavaConstant" .getJavaKind jc))
                    (= (#_"JavaConstant" .asLong jc) expected)
                )
            )
        )
    )

    (§ defn #_"boolean" LIRValueUtil'isStackSlotValue-1 [#_"Value" value]
        (or (instance? StackSlot value) (instance? VirtualStackSlot value))
    )

    (§ defn #_"boolean" LIRValueUtil'sameRegister-2 [#_"Value" v1, #_"Value" v2]
        (and (instance? RegisterValue v1) (instance? RegisterValue v2) (= (#_"RegisterValue" .getRegister v1) (#_"RegisterValue" .getRegister v2)))
    )

    #_unused
    (§ defn #_"boolean" LIRValueUtil'sameRegister-3 [#_"Value" v1, #_"Value" v2, #_"Value" v3]
        (and (LIRValueUtil'sameRegister-2 v1, v2) (LIRValueUtil'sameRegister-2 v1, v3))
    )

    ;;;
     ; Checks if all the provided values are different physical registers. The parameters can be
     ; either {@link Register registers}, {@link Value values} or arrays of them. All values that
     ; are not {@link RegisterValue registers} are ignored.
     ;;
    #_unused
    (§ defn #_"boolean" LIRValueUtil'differentRegisters-1* [#_"Object..." values]
        (let [
            #_"List<Register>" registers (LIRValueUtil'collectRegisters-2 values, (ArrayList.))
        ]
            (loop-when [#_"int" i 1] (< i (count registers)) => true
                (let [
                    #_"Register" r1 (nth registers i)
                ]
                    (and
                        (loop-when [#_"int" j 0] (< j i) => true
                            (let [
                                #_"Register" r2 (nth registers j)
                            ]
                                (if (= r1 r2)
                                    false
                                    (recur (inc j))
                                )
                            )
                        )
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (§ defn- #_"List<Register>" LIRValueUtil'collectRegisters-2 [#_"Object[]" values, #_"List<Register>" registers]
        (doseq [#_"Object" value values]
            (condp instance? value
                Register      (#_"List" .add registers, value)
                Value         (when (instance? RegisterValue value) (#_"List" .add registers, (#_"RegisterValue" .getRegister value)))
                Object*'class (LIRValueUtil'collectRegisters-2 value, registers)
            )
        )
        registers
    )

    ;;;
     ; Subtract sets of registers (x - y).
     ;
     ; @param x a set of register to subtract from.
     ; @param y a set of registers to subtract.
     ; @return resulting set of registers (x - y)
     ;;
    #_unused
    (§ defn #_"Value[]" LIRValueUtil'subtractRegisters-2 [#_"Value[]" x, #_"Value[]" y]
        (let [
            #_"ArrayList<Value>" result (ArrayList.)
        ]
            (doseq [#_"Value" i x]
                (when-not (loop [#_"ISeq" s (seq y)] (and (some? s) (or (LIRValueUtil'sameRegister-2 i, (first s)) (recur (next s)))))
                    (#_"ArrayList" .add result, i)
                )
            )
            (#_"ArrayList" .toArray result, (make-array Value (count result)))
        )
    )
)

(final-ns NullCheckOptimizer (§ extends PostAllocationOptimizationPhase)
    (§ defn #_"NullCheckOptimizer" NullCheckOptimizer'new-0 []
        (PostAllocationOptimizationPhase'new-0)
    )

    #_unused
    (§ override! #_"void" NullCheckOptimizer''run-3 [#_"NullCheckOptimizer" this, #_"LIRGenerationResult" lirGenRes, #_"PostAllocationOptimizationContext" context]
        (doseq [#_"Block" block (:codeEmittingOrder (:lir lirGenRes))]
            (when (some? block)
                (let [
                    #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir lirGenRes), block)
                ]
                    (when (seq ops)
                        (loop-when [#_"LIRInstruction" ins' (nth ops 0) #_"int" i 0] (< i (count ops))
                            (let [
                                #_"LIRInstruction" ins (nth ops i)
                                ins
                                    (when (and (instance? ImplicitNullCheck ins) (instance? NullCheck ins') (ImplicitNullCheck''makeNullCheckFor-3 ins, (NullCheck''getCheckedValue-1 ins'), (.implicitNullCheckLimit HotSpot'target))) => ins
                                        (#_"ArrayList" .remove ops, (dec i))
                                        (if (< i (count ops)) (nth ops i) ins)
                                    )
                            ]
                                (recur ins (inc i))
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; Denotes an opcode name for an annotated LIRInstruction.
 ;
 ; @target ElementType.TYPE, ElementType.FIELD
 ;;
(§ annotation LIROpcode
)

(class-ns AllocationPhase (§ extends LIRPhase #_"<AllocationContext>")
    (§ defn #_"AllocationPhase" AllocationPhase'new-0 []
        (LIRPhase'new-0)
    )
)

;;;
 ; @anno AllocationPhase.AllocationContext
 ;;
(final-ns AllocationContext (§ extends GenericContext)
    (§ final #_"MoveFactory" :moveFactory nil)
    (§ final #_"RegisterAllocationConfig" :registerAllocationConfig nil)

    (§ defn #_"AllocationContext" AllocationContext'new-2 [#_"MoveFactory" moveFactory, #_"RegisterAllocationConfig" registerAllocationConfig]
        (let [
            #_"AllocationContext" this (GenericContext'new-0)
            this (assoc this :moveFactory moveFactory)
            this (assoc this :registerAllocationConfig registerAllocationConfig)
        ]
            this
        )
    )
)

(final-ns AllocationStage (§ extends LIRPhaseSuite #_"<AllocationContext>")
    (§ defn #_"AllocationStage" AllocationStage'new-0 []
        (let [
            #_"AllocationStage" this (LIRPhaseSuite'new-0)
        ]
            (LIRPhaseSuite''appendPhase-2 this, (LinearScanPhase'new-0))

            ;; build frame map
            (if GraalOptions'lirOptLSStackSlotAllocator
                (LIRPhaseSuite''appendPhase-2 this, (LSStackSlotAllocator'new-0))
                (LIRPhaseSuite''appendPhase-2 this, (SimpleStackSlotAllocator'new-0))
            )
            this
        )
    )
)

;;;
 ; Allows storing of arbitrary data.
 ;;
(class-ns GenericContext
    (§ mutable #_"ArrayList<Object>" :context nil)

    (§ defn #_"GenericContext" GenericContext'new-0 []
        (let [
            #_"GenericContext" this (Object.)
            this (assoc this :context nil)
        ]
            this
        )
    )

    #_unused
    (§ method! #_"<T> void" GenericContext''contextAdd-2 [#_"GenericContext" this, #_"T" obj]
        (when (nil? (:context this))
            (§ ass! this (assoc this :context (ArrayList.)))
        )
        (#_"ArrayList" .add (:context this), obj)
        nil
    )

    #_unused
    (§ method! #_"<T> T" GenericContext''contextLookup-2 [#_"GenericContext" this, #_"Class<T>" clazz]
        (loop-when [#_"ISeq" s (seq (:context this))] (some? s)
            (let [
                #_"Object" e (first s)
            ]
                (if (#_"Class" .isInstance clazz, e)
                    (§ cast #_"T" e)
                    (recur (next s))
                )
            )
        )
    )

    #_unused
    (§ method! #_"<T> T" GenericContext''contextRemove-2 [#_"GenericContext" this, #_"Class<T>" clazz]
        (when (some? (:context this))
            (loop-when [#_"ListIterator<Object>" it (#_"ArrayList" .listIterator (:context this))] (#_"ListIterator" .hasNext it)
                (let [
                    #_"Object" e (#_"ListIterator" .next it)
                ]
                    (when (#_"Class" .isInstance clazz, e) => (recur it)
                        ;; remove entry
                        (#_"ListIterator" .remove it)
                        (when (empty? (:context this))
                            (§ ass! this (assoc this :context nil))
                        )
                        (§ cast #_"T" e)
                    )
                )
            )
        )
    )
)

;;;
 ; Base class for all {@link LIR low-level} phases. Subclasses should be stateless. There will be
 ; one global instance for each phase that is shared for all compilations.
 ;;
(class-ns LIRPhase #_"<C>"
    (§ defn #_"LIRPhase" LIRPhase'new-0 []
        (Object.)
    )

    (§ abstract #_"void" LIRPhase''run-3 [#_"LIRPhase<C>" this, #_"LIRGenerationResult" lirGenRes, #_"C" context])

    (§ method! #_"void" LIRPhase''apply-3 [#_"LIRPhase<C>" this, #_"LIRGenerationResult" lirGenRes, #_"C" context]
        (LIRPhase''run-3 this, lirGenRes, context)
        nil
    )
)

(class-ns LIRPhaseSuite #_"<C>" (§ extends LIRPhase #_"<C>")
    (§ mutable #_"List<LIRPhase<C>>" :phases nil)

    (§ defn #_"LIRPhaseSuite" LIRPhaseSuite'new-0 []
        (let [
            #_"LIRPhaseSuite" this (LIRPhase'new-0)
            this (assoc this :phases (ArrayList.))
        ]
            this
        )
    )

    ;;;
     ; Gets an unmodifiable view on the phases in this suite.
     ;;
    #_unused
    (§ method #_"List<LIRPhase<C>>" LIRPhaseSuite''getPhases-1 [#_"LIRPhaseSuite<C>" this]
        (Collections/unmodifiableList (:phases this))
    )

    ;;;
     ; Add a new phase at the beginning of this suite.
     ;;
    #_unused
    (§ method! #_"void" LIRPhaseSuite''prependPhase-2 [#_"LIRPhaseSuite<C>" this, #_"LIRPhase<C>" phase]
        (#_"List" .add (:phases this), 0, phase)
        nil
    )

    ;;;
     ; Add a new phase at the end of this suite.
     ;;
    (§ method! #_"void" LIRPhaseSuite''appendPhase-2 [#_"LIRPhaseSuite<C>" this, #_"LIRPhase<C>" phase]
        (#_"List" .add (:phases this), phase)
        nil
    )

    #_unused
    (§ method! #_"ListIterator<LIRPhase<C>>" LIRPhaseSuite''findPhase-2 [#_"LIRPhaseSuite<C>" this, #_"Class<? extends LIRPhase<C>>" phaseClass]
        (let [
            #_"ListIterator<LIRPhase<C>>" it (#_"List" .listIterator (:phases this))
        ]
            (when (LIRPhaseSuite'findNextPhase-2 it, phaseClass) it)
        )
    )

    #_unused
    (§ method! #_"<T extends LIRPhase<C>> T" LIRPhaseSuite''findPhaseInstance-2 [#_"LIRPhaseSuite<C>" this, #_"Class<T>" phaseClass]
        (loop-when [#_"ListIterator<LIRPhase<C>>" it (#_"List" .listIterator (:phases this))] (#_"ListIterator" .hasNext it)
            (let [
                #_"LIRPhase<C>" phase (#_"ListIterator" .next it)
            ]
                (when (#_"Class" .isInstance phaseClass, phase) => (recur it)
                    (#_"Class" .cast phaseClass, phase)
                )
            )
        )
    )

    (§ defn #_"<C> boolean" LIRPhaseSuite'findNextPhase-2 [#_"ListIterator<LIRPhase<C>>" it, #_"Class<? extends LIRPhase<C>>" phaseClass]
        (loop [] (and (#_"ListIterator" .hasNext it) (or (#_"Class" .isInstance phaseClass, (#_"ListIterator" .next it)) (recur))))
    )

    #_unused
    (§ override! #_"void" LIRPhaseSuite''run-3 [#_"LIRPhaseSuite<C>" this, #_"LIRGenerationResult" lirGenRes, #_"C" context]
        (doseq [#_"LIRPhase<C>" phase (:phases this)]
            (LIRPhase''apply-3 phase, lirGenRes, context)
        )
        nil
    )
)

(final-ns LIRSuites
    ;;;
     ; PreAllocationOptimizationPhases are executed between LIR generation and register allocation.
     ;
     ; {@link PreAllocationOptimizationPhase Implementers} can create new {@link LIRGenerator#newVariable variables},
     ; {@link LIRGenerationResult#getFrameMap stack slots} and {@link LIRGenerationResult#getFrameMapBuilder virtual stack slots}.
     ;;
    (§ final #_"LIRPhaseSuite<PreAllocationOptimizationContext>" :preAllocOptStage nil)
    ;;;
     ; AllocationPhases are responsible for register allocation and translating VirtualStackSlots into StackSlots.
     ;
     ; After the AllocationStage there should be no more Variables and VirtualStackSlots.
     ;;
    (§ final #_"LIRPhaseSuite<AllocationContext>" :allocStage nil)
    ;;;
     ; PostAllocationOptimizationPhases are executed after register allocation and before machine code generation.
     ;
     ; A PostAllocationOptimizationPhase must not introduce new Variables, VirtualStackSlots or StackSlots.
     ; Blocks might be removed from LIR#codeEmittingOrder() by overwriting them with nil.
     ;;
    (§ final #_"LIRPhaseSuite<PostAllocationOptimizationContext>" :postAllocStage nil)

    (§ defn #_"LIRSuites" LIRSuites'new-3 [#_"LIRPhaseSuite<PreAllocationOptimizationContext>" preAllocOptStage, #_"LIRPhaseSuite<AllocationContext>" allocStage, #_"LIRPhaseSuite<PostAllocationOptimizationContext>" postAllocStage]
        (let [
            #_"LIRSuites" this (Object.)
            this (assoc this :preAllocOptStage preAllocOptStage)
            this (assoc this :allocStage allocStage)
            this (assoc this :postAllocStage postAllocStage)
        ]
            this
        )
    )
)

(class-ns PostAllocationOptimizationPhase (§ extends LIRPhase #_"<PostAllocationOptimizationContext>")
    (§ defn #_"PostAllocationOptimizationPhase" PostAllocationOptimizationPhase'new-0 []
        (LIRPhase'new-0)
    )
)

;;;
 ; @anno PostAllocationOptimizationPhase.PostAllocationOptimizationContext
 ;;
(final-ns PostAllocationOptimizationContext
    (§ defn #_"PostAllocationOptimizationContext" PostAllocationOptimizationContext'new-0 []
        (Object.)
    )
)

(final-ns PostAllocationOptimizationStage (§ extends LIRPhaseSuite #_"<PostAllocationOptimizationContext>")
    (§ defn #_"PostAllocationOptimizationStage" PostAllocationOptimizationStage'new-0 []
        (let [
            #_"PostAllocationOptimizationStage" this (LIRPhaseSuite'new-0)
        ]
            (when GraalOptions'lirOptEdgeMoveOptimizer
                (LIRPhaseSuite''appendPhase-2 this, (EdgeMoveOptimizer'new-0))
            )
            (when GraalOptions'lirOptControlFlowOptimizer
                (LIRPhaseSuite''appendPhase-2 this, (ControlFlowOptimizer'new-0))
            )
            (when GraalOptions'lirOptRedundantMoveElimination
                (LIRPhaseSuite''appendPhase-2 this, (RedundantMoveElimination'new-0))
            )
            (when GraalOptions'lirOptNullCheckOptimizer
                (LIRPhaseSuite''appendPhase-2 this, (NullCheckOptimizer'new-0))
            )
            this
        )
    )
)

(class-ns PreAllocationOptimizationPhase (§ extends LIRPhase #_"<PreAllocationOptimizationContext>")
    (§ defn #_"PreAllocationOptimizationPhase" PreAllocationOptimizationPhase'new-0 []
        (LIRPhase'new-0)
    )
)

;;;
 ; @anno PreAllocationOptimizationPhase.PreAllocationOptimizationContext
 ;;
(final-ns PreAllocationOptimizationContext
    (§ final #_"LIRGenerator" :lirGen nil)

    (§ defn #_"PreAllocationOptimizationContext" PreAllocationOptimizationContext'new-1 [#_"LIRGenerator" lirGen]
        (let [
            #_"PreAllocationOptimizationContext" this (Object.)
            this (assoc this :lirGen lirGen)
        ]
            this
        )
    )
)

(final-ns PreAllocationOptimizationStage (§ extends LIRPhaseSuite #_"<PreAllocationOptimizationContext>")
    (§ defn #_"PreAllocationOptimizationStage" PreAllocationOptimizationStage'new-0 []
        (let [
            #_"PreAllocationOptimizationStage" this (LIRPhaseSuite'new-0)
        ]
            (when GraalOptions'lirOptConstantLoadOptimization
                (LIRPhaseSuite''appendPhase-2 this, (ConstantLoadOptimization'new-0))
            )
            (LIRPhaseSuite''appendPhase-2 this, (SaveCalleeSaveRegisters'new-0))
            this
        )
    )
)

;;;
 ; Removes move instructions, where the destination value is already in place.
 ;;
(final-ns RedundantMoveElimination (§ extends PostAllocationOptimizationPhase)
    (§ defn #_"RedundantMoveElimination" RedundantMoveElimination'new-0 []
        (PostAllocationOptimizationPhase'new-0)
    )

    #_unused
    (§ override! #_"void" RedundantMoveElimination''run-3 [#_"RedundantMoveElimination" this, #_"LIRGenerationResult" lirGenRes, #_"PostAllocationOptimizationContext" context]
        (§ ass! (RMEOptimization'new-1 (:frameMap lirGenRes)) (RMEOptimization''doOptimize-2 (RMEOptimization'new-1 (:frameMap lirGenRes)), (:lir lirGenRes)))
        nil
    )
)

;;;
 ; Holds the entry and exit states for each block for dataflow analysis. The state is an array
 ; with an element for each relevant location (register or stack slot). Each element holds the
 ; global number of the location's definition. A location definition is simply an output of an
 ; instruction. Note that because instructions can have multiple outputs it is not possible to
 ; use the instruction id for value numbering. In addition, the result of merging at block
 ; entries (= phi values) get unique value numbers.
 ;
 ; The value numbers also contain information if it is an object kind value or not: if the
 ; number is negative it is an object kind value.
 ;
 ; @anno RedundantMoveElimination.BlockStates
 ;;
(final-ns BlockStates
    ;; The state at block entry for global dataflow analysis. It contains a global value number
    ;; for each location to optimize.

    (§ mutable #_"int[]" :entryState nil)

    ;; The state at block exit for global dataflow analysis. It contains a global value number
    ;; for each location to optimize.

    (§ mutable #_"int[]" :exitState nil)

    ;; The starting number for global value numbering in this block.

    (§ mutable #_"int" :entryValueNum 0)

    (§ defn #_"BlockStates" BlockStates'new-1 [#_"int" stateSize]
        (let [
            #_"BlockStates" this (Object.)
            this (assoc this :entryState (int-array stateSize))
            this (assoc this :exitState (int-array stateSize))
        ]
            this
        )
    )
)

;;;
 ; @anno RedundantMoveElimination.RMEOptimization
 ;;
(final-ns RMEOptimization
    (§ mutable #_"EconomicMap<Block, BlockStates>" :blockData (EconomicMap/create Equivalence/IDENTITY))

    (§ mutable #_"RegisterArray" :callerSaveRegs nil)

    ;;;
     ; Contains the register number for registers which can be optimized and -1 for the others.
     ;;
    (§ mutable #_"int[]" :eligibleRegs nil)

    ;;;
     ; A map from the StackSlot {@link #getOffset offset} to an index into the state.
     ; StackSlots of different kinds that map to the same location will map to the same index.
     ;;
    (§ mutable #_"EconomicMap<Integer, Integer>" :stackIndices (EconomicMap/create Equivalence/DEFAULT))

    (§ mutable #_"int" :numRegs 0)

    (§ final #_"FrameMap" :frameMap nil)

    ;; Pseudo value for a not yet assigned location.
    (def #_"int" RMEOptimization'INIT_VALUE 0)

    (§ defn #_"RMEOptimization" RMEOptimization'new-1 [#_"FrameMap" frameMap]
        (let [
            #_"RMEOptimization" this (Object.)
            this (assoc this :frameMap frameMap)
        ]
            this
        )
    )

    ;;;
     ; The main method doing the elimination of redundant moves.
     ;;
    (§ method- #_"RMEOptimization" RMEOptimization''doOptimize-2 [#_"RMEOptimization" this, #_"LIR" lir]
        (let [
            this (assoc this :callerSaveRegs (#_"RegisterConfig" .getCallerSaveRegisters HotSpot'registerConfig))
            this (RMEOptimization''initBlockData-2 this, lir)
            ;; Compute a table of the registers which are eligible for move optimization.
            ;; Unallocatable registers should never be optimized.
            this (assoc this :eligibleRegs (int-array (:numRegs this)))
            _ (Arrays/fill (:eligibleRegs this), -1)
        ]
            (doseq [#_"Register" reg (#_"RegisterConfig" .getAllocatableRegisters HotSpot'registerConfig)]
                (when (< (.number reg) (:numRegs this))
                    (aset (:eligibleRegs this) (.number reg) (.number reg))
                )
            )
            (when (RMEOptimization''solveDataFlow-2 this, lir)
                (RMEOptimization''eliminateMoves-2 this, lir)
            )
            this
        )
    )

    ;;;
     ; The maximum number of locations * blocks. This is a complexity limit for the inner loop
     ; in #mergeState (assuming a small number of iterations in #solveDataFlow).
     ;;
    (def- #_"int" RMEOptimization'COMPLEXITY_LIMIT 30000)

    (§ method- #_"RMEOptimization" RMEOptimization''initBlockData-2 [#_"RMEOptimization" this, #_"LIR" lir]
        (let [
            this (assoc this :numRegs 0)
            #_"Block[]" blocks (:linearScanOrder lir)
            #_"int" maxStackLocations (quot RMEOptimization'COMPLEXITY_LIMIT (count blocks))
            ;; Search for relevant locations which can be optimized. These are register or stack
            ;; slots which occur as destinations of move instructions.
            _
                (loop-when-recur [#_"ISeq" s (seq blocks)] (some? s) [(next s)]
                    (let [
                        #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, (first s))
                    ]
                        (loop-when-recur [#_"ISeq" s (seq ops)] (some? s) [(next s)]
                            (let [
                                #_"LIRInstruction" op (first s)
                            ]
                                (when (RMEOptimization'isEligibleMove-1 op)
                                    (let [
                                        #_"Value" dest (MoveOp''getResult-1 op)
                                    ]
                                        (condp instance? dest
                                            RegisterValue
                                                (let [
                                                    #_"int" regNum (.number (#_"RegisterValue" .getRegister dest))
                                                ]
                                                    (when (<= (:numRegs this) regNum)
                                                        (§ ass! this (assoc this :numRegs (inc regNum)))
                                                    )
                                                )
                                            StackSlot
                                                (let [
                                                    #_"Integer" offset (RMEOptimization''getOffset-2 this, dest)
                                                ]
                                                    (when (and (not (contains? (:stackIndices this) offset)) (< (count (:stackIndices this)) maxStackLocations))
                                                        (#_"EconomicMap" .put (:stackIndices this), offset, (count (:stackIndices this)))
                                                    )
                                                )
                                            nil
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ;; Now we know the number of locations to optimize, so we can allocate the block states.
            #_"int" numLocations (+ (:numRegs this) (count (:stackIndices this)))
        ]
            (doseq [#_"Block" block blocks]
                (#_"EconomicMap" .put (:blockData this), block, (BlockStates'new-1 numLocations))
            )
            this
        )
    )

    (§ method- #_"int" RMEOptimization''getOffset-2 [#_"RMEOptimization" this, #_"StackSlot" stackSlot]
        (#_"StackSlot" .getOffset stackSlot, (FrameMap''totalFrameSize-1 (:frameMap this)))
    )

    ;;;
     ; Calculates the entry and exit states for all basic blocks.
     ;
     ; @return true on success and false if the control flow is too complex
     ;;
    (§ method- #_"boolean" RMEOptimization''solveDataFlow-2 [#_"RMEOptimization" this, #_"LIR" lir]
        (let [
            #_"Block[]" blocks (:linearScanOrder lir)
            ;; Iterate until there are no more changes.
            #_"int" currentValueNum 1
        ]
            (loop [#_"int" iteration 0]
                (let [
                    #_"boolean" changed?
                        (loop-when [changed? false #_"ISeq" s (seq blocks)] (some? s) => changed?
                            (let [
                                #_"Block" block (first s)
                                #_"BlockStates" data (get (:blockData this) block)
                            ]
                                ;; Initialize the number for global value numbering for this block.
                                ;; It is essential that the starting number for a block is consistent
                                ;; at all iterations and also in eliminateMoves().
                                (when (zero? iteration)
                                    (§ ass! data (assoc data :entryValueNum currentValueNum))
                                )
                                (let [
                                    #_"int" valueNum (:entryValueNum data)
                                    #_"boolean" newState
                                        (if (= block (nth blocks 0))
                                            (do
                                                ;; The entry block has undefined values. And also exception handler blocks:
                                                ;; the LinearScan can insert moves at the end of an exception handler predecessor
                                                ;; block (after the invoke, which throws the exception),
                                                ;; and in reality such moves are not in the control flow in case of an exception.
                                                ;; So we assume a save default for exception handler blocks.
                                                (RMEOptimization'clearValues-2 (:entryState data), valueNum)
                                                false
                                            )
                                            ;; Merge the states of predecessor blocks.
                                            (loop-when-recur [newState false #_"ISeq" s (seq (:predecessors block))]
                                                             (some? s)
                                                             [(or newState (RMEOptimization'mergeState-3 (:entryState data), (:exitState (get (:blockData this) (first s))), valueNum)) (next s)]
                                                          => newState
                                            )
                                        )
                                    ;; Advance by the value numbers which are "consumed" by clearValues and mergeState.
                                    valueNum (+ valueNum (count (:entryState data)))
                                    [valueNum changed?]
                                        (when (or newState (zero? iteration)) => [valueNum changed?]
                                            ;; Derive the exit state from the entry state by iterating through all instructions of the block.
                                            (let [
                                                #_"int[]" iterState (:exitState data)
                                            ]
                                                (RMEOptimization'copyState-2 iterState, (:entryState data))
                                                (let [
                                                    valueNum
                                                        (loop-when-recur [valueNum valueNum #_"ISeq" s (seq (LIR''getLIRforBlock-2 lir, block))]
                                                                         (some? s)
                                                                         [(RMEOptimization''updateState-4 this, iterState, (first s), valueNum) (next s)]
                                                                      => valueNum
                                                        )
                                                ]
                                                    [valueNum true]
                                                )
                                            )
                                        )
                                ]
                                    (when (zero? iteration)
                                        (§ ass currentValueNum valueNum)
                                    )
                                    (recur changed? (next s))
                                )
                            )
                        )
                    iteration (inc iteration)
                ]
                    (if (< 5 iteration)
                        false ;; fairly rare
                        (recur-if changed? [iteration] => true)
                    )
                )
            )
        )
    )

    ;;;
     ; Deletes all move instructions where the target location already contains the source value.
     ;;
    (§ method- #_"void" RMEOptimization''eliminateMoves-2 [#_"RMEOptimization" this, #_"LIR" lir]
        (doseq [#_"Block" block (:linearScanOrder lir)]
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
                #_"BlockStates" data (get (:blockData this) block)
                ;; reuse the entry state for iteration, we don't need it later
                #_"int[]" state (:entryState data)
                ;; add the values which are "consumed" by clearValues and mergeState in solveDataFlow
                #_"boolean" hasDead
                    (loop-when [hasDead false #_"int" valueNum (+ (:entryValueNum data) (count (:entryState data))) #_"int" i 0] (< i (count ops)) => hasDead
                        (let [
                            #_"LIRInstruction" op (nth ops i)
                            hasDead
                                (when (RMEOptimization'isEligibleMove-1 op) => hasDead
                                    (let [
                                        #_"int" src (RMEOptimization''getStateIdx-2 this, (ValueMoveOp''getInput-1 op))
                                        #_"int" dst (RMEOptimization''getStateIdx-2 this, (MoveOp''getResult-1 op))
                                    ]
                                        (when (and (<= 0 src) (<= 0 dst) (= (nth state src) (nth state dst))) => hasDead
                                            (#_"ArrayList" .set ops, i, nil)
                                            true
                                        )
                                    )
                                )
                        ]
                            ;; it doesn't harm if updateState is also called for a deleted move
                            (recur hasDead (RMEOptimization''updateState-4 this, state, op, valueNum) (inc i))
                        )
                    )
            ]
                (when hasDead
                    (#_"ArrayList" .removeAll ops, (Collections/singleton nil))
                )
            )
        )
        nil
    )

    ;;;
     ; Updates the state for one instruction.
     ;;
    (§ method- #_"int" RMEOptimization''updateState-4 [#_"RMEOptimization" this, #_"int[]" state, #_"LIRInstruction" op, #_"int" initValueNum]
        (when (RMEOptimization'isEligibleMove-1 op)
            ;; handle the special case of a move instruction
            (let [
                #_"int" src (RMEOptimization''getStateIdx-2 this, (ValueMoveOp''getInput-1 op))
                #_"int" dst (RMEOptimization''getStateIdx-2 this, (MoveOp''getResult-1 op))
            ]
                (when (and (<= 0 src) (<= 0 dst))
                    (aset state dst (nth state src))
                    (§ return initValueNum)
                )
            )
        )

        (let [
            #_"int[]" valueNum (§ array initValueNum )
        ]
            (when (LIRInstruction''destroysCallerSavedRegisters-1 op)
                (doseq [#_"Register" reg (:callerSaveRegs this)]
                    (when (< (.number reg) (:numRegs this))
                        ;; Kind.Object is the save default
                        (aset state (.number reg) (RMEOptimization'encodeValueNum-2 (nth valueNum 0), true))
                        (aswap valueNum 0 inc)
                    )
                )
            )

            ;; Value procedure for the instruction's output and temp values.
            (let [
                #_"RMEOptimization" optimization this
                #_"ValueConsumer" outputValueConsumer
                    (§ reify #_"ValueConsumer" (ValueConsumer'reify-0)
                        (§ override! #_"void" ValueConsumer''visitValue-4 [#_"ValueConsumer" this, #_"Value" operand, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags]
                            (let [
                                #_"int" i (RMEOptimization''getStateIdx-2 optimization, operand)
                            ]
                                (when (<= 0 i)
                                    ;; Assign a unique number to the output or temp location.
                                    (aset state i (RMEOptimization'encodeValueNum-2 (nth valueNum 0), (not (LIRKind'isValue-1 operand))))
                                    (aswap valueNum 0 inc)
                                )
                            )
                            nil
                        )
                    )
            ]
                (LIRInstruction''visitEachTemp-2 op, outputValueConsumer)
                ;; Semantically the output values are written _after_ the temp values.
                (LIRInstruction''visitEachOutput-2 op, outputValueConsumer)

                (nth valueNum 0)
            )
        )
    )

    ;;;
     ; The state merge function for dataflow joins.
     ;;
    (§ defn- #_"boolean" RMEOptimization'mergeState-3 [#_"int[]" dst*, #_"int[]" src*, #_"int" defNum]
        (loop-when [#_"boolean" changed? false #_"int" i 0] (< i (count src*)) => changed?
            (let [
                #_"int" phiNum (+ defNum i)
                #_"int" dst (nth dst* i)
                #_"int" src (nth src* i)
                changed?
                    (when (and (not= dst src) (not= src RMEOptimization'INIT_VALUE) (not= dst (RMEOptimization'encodeValueNum-2 phiNum, (RMEOptimization'isObjectValue-1 dst)))) => changed?
                        (aset dst* i (if (not= dst RMEOptimization'INIT_VALUE) (RMEOptimization'encodeValueNum-2 phiNum, (or (RMEOptimization'isObjectValue-1 dst) (RMEOptimization'isObjectValue-1 src))) src))
                        true
                    )
            ]
                (recur changed? (inc i))
            )
        )
    )

    (§ defn- #_"void" RMEOptimization'copyState-2 [#_"int[]" dest, #_"int[]" source]
        (dotimes [#_"int" i (count source)]
            (aset dest i (nth source i))
        )
        nil
    )

    (§ defn- #_"void" RMEOptimization'clearValues-2 [#_"int[]" state, #_"int" defNum]
        (dotimes [#_"int" i (count state)]
            ;; Let the killed values assume to be object references: it's the save default.
            (aset state i (RMEOptimization'encodeValueNum-2 (+ defNum i), true))
        )
        nil
    )

    #_unused
    (§ defn- #_"void" RMEOptimization'clearValuesOfKindObject-2 [#_"int[]" state, #_"int" defNum]
        (dotimes [#_"int" i (count state)]
            (when (RMEOptimization'isObjectValue-1 (nth state i))
                (aset state i (RMEOptimization'encodeValueNum-2 (+ defNum i), true))
            )
        )
        nil
    )

    ;;;
     ; Returns the index to the state arrays in BlockStates for a specific location.
     ;;
    (§ method- #_"int" RMEOptimization''getStateIdx-2 [#_"RMEOptimization" this, #_"Value" location]
        (condp instance? location
            RegisterValue
                (let [
                    #_"int" n (.number (#_"RegisterValue" .getRegister location))
                ]
                    (if (< n (:numRegs this)) (nth (:eligibleRegs this) n) -1)
                )
            StackSlot
                (let [
                    #_"Integer" i (get (:stackIndices this) (RMEOptimization''getOffset-2 this, location))
                ]
                    (if (some? i) (+ (#_"Integer" .intValue i) (:numRegs this)) -1)
                )
            -1
        )
    )

    ;;;
     ; Encodes a value number + the is-object information to a number to be stored in a state.
     ;;
    (§ defn- #_"int" RMEOptimization'encodeValueNum-2 [#_"int" valueNum, #_"boolean" object?]
        (if object? (- valueNum) valueNum)
    )

    ;;;
     ; Returns true if an encoded value number (which is stored in a state) refers to an object reference.
     ;;
    (§ defn- #_"boolean" RMEOptimization'isObjectValue-1 [#_"int" encodedValueNum]
        (neg? encodedValueNum)
    )

    ;;;
     ; Returns true for a move instruction which is a candidate for elimination.
     ;;
    (§ defn- #_"boolean" RMEOptimization'isEligibleMove-1 [#_"LIRInstruction" op]
        (and (LIRInstruction''isValueMoveOp-1 op)
            ;; Moves with mismatching kinds are not moves, but memory loads/stores!
            (= (#_"Value" .getValueKind (ValueMoveOp''getInput-1 op)) (#_"Value" .getValueKind (MoveOp''getResult-1 op)))
        )
    )
)

;;;
 ; Utilities for working with Static-Single-Assignment LIR form.
 ;
 ; Representation of {@code PHI}s
 ;
 ; There is no explicit {@code PHI} LIRInstruction. Instead, they are implemented
 ; as parallel copy that span across a control-flow edge.
 ;
 ; The variables introduced by {@code PHI}s of a specific merge block
 ; are {@linkplain LabelOp#setIncomingValues attached} to the LabelOp
 ; of the block. The outgoing values from the predecessor are {@link JumpOp#getOutgoingValue input}
 ; to the BlockEndOp of the predecessor. Because there are no critical edges we know
 ; that the BlockEndOp of the predecessor has to be a JumpOp.
 ;
 ; Example:
 ;
 ; B0 -> B1
 ;   ...
 ;   v0|i = ...
 ;   JUMP ~[v0|i, int[0|0x0]] destination: B0 -> B1
 ; ________________________________________________
 ;
 ; B2 -> B1
 ;   ...
 ;   v1|i = ...
 ;   v2|i = ...
 ;   JUMP ~[v1|i, v2|i] destination: B2 -> B1
 ; ________________________________________________
 ;
 ; B1 <- B0,B2
 ;   [v3|i, v4|i] = LABEL
 ;   ...
 ;;
(value-ns SSAUtil
    ;;;
     ; Visits each phi value pair of an edge, i.e. the outgoing value from the predecessor and the
     ; incoming value to the merge block.
     ;;
    (§ defn #_"void" SSAUtil'forEachPhiValuePair-4 [#_"LIR" lir, #_"Block" merge, #_"Block" pred, #_"PhiValueVisitor" visitor]
        (when-not (< (count (:predecessors merge)) 2)
            (let [
                #_"LabelOp" label (SSAUtil'phiIn-2 lir, merge)
                #_"JumpOp" jump (SSAUtil'phiOut-2 lir, pred)
            ]
                (dotimes [#_"int" i (:numbPhis label)]
                    (PhiValueVisitor''visit-3 visitor, (LabelOp''getIncomingValue-2 label, i), (JumpOp''getOutgoingValue-2 jump, i))
                )
            )
        )
        nil
    )

    (§ defn #_"LabelOp" SSAUtil'phiIn-2 [#_"LIR" lir, #_"Block" block]
        (nth (LIR''getLIRforBlock-2 lir, block) 0)
    )

    (§ defn #_"void" SSAUtil'removePhiIn-2 [#_"LIR" lir, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
        ]
            (§ ass! (nth ops 0) (LabelOp''clearIncomingValues-1 (nth ops 0)))
        )
        nil
    )

    (§ defn #_"JumpOp" SSAUtil'phiOut-2 [#_"LIR" lir, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
        ]
            (nth ops (dec (count ops)))
        )
    )

    #_unused
    (§ defn #_"JumpOp" SSAUtil'phiOutOrNull-2 [#_"LIR" lir, #_"Block" block]
        (when (= (count (:successors block)) 1) (SSAUtil'phiOut-2 lir, block))
    )

    (§ defn #_"int" SSAUtil'phiOutIndex-2 [#_"LIR" lir, #_"Block" block]
        (dec (count (LIR''getLIRforBlock-2 lir, block)))
    )

    (§ defn #_"void" SSAUtil'removePhiOut-2 [#_"LIR" lir, #_"Block" block]
        (let [
            #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, block)
        ]
            (§ ass! (nth ops (dec (count ops))) (JumpOp''clearOutgoingValues-1 (nth ops (dec (count ops)))))
        )
        nil
    )

    (§ defn #_"boolean" SSAUtil'isMerge-1 [#_"Block" block]
        (< 1 (count (:predecessors block)))
    )

    (§ defn- #_"int" SSAUtil'indexOfValue-2 [#_"LabelOp" label, #_"Value" value]
        (loop-when [#_"int" i 0] (< i (LabelOp''getIncomingSize-1 label)) => -1
            (if (= (LabelOp''getIncomingValue-2 label, i) value)
                i
                (recur (inc i))
            )
        )
    )

    (§ defn #_"void" SSAUtil'forEachPhiRegisterHint-6 [#_"LIR" lir, #_"Block" block, #_"LabelOp" label, #_"Value" targetValue, #_"OperandMode" mode, #_"ValueConsumer" valueConsumer]
        (when (LabelOp''isPhiIn-1 label)
            (let [
                #_"int" idx (SSAUtil'indexOfValue-2 label, targetValue)
            ]
                (doseq [#_"Block" pred (:predecessors block)]
                    (let [
                        #_"JumpOp" jump (SSAUtil'phiOut-2 lir, pred)
                        #_"Value" sourceValue (JumpOp''getOutgoingValue-2 jump, idx)
                    ]
                        (ValueConsumer''visitValue-5 valueConsumer, jump, sourceValue, nil, nil)
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"int" SSAUtil'numPhiIn-2 [#_"LIR" lir, #_"Block" block]
        (if (SSAUtil'isMerge-1 block)
            (:numbPhis (SSAUtil'phiIn-2 lir, block))
            0
        )
    )

    #_unused
    (§ defn #_"int" SSAUtil'numPhiOut-2 [#_"LIR" lir, #_"Block" block]
        (if (= (count (:successors block)) 1)
            (SSAUtil'numPhiIn-2 lir, (nth (:successors block) 0))
            ;; cannot be a phi_out block
            0
        )
    )
)

;;;
 ; @anno SSAUtil.PhiValueVisitor
 ;;
(§ interface PhiValueVisitor
    ;;;
     ; @param phiIn the incoming value at the merge block
     ; @param phiOut the outgoing value from the predecessor block
     ;;
    (§ abstract #_"void" PhiValueVisitor''visit-3 [#_"PhiValueVisitor" this, #_"Value" phiIn, #_"Value" phiOut])
)

;;;
 ; Calculates the stack intervals using a worklist-based backwards data-flow analysis.
 ;;
(final-ns FixPointIntervalBuilder
    (§ final #_"LIR" :lir nil)
    (§ final #_"StackInterval[]" :stackSlotMap nil)
    (§ final #_"int" :maxOpId 0)
    (§ final #_"BlockMap<BitSet>" :liveInMap nil)
    (§ final #_"BlockMap<BitSet>" :liveOutMap nil)
    (§ final #_"EconomicSet<LIRInstruction>" :usePos (EconomicSet/create Equivalence/IDENTITY))

    (§ defn #_"FixPointIntervalBuilder" FixPointIntervalBuilder'new-3 [#_"LIR" lir, #_"StackInterval[]" stackSlotMap, #_"int" maxOpId]
        (let [
            #_"FixPointIntervalBuilder" this (Object.)
            this (assoc this :lir lir)
            this (assoc this :stackSlotMap stackSlotMap)
            this (assoc this :maxOpId maxOpId)
            this (assoc this :liveInMap (BlockMap'new-1 (:cfg lir)))
            this (assoc this :liveOutMap (BlockMap'new-1 (:cfg lir)))
        ]
            this
        )
    )

    ;;;
     ; Builds the lifetime intervals for {@link VirtualStackSlot virtual stack slots}, sets up #stackSlotMap
     ; and returns a set of use positions, i.e. instructions that contain virtual stack slots.
     ;;
    (§ method! #_"EconomicSet<LIRInstruction>" FixPointIntervalBuilder''build-1 [#_"FixPointIntervalBuilder" this]
        (let [
            #_"Deque<Block>" worklist (ArrayDeque.)
            #_"Block[]" blocks (:reversePostOrder (:cfg (:lir this)))
        ]
            (loop-when-recur [#_"int" i (dec (count blocks))] (<= 0 i) [(dec i)]
                (#_"Deque" .add worklist, (nth blocks i))
            )
            (doseq [#_"Block" block (:reversePostOrder (:cfg (:lir this)))]
                (BlockMap''put-3 (:liveInMap this), block, (BitSet. (count (:stackSlotMap this))))
            )
            (while (seq worklist)
                (FixPointIntervalBuilder''processBlock-3 this, (#_"Deque" .poll worklist), worklist)
            )
            (:usePos this)
        )
    )

    ;;;
     ; Merge outSet with in-set of successors.
     ;;
    (§ method- #_"boolean" FixPointIntervalBuilder''updateOutBlock-2 [#_"FixPointIntervalBuilder" this, #_"Block" block]
        (let [
            #_"BitSet" union (BitSet. (count (:stackSlotMap this)))
        ]
            (doseq [#_"Block" succ (:successors block)]
                (#_"BitSet" .or union, (BlockMap''get-2 (:liveInMap this), succ))
            )
            (let [
                #_"BitSet" outSet (BlockMap''get-2 (:liveOutMap this), block)
            ]
                ;; check if changed
                (when-not (and (some? outSet) (= union outSet)) => false
                    (BlockMap''put-3 (:liveOutMap this), block, union)
                    true
                )
            )
        )
    )

    (§ method- #_"void" FixPointIntervalBuilder''processBlock-3 [#_"FixPointIntervalBuilder" this, #_"Block" block, #_"Deque<Block>" worklist]
        (when (FixPointIntervalBuilder''updateOutBlock-2 this, block)
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 (:lir this), block)
                ;; get out set and mark intervals
                #_"BitSet" outSet (BlockMap''get-2 (:liveOutMap this), block)
            ]
                (FixPointIntervalBuilder''markOutInterval-3 this, outSet, (FixPointIntervalBuilder'getBlockEnd-1 ops))

                ;; process instructions
                (let [
                    #_"BlockClosure" closure (BlockClosure'new-2 this, (#_"Object" .clone outSet))
                ]
                    (loop-when-recur [#_"int" i (dec (count ops))] (<= 0 i) [(dec i)]
                        (BlockClosure''processInstructionBottomUp-2 closure, (nth ops i))
                    )

                    ;; add predecessors to work list
                    (doseq [#_"Block" b (:predecessors block)]
                        (#_"Deque" .add worklist, b)
                    )
                    ;; set in set and mark intervals
                    (let [
                        #_"BitSet" inSet (:currentSet closure)
                    ]
                        (BlockMap''put-3 (:liveInMap this), block, inSet)
                        (FixPointIntervalBuilder''markInInterval-3 this, inSet, (FixPointIntervalBuilder'getBlockBegin-1 ops))
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" FixPointIntervalBuilder''markOutInterval-3 [#_"FixPointIntervalBuilder" this, #_"BitSet" outSet, #_"int" blockEndOpId]
        (loop-when-recur [#_"int" i (#_"BitSet" .nextSetBit outSet, 0)] (<= 0 i) [(#_"BitSet" .nextSetBit outSet, (inc i))]
            (§ ass! (FixPointIntervalBuilder''getIntervalFromStackId-2 this, i) (StackInterval''addTo-2 (FixPointIntervalBuilder''getIntervalFromStackId-2 this, i), blockEndOpId))
        )
        nil
    )

    (§ method- #_"void" FixPointIntervalBuilder''markInInterval-3 [#_"FixPointIntervalBuilder" this, #_"BitSet" inSet, #_"int" blockFirstOpId]
        (loop-when-recur [#_"int" i (#_"BitSet" .nextSetBit inSet, 0)] (<= 0 i) [(#_"BitSet" .nextSetBit inSet, (inc i))]
            (§ ass! (FixPointIntervalBuilder''getIntervalFromStackId-2 this, i) (StackInterval''addFrom-2 (FixPointIntervalBuilder''getIntervalFromStackId-2 this, i), blockFirstOpId))
        )
        nil
    )

    (§ method- #_"StackInterval" FixPointIntervalBuilder''get-2 [#_"FixPointIntervalBuilder" this, #_"VirtualStackSlot" stackSlot]
        (nth (:stackSlotMap this) (:id stackSlot))
    )

    (§ method- #_"void" FixPointIntervalBuilder''put-3 [#_"FixPointIntervalBuilder" this, #_"VirtualStackSlot" stackSlot, #_"StackInterval" interval]
        (aset (:stackSlotMap this) (:id stackSlot) interval)
        nil
    )

    (§ method- #_"StackInterval" FixPointIntervalBuilder''getOrCreateInterval-2 [#_"FixPointIntervalBuilder" this, #_"VirtualStackSlot" stackSlot]
        (let [
            #_"StackInterval" interval (FixPointIntervalBuilder''get-2 this, stackSlot)
        ]
            (when (nil? interval)
                (§ ass interval (StackInterval'new-2 stackSlot, (#_"Value" .getValueKind stackSlot)))
                (FixPointIntervalBuilder''put-3 this, stackSlot, interval)
            )
            interval
        )
    )

    (§ method- #_"StackInterval" FixPointIntervalBuilder''getIntervalFromStackId-2 [#_"FixPointIntervalBuilder" this, #_"int" id]
        (nth (:stackSlotMap this) id)
    )

    (§ defn- #_"int" FixPointIntervalBuilder'getBlockBegin-1 [#_"List<LIRInstruction>" ops]
        (LIRInstruction''id-1 (nth ops 0))
    )

    (§ defn- #_"int" FixPointIntervalBuilder'getBlockEnd-1 [#_"List<LIRInstruction>" ops]
        (inc (LIRInstruction''id-1 (nth ops (dec (count ops)))))
    )
)

;;;
 ; @anno FixPointIntervalBuilder.BlockClosure
 ;;
(final-ns BlockClosure
    (§ final #_"FixPointIntervalBuilder" :builder nil)

    (§ final #_"BitSet" :currentSet nil)

    (§ mutable #_"InstructionValueConsumer" :defConsumer nil)
    (§ mutable #_"InstructionValueConsumer" :useConsumer nil)

    (§ defn- #_"BlockClosure" BlockClosure'new-2 [#_"FixPointIntervalBuilder" builder, #_"BitSet" set]
        (let [
            #_"BlockClosure" this (Object.)
            this (assoc this :builder builder)
            this (assoc this :currentSet set)
            #_"BlockClosure" closure this
            this
                (assoc this :defConsumer
                    (§ reify #_"InstructionValueConsumer" (InstructionValueConsumer'reify-0)
                        (§ override! #_"void" InstructionValueConsumer''visitValue-5 [#_"InstructionValueConsumer" this, #_"LIRInstruction" op, #_"Value" operand, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags]
                            (when (instance? VirtualStackSlot operand)
                                (BlockClosure''addDef-3 closure, operand, op)
                                (BlockClosure''addRegisterHint-6 closure, op, operand, mode, flags, true)
                                (#_"EconomicSet" .add (:usePos (:builder closure)), op)
                                (#_"BitSet" .clear set, (:id operand))
                            )
                            nil
                        )
                    )
                )
            this
                (assoc this :useConsumer
                    (§ reify #_"InstructionValueConsumer" (InstructionValueConsumer'reify-0)
                        (§ override! #_"void" InstructionValueConsumer''visitValue-5 [#_"InstructionValueConsumer" this, #_"LIRInstruction" op, #_"Value" operand, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags]
                            (when (instance? VirtualStackSlot operand)
                                (BlockClosure''addUse-4 closure, operand, op, flags)
                                (BlockClosure''addRegisterHint-6 closure, op, operand, mode, flags, false)
                                (#_"EconomicSet" .add (:usePos (:builder closure)), op)
                                (#_"BitSet" .set set, (:id operand))
                            )
                            nil
                        )
                    )
                )
        ]
            this
        )
    )

    ;;;
     ; Process all values of an instruction bottom-up, i.e. definitions before usages.
     ; Values that start or end at the current operation are not included.
     ;;
    (§ method- #_"void" BlockClosure''processInstructionBottomUp-2 [#_"BlockClosure" this, #_"LIRInstruction" op]
        (LIRInstruction''visitEachTemp-2 op, (:defConsumer this))
        (LIRInstruction''visitEachOutput-2 op, (:defConsumer this))

        (LIRInstruction''visitEachAlive-2 op, (:useConsumer this))
        (LIRInstruction''visitEachInput-2 op, (:useConsumer this))
        nil
    )

    (§ method- #_"void" BlockClosure''addUse-4 [#_"BlockClosure" this, #_"VirtualStackSlot" stackSlot, #_"LIRInstruction" op, #_"EnumSet<OperandFlag>" flags]
        (let [
            #_"StackInterval" interval (FixPointIntervalBuilder''getOrCreateInterval-2 (:builder this), stackSlot)
        ]
            (if (#_"EnumSet" .contains flags, OperandFlag'UNINITIALIZED)
                (do
                    ;; Stack slot is marked uninitialized so we have to assume it is live all the time.
                    (§ ass! interval (StackInterval''addFrom-2 interval, 0))
                    (§ ass! interval (StackInterval''addTo-2 interval, (:maxOpId (:builder this))))
                )
                (§ ass! interval (StackInterval''addTo-2 interval, (LIRInstruction''id-1 op)))
            )
        )
        nil
    )

    (§ method- #_"void" BlockClosure''addDef-3 [#_"BlockClosure" this, #_"VirtualStackSlot" stackSlot, #_"LIRInstruction" op]
        (§ ass! (FixPointIntervalBuilder''getOrCreateInterval-2 (:builder this), stackSlot) (StackInterval''addFrom-2 (FixPointIntervalBuilder''getOrCreateInterval-2 (:builder this), stackSlot), (LIRInstruction''id-1 op)))
        nil
    )

    (§ method! #_"void" BlockClosure''addRegisterHint-6 [#_"BlockClosure" this, #_"LIRInstruction" op, #_"VirtualStackSlot" targetValue, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags, #_"boolean" hintAtDef]
        (when (#_"EnumSet" .contains flags, OperandFlag'HINT)
            (let [
                #_"FixPointIntervalBuilder" builder (:builder this)
                #_"InstructionValueProcedure" proc
                    (§ reify #_"InstructionValueProcedure" (InstructionValueProcedure'reify-0)
                        (§ override! #_"Value" InstructionValueProcedure''doValue-5 [#_"InstructionValueProcedure" this, #_"LIRInstruction" instruction, #_"Value" registerHint, #_"OperandMode" vaueMode, #_"EnumSet<OperandFlag>" valueFlags]
                            (when (instance? VirtualStackSlot registerHint)
                                (let [
                                    #_"StackInterval" from (FixPointIntervalBuilder''getOrCreateInterval-2 builder, registerHint)
                                    #_"StackInterval" to (FixPointIntervalBuilder''getOrCreateInterval-2 builder, targetValue)
                                ]
                                    ;; hints always point from def to use
                                    (if hintAtDef
                                        (§ ass! to (StackInterval''setLocationHint-2 to, from))
                                        (§ ass! from (StackInterval''setLocationHint-2 from, to))
                                    )

                                    registerHint
                                )
                            )
                        )
                    )
            ]
                (LIRInstruction''forEachRegisterHint-4 op, targetValue, mode, proc)
            )
        )
        nil
    )
)

;;;
 ; Linear Scan stack slot allocator.
 ;
 ; Remark: The analysis works under the assumption that a stack slot is no longer live after its last usage.
 ; If an {@link LIRInstruction instruction} transfers the raw address of the stack slot to another location,
 ; e.g. a registers, and this location is referenced later on, the {@link Use usage} of the
 ; stack slot must be marked with the OperandFlag#UNINITIALIZED. Otherwise the stack
 ; slot might be reused and its content destroyed.
 ;;
(final-ns LSStackSlotAllocator (§ extends AllocationPhase)
    (§ defn #_"LSStackSlotAllocator" LSStackSlotAllocator'new-0 []
        (AllocationPhase'new-0)
    )

    (§ defn- #_"void" LSStackSlotAllocator'allocateStackSlots-2 [#_"FrameMapBuilderTool" builder, #_"LIRGenerationResult" res]
        (when (pos? (FrameMapBuilderTool''getNumberOfStackSlots-1 builder))
            (Allocator''allocate-1 (Allocator'new-2 (:lir res), builder))
        )
        nil
    )

    #_unused
    (§ override! #_"void" LSStackSlotAllocator''run-3 [#_"LSStackSlotAllocator" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context]
        (LSStackSlotAllocator'allocateStackSlots-2 (:frameMapBuilder lirGenRes), lirGenRes)
        (§ ass! lirGenRes (LIRGenerationResult''buildFrameMap-1 lirGenRes))
        nil
    )
)

;;;
 ; @anno LSStackSlotAllocator.Allocator
 ;;
(final-ns Allocator
    (§ final #_"LIR" :lir nil)
    (§ final #_"FrameMapBuilderTool" :frameMapBuilder nil)
    (§ final #_"StackInterval[]" :stackSlotMap nil)
    (§ final #_"PriorityQueue<StackInterval>" :unhandled nil)
    (§ final #_"PriorityQueue<StackInterval>" :active nil)
    (§ final #_"Block[]" :sortedBlocks nil)
    ;;;
     ; Highest instruction id.
     ;;
    (§ final #_"int" :maxOpId 0)

    (§ defn- #_"Allocator" Allocator'new-2 [#_"LIR" lir, #_"FrameMapBuilderTool" frameMapBuilder]
        (let [
            #_"Allocator" this (Object.)
            this (assoc this :lir lir)
            this (assoc this :frameMapBuilder frameMapBuilder)
            this (assoc this :stackSlotMap (make-array StackInterval (FrameMapBuilderTool''getNumberOfStackSlots-1 frameMapBuilder)))
            this (assoc this :sortedBlocks (:reversePostOrder (:cfg lir)))
            ;; insert by from
            this (assoc this :unhandled (PriorityQueue. (ß (a, b) -> (§ fun (- (:from a) (:from b))))))
            ;; insert by to
            this (assoc this :active (PriorityQueue. (ß (a, b) -> (§ fun (- (:to a) (:to b))))))
            ;; step 1: number instructions
            this (assoc this :maxOpId (Allocator'numberInstructions-2 lir, (:sortedBlocks this)))
        ]
            this
        )
    )

    (§ method- #_"void" Allocator''allocate-1 [#_"Allocator" this]
        ;; step 2: build intervals
        (let [
            #_"EconomicSet<LIRInstruction>" usePos (Allocator''buildIntervals-1 this)
        ]
            ;; step 3: verify intervals
            ;; step 4: allocate stack slots
            (Allocator''allocateStackSlots-1 this)
            ;; step 5: assign stack slots
            (Allocator''assignStackSlots-2 this, usePos)
        )
        nil
    )

    ;; ====================
    ;; step 1: number instructions
    ;; ====================

    ;;;
     ; Numbers all instructions in all blocks.
     ;
     ; @return the id of the last operation
     ;;
    (§ defn- #_"int" Allocator'numberInstructions-2 [#_"LIR" lir, #_"Block[]" sortedBlocks]
        (loop-when [#_"int" opId 0 #_"ISeq" s (seq sortedBlocks)] (some? s) => (- opId 2)
            (let [
                #_"List<LIRInstruction>" ops (LIR''getLIRforBlock-2 lir, (first s))
                opId
                    (loop-when [opId opId #_"int" i 0] (< i (count ops)) => opId
                        (§ ass! (nth ops i) (LIRInstruction''setId-2 (nth ops i), opId))
                        ;; numbering of lirOps by two
                        (recur (+ opId 2) (inc i))
                    )
            ]
                (recur opId (next s))
            )
        )
    )

    ;; ====================
    ;; step 2: build intervals
    ;; ====================

    (§ method- #_"EconomicSet<LIRInstruction>" Allocator''buildIntervals-1 [#_"Allocator" this]
        (FixPointIntervalBuilder''build-1 (FixPointIntervalBuilder'new-3 (:lir this), (:stackSlotMap this), (:maxOpId this)))
    )

    ;; ====================
    ;; step 3: verify intervals
    ;; ====================

    ;; ====================
    ;; step 4: allocate stack slots
    ;; ====================

    (§ method- #_"void" Allocator''allocateStackSlots-1 [#_"Allocator" this]
        ;; create unhandled lists
        (doseq [#_"StackInterval" interval (:stackSlotMap this)]
            (when (some? interval)
                (#_"PriorityQueue" .add (:unhandled this), interval)
            )
        )

        (loop-when-recur [#_"StackInterval" current (Allocator''activateNext-1 this)] (some? current) [(Allocator''activateNext-1 this)]
            (Allocator''allocateSlot-2 this, current)
        )
        nil
    )

    (§ method- #_"void" Allocator''allocateSlot-2 [#_"Allocator" this, #_"StackInterval" current]
        (let [
            #_"VirtualStackSlot" virtualSlot (:operand current)
            #_"StackSlot" location
                (if (instance? VirtualStackSlotRange virtualSlot)
                    ;; No reuse of ranges (yet).
                    (let [
                        #_"VirtualStackSlotRange" slotRange virtualSlot
                    ]
                        (FrameMap''allocateStackSlots-3 (FrameMapBuilderTool''getFrameMap-1 (:frameMapBuilder this)), (:slots slotRange), (VirtualStackSlotRange''getObjects-1 slotRange))
                    )
                    (let [
                        #_"StackSlot" slot (Allocator''findFreeSlot-2 this, virtualSlot)
                    ]
                        (if (some? slot)
                            ;; Free stack slot available. Note that we create a new one because the kind might not match.
                            (StackSlot/get (:kind current), (#_"StackSlot" .getRawOffset slot), (#_"StackSlot" .getRawAddFrameSize slot))
                            ;; Allocate new stack slot.
                            (FrameMap''allocateSpillSlot-2 (FrameMapBuilderTool''getFrameMap-1 (:frameMapBuilder this)), (#_"Value" .getValueKind virtualSlot))
                        )
                    )
                )
        ]
            (§ ass! current (StackInterval''setLocation-2 current, location))
        )
        nil
    )

    (§ method- #_"SlotSize" Allocator''forKind-2 [#_"Allocator" this, #_"ValueKind" kind]
        (case (FrameMap''spillSlotSize-2 (FrameMapBuilderTool''getFrameMap-1 (:frameMapBuilder this)), kind)
            1 SlotSize'Size1
            2 SlotSize'Size2
            4 SlotSize'Size4
            8 SlotSize'Size8
              SlotSize'Illegal
        )
    )

    (§ mutable #_"EnumMap<SlotSize, Deque<StackSlot>>" :freeSlots nil)

    ;;;
     ; @return the list of free stack slots for {@code size} or nil if there is none
     ;;
    (§ method- #_"Deque<StackSlot>" Allocator''getOrNullFreeSlots-2 [#_"Allocator" this, #_"SlotSize" size]
        (when (some? (:freeSlots this))
            (get (:freeSlots this) size)
        )
    )

    ;;;
     ; @return the list of free stack slots for {@code size}. If there is none a list is created
     ;;
    (§ method- #_"Deque<StackSlot>" Allocator''getOrInitFreeSlots-2 [#_"Allocator" this, #_"SlotSize" size]
        (let [
            #_"Deque<StackSlot>" freeList
                (if (some? (:freeSlots this))
                    (get (:freeSlots this) size)
                    (do
                        (§ ass! this (assoc this :freeSlots (EnumMap. SlotSize)))
                        nil
                    )
                )
        ]
            (or freeList
                (let [
                    freeList (ArrayDeque.)
                ]
                    (#_"EnumMap" .put (:freeSlots this), size, freeList)
                    freeList
                )
            )
        )
    )

    ;;;
     ; Gets a free stack slot for {@code slot} or nil if there is none.
     ;;
    (§ method- #_"StackSlot" Allocator''findFreeSlot-2 [#_"Allocator" this, #_"SimpleVirtualStackSlot" slot]
        (let [
            #_"SlotSize" size (Allocator''forKind-2 this, (#_"Value" .getValueKind slot))
        ]
            (when-not (= size SlotSize'Illegal)
                (let [
                    #_"Deque<StackSlot>" freeList (Allocator''getOrNullFreeSlots-2 this, size)
                ]
                    (when (some? freeList)
                        (#_"Deque" .pollLast freeList)
                    )
                )
            )
        )
    )

    ;;;
     ; Adds a stack slot to the list of free slots.
     ;;
    (§ method- #_"void" Allocator''freeSlot-2 [#_"Allocator" this, #_"StackSlot" slot]
        (let [
            #_"SlotSize" size (Allocator''forKind-2 this, (#_"StackSlot" .getValueKind slot))
        ]
            (when-not (= size SlotSize'Illegal)
                (#_"Deque" .addLast (Allocator''getOrInitFreeSlots-2 this, size), slot)
            )
        )
        nil
    )

    ;;;
     ; Gets the next unhandled interval and finishes handled intervals.
     ;;
    (§ method- #_"StackInterval" Allocator''activateNext-1 [#_"Allocator" this]
        (when (seq (:unhandled this))
            (let [
                #_"StackInterval" next (#_"PriorityQueue" .poll (:unhandled this))
            ]
                ;; finish handled intervals
                (loop-when-recur [#_"int" id (:from next)] (< (Allocator''activePeekId-1 this) id) [id]
                    (Allocator''finished-2 this, (#_"PriorityQueue" .poll (:active this)))
                )
                (#_"PriorityQueue" .add (:active this), next)
                next
            )
        )
    )

    ;;;
     ; Gets the lowest {@link StackInterval#to() end position} of all active intervals.
     ; If there is none Integer#MAX_VALUE is returned.
     ;;
    (§ method- #_"int" Allocator''activePeekId-1 [#_"Allocator" this]
        (let [
            #_"StackInterval" interval (#_"PriorityQueue" .peek (:active this))
        ]
            (if (some? interval) (:to interval) Integer/MAX_VALUE)
        )
    )

    ;;;
     ; Finishes {@code interval} by adding its location to the list of free stack slots.
     ;;
    (§ method- #_"void" Allocator''finished-2 [#_"Allocator" this, #_"StackInterval" interval]
        (Allocator''freeSlot-2 this, (:location interval))
        nil
    )

    ;; ====================
    ;; step 5: assign stack slots
    ;; ====================

    (§ method- #_"void" Allocator''assignStackSlots-2 [#_"Allocator" this, #_"EconomicSet<LIRInstruction>" usePos]
        (let [
            #_"Allocator" allocator this
            #_"ValueProcedure" assignSlot
                (§ reify #_"ValueProcedure" (ValueProcedure'reify-0)
                    (§ override! #_"Value" ValueProcedure''doValue-4 [#_"ValueProcedure" this, #_"Value" value, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags]
                        (when (instance? VirtualStackSlot value) => value
                            (:location (Allocator''get-2 allocator, value))
                        )
                    )
                )
        ]
            (doseq [#_"LIRInstruction" op usePos]
                (LIRInstruction''forEachInput-2 op, assignSlot)
                (LIRInstruction''forEachAlive-2 op, assignSlot)
                (LIRInstruction''forEachTemp-2 op, assignSlot)
                (LIRInstruction''forEachOutput-2 op, assignSlot)
            )
        )
        nil
    )

    (§ method- #_"StackInterval" Allocator''get-2 [#_"Allocator" this, #_"VirtualStackSlot" stackSlot]
        (nth (:stackSlotMap this) (:id stackSlot))
    )
)

;;;
 ; @anno LSStackSlotAllocator.Allocator.SlotSize
 ;;
(value-ns SlotSize
    (§ enum SlotSize'Size1)
    (§ enum SlotSize'Size2)
    (§ enum SlotSize'Size4)
    (§ enum SlotSize'Size8)
    (§ enum SlotSize'Illegal)
)

(final-ns SimpleStackSlotAllocator (§ extends AllocationPhase)
    (§ defn #_"SimpleStackSlotAllocator" SimpleStackSlotAllocator'new-0 []
        (AllocationPhase'new-0)
    )

    (§ defn- #_"StackSlot" SimpleStackSlotAllocator'mapSimpleVirtualStackSlot-2 [#_"FrameMapBuilderTool" builder, #_"SimpleVirtualStackSlot" virtualStackSlot]
        (FrameMap''allocateSpillSlot-2 (FrameMapBuilderTool''getFrameMap-1 builder), (#_"Value" .getValueKind virtualStackSlot))
    )

    (§ defn- #_"StackSlot" SimpleStackSlotAllocator'mapVirtualStackSlotRange-2 [#_"FrameMapBuilderTool" builder, #_"VirtualStackSlotRange" virtualStackSlot]
        (FrameMap''allocateStackSlots-3 (FrameMapBuilderTool''getFrameMap-1 builder), (:slots virtualStackSlot), (VirtualStackSlotRange''getObjects-1 virtualStackSlot))
    )

    (§ method! #_"void" SimpleStackSlotAllocator''updateLIR-3 [#_"SimpleStackSlotAllocator" this, #_"LIRGenerationResult" res, #_"StackSlot[]" mapping]
        (let [
            #_"ValueProcedure" updateProc (ß (value, mode, flags) ->
                (§ fun
                    (when (instance? VirtualStackSlot value) => value
                        (nth mapping (:id value))
                    )
                )
            )
        ]
            (doseq [#_"Block" block (:reversePostOrder (:cfg (:lir res)))]
                (doseq [#_"LIRInstruction" op (LIR''getLIRforBlock-2 (:lir res), block)]
                    (LIRInstruction''forEachAlive-2 op, updateProc)
                    (LIRInstruction''forEachInput-2 op, updateProc)
                    (LIRInstruction''forEachOutput-2 op, updateProc)
                    (LIRInstruction''forEachTemp-2 op, updateProc)
                )
            )
        )
        nil
    )

    (§ method! #_"void" SimpleStackSlotAllocator''allocateStackSlots-3 [#_"SimpleStackSlotAllocator" this, #_"FrameMapBuilderTool" builder, #_"LIRGenerationResult" res]
        (let [
            #_"StackSlot[]" mapping (make-array StackSlot (FrameMapBuilderTool''getNumberOfStackSlots-1 builder))
        ]
            (doseq [#_"VirtualStackSlot" virtualSlot (FrameMapBuilderTool''getStackSlots-1 builder)]
                (let [
                    #_"StackSlot" slot
                        (condp instance? virtualSlot
                            SimpleVirtualStackSlot (SimpleStackSlotAllocator'mapSimpleVirtualStackSlot-2 builder, virtualSlot)
                            VirtualStackSlotRange (SimpleStackSlotAllocator'mapVirtualStackSlotRange-2 builder, virtualSlot)
                        )
                ]
                    (aset mapping (:id virtualSlot) slot)
                )
            )
            (SimpleStackSlotAllocator''updateLIR-3 this, res, mapping)
        )
        nil
    )

    #_unused
    (§ override! #_"void" SimpleStackSlotAllocator''run-3 [#_"SimpleStackSlotAllocator" this, #_"LIRGenerationResult" lirGenRes, #_"AllocationContext" context]
        (SimpleStackSlotAllocator''allocateStackSlots-3 this, (:frameMapBuilder lirGenRes), lirGenRes)
        (§ ass! lirGenRes (LIRGenerationResult''buildFrameMap-1 lirGenRes))
        nil
    )
)

(final-ns StackInterval
    (§ def- #_"int" StackInterval'INVALID_START Integer/MAX_VALUE)
    (§ def- #_"int" StackInterval'INVALID_END Integer/MIN_VALUE)

    (§ final #_"VirtualStackSlot" :operand nil)
    (§ mutable #_"StackInterval" :hint nil)
    (§ final #_"ValueKind" :kind nil)
    (§ mutable #_"int" :from StackInterval'INVALID_START)
    (§ mutable #_"int" :to StackInterval'INVALID_END)
    (§ mutable #_"StackSlot" :location nil)

    (§ defn #_"StackInterval" StackInterval'new-2 [#_"VirtualStackSlot" operand, #_"ValueKind" kind]
        (let [
            #_"StackInterval" this (Object.)
            this (assoc this :operand operand)
            this (assoc this :kind kind)
        ]
            this
        )
    )

    (§ method! #_"StackInterval" StackInterval''addTo-2 [#_"StackInterval" this, #_"int" opId]
        (when (<= (:to this) opId) => this
            (assoc this :to opId)
        )
    )

    (§ method! #_"StackInterval" StackInterval''addFrom-2 [#_"StackInterval" this, #_"int" opId]
        (when (< opId (:from this)) => this
            (let [
                this (assoc this :from opId)
            ]
                ;; set opId also as to if it has not yet been set
                (when (= (:to this) StackInterval'INVALID_END) => this
                    (assoc this :to opId)
                )
            )
        )
    )

    (§ method! #_"StackInterval" StackInterval''setLocation-2 [#_"StackInterval" this, #_"StackSlot" location]
        (assoc this :location location)
    )

    #_unused
    (§ method! #_"StackInterval" StackInterval''fixFrom-1 [#_"StackInterval" this]
        (when (= (:from this) StackInterval'INVALID_START) => this
            (assoc this :from 0)
        )
    )

    #_unused
    (§ method! #_"boolean" StackInterval''isFixed-1 [#_"StackInterval" this]
        (zero? (:from this))
    )

    (§ method! #_"StackInterval" StackInterval''setLocationHint-2 [#_"StackInterval" this, #_"StackInterval" locationHint]
        (assoc this :hint locationHint)
    )
)

;;;
 ; A collection of machine-independent LIR operations, as well as interfaces to be implemented
 ; for specific kinds or LIR operations.
 ;;
(value-ns StandardOp
)

;;;
 ; A block delimiter. Every well formed block must contain exactly one such operation and it
 ; must be the last operation in the block.
 ;
 ; @anno StandardOp.BlockEndOp
 ;;
(§ interface BlockEndOp
)

;;;
 ; @anno StandardOp.NullCheck
 ;;
(§ interface NullCheck
    (§ abstract #_"Value" NullCheck''getCheckedValue-1 [#_"NullCheck" this])
)

;;;
 ; @anno StandardOp.ImplicitNullCheck
 ;;
(§ interface ImplicitNullCheck
    (§ abstract #_"boolean" ImplicitNullCheck''makeNullCheckFor-3 [#_"ImplicitNullCheck" this, #_"Value" value, #_"int" implicitNullCheckLimit])
)

;;;
 ; LIR operation that defines the position of a label.
 ;
 ; @anno StandardOp.LabelOp
 ;;
(final-ns LabelOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<LabelOp>" LabelOp'TYPE (LIRInstructionClass'new-1 LabelOp))

    (§ def #_"EnumSet<OperandFlag>" LabelOp'incomingFlags (EnumSet/of OperandFlag'REG, OperandFlag'STACK))

    ;;;
     ; In the LIR, every register and variable must be defined before it is used. For method
     ; parameters that are passed in fixed registers, exception objects passed to the exception
     ; handler in a fixed register, or any other use of a fixed register not defined in this
     ; method, an artificial definition is necessary. To avoid spill moves to be inserted
     ; between the label at the beginning of a block an an actual definition in the second
     ; instruction of a block, the registers are defined here in the label.
     ;;
    ; @Def({OperandFlag'REG, OperandFlag'STACK})
    (§ mutable #_"Value[]" :incomingValues nil)
    (§ final #_"Label" :label nil)
    (§ final #_"boolean" :aligned? false)
    (§ mutable #_"int" :numbPhis 0)

    (§ defn #_"LabelOp" LabelOp'new-2 [#_"Label" label, #_"boolean" aligned?]
        (let [
            #_"LabelOp" this (LIRInstruction'new-1 LabelOp'TYPE)
            this (assoc this :label label)
            this (assoc this :aligned? aligned?)
            this (assoc this :incomingValues Value/NO_VALUES)
            this (assoc this :numbPhis 0)
        ]
            this
        )
    )

    (§ method! #_"LabelOp" LabelOp''setPhiValues-2 [#_"LabelOp" this, #_"Value[]" values]
        (let [
            this (LabelOp''setIncomingValues-2 this, values)
            this (LabelOp''setNumberOfPhis-2 this, (count values))
        ]
            this
        )
    )

    (§ method- #_"LabelOp" LabelOp''setNumberOfPhis-2 [#_"LabelOp" this, #_"int" numPhis]
        (assoc this :numbPhis numPhis)
    )

    (§ method! #_"LabelOp" LabelOp''setIncomingValues-2 [#_"LabelOp" this, #_"Value[]" values]
        (assoc this :incomingValues values)
    )

    (§ method! #_"int" LabelOp''getIncomingSize-1 [#_"LabelOp" this]
        (count (:incomingValues this))
    )

    (§ method! #_"Value" LabelOp''getIncomingValue-2 [#_"LabelOp" this, #_"int" idx]
        (nth (:incomingValues this) idx)
    )

    (§ method! #_"LabelOp" LabelOp''clearIncomingValues-1 [#_"LabelOp" this]
        (assoc this :incomingValues Value/NO_VALUES)
    )

    (§ method! #_"LabelOp" LabelOp''addIncomingValues-2 [#_"LabelOp" this, #_"Value[]" values]
        (when (seq (:incomingValues this)) => (§ ass! this (LabelOp''setIncomingValues-2 this, values)) => this
            (let [
                #_"Value[]" a (make-array Value (+ (count (:incomingValues this)) (count values)))
            ]
                (System/arraycopy (:incomingValues this), 0, a, 0, (count (:incomingValues this)))
                (System/arraycopy values, 0, a, (count (:incomingValues this)), (count values))
                (assoc this :incomingValues a)
            )
        )
    )

    #_unused
    (§ method- #_"boolean" LabelOp''checkRange-2 [#_"LabelOp" this, #_"int" idx]
        (< idx (count (:incomingValues this)))
    )

    #_unused
    (§ override! #_"void" LabelOp''emitCode-2 [#_"LabelOp" this, #_"Assembler" asm]
        (when (:aligned? this)
            (Assembler''align-2 asm, (* (.wordSize HotSpot'target) 2))
        )
        (Assembler''bind-2 asm, (:label this))
        nil
    )

    ;;;
     ; @return true if this label acts as a PhiIn
     ;;
    (§ method! #_"boolean" LabelOp''isPhiIn-1 [#_"LabelOp" this]
        (pos? (:numbPhis this))
    )

    #_unused
    (§ method! #_"void" LabelOp''forEachIncomingValue-2 [#_"LabelOp" this, #_"InstructionValueProcedure" proc]
        (dotimes [#_"int" i (count (:incomingValues this))]
            (aset (:incomingValues this) i (InstructionValueProcedure''doValue-5 proc, this, (nth (:incomingValues this) i), OperandMode'DEF, LabelOp'incomingFlags))
        )
        nil
    )
)

;;;
 ; LIR operation that is an unconditional jump to a #destination().
 ;
 ; @anno StandardOp.JumpOp
 ;;
(final-ns JumpOp (§ extends LIRInstruction) (§ implements BlockEndOp)
    (§ def #_"LIRInstructionClass<JumpOp>" JumpOp'TYPE (LIRInstructionClass'new-1 JumpOp))

    (§ def #_"EnumSet<OperandFlag>" JumpOp'outgoingFlags (EnumSet/of OperandFlag'REG, OperandFlag'STACK, OperandFlag'CONST, OperandFlag'OUTGOING))

    ; @Alive({OperandFlag'REG, OperandFlag'STACK, OperandFlag'CONST, OperandFlag'OUTGOING})
    (§ mutable #_"Value[]" :outgoingValues nil)

    (§ final #_"LabelRef" :destination nil)

    (§ defn #_"JumpOp" JumpOp'new-1 [#_"LabelRef" destination]
        (JumpOp'new-2 JumpOp'TYPE, destination)
    )

    (§ defn #_"JumpOp" JumpOp'new-2 [#_"LIRInstructionClass<? extends JumpOp>" c, #_"LabelRef" destination]
        (let [
            #_"JumpOp" this (LIRInstruction'new-1 c)
            this (assoc this :destination destination)
            this (assoc this :outgoingValues Value/NO_VALUES)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" JumpOp''emitCode-2 [#_"JumpOp" this, #_"Assembler" asm]
        (when-not (Assembler''isSuccessorEdge-2 asm, (:destination this))
            (Assembler''jmp-2 asm, (LabelRef''label-1 (:destination this)))
        )
        nil
    )

    (§ method! #_"JumpOp" JumpOp''setPhiValues-2 [#_"JumpOp" this, #_"Value[]" values]
        (assoc this :outgoingValues values)
    )

    #_unused
    (§ method! #_"int" JumpOp''getPhiSize-1 [#_"JumpOp" this]
        (count (:outgoingValues this))
    )

    (§ method! #_"Value" JumpOp''getOutgoingValue-2 [#_"JumpOp" this, #_"int" idx]
        (nth (:outgoingValues this) idx)
    )

    (§ method! #_"JumpOp" JumpOp''clearOutgoingValues-1 [#_"JumpOp" this]
        (assoc this :outgoingValues Value/NO_VALUES)
    )

    #_unused
    (§ method- #_"boolean" JumpOp''checkRange-2 [#_"JumpOp" this, #_"int" idx]
        (< idx (count (:outgoingValues this)))
    )
)

;;;
 ; Marker interface for a LIR operation that is a conditional jump.
 ;
 ; @anno StandardOp.StandardBranchOp
 ;;
(§ interface StandardBranchOp (§ extends BlockEndOp)
)

;;;
 ; Marker interface for a LIR operation that moves a value to #getResult().
 ;
 ; @anno StandardOp.MoveOp
 ;;
(§ interface MoveOp
    (§ abstract #_"AllocatableValue" MoveOp''getResult-1 [#_"MoveOp" this])
)

;;;
 ; Marker interface for a LIR operation that moves some non-constant value to another location.
 ;
 ; @anno StandardOp.ValueMoveOp
 ;;
(§ interface ValueMoveOp (§ extends MoveOp)
    (§ abstract #_"AllocatableValue" ValueMoveOp''getInput-1 [#_"ValueMoveOp" this])
)

;;;
 ; Marker interface for a LIR operation that loads a #getConstant().
 ;
 ; @anno StandardOp.LoadConstantOp
 ;;
(§ interface LoadConstantOp (§ extends MoveOp)
    (§ abstract #_"Constant" LoadConstantOp''getConstant-1 [#_"LoadConstantOp" this])
)

;;;
 ; An operation that saves registers to the stack. The set of saved registers can be
 ; {@linkplain #remove(EconomicSet) pruned} and a mapping from registers to the frame slots in
 ; which they are saved can be {@linkplain #getMap(FrameMap) retrieved}.
 ;
 ; @anno StandardOp.SaveRegistersOp
 ;;
(§ interface SaveRegistersOp
    ;;;
     ; Gets a map from the saved registers saved by this operation to the frame slots in which
     ; they are saved.
     ;
     ; @param frameMap used to {@linkplain FrameMap#offsetForStackSlot(StackSlot) convert} a
     ;            virtual slot to a frame slot index
     ;;
    #_unused
    (§ abstract #_"RegisterSaveLayout" SaveRegistersOp''getMap-2 [#_"SaveRegistersOp" this, #_"FrameMap" frameMap])
)

;;;
 ; A LIR operation that does nothing. If the operation records its position, it can be
 ; subsequently {@linkplain #replace(LIR, LIRInstruction) replaced}.
 ;
 ; @anno StandardOp.NoOp
 ;;
(final-ns NoOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<NoOp>" NoOp'TYPE (LIRInstructionClass'new-1 NoOp))

    ;;;
     ; The block in which this instruction is located.
     ;;
    (§ final #_"Block" :block nil)
    ;;;
     ; The block index of this instruction.
     ;;
    (§ final #_"int" :index 0)

    (§ defn #_"NoOp" NoOp'new-2 [#_"Block" block, #_"int" index]
        (let [
            #_"NoOp" this (LIRInstruction'new-1 NoOp'TYPE)
            this (assoc this :block block)
            this (assoc this :index index)
        ]
            this
        )
    )

    (§ method! #_"void" NoOp''replace-3 [#_"NoOp" this, #_"LIR" lir, #_"LIRInstruction" replacement]
        (#_"ArrayList" .set (LIR''getLIRforBlock-2 lir, (:block this)), (:index this), replacement)
        nil
    )

    #_unused
    (§ method! #_"void" NoOp''remove-2 [#_"NoOp" this, #_"LIR" lir]
        (#_"ArrayList" .remove (LIR''getLIRforBlock-2 lir, (:block this)), (:index this))
        nil
    )

    #_unused
    (§ override! #_"void" NoOp''emitCode-2 [#_"NoOp" this, #_"Assembler" asm]
        (when (some? (:block this))
            (throw! (str this " should have been replaced"))
        )
        nil
    )
)

;;;
 ; @anno StandardOp.BlackholeOp
 ;;
; @LIROpcode
(final-ns BlackholeOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<BlackholeOp>" BlackholeOp'TYPE (LIRInstructionClass'new-1 BlackholeOp))

    ; @Use({OperandFlag'REG, OperandFlag'STACK, OperandFlag'CONST})
    (§ mutable #_"Value" :value nil)

    (§ defn #_"BlackholeOp" BlackholeOp'new-1 [#_"Value" value]
        (let [
            #_"BlackholeOp" this (LIRInstruction'new-1 BlackholeOp'TYPE)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" BlackholeOp''emitCode-2 [#_"BlackholeOp" this, #_"Assembler" asm]
        ;; do nothing, just keep value alive until at least here
        nil
    )
)

;;;
 ; @anno StandardOp.BindToRegisterOp
 ;;
(final-ns BindToRegisterOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<BindToRegisterOp>" BindToRegisterOp'TYPE (LIRInstructionClass'new-1 BindToRegisterOp))

    ; @Use({OperandFlag'REG})
    (§ mutable #_"Value" :value nil)

    (§ defn #_"BindToRegisterOp" BindToRegisterOp'new-1 [#_"Value" value]
        (let [
            #_"BindToRegisterOp" this (LIRInstruction'new-1 BindToRegisterOp'TYPE)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" BindToRegisterOp''emitCode-2 [#_"BindToRegisterOp" this, #_"Assembler" asm]
        ;; do nothing, just keep value alive until at least here
        nil
    )
)

;;;
 ; @anno StandardOp.SpillRegistersOp
 ;;
; @LIROpcode
(final-ns SpillRegistersOp (§ extends LIRInstruction)
    (§ def #_"LIRInstructionClass<SpillRegistersOp>" SpillRegistersOp'TYPE (LIRInstructionClass'new-1 SpillRegistersOp))

    (§ defn #_"SpillRegistersOp" SpillRegistersOp'new-0 []
        (LIRInstruction'new-1 SpillRegistersOp'TYPE)
    )

    #_unused
    (§ override! #_"boolean" SpillRegistersOp''destroysCallerSavedRegisters-1 [#_"SpillRegistersOp" this]
        true
    )

    #_unused
    (§ override! #_"void" SpillRegistersOp''emitCode-2 [#_"SpillRegistersOp" this, #_"Assembler" asm]
        ;; do nothing, just keep value alive until at least here
        nil
    )
)

;;;
 ; @anno StandardOp.StackMove
 ;;
(final-ns StackMove (§ extends LIRInstruction) (§ implements ValueMoveOp)
    (§ def #_"LIRInstructionClass<StackMove>" StackMove'TYPE (LIRInstructionClass'new-1 StackMove))

    ; @Def({OperandFlag'STACK, OperandFlag'HINT})
    (§ mutable #_"AllocatableValue" :result nil)
    ; @Use({OperandFlag'STACK})
    (§ mutable #_"AllocatableValue" :input nil)

    #_unused
    (§ defn #_"StackMove" StackMove'new-2 [#_"AllocatableValue" result, #_"AllocatableValue" input]
        (let [
            #_"StackMove" this (LIRInstruction'new-1 StackMove'TYPE)
            this (assoc this :result result)
            this (assoc this :input input)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" StackMove''emitCode-2 [#_"StackMove" this, #_"Assembler" asm]
        (throw! (str this " should have been removed"))
    )

    #_unused
    (§ override! #_"AllocatableValue" StackMove''getInput-1 [#_"StackMove" this]
        (:input this)
    )

    #_unused
    (§ override! #_"AllocatableValue" StackMove''getResult-1 [#_"StackMove" this]
        (:result this)
    )
)

;;;
 ; This class encapsulates different strategies on how to generate code for switch instructions.
 ;
 ; The #getBestStrategy(double[], JavaConstant[], LabelRef[]) method can be used to get
 ; strategy with the smallest average effort (average number of comparisons until a decision is
 ; reached). The strategy returned by this method will have its averageEffort set, while a strategy
 ; constructed directly will not.
 ;;
(class-ns SwitchStrategy
    (§ final #_"double[]" :keyProbabilities nil)
    (§ mutable #_"double" :averageEffort -1)
    (§ mutable #_"EffortClosure" :effortClosure nil)

    (§ defn #_"SwitchStrategy" SwitchStrategy'new-1 [#_"double[]" keyProbabilities]
        (let [
            #_"SwitchStrategy" this (Object.)
            this (assoc this :keyProbabilities keyProbabilities)
        ]
            this
        )
    )

    (§ method #_"double" SwitchStrategy''getAverageEffort-1 [#_"SwitchStrategy" this]
        (:averageEffort this)
    )

    ;;;
     ; Tells the system that the given (inclusive) range of keys is reached after depth number
     ; of comparisons, which is used to calculate the average effort.
     ;;
    (§ method! #_"void" SwitchStrategy''registerEffort-4 [#_"SwitchStrategy" this, #_"int" rangeStart, #_"int" rangeEnd, #_"int" depth]
        (when (some? (:effortClosure this))
            (loop-when-recur [#_"int" i rangeStart] (<= i rangeEnd) [(inc i)]
                (aswap (:keyEfforts (:effortClosure this)) i + depth)
                (aswap (:keyCounts (:effortClosure this)) i inc)
            )
        )
        nil
    )

    ;;;
     ; Tells the system that the default successor is reached after depth number of comparisons,
     ; which is used to calculate average effort.
     ;;
    (§ method! #_"SwitchStrategy" SwitchStrategy''registerDefaultEffort-2 [#_"SwitchStrategy" this, #_"int" depth]
        (when (some? (:effortClosure this)) => this
            (let [
                this (update-in this [:effortClosure :defaultEffort] + depth)
                this (update-in this [:effortClosure :defaultCount] inc)
            ]
                this
            )
        )
    )

    (§ abstract #_"void" SwitchStrategy''run-2 [#_"SwitchStrategy" this, #_"SwitchClosure" closure])

    (§ defn- #_"SwitchStrategy[]" SwitchStrategy'getStrategies-3 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants, #_"LabelRef[]" keyTargets]
        (let [
            #_"SwitchStrategy[]" strategies (into-array SwitchStrategy [ (SequentialStrategy'new-2 keyProbabilities, keyConstants), (RangesStrategy'new-2 keyProbabilities, keyConstants), (BinaryStrategy'new-2 keyProbabilities, keyConstants) ])
        ]
            (loop-when-recur [#_"ISeq" s (seq strategies)] (some? s) [(next s)]
                (let [
                    #_"SwitchStrategy" strategy (first s)
                ]
                    (§ ass! strategy (assoc strategy :effortClosure (EffortClosure'new-2 strategy, keyTargets)))
                    (SwitchStrategy''run-2 strategy, (:effortClosure strategy))
                    (§ ass! strategy (assoc strategy :averageEffort (EffortClosure''getAverageEffort-1 (:effortClosure strategy))))
                    (§ ass! strategy (assoc strategy :effortClosure nil))
                )
            )
            strategies
        )
    )

    ;;;
     ; Creates all switch strategies for the given switch, evaluates them (based on average effort)
     ; and returns the best one.
     ;;
    (§ defn #_"SwitchStrategy" SwitchStrategy'getBestStrategy-3 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants, #_"LabelRef[]" keyTargets]
        (let [
            #_"SwitchStrategy[]" strategies (SwitchStrategy'getStrategies-3 keyProbabilities, keyConstants, keyTargets)
        ]
            (loop-when [#_"double" bestEffort Integer/MAX_VALUE #_"SwitchStrategy" bestStrategy nil #_"ISeq" s (seq strategies)] (some? s) => bestStrategy
                (let [
                    #_"SwitchStrategy" strategy (first s)
                    [bestEffort bestStrategy]
                        (when (< (SwitchStrategy''getAverageEffort-1 strategy) bestEffort) => [bestEffort bestStrategy]
                            [(SwitchStrategy''getAverageEffort-1 strategy) strategy]
                        )
                ]
                    (recur bestEffort bestStrategy (next s))
                )
            )
        )
    )
)

;;;
 ; @anno SwitchStrategy.SwitchClosure
 ;;
(§ interface SwitchClosure
    ;;;
     ; Generates a conditional or unconditional jump. The jump will be unconditional if
     ; condition is nil. If defaultTarget is true, then the jump will go the default.
     ;
     ; @param index Index of the value and the jump target (only used if defaultTarget == false)
     ; @param condition The condition on which to jump (can be nil)
     ; @param defaultTarget true if the jump should go to the default target, false if index should be used
     ;;
    (§ abstract #_"void" SwitchClosure''conditionalJump-4 [#_"SwitchClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" defaultTarget])

    ;;;
     ; Generates a conditional jump to the target with the specified index. The fall through
     ; should go to the default target.
     ;
     ; @param index Index of the value and the jump target
     ; @param condition The condition on which to jump
     ; @param canFallThrough true if this is the last instruction in the switch statement, to allow for fall-through optimizations
     ;;
    (§ abstract #_"void" SwitchClosure''conditionalJumpOrDefault-4 [#_"SwitchClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" canFallThrough])

    ;;;
     ; Create a new label and generate a conditional jump to it.
     ;
     ; @param index Index of the value and the jump target
     ; @param condition The condition on which to jump
     ; @return a new Label
     ;;
    (§ abstract #_"Label" SwitchClosure''conditionalJump-3 [#_"SwitchClosure" this, #_"int" index, #_"Condition" condition])

    ;;;
     ; Binds a label returned by #conditionalJump(int, Condition).
     ;;
    (§ abstract #_"void" SwitchClosure''bind-2 [#_"SwitchClosure" this, #_"Label" label])

    ;;;
     ; Return true iff the target of both indexes is the same.
     ;;
    (§ abstract #_"boolean" SwitchClosure''isSameTarget-3 [#_"SwitchClosure" this, #_"int" index1, #_"int" index2])
)

;;;
 ; Backends can subclass this abstract class and generate code for switch strategies by
 ; implementing the #conditionalJump(int, Condition, Label) method.
 ;
 ; @anno SwitchStrategy.BaseSwitchClosure
 ;;
(class-ns BaseSwitchClosure (§ implements SwitchClosure)
    (§ final #_"Assembler" :asm nil)
    (§ final #_"LabelRef[]" :keyTargets nil)
    (§ final #_"LabelRef" :defaultTarget nil)

    (§ defn #_"BaseSwitchClosure" BaseSwitchClosure'new-3 [#_"Assembler" asm, #_"LabelRef[]" keyTargets, #_"LabelRef" defaultTarget]
        (let [
            #_"BaseSwitchClosure" this (Object.)
            this (assoc this :asm asm)
            this (assoc this :keyTargets keyTargets)
            this (assoc this :defaultTarget defaultTarget)
        ]
            this
        )
    )

    ;;;
     ; This method generates code for a comparison between the actual value and the constant at
     ; the given index and a condition jump to target.
     ;;
    (§ abstract #_"void" BaseSwitchClosure''conditionalJump-4 [#_"BaseSwitchClosure" this, #_"int" index, #_"Condition" condition, #_"Label" target])

    (§ override #_"void" BaseSwitchClosure''conditionalJump-4 [#_"BaseSwitchClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" targetDefault]
        (let [
            #_"Label" target (if targetDefault (LabelRef''label-1 (:defaultTarget this)) (LabelRef''label-1 (nth (:keyTargets this) index)))
        ]
            (if (nil? condition)
                (Assembler''jmp-2 (:asm this), target)
                (BaseSwitchClosure''conditionalJump-4 this, index, condition, target)
            )
        )
        nil
    )

    #_unused
    (§ override #_"void" BaseSwitchClosure''conditionalJumpOrDefault-4 [#_"BaseSwitchClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" canFallThrough]
        (cond
            (and canFallThrough (Assembler''isSuccessorEdge-2 (:asm this), (:defaultTarget this)))
                (BaseSwitchClosure''conditionalJump-4 this, index, condition, (LabelRef''label-1 (nth (:keyTargets this) index)))
            (and canFallThrough (Assembler''isSuccessorEdge-2 (:asm this), (nth (:keyTargets this) index)))
                (BaseSwitchClosure''conditionalJump-4 this, index, (Condition''negate-1 condition), (LabelRef''label-1 (:defaultTarget this)))
            :else
            (do
                (BaseSwitchClosure''conditionalJump-4 this, index, condition, (LabelRef''label-1 (nth (:keyTargets this) index)))
                (Assembler''jmp-2 (:asm this), (LabelRef''label-1 (:defaultTarget this)))
            )
        )
        nil
    )

    #_unused
    (§ override #_"Label" BaseSwitchClosure''conditionalJump-3 [#_"BaseSwitchClosure" this, #_"int" index, #_"Condition" condition]
        (let [
            #_"Label" label (Label'new-0)
        ]
            (BaseSwitchClosure''conditionalJump-4 this, index, condition, label)
            label
        )
    )

    #_unused
    (§ override #_"void" BaseSwitchClosure''bind-2 [#_"BaseSwitchClosure" this, #_"Label" label]
        (Assembler''bind-2 (:asm this), label)
        nil
    )

    #_unused
    (§ override #_"boolean" BaseSwitchClosure''isSameTarget-3 [#_"BaseSwitchClosure" this, #_"int" index1, #_"int" index2]
        (= (nth (:keyTargets this) index1) (nth (:keyTargets this) index2))
    )
)

;;;
 ; This closure is used internally to determine the average effort for a certain strategy on a
 ; given switch instruction.
 ;
 ; @anno SwitchStrategy.EffortClosure
 ;;
(final-ns EffortClosure (§ implements SwitchClosure)
    (§ final #_"SwitchStrategy" :strategy nil)

    (§ mutable #_"int" :defaultEffort 0)
    (§ mutable #_"int" :defaultCount 0)
    (§ final #_"int[]" :keyEfforts nil)
    (§ final #_"int[]" :keyCounts nil)
    (§ final #_"LabelRef[]" :keyTargets nil)

    (§ defn #_"EffortClosure" EffortClosure'new-2 [#_"SwitchStrategy" strategy, #_"LabelRef[]" keyTargets]
        (let [
            #_"EffortClosure" this (Object.)
            this (assoc this :strategy strategy)
            this (assoc this :keyEfforts (int-array (count (:keyProbabilities strategy))))
            this (assoc this :keyCounts (int-array (count (:keyProbabilities strategy))))
            this (assoc this :keyTargets keyTargets)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" EffortClosure''conditionalJump-4 [#_"EffortClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" defaultTarget]
        ;; nothing to do
        nil
    )

    #_unused
    (§ override! #_"void" EffortClosure''conditionalJumpOrDefault-4 [#_"EffortClosure" this, #_"int" index, #_"Condition" condition, #_"boolean" canFallThrough]
        ;; nothing to do
        nil
    )

    #_unused
    (§ override! #_"Label" EffortClosure''conditionalJump-3 [#_"EffortClosure" this, #_"int" index, #_"Condition" condition]
        ;; nothing to do
        nil
    )

    #_unused
    (§ override! #_"void" EffortClosure''bind-2 [#_"EffortClosure" this, #_"Label" label]
        ;; nothing to do
        nil
    )

    #_unused
    (§ override! #_"boolean" EffortClosure''isSameTarget-3 [#_"EffortClosure" this, #_"int" index1, #_"int" index2]
        (= (nth (:keyTargets this) index1) (nth (:keyTargets this) index2))
    )

    (§ method! #_"double" EffortClosure''getAverageEffort-1 [#_"EffortClosure" this]
        (loop-when-recur [#_"double" effort 0.0 #_"double" defaultProbability 1.0 #_"int" i 0]
                         (< i (count (:keyProbabilities (:strategy this))))
                         [(+ effort (/ (* (nth (:keyEfforts this) i) (nth (:keyProbabilities (:strategy this)) i)) (nth (:keyCounts this) i)))
                          (- defaultProbability (nth (:keyProbabilities (:strategy this)) i))
                          (inc i)]
                      => (+ effort (/ (* (:defaultEffort this) defaultProbability) (:defaultCount this)))
        )
    )
)

;;;
 ; This strategy orders the keys according to their probability and creates one equality
 ; comparison per key.
 ;
 ; @anno SwitchStrategy.SequentialStrategy
 ;;
(final-ns SequentialStrategy (§ extends SwitchStrategy)
    (§ final #_"Integer[]" :indexes nil)
    (§ final #_"Constant[]" :keyConstants nil)

    (§ defn #_"SequentialStrategy" SequentialStrategy'new-2 [#_"double[]" keyProbabilities, #_"Constant[]" keyConstants]
        (let [
            #_"SequentialStrategy" this (SwitchStrategy'new-1 keyProbabilities)
            this (assoc this :keyConstants keyConstants)
            #_"int" n (count keyConstants)
            this (assoc this :indexes (make-array Integer n))
            _
                (dotimes [#_"int" i n]
                    (aset (:indexes this) i i)
                )
            _
                (Arrays/sort (:indexes this),
                    (§ reify #_"Comparator<Integer>" (Comparator.)
                        (§ override! #_"int" #_"Comparator" .compare [#_"Comparator<Integer>" this, #_"Integer" o1, #_"Integer" o2]
                            (cond (< (nth keyProbabilities o1) (nth keyProbabilities o2)) 1 (> (nth keyProbabilities o1) (nth keyProbabilities o2)) -1 :else 0)
                        )
                    )
                )
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" SequentialStrategy''run-2 [#_"SequentialStrategy" this, #_"SwitchClosure" closure]
        (dotimes [#_"int" i (dec (count (:keyConstants this)))]
            (SwitchClosure''conditionalJump-4 closure, (nth (:indexes this) i), Condition'EQ, false)
            (SwitchStrategy''registerEffort-4 this, (nth (:indexes this) i), (nth (:indexes this) i), (inc i))
        )
        (SwitchClosure''conditionalJumpOrDefault-4 closure, (nth (:indexes this) (dec (count (:keyConstants this)))), Condition'EQ, true)
        (SwitchStrategy''registerEffort-4 this, (nth (:indexes this) (dec (count (:keyConstants this)))), (nth (:indexes this) (dec (count (:keyConstants this)))), (count (:keyConstants this)))
        (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, (count (:keyConstants this))))
        nil
    )
)

;;;
 ; Base class for strategies that rely on primitive integer keys.
 ;
 ; @anno SwitchStrategy.PrimitiveStrategy
 ;;
(class-ns PrimitiveStrategy (§ extends SwitchStrategy)
    (§ final #_"JavaConstant[]" :keyConstants nil)

    (§ defn #_"PrimitiveStrategy" PrimitiveStrategy'new-2 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants]
        (let [
            #_"PrimitiveStrategy" this (SwitchStrategy'new-1 keyProbabilities)
            this (assoc this :keyConstants keyConstants)
        ]
            this
        )
    )

    ;;;
     ; Looks for the end of a stretch of key constants that are successive numbers and have the same target.
     ;;
    (§ method! #_"int" PrimitiveStrategy''getSliceEnd-3 [#_"PrimitiveStrategy" this, #_"SwitchClosure" closure, #_"int" pos]
        (let [
            #_"JavaConstant[]" a (:keyConstants this)
        ]
            (loop-when-recur [#_"int" i pos]
                             (and (< i (dec (count a)))
                                  (= (#_"JavaConstant" .asLong (nth a (inc i))) (inc (#_"JavaConstant" .asLong (nth a i))))
                                  (SwitchClosure''isSameTarget-3 closure, i, (inc i))
                             )
                             [(inc i)]
                          => i
            )
        )
    )
)

;;;
 ; This strategy divides the keys into ranges of successive keys with the same target and
 ; creates comparisons for these ranges.
 ;
 ; @anno SwitchStrategy.RangesStrategy
 ;;
(final-ns RangesStrategy (§ extends PrimitiveStrategy)
    (§ final #_"Integer[]" :indexes nil)

    (§ defn #_"RangesStrategy" RangesStrategy'new-2 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants]
        (let [
            #_"RangesStrategy" this (PrimitiveStrategy'new-2 keyProbabilities, keyConstants)
            #_"int" n (count keyConstants)
            this (assoc this :indexes (make-array Integer n))
            _
                (dotimes [#_"int" i n]
                    (aset (:indexes this) i i)
                )
            _
                (Arrays/sort (:indexes this),
                    (§ reify #_"Comparator<Integer>" (Comparator.)
                        (§ override! #_"int" #_"Comparator" .compare [#_"Comparator<Integer>" this, #_"Integer" o1, #_"Integer" o2]
                            (cond (< (nth keyProbabilities o1) (nth keyProbabilities o2)) 1 (> (nth keyProbabilities o1) (nth keyProbabilities o2)) -1 :else 0)
                        )
                    )
                )
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" RangesStrategy''run-2 [#_"RangesStrategy" this, #_"SwitchClosure" closure]
        (let [
            #_"int'" depth (volatile! 0)
        ]
            (SwitchClosure''conditionalJump-4 closure, 0, Condition'LT, true)
            (vswap! depth inc)
            (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, @depth))
            (let [
                [#_"int" start #_"int" end]
                    (loop-when [start 0 end (PrimitiveStrategy''getSliceEnd-3 this, closure, start)] (not= end (dec (count (:keyConstants this)))) => [start end]
                        (if (= start end)
                            (do
                                (SwitchClosure''conditionalJump-4 closure, start, Condition'EQ, false)
                                (vswap! depth inc)
                                (SwitchStrategy''registerEffort-4 this, start, end, @depth)
                            )
                            (do
                                (when (or (zero? start) (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) (dec start)))) (#_"JavaConstant" .asLong (nth (:keyConstants this) start))))
                                    (SwitchClosure''conditionalJump-4 closure, start, Condition'LT, true)
                                    (vswap! depth inc)
                                    (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, @depth))
                                )
                                (SwitchClosure''conditionalJump-4 closure, end, Condition'LE, false)
                                (vswap! depth inc)
                                (SwitchStrategy''registerEffort-4 this, start, end, @depth)
                            )
                        )
                        (let [
                            start (inc end)
                        ]
                            (recur start (PrimitiveStrategy''getSliceEnd-3 this, closure, start))
                        )
                    )
            ]
                (if (= start end)
                    (do
                        (SwitchClosure''conditionalJumpOrDefault-4 closure, start, Condition'EQ, true)
                        (vswap! depth inc)
                        (SwitchStrategy''registerEffort-4 this, start, end, @depth)
                        (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, @depth))
                    )
                    (do
                        (when (or (zero? start) (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) (dec start)))) (#_"JavaConstant" .asLong (nth (:keyConstants this) start))))
                            (SwitchClosure''conditionalJump-4 closure, start, Condition'LT, true)
                            (vswap! depth inc)
                            (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, @depth))
                        )
                        (SwitchClosure''conditionalJumpOrDefault-4 closure, end, Condition'LE, true)
                        (vswap! depth inc)
                        (SwitchStrategy''registerEffort-4 this, start, end, @depth)
                        (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, @depth))
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; This strategy recursively subdivides the list of keys to create a binary search based on probabilities.
 ;
 ; @anno SwitchStrategy.BinaryStrategy
 ;;
(final-ns BinaryStrategy (§ extends PrimitiveStrategy)
    (def- #_"double" BinaryStrategy'MIN_PROBABILITY 0.00001)

    (§ final #_"double[]" :probabilitySums nil)

    (§ defn #_"BinaryStrategy" BinaryStrategy'new-2 [#_"double[]" keyProbabilities, #_"JavaConstant[]" keyConstants]
        (let [
            #_"BinaryStrategy" this (PrimitiveStrategy'new-2 keyProbabilities, keyConstants)
            this (assoc this :probabilitySums (double-array (inc (count keyProbabilities))))
            _
                (loop-when [#_"double" sum 0.0 #_"int" i 0] (< i (count keyConstants))
                    (let [
                        sum (+ sum (max BinaryStrategy'MIN_PROBABILITY (nth keyProbabilities i)))
                    ]
                        (aset (:probabilitySums this) (inc i) sum)
                        (recur sum (inc i))
                    )
                )
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" BinaryStrategy''run-2 [#_"BinaryStrategy" this, #_"SwitchClosure" closure]
        (BinaryStrategy''recurseBinarySwitch-5 this, closure, 0, (dec (count (:keyConstants this))), 0)
        nil
    )

    ;;;
     ; Recursively generate a list of comparisons that always subdivides the keys in the given
     ; (inclusive) range in the middle (in terms of probability, not index). If left is bigger
     ; than zero, then we always know that the value is equal to or bigger than the left key.
     ; This does not hold for the right key, as there may be a gap afterwards.
     ;;
    (§ method- #_"void" BinaryStrategy''recurseBinarySwitch-5 [#_"BinaryStrategy" this, #_"SwitchClosure" closure, #_"int" left, #_"int" right, #_"int" depth]
        (let [
            #_"boolean" leftBorder (zero? left)
            #_"boolean" rightBorder (= right (dec (count (:keyConstants this))))
        ]
            (if (= (inc left) right)
                ;; only two possible values
                (if (or leftBorder rightBorder (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) right))) (#_"JavaConstant" .asLong (nth (:keyConstants this) (inc right)))) (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) left))) (#_"JavaConstant" .asLong (nth (:keyConstants this) right))))
                    (do
                        (SwitchClosure''conditionalJump-4 closure, left, Condition'EQ, false)
                        (§ ass depth (inc depth))
                        (SwitchStrategy''registerEffort-4 this, left, left, depth)
                        (SwitchClosure''conditionalJumpOrDefault-4 closure, right, Condition'EQ, rightBorder)
                        (§ ass depth (inc depth))
                        (SwitchStrategy''registerEffort-4 this, right, right, depth)
                        (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                    )
                    (do
                        ;; here we know that the value can only be one of these two keys in the range
                        (SwitchClosure''conditionalJump-4 closure, left, Condition'EQ, false)
                        (§ ass depth (inc depth))
                        (SwitchStrategy''registerEffort-4 this, left, left, depth)
                        (SwitchClosure''conditionalJump-4 closure, right, nil, false)
                        (SwitchStrategy''registerEffort-4 this, right, right, depth)
                    )
                )
                (let [
                    #_"double" probabilityStart (nth (:probabilitySums this) left)
                    #_"double" probabilityMiddle (/ (+ probabilityStart (nth (:probabilitySums this) (inc right))) 2)
                    #_"int" middle
                        (loop [middle left]
                            (let [#_"int" end (PrimitiveStrategy''getSliceEnd-3 this, closure, (inc middle))]
                                (recur-if (and (< end right) (< (nth (:probabilitySums this) end) probabilityMiddle))
                                        [end]
                                    => (PrimitiveStrategy''getSliceEnd-3 this, closure, middle)
                                )
                            )
                        )
                ]
                    (cond
                        (= (PrimitiveStrategy''getSliceEnd-3 this, closure, left) middle)
                            (do
                                (when (zero? left)
                                    (SwitchClosure''conditionalJump-4 closure, 0, Condition'LT, true)
                                    (§ ass depth (inc depth))
                                    (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                )
                                (SwitchClosure''conditionalJump-4 closure, middle, Condition'LE, false)
                                (§ ass depth (inc depth))
                                (SwitchStrategy''registerEffort-4 this, left, middle, depth)

                                (if (= (inc middle) right)
                                    (do
                                        (SwitchClosure''conditionalJumpOrDefault-4 closure, right, Condition'EQ, rightBorder)
                                        (§ ass depth (inc depth))
                                        (SwitchStrategy''registerEffort-4 this, right, right, depth)
                                        (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                    )
                                    (do
                                        (when-not (= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) middle))) (#_"JavaConstant" .asLong (nth (:keyConstants this) (inc middle))))
                                            (SwitchClosure''conditionalJump-4 closure, (inc middle), Condition'LT, true)
                                            (§ ass depth (inc depth))
                                            (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                        )
                                        (if (= (PrimitiveStrategy''getSliceEnd-3 this, closure, (inc middle)) right)
                                            (if (or (= right (dec (count (:keyConstants this)))) (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) right))) (#_"JavaConstant" .asLong (nth (:keyConstants this) (inc right)))))
                                                (do
                                                    (SwitchClosure''conditionalJumpOrDefault-4 closure, right, Condition'LE, rightBorder)
                                                    (§ ass depth (inc depth))
                                                    (SwitchStrategy''registerEffort-4 this, (inc middle), right, depth)
                                                    (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                                )
                                                (do
                                                    (SwitchClosure''conditionalJump-4 closure, (inc middle), nil, false)
                                                    (SwitchStrategy''registerEffort-4 this, (inc middle), right, depth)
                                                )
                                            )
                                            (BinaryStrategy''recurseBinarySwitch-5 this, closure, (inc middle), right, depth)
                                        )
                                    )
                                )
                            )
                        (= (PrimitiveStrategy''getSliceEnd-3 this, closure, (inc middle)) right)
                            (do
                                (when (or rightBorder (not= (inc (#_"JavaConstant" .asLong (nth (:keyConstants this) right))) (#_"JavaConstant" .asLong (nth (:keyConstants this) (inc right)))))
                                    (SwitchClosure''conditionalJump-4 closure, right, Condition'GT, true)
                                    (§ ass depth (inc depth))
                                    (§ ass! this (SwitchStrategy''registerDefaultEffort-2 this, depth))
                                )
                                (SwitchClosure''conditionalJump-4 closure, (inc middle), Condition'GE, false)
                                (§ ass depth (inc depth))
                                (SwitchStrategy''registerEffort-4 this, (inc middle), right, depth)
                                (BinaryStrategy''recurseBinarySwitch-5 this, closure, left, middle, depth)
                            )
                        :else
                            (let [
                                #_"Label" label (SwitchClosure''conditionalJump-3 closure, (inc middle), Condition'GE)
                            ]
                                (§ ass depth (inc depth))
                                (BinaryStrategy''recurseBinarySwitch-5 this, closure, left, middle, depth)
                                (SwitchClosure''bind-2 closure, label)
                                (BinaryStrategy''recurseBinarySwitch-5 this, closure, (inc middle), right, depth)
                            )
                    )
                )
            )
        )
        nil
    )
)

(final-ns RegisterMap #_"<T>"
    (§ final #_"Object[]" :values nil)
    (§ final #_"Architecture" :arch nil)

    (§ defn #_"RegisterMap" RegisterMap'new-1 [#_"Architecture" arch]
        (let [
            #_"RegisterMap" this (Object.)
            this (assoc this :values (make-array Object (#_"RegisterArray" .size (#_"Architecture" .getRegisters arch))))
            this (assoc this :arch arch)
        ]
            this
        )
    )

    #_unused
    (§ method! #_"T" RegisterMap''get-2 [#_"RegisterMap<T>" this, #_"Register" reg]
        (§ cast #_"T" (nth (:values this) (RegisterMap'index-1 reg)))
    )

    #_unused
    (§ method! #_"void" RegisterMap''remove-2 [#_"RegisterMap<T>" this, #_"Register" reg]
        (aset (:values this) (RegisterMap'index-1 reg) nil)
        nil
    )

    (§ method! #_"void" RegisterMap''put-3 [#_"RegisterMap<T>" this, #_"Register" reg, #_"T" value]
        (aset (:values this) (RegisterMap'index-1 reg) value)
        nil
    )

    (§ method! #_"void" RegisterMap''forEach-2 [#_"RegisterMap<T>" this, #_"BiConsumer<? super Register, ? super T>" consumer]
        (dotimes [#_"int" i (count (:values this))]
            (let [
                #_"T" value (nth (:values this) i)
            ]
                (when (some? value)
                    (#_"BiConsumer" .accept consumer, (#_"RegisterArray" .get (#_"Architecture" .getRegisters (:arch this)), i), value)
                )
            )
        )
        nil
    )

    (§ defn- #_"int" RegisterMap'index-1 [#_"Register" reg]
        (.number reg)
    )
)

;;;
 ; Non-modifying version of ValueProcedure.
 ;;
; @FunctionalInterface
(§ interface ValueConsumer (§ extends InstructionValueConsumer)
    ;;;
     ; Iterator method to be overwritten.
     ;
     ; @param value The value that is iterated.
     ; @param mode The operand mode for the value.
     ; @param flags A set of flags for the value.
     ;;
    (§ abstract #_"void" ValueConsumer''visitValue-4 [#_"ValueConsumer" this, #_"Value" value, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags])

    (§ default #_"void" ValueConsumer''visitValue-5 [#_"ValueConsumer" this, #_"LIRInstruction" instruction, #_"Value" value, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags]
        (ValueConsumer''visitValue-4 this, value, mode, flags)
        nil
    )
)

;;;
 ; Similar to InstructionValueProcedure but without an LIRInstruction parameter.
 ;;
; @FunctionalInterface
(§ interface ValueProcedure (§ extends InstructionValueProcedure)
    ;;;
     ; Iterator method to be overwritten.
     ;
     ; @param value The value that is iterated.
     ; @param mode The operand mode for the value.
     ; @param flags A set of flags for the value.
     ; @return the new value to replace the value that was passed in
     ;;
    (§ abstract #_"Value" ValueProcedure''doValue-4 [#_"ValueProcedure" this, #_"Value" value, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags])

    #_unused
    (§ default #_"Value" ValueProcedure''doValue-5 [#_"ValueProcedure" this, #_"LIRInstruction" instruction, #_"Value" value, #_"OperandMode" mode, #_"EnumSet<OperandFlag>" flags]
        (ValueProcedure''doValue-4 this, value, mode, flags)
    )
)

;;;
 ; Represents a value that is yet to be bound to a machine location (such as a RegisterValue
 ; or StackSlot) by a register allocator.
 ;;
(final-ns Variable (§ extends AllocatableValue)
    ;;;
     ; The identifier of the variable. This is a non-zero index in a contiguous 0-based name space.
     ;;
    (§ final #_"int" :index 0)

    (§ mutable #_"String" :name nil)

    ;;;
     ; Creates a new variable.
     ;;
    (§ defn #_"Variable" Variable'new-2 [#_"ValueKind" kind, #_"int" index]
        (let [
            #_"Variable" this (AllocatableValue. kind)
            this (assoc this :index index)
        ]
            this
        )
    )
)

;;;
 ; VirtualStackSlots are stack slots that are not yet fixed to specific frame offset. They
 ; are replaced by real StackSlots with a fixed position in the frame before code emission.
 ;;
(class-ns VirtualStackSlot (§ extends AllocatableValue)
    (§ final #_"int" :id 0)

    (§ defn #_"VirtualStackSlot" VirtualStackSlot'new-2 [#_"int" id, #_"ValueKind" kind]
        (let [
            #_"VirtualStackSlot" this (AllocatableValue. kind)
            this (assoc this :id id)
        ]
            this
        )
    )
)

(final-ns BasicInductionVariable (§ extends InductionVariable)
    (§ final #_"ValuePhiNode" :phi nil)
    (§ final #_"ValueNode" :init nil)
    (§ mutable #_"ValueNode" :rawStride nil)
    (§ mutable #_"BinaryArithmeticNode" :op nil)

    (§ defn #_"BasicInductionVariable" BasicInductionVariable'new-5 [#_"LoopEx" loop, #_"ValuePhiNode" phi, #_"ValueNode" init, #_"ValueNode" rawStride, #_"BinaryArithmeticNode" op]
        (let [
            #_"BasicInductionVariable" this (InductionVariable'new-1 loop)
            this (assoc this :phi phi)
            this (assoc this :init init)
            this (assoc this :rawStride rawStride)
            this (assoc this :op op)
        ]
            this
        )
    )

    (§ override! #_"Graph" BasicInductionVariable''graph-1 [#_"BasicInductionVariable" this]
        (:graph (:phi this))
    )

    #_unused
    (§ method! #_"BasicInductionVariable" BasicInductionVariable''setOP-2 [#_"BasicInductionVariable" this, #_"BinaryArithmeticNode" newOp]
        (let [
            this (assoc this :rawStride (:y newOp))
            this (assoc this :op newOp)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Direction" BasicInductionVariable''direction-1 [#_"BasicInductionVariable" this]
        (let [
            #_"Stamp" stamp (:stamp (:rawStride this))
        ]
            (when (instance? IntegerStamp stamp)
                (let [
                    #_"Direction" dir
                        (cond
                            (IntegerStamp''isStrictlyPositive-1 stamp) :Direction'Up
                            (IntegerStamp''isStrictlyNegative-1 stamp) :Direction'Down
                        )
                ]
                    (when (some? dir)
                        (if (instance? AddNode (:op this)) dir (Direction''opposite-1 dir))
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"ValuePhiNode" BasicInductionVariable''valueNode-1 [#_"BasicInductionVariable" this]
        (:phi this)
    )

    (§ override! #_"ValueNode" BasicInductionVariable''initNode-1 [#_"BasicInductionVariable" this]
        (:init this)
    )

    (§ override! #_"ValueNode" BasicInductionVariable''strideNode-1 [#_"BasicInductionVariable" this]
        (condp instance? (:op this)
            AddNode (:rawStride this)
            SubNode (Graph''add-2 (BasicInductionVariable''graph-1 this), (NegateNode'new-1 (:rawStride this)))
        )
    )

    (§ override! #_"boolean" BasicInductionVariable''isConstantInit-1 [#_"BasicInductionVariable" this]
        (instance? ConstantNode (:init this))
    )

    (§ override! #_"boolean" BasicInductionVariable''isConstantStride-1 [#_"BasicInductionVariable" this]
        (instance? ConstantNode (:rawStride this))
    )

    (§ override! #_"long" BasicInductionVariable''constantInit-1 [#_"BasicInductionVariable" this]
        (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:init this)))
    )

    (§ override! #_"long" BasicInductionVariable''constantStride-1 [#_"BasicInductionVariable" this]
        (condp instance? (:op this)
            AddNode    (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:rawStride this)))
            SubNode (- (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:rawStride this))))
        )
    )

    #_unused
    (§ override! #_"ValueNode" BasicInductionVariable''extremumNode-3 [#_"BasicInductionVariable" this, #_"boolean" assumePositiveTripCount, #_"Stamp" stamp]
        (let [
            #_"Stamp" fromStamp (:stamp (:phi this))
            #_"Graph" graph (BasicInductionVariable''graph-1 this)
            #_"ValueNode" stride (BasicInductionVariable''strideNode-1 this)
            #_"ValueNode" initNode (BasicInductionVariable''initNode-1 this)
        ]
            (when-not (Stamp''isCompatible-2 fromStamp, stamp)
                (§ ass stride (IntegerConvertNode'convert-3 stride, stamp, (BasicInductionVariable''graph-1 this)))
                (§ ass initNode (IntegerConvertNode'convert-3 initNode, stamp, (BasicInductionVariable''graph-1 this)))
            )
            (let [
                #_"ValueNode" maxTripCount (CountedLoopInfo''maxTripCountNode-2 (:counted (:loop this)), assumePositiveTripCount)
            ]
                (when-not (Stamp''isCompatible-2 (:stamp maxTripCount), stamp)
                    (§ ass maxTripCount (IntegerConvertNode'convert-3 maxTripCount, stamp, (BasicInductionVariable''graph-1 this)))
                )
                (MathUtil'add-3 graph, (MathUtil'mul-3 graph, stride, (MathUtil'sub-3 graph, maxTripCount, (ConstantNode'forIntegerStamp-3 stamp, 1, graph))), initNode)
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" BasicInductionVariable''exitValueNode-1 [#_"BasicInductionVariable" this]
        (let [
            #_"Stamp" stamp (:stamp (:phi this))
            #_"ValueNode" maxTripCount (CountedLoopInfo''maxTripCountNode-1 (:counted (:loop this)))
        ]
            (when-not (Stamp''isCompatible-2 (:stamp maxTripCount), stamp)
                (§ ass maxTripCount (IntegerConvertNode'convert-3 maxTripCount, stamp, (BasicInductionVariable''graph-1 this)))
            )
            (MathUtil'add-3 (BasicInductionVariable''graph-1 this), (MathUtil'mul-3 (BasicInductionVariable''graph-1 this), (BasicInductionVariable''strideNode-1 this), maxTripCount), (BasicInductionVariable''initNode-1 this))
        )
    )

    #_unused
    (§ override! #_"boolean" BasicInductionVariable''isConstantExtremum-1 [#_"BasicInductionVariable" this]
        (and (BasicInductionVariable''isConstantInit-1 this) (BasicInductionVariable''isConstantStride-1 this) (CountedLoopInfo''isConstantMaxTripCount-1 (:counted (:loop this))))
    )

    #_unused
    (§ override! #_"long" BasicInductionVariable''constantExtremum-1 [#_"BasicInductionVariable" this]
        (let [
            #_"UnsignedLong" tripCount (CountedLoopInfo''constantMaxTripCount-1 (:counted (:loop this)))
        ]
            (if (UnsignedLong''isLessThan-2 tripCount, 1)
                (BasicInductionVariable''constantInit-1 this)
                (UnsignedLong''asLong-1 (UnsignedLong''wrappingPlus-2 (UnsignedLong''wrappingTimes-2 (UnsignedLong''minus-2 tripCount, 1), (BasicInductionVariable''constantStride-1 this)), (BasicInductionVariable''constantInit-1 this)))
            )
        )
    )

    #_unused
    (§ override! #_"void" BasicInductionVariable''deleteUnusedNodes-1 [#_"BasicInductionVariable" this]
        nil
    )
)

(final-ns CountedLoopInfo
    (§ final #_"LoopEx" :loop nil)
    (§ mutable #_"InductionVariable" :iv nil)
    (§ mutable #_"ValueNode" :end nil)
    (§ mutable #_"boolean" :oneOff false)
    (§ mutable #_"AbstractBeginNode" :body nil)
    (§ mutable #_"IfNode" :ifNode nil)

    (§ defn #_"CountedLoopInfo" CountedLoopInfo'new-6 [#_"LoopEx" loop, #_"InductionVariable" iv, #_"IfNode" ifNode, #_"ValueNode" end, #_"boolean" oneOff, #_"AbstractBeginNode" body]
        (let [
            #_"CountedLoopInfo" this (Object.)
            this (assoc this :loop loop)
            this (assoc this :iv iv)
            this (assoc this :end end)
            this (assoc this :oneOff oneOff)
            this (assoc this :body body)
            this (assoc this :ifNode ifNode)
        ]
            this
        )
    )

    ;;;
     ; Returns a node that computes the maximum trip count of this loop. That is the trip count of
     ; this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
     ; count check}.
     ;
     ; This count is exact if #isExactTripCount() returns true.
     ;
     ; THIS VALUE SHOULD BE TREATED AS UNSIGNED.
     ;;
    (§ method! #_"ValueNode" CountedLoopInfo''maxTripCountNode-1 [#_"CountedLoopInfo" this]
        (CountedLoopInfo''maxTripCountNode-2 this, false)
    )

    ;;;
     ; Returns a node that computes the maximum trip count of this loop. That is the trip count of
     ; this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
     ; count check}.
     ;
     ; This count is exact if #isExactTripCount() returns true.
     ;
     ; THIS VALUE SHOULD BE TREATED AS UNSIGNED.
     ;
     ; @param assumePositive if true the check that the loop is entered at all will be omitted.
     ;;
    (§ method! #_"ValueNode" CountedLoopInfo''maxTripCountNode-2 [#_"CountedLoopInfo" this, #_"boolean" assumePositive]
        (let [
            #_"Graph" graph (:graph (InductionVariable''valueNode-1 (:iv this)))
            #_"Stamp" stamp (:stamp (InductionVariable''valueNode-1 (:iv this)))
            [#_"ValueNode" absStride #_"ValueNode" range #_"ValueNode" max #_"ValueNode" min]
                (if (= (InductionVariable''direction-1 (:iv this)) :Direction'Up)
                    [
                        (InductionVariable''strideNode-1 (:iv this))
                        (MathUtil'sub-3 graph, (:end this), (InductionVariable''initNode-1 (:iv this)))
                        (:end this)
                        (InductionVariable''initNode-1 (:iv this))
                    ]
                    [
                        (Graph''maybeAddOrUnique-2 graph, (NegateNode'create-1 (InductionVariable''strideNode-1 (:iv this))))
                        (MathUtil'sub-3 graph, (InductionVariable''initNode-1 (:iv this)), (:end this))
                        (InductionVariable''initNode-1 (:iv this))
                        (:end this)
                    ]
                )
            #_"ConstantNode" one (ConstantNode'forIntegerStamp-3 stamp, 1, graph)
            range (if (:oneOff this) (MathUtil'add-3 graph, range, one) range)
            ;; round-away-from-zero divison: (range + stride -/+ 1) / stride
            #_"ValueNode" denominator (MathUtil'add-3 graph, range, (MathUtil'sub-3 graph, absStride, one))
            #_"ValueNode" div (MathUtil'unsignedDivBefore-4 graph, (LoopEx''entryPoint-1 (:loop this)), denominator, absStride)
        ]
            (if assumePositive
                div
                (Graph''add-2 graph, (ConditionalNode'new-3 (Graph''add-2 graph, (IntegerLessThanNode'new-2 max, min)), (ConstantNode'forIntegerStamp-3 stamp, 0, graph), div))
            )
        )
    )

    ;;;
     ; @return true if the loop has constant bounds
     ;;
    (§ method! #_"boolean" CountedLoopInfo''isConstantMaxTripCount-1 [#_"CountedLoopInfo" this]
        (and (instance? ConstantNode (:end this)) (InductionVariable''isConstantInit-1 (:iv this)) (InductionVariable''isConstantStride-1 (:iv this)))
    )

    (§ method! #_"UnsignedLong" CountedLoopInfo''constantMaxTripCount-1 [#_"CountedLoopInfo" this]
        (UnsignedLong'new-1 (CountedLoopInfo''rawConstantMaxTripCount-1 this))
    )

    ;;;
     ; Compute the raw value of the trip count for this loop. THIS IS AN UNSIGNED VALUE!
     ;;
    (§ method- #_"long" CountedLoopInfo''rawConstantMaxTripCount-1 [#_"CountedLoopInfo" this]
        (let [
            #_"long" endValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:end this)))
            #_"long" initValue (InductionVariable''constantInit-1 (:iv this))
            [#_"long" range #_"long" absStride]
                (if (= (InductionVariable''direction-1 (:iv this)) :Direction'Up)
                    (if (< endValue initValue)
                        (§ return 0)
                        [(- endValue (InductionVariable''constantInit-1 (:iv this))) (InductionVariable''constantStride-1 (:iv this))]
                    )
                    (if (< initValue endValue)
                        (§ return 0)
                        [(- (InductionVariable''constantInit-1 (:iv this)) endValue) (- (InductionVariable''constantStride-1 (:iv this)))]
                    )
                )
            range (if (:oneOff this) (inc range) range)
        ]
            (Long/divideUnsigned (dec (+ range absStride)), absStride)
        )
    )

    (§ method! #_"boolean" CountedLoopInfo''isExactTripCount-1 [#_"CountedLoopInfo" this]
        (= (-> (LoopEx''loopBegin-1 (:loop this)) (LoopBeginNode''loopExits-1) (NodeIterable''count-1)) 1)
    )

    #_unused
    (§ method! #_"ValueNode" CountedLoopInfo''exactTripCountNode-1 [#_"CountedLoopInfo" this]
        (CountedLoopInfo''maxTripCountNode-1 this)
    )

    (§ method! #_"boolean" CountedLoopInfo''isConstantExactTripCount-1 [#_"CountedLoopInfo" this]
        (CountedLoopInfo''isConstantMaxTripCount-1 this)
    )

    #_unused
    (§ method! #_"UnsignedLong" CountedLoopInfo''constantExactTripCount-1 [#_"CountedLoopInfo" this]
        (CountedLoopInfo''constantMaxTripCount-1 this)
    )

    (§ method! #_"ValueNode" CountedLoopInfo''getStart-1 [#_"CountedLoopInfo" this]
        (InductionVariable''initNode-1 (:iv this))
    )

    #_unused
    (§ method! #_"Direction" CountedLoopInfo''getDirection-1 [#_"CountedLoopInfo" this]
        (InductionVariable''direction-1 (:iv this))
    )

    (§ method! #_"GuardingNode" CountedLoopInfo''getOverFlowGuard-1 [#_"CountedLoopInfo" this]
        (:overflowGuard (LoopEx''loopBegin-1 (:loop this)))
    )

    (§ method! #_"GuardingNode" CountedLoopInfo''createOverFlowGuard-1 [#_"CountedLoopInfo" this]
        (or (CountedLoopInfo''getOverFlowGuard-1 this)
            (let [
                #_"IntegerStamp" stamp (:stamp (InductionVariable''valueNode-1 (:iv this)))
                #_"Graph" graph (:graph (InductionVariable''valueNode-1 (:iv this)))
                #_"ConstantNode" one (ConstantNode'forIntegerStamp-3 stamp, 1, graph)
                #_"CompareNode" cond ;; we use a negated guard with a < condition to achieve a >=
                    (if (= (InductionVariable''direction-1 (:iv this)) :Direction'Up)
                        (let [
                            #_"ValueNode" v1 (MathUtil'sub-3 graph, (ConstantNode'forIntegerStamp-3 stamp, (CodeUtil/maxValue (:bits stamp)), graph), (MathUtil'sub-3 graph, (InductionVariable''strideNode-1 (:iv this)), one))
                        ]
                            (Graph''add-2 graph, (IntegerLessThanNode'new-2 (if (:oneOff this) (MathUtil'sub-3 graph, v1, one) v1), (:end this)))
                        )
                        (let [
                            #_"ValueNode" v1 (MathUtil'add-3 graph, (ConstantNode'forIntegerStamp-3 stamp, (CodeUtil/minValue (:bits stamp)), graph), (MathUtil'sub-3 graph, one, (InductionVariable''strideNode-1 (:iv this))))
                        ]
                            (Graph''add-2 graph, (IntegerLessThanNode'new-2 (:end this), (if (:oneOff this) (MathUtil'add-3 graph, v1, one) v1)))
                        )
                    )
                #_"GuardingNode" overflowGuard (Graph''add-2 graph, (GuardNode'new-6 cond, (AbstractBeginNode'prevBegin-1 (LoopEx''entryPoint-1 (:loop this))), DeoptimizationReason/LoopLimitCheck, DeoptimizationAction/InvalidateRecompile, true, JavaConstant/NULL_POINTER))
            ]
                (§ ass! (LoopEx''loopBegin-1 (:loop this)) (LoopBeginNode''setOverflowGuard-2 (LoopEx''loopBegin-1 (:loop this)), overflowGuard))
                overflowGuard
            )
        )
    )

    (§ method! #_"IntegerStamp" CountedLoopInfo''getStamp-1 [#_"CountedLoopInfo" this]
        (:stamp (InductionVariable''valueNode-1 (:iv this)))
    )
)

(final-ns DefaultLoopPolicies (§ implements LoopPolicies)
    (§ defn #_"DefaultLoopPolicies" DefaultLoopPolicies'new-0 []
        (Object.)
    )

    #_unused
    (§ override! #_"boolean" DefaultLoopPolicies''shouldPeel-3 [#_"DefaultLoopPolicies" this, #_"LoopEx" loop, #_"ControlFlowGraph" cfg]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 loop)
        ]
            (and (< GraalOptions'minimumPeelProbability (:probability (ControlFlowGraph''blockFor-2 cfg, (LoopBeginNode''forwardEnd-1 loopBegin))))
                 (< (+ (LoopEx''size-1 loop) (Graph''getNodeCount-1 (:graph loopBegin))) GraalOptions'maximumDesiredSize)
                 ;; check whether we're allowed to peel this loop
                 (LoopEx''canDuplicateLoop-1 loop)
            )
        )
    )

    #_unused
    (§ override! #_"boolean" DefaultLoopPolicies''shouldFullUnroll-2 [#_"DefaultLoopPolicies" this, #_"LoopEx" loop]
        (and (LoopEx''isCounted-1 loop) (CountedLoopInfo''isConstantMaxTripCount-1 (:counted loop))
            (let [
                #_"CountedLoopInfo" counted (:counted loop)
                #_"UnsignedLong" maxTrips (CountedLoopInfo''constantMaxTripCount-1 counted)
            ]
                (if (zero? maxTrips)
                    (LoopEx''canDuplicateLoop-1 loop)
                    (let [
                        #_"int" maxNodes (if (and (CountedLoopInfo''isExactTripCount-1 counted) (CountedLoopInfo''isConstantExactTripCount-1 counted)) GraalOptions'exactFullUnrollMaxNodes GraalOptions'fullUnrollMaxNodes)
                        maxNodes (min maxNodes (max 0 (- GraalOptions'maximumDesiredSize (Graph''getNodeCount-1 (:graph (LoopEx''loopBegin-1 loop))))))
                        #_"int" size (max 1 (- (LoopEx''size-1 loop) 1 (-> (LoopEx''loopBegin-1 loop) (AbstractMergeNode''phis-1) (NodeIterable''count-1))))
                    ]
                        ;; The check below should not throw ArithmeticException because:
                        ;; maxTrips is guaranteed to be >= 1 by the check above
                        ;; - maxTrips * size can not overfow because:
                        ;;   - maxTrips <= FullUnrollMaxIterations <= Integer.MAX_VALUE
                        ;;   - 1 <= size <= Integer.MAX_VALUE
                        (and (UnsignedLong''isLessOrEqualTo-2 maxTrips, GraalOptions'fullUnrollMaxIterations)
                            (UnsignedLong''isLessOrEqualTo-2 (UnsignedLong''times-2 (UnsignedLong''minus-2 maxTrips, 1), size), maxNodes)
                            ;; check whether we're allowed to unroll this loop
                            (LoopEx''canDuplicateLoop-1 loop)
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"boolean" DefaultLoopPolicies''shouldPartiallyUnroll-2 [#_"DefaultLoopPolicies" this, #_"LoopEx" loop]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 loop)
        ]
            (and (LoopEx''isCounted-1 loop)
                (let [
                    #_"int" maxNodes GraalOptions'exactPartialUnrollMaxNodes
                    maxNodes (min maxNodes (max 0 (- GraalOptions'maximumDesiredSize (Graph''getNodeCount-1 (:graph (LoopEx''loopBegin-1 loop))))))
                    #_"int" size (max 1 (- (LoopEx''size-1 loop) 1 (-> (LoopEx''loopBegin-1 loop) (AbstractMergeNode''phis-1) (NodeIterable''count-1))))
                    #_"int" unrollFactor (:unrollFactor loopBegin)
                ]
                    (when (= unrollFactor 1)
                        (let [
                            #_"double" loopFrequency (:loopFrequency loopBegin)
                        ]
                            (when (and (LoopBeginNode''isSimpleLoop-1 loopBegin) (< loopFrequency 5.0))
                                (§ return false)
                            )
                            (§ ass! loopBegin (LoopBeginNode''setLoopOrigFrequency-2 loopBegin, loopFrequency))
                        )
                    )
                    (let [
                        #_"int" maxUnroll GraalOptions'unrollMaxIterations
                        ;; Now correct size for the next unroll. UnrollMaxIterations == 1 means perform
                        ;; the pre/main/post transformation but don't actually unroll the main loop.
                        size (+ size size)
                    ]
                        (and (or (and (= maxUnroll 1) (LoopBeginNode''isSimpleLoop-1 loopBegin)) (and (<= size maxNodes) (< unrollFactor maxUnroll)))
                            ;; Will the next unroll fit?
                            (<= (* unrollFactor 2) (int (:loopOrigFrequency loopBegin)))
                            ;; check whether we're allowed to unroll this loop
                            (loop-when [#_"ISeq" s (seq (LoopFragmentInside''nodes-1 (LoopEx''inside-1 loop)))] (some? s) => true
                                (let [
                                    #_"Node" node (first s)
                                ]
                                    (when-not (or (instance? ControlFlowAnchorNode node) (instance? InvokeNode node)) => false
                                        (recur (next s))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"boolean" DefaultLoopPolicies''shouldTryUnswitch-2 [#_"DefaultLoopPolicies" this, #_"LoopEx" loop]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 loop)
        ]
            (and (< 1.0 (:loopFrequency loopBegin)) (<= (:unswitches loopBegin) GraalOptions'loopMaxUnswitch))
        )
    )

    #_unused
    (§ override! #_"boolean" DefaultLoopPolicies''shouldUnswitch-3 [#_"DefaultLoopPolicies" this, #_"LoopEx" loop, #_"List<ControlSplitNode>" controlSplits]
        (let [
            #_"Graph" graph (:graph (LoopEx''loopBegin-1 loop))
            #_"NodeBitMap" branchNodes (NodeBitMap'new-1 graph)
            #_"int" phis
                (loop-when [phis 0 #_"ISeq" s (seq controlSplits)] (some? s) => phis
                    (let [
                        #_"ControlSplitNode" controlSplit (first s)
                    ]
                        (doseq [#_"Node" successor (Node''successors-1 controlSplit)]
                            ;; this may count twice because of fall-through in switches
                            (LoopEx''nodesInLoopBranch-3 loop, branchNodes, successor)
                        )
                        (let [
                            #_"Block" postDomBlock (:postdominator (ControlFlowGraph''blockFor-2 (:cfg (:data loop)), controlSplit))
                            phis
                                (when (some? postDomBlock) => phis
                                    (+ phis (NodeIterable''count-1 (AbstractMergeNode''phis-1 (:beginNode postDomBlock))))
                                )
                        ]
                            (recur phis (next s))
                        )
                    )
                )
            #_"int" maxDiff
                (min (+ GraalOptions'loopUnswitchTrivial (int (* GraalOptions'loopUnswitchFrequencyBoost (+ (:loopFrequency (LoopEx''loopBegin-1 loop)) -1.0 phis))))
                     GraalOptions'loopUnswitchMaxIncrease
                     (- GraalOptions'maximumDesiredSize (Graph''getNodeCount-1 graph))
                )
            #_"int" inBranchTotal (NodeBitMap''count-1 branchNodes)
            #_"CountingClosure" stateNodesCount (CountingClosure'new-0)
        ]
            (FrameState''applyToVirtual-2 (BeginStateSplitNode''stateAfter-1 (LoopEx''loopBegin-1 loop)), stateNodesCount)
            (and (<= (- (LoopEx''size-1 loop) (NodeIterable''count-1 (AbstractMergeNode''phis-1 (LoopEx''loopBegin-1 loop))) (:count stateNodesCount) 1 inBranchTotal) maxDiff)
                ;; check whether we're allowed to unswitch this loop
                (LoopEx''canDuplicateLoop-1 loop)
            )
        )
    )
)

;;;
 ; @anno DefaultLoopPolicies.CountingClosure
 ;;
(final-ns CountingClosure (§ implements VirtualClosure)
    (§ mutable #_"int" :count 0)

    (§ defn #_"CountingClosure" CountingClosure'new-0 []
        (Object.)
    )

    #_unused
    (§ override! #_"void" CountingClosure''apply-2 [#_"CountingClosure" this, #_"VirtualState" node]
        (§ ass! this (update this :count inc))
        nil
    )
)

(final-ns DerivedConvertedInductionVariable (§ extends DerivedInductionVariable)
    (§ final #_"Stamp" :stamp nil)
    (§ final #_"ValueNode" :value nil)

    (§ defn #_"DerivedConvertedInductionVariable" DerivedConvertedInductionVariable'new-4 [#_"LoopEx" loop, #_"InductionVariable" base, #_"Stamp" stamp, #_"ValueNode" value]
        (let [
            #_"DerivedConvertedInductionVariable" this (DerivedInductionVariable'new-2 loop, base)
            this (assoc this :stamp stamp)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"ValueNode" DerivedConvertedInductionVariable''valueNode-1 [#_"DerivedConvertedInductionVariable" this]
        (:value this)
    )

    #_unused
    (§ override! #_"Direction" DerivedConvertedInductionVariable''direction-1 [#_"DerivedConvertedInductionVariable" this]
        (InductionVariable''direction-1 (:base this))
    )

    #_unused
    (§ override! #_"ValueNode" DerivedConvertedInductionVariable''initNode-1 [#_"DerivedConvertedInductionVariable" this]
        (IntegerConvertNode'convert-3 (InductionVariable''initNode-1 (:base this)), (:stamp this), (InductionVariable''graph-1 this))
    )

    #_unused
    (§ override! #_"ValueNode" DerivedConvertedInductionVariable''strideNode-1 [#_"DerivedConvertedInductionVariable" this]
        (IntegerConvertNode'convert-3 (InductionVariable''strideNode-1 (:base this)), (:stamp this), (InductionVariable''graph-1 this))
    )

    #_unused
    (§ override! #_"boolean" DerivedConvertedInductionVariable''isConstantInit-1 [#_"DerivedConvertedInductionVariable" this]
        (InductionVariable''isConstantInit-1 (:base this))
    )

    #_unused
    (§ override! #_"boolean" DerivedConvertedInductionVariable''isConstantStride-1 [#_"DerivedConvertedInductionVariable" this]
        (InductionVariable''isConstantStride-1 (:base this))
    )

    #_unused
    (§ override! #_"long" DerivedConvertedInductionVariable''constantInit-1 [#_"DerivedConvertedInductionVariable" this]
        (InductionVariable''constantInit-1 (:base this))
    )

    #_unused
    (§ override! #_"long" DerivedConvertedInductionVariable''constantStride-1 [#_"DerivedConvertedInductionVariable" this]
        (InductionVariable''constantStride-1 (:base this))
    )

    #_unused
    (§ override! #_"ValueNode" DerivedConvertedInductionVariable''extremumNode-3 [#_"DerivedConvertedInductionVariable" this, #_"boolean" assumePositiveTripCount, #_"Stamp" s]
        (InductionVariable''extremumNode-3 (:base this), assumePositiveTripCount, s)
    )

    #_unused
    (§ override! #_"ValueNode" DerivedConvertedInductionVariable''exitValueNode-1 [#_"DerivedConvertedInductionVariable" this]
        (IntegerConvertNode'convert-3 (InductionVariable''exitValueNode-1 (:base this)), (:stamp this), (InductionVariable''graph-1 this))
    )

    #_unused
    (§ override! #_"boolean" DerivedConvertedInductionVariable''isConstantExtremum-1 [#_"DerivedConvertedInductionVariable" this]
        (InductionVariable''isConstantExtremum-1 (:base this))
    )

    #_unused
    (§ override! #_"long" DerivedConvertedInductionVariable''constantExtremum-1 [#_"DerivedConvertedInductionVariable" this]
        (InductionVariable''constantExtremum-1 (:base this))
    )

    #_unused
    (§ override! #_"void" DerivedConvertedInductionVariable''deleteUnusedNodes-1 [#_"DerivedConvertedInductionVariable" this]
        nil
    )
)

;;;
 ; Base class of the derived induction variables.
 ;;
(class-ns DerivedInductionVariable (§ extends InductionVariable)
    (§ final #_"InductionVariable" :base nil)

    (§ defn #_"DerivedInductionVariable" DerivedInductionVariable'new-2 [#_"LoopEx" loop, #_"InductionVariable" base]
        (let [
            #_"DerivedInductionVariable" this (InductionVariable'new-1 loop)
            this (assoc this :base base)
        ]
            this
        )
    )

    #_unused
    (§ override #_"Graph" DerivedInductionVariable''graph-1 [#_"DerivedInductionVariable" this]
        (InductionVariable''graph-1 (:base this))
    )

    (§ method #_"InductionVariable" DerivedInductionVariable''getBase-1 [#_"DerivedInductionVariable" this]
        (:base this)
    )
)

(final-ns DerivedOffsetInductionVariable (§ extends DerivedInductionVariable)
    (§ final #_"ValueNode" :offset nil)
    (§ final #_"BinaryArithmeticNode" :value nil)

    (§ defn #_"DerivedOffsetInductionVariable" DerivedOffsetInductionVariable'new-4 [#_"LoopEx" loop, #_"InductionVariable" base, #_"ValueNode" offset, #_"BinaryArithmeticNode" value]
        (let [
            #_"DerivedOffsetInductionVariable" this (DerivedInductionVariable'new-2 loop, base)
            this (assoc this :offset offset)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Direction" DerivedOffsetInductionVariable''direction-1 [#_"DerivedOffsetInductionVariable" this]
        (InductionVariable''direction-1 (:base this))
    )

    #_unused
    (§ override! #_"ValueNode" DerivedOffsetInductionVariable''valueNode-1 [#_"DerivedOffsetInductionVariable" this]
        (:value this)
    )

    #_unused
    (§ override! #_"boolean" DerivedOffsetInductionVariable''isConstantInit-1 [#_"DerivedOffsetInductionVariable" this]
        (and (instance? ConstantNode (:offset this)) (InductionVariable''isConstantInit-1 (:base this)))
    )

    #_unused
    (§ override! #_"boolean" DerivedOffsetInductionVariable''isConstantStride-1 [#_"DerivedOffsetInductionVariable" this]
        (InductionVariable''isConstantStride-1 (:base this))
    )

    #_unused
    (§ override! #_"long" DerivedOffsetInductionVariable''constantInit-1 [#_"DerivedOffsetInductionVariable" this]
        (DerivedOffsetInductionVariable''op-3 this, (InductionVariable''constantInit-1 (:base this)), (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset this))))
    )

    #_unused
    (§ override! #_"long" DerivedOffsetInductionVariable''constantStride-1 [#_"DerivedOffsetInductionVariable" this]
        (if (and (instance? SubNode (:value this)) (= (InductionVariable''valueNode-1 (:base this)) (:y (:value this))))
            (- (InductionVariable''constantStride-1 (:base this)))
            (InductionVariable''constantStride-1 (:base this))
        )
    )

    #_unused
    (§ override! #_"ValueNode" DerivedOffsetInductionVariable''initNode-1 [#_"DerivedOffsetInductionVariable" this]
        (DerivedOffsetInductionVariable''op-3 this, (InductionVariable''initNode-1 (:base this)), (:offset this))
    )

    #_unused
    (§ override! #_"ValueNode" DerivedOffsetInductionVariable''strideNode-1 [#_"DerivedOffsetInductionVariable" this]
        (if (and (instance? SubNode (:value this)) (= (InductionVariable''valueNode-1 (:base this)) (:y (:value this))))
            (Graph''addOrUniqueWithInputs-2 (InductionVariable''graph-1 this), (NegateNode'create-1 (InductionVariable''strideNode-1 (:base this))))
            (InductionVariable''strideNode-1 (:base this))
        )
    )

    #_unused
    (§ override! #_"ValueNode" DerivedOffsetInductionVariable''extremumNode-3 [#_"DerivedOffsetInductionVariable" this, #_"boolean" assumePositiveTripCount, #_"Stamp" stamp]
        (DerivedOffsetInductionVariable''op-3 this, (InductionVariable''extremumNode-3 (:base this), assumePositiveTripCount, stamp), (IntegerConvertNode'convert-3 (:offset this), stamp, (InductionVariable''graph-1 this)))
    )

    #_unused
    (§ override! #_"ValueNode" DerivedOffsetInductionVariable''exitValueNode-1 [#_"DerivedOffsetInductionVariable" this]
        (DerivedOffsetInductionVariable''op-3 this, (InductionVariable''exitValueNode-1 (:base this)), (:offset this))
    )

    #_unused
    (§ override! #_"boolean" DerivedOffsetInductionVariable''isConstantExtremum-1 [#_"DerivedOffsetInductionVariable" this]
        (and (instance? ConstantNode (:offset this)) (InductionVariable''isConstantExtremum-1 (:base this)))
    )

    #_unused
    (§ override! #_"long" DerivedOffsetInductionVariable''constantExtremum-1 [#_"DerivedOffsetInductionVariable" this]
        (DerivedOffsetInductionVariable''op-3 this, (InductionVariable''constantExtremum-1 (:base this)), (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset this))))
    )

    (§ method- #_"long" DerivedOffsetInductionVariable''op-3 [#_"DerivedOffsetInductionVariable" this, #_"long" b, #_"long" o]
        (condp instance? (:value this)
            AddNode
                (+ b o)
            SubNode
                (if (= (InductionVariable''valueNode-1 (:base this)) (:x (:value this)))
                    (- b o)
                    (- o b)
                )
        )
    )

    (§ method- #_"ValueNode" DerivedOffsetInductionVariable''op-3 [#_"DerivedOffsetInductionVariable" this, #_"ValueNode" b, #_"ValueNode" o]
        (condp instance? (:value this)
            AddNode
                (MathUtil'add-3 (InductionVariable''graph-1 this), b, o)
            SubNode
                (if (= (InductionVariable''valueNode-1 (:base this)) (:x (:value this)))
                    (MathUtil'sub-3 (InductionVariable''graph-1 this), b, o)
                    (MathUtil'sub-3 (InductionVariable''graph-1 this), o, b)
                )
        )
    )

    #_unused
    (§ override! #_"void" DerivedOffsetInductionVariable''deleteUnusedNodes-1 [#_"DerivedOffsetInductionVariable" this]
        nil
    )
)

(final-ns DerivedScaledInductionVariable (§ extends DerivedInductionVariable)
    (§ final #_"ValueNode" :scale nil)
    (§ final #_"ValueNode" :value nil)

    (§ defn #_"DerivedScaledInductionVariable" DerivedScaledInductionVariable'new-4 [#_"LoopEx" loop, #_"InductionVariable" base, #_"ValueNode" scale, #_"ValueNode" value]
        (let [
            #_"DerivedScaledInductionVariable" this (DerivedInductionVariable'new-2 loop, base)
            this (assoc this :scale scale)
            this (assoc this :value value)
        ]
            this
        )
    )

    (§ defn #_"DerivedScaledInductionVariable" DerivedScaledInductionVariable'new-3 [#_"LoopEx" loop, #_"InductionVariable" base, #_"NegateNode" value]
        (let [
            #_"DerivedScaledInductionVariable" this (DerivedInductionVariable'new-2 loop, base)
            this (assoc this :scale (ConstantNode'forIntegerStamp-3 (:stamp value), -1, (:graph value)))
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"ValueNode" DerivedScaledInductionVariable''valueNode-1 [#_"DerivedScaledInductionVariable" this]
        (:value this)
    )

    #_unused
    (§ override! #_"Direction" DerivedScaledInductionVariable''direction-1 [#_"DerivedScaledInductionVariable" this]
        (let [
            #_"Stamp" stamp (:stamp (:scale this))
        ]
            (when (instance? IntegerStamp stamp)
                (cond
                    (IntegerStamp''isStrictlyPositive-1 stamp)                        (InductionVariable''direction-1 (:base this))
                    (IntegerStamp''isStrictlyNegative-1 stamp) (Direction''opposite-1 (InductionVariable''direction-1 (:base this)))
                )
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" DerivedScaledInductionVariable''initNode-1 [#_"DerivedScaledInductionVariable" this]
        (MathUtil'mul-3 (InductionVariable''graph-1 this), (InductionVariable''initNode-1 (:base this)), (:scale this))
    )

    #_unused
    (§ override! #_"ValueNode" DerivedScaledInductionVariable''strideNode-1 [#_"DerivedScaledInductionVariable" this]
        (MathUtil'mul-3 (InductionVariable''graph-1 this), (InductionVariable''strideNode-1 (:base this)), (:scale this))
    )

    #_unused
    (§ override! #_"boolean" DerivedScaledInductionVariable''isConstantInit-1 [#_"DerivedScaledInductionVariable" this]
        (and (instance? ConstantNode (:scale this)) (InductionVariable''isConstantInit-1 (:base this)))
    )

    #_unused
    (§ override! #_"boolean" DerivedScaledInductionVariable''isConstantStride-1 [#_"DerivedScaledInductionVariable" this]
        (and (instance? ConstantNode (:scale this)) (InductionVariable''isConstantStride-1 (:base this)))
    )

    #_unused
    (§ override! #_"long" DerivedScaledInductionVariable''constantInit-1 [#_"DerivedScaledInductionVariable" this]
        (* (InductionVariable''constantInit-1 (:base this)) (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:scale this))))
    )

    #_unused
    (§ override! #_"long" DerivedScaledInductionVariable''constantStride-1 [#_"DerivedScaledInductionVariable" this]
        (* (InductionVariable''constantStride-1 (:base this)) (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:scale this))))
    )

    #_unused
    (§ override! #_"ValueNode" DerivedScaledInductionVariable''extremumNode-3 [#_"DerivedScaledInductionVariable" this, #_"boolean" assumePositiveTripCount, #_"Stamp" stamp]
        (MathUtil'mul-3 (InductionVariable''graph-1 this), (InductionVariable''extremumNode-3 (:base this), assumePositiveTripCount, stamp), (IntegerConvertNode'convert-3 (:scale this), stamp, (InductionVariable''graph-1 this)))
    )

    #_unused
    (§ override! #_"ValueNode" DerivedScaledInductionVariable''exitValueNode-1 [#_"DerivedScaledInductionVariable" this]
        (MathUtil'mul-3 (InductionVariable''graph-1 this), (InductionVariable''exitValueNode-1 (:base this)), (:scale this))
    )

    #_unused
    (§ override! #_"boolean" DerivedScaledInductionVariable''isConstantExtremum-1 [#_"DerivedScaledInductionVariable" this]
        (and (instance? ConstantNode (:scale this)) (InductionVariable''isConstantExtremum-1 (:base this)))
    )

    #_unused
    (§ override! #_"long" DerivedScaledInductionVariable''constantExtremum-1 [#_"DerivedScaledInductionVariable" this]
        (* (InductionVariable''constantExtremum-1 (:base this)) (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:scale this))))
    )

    #_unused
    (§ override! #_"void" DerivedScaledInductionVariable''deleteUnusedNodes-1 [#_"DerivedScaledInductionVariable" this]
        (GraphUtil'tryKillUnused-1 (:scale this))
        nil
    )
)

;;;
 ; This class describes a value node that is an induction variable in a counted loop.
 ;;
(class-ns InductionVariable
    (§ abstract #_"Graph" InductionVariable''graph-1 [#_"InductionVariable" this])

    (§ final #_"LoopEx" :loop nil)

    (§ defn #_"InductionVariable" InductionVariable'new-1 [#_"LoopEx" loop]
        (let [
            #_"InductionVariable" this (Object.)
            this (assoc this :loop loop)
        ]
            this
        )
    )

    #_unused
    (§ method #_"LoopEx" InductionVariable''getLoop-1 [#_"InductionVariable" this]
        (:loop this)
    )

    (§ abstract #_"Direction" InductionVariable''direction-1 [#_"InductionVariable" this])

    ;;;
     ; Returns the value node that is described by this induction variable.
     ;;
    (§ abstract #_"ValueNode" InductionVariable''valueNode-1 [#_"InductionVariable" this])

    ;;;
     ; Returns the node that gives the initial value of this induction variable.
     ;;
    (§ abstract #_"ValueNode" InductionVariable''initNode-1 [#_"InductionVariable" this])

    ;;;
     ; Returns the stride of the induction variable. The stride is the value that is added to the
     ; induction variable at each iteration.
     ;;
    (§ abstract #_"ValueNode" InductionVariable''strideNode-1 [#_"InductionVariable" this])

    (§ abstract #_"boolean" InductionVariable''isConstantInit-1 [#_"InductionVariable" this])

    (§ abstract #_"boolean" InductionVariable''isConstantStride-1 [#_"InductionVariable" this])

    (§ abstract #_"long" InductionVariable''constantInit-1 [#_"InductionVariable" this])

    (§ abstract #_"long" InductionVariable''constantStride-1 [#_"InductionVariable" this])

    ;;;
     ; Returns the extremum value of the induction variable. The extremum value is the value of the
     ; induction variable in the loop body of the last iteration, only taking into account the main
     ; loop limit test. It's possible for the loop to exit before this value if
     ; CountedLoopInfo#isExactTripCount() returns false for the containing loop.
     ;;
    #_unused
    (§ method #_"ValueNode" InductionVariable''extremumNode-1 [#_"InductionVariable" this]
        (InductionVariable''extremumNode-3 this, false, (:stamp (InductionVariable''valueNode-1 this)))
    )

    (§ abstract #_"ValueNode" InductionVariable''extremumNode-3 [#_"InductionVariable" this, #_"boolean" assumePositiveTripCount, #_"Stamp" stamp])

    (§ abstract #_"boolean" InductionVariable''isConstantExtremum-1 [#_"InductionVariable" this])

    (§ abstract #_"long" InductionVariable''constantExtremum-1 [#_"InductionVariable" this])

    ;;;
     ; Returns the exit value of the induction variable. The exit value is the value of the
     ; induction variable at the loop exit.
     ;;
    (§ abstract #_"ValueNode" InductionVariable''exitValueNode-1 [#_"InductionVariable" this])

    ;;;
     ; Deletes any nodes created within the scope of this object that have no usages.
     ;;
    (§ abstract #_"void" InductionVariable''deleteUnusedNodes-1 [#_"InductionVariable" this])
)

;;;
 ; @anno InductionVariable.Direction
 ;;
(value-ns Direction
    :Direction'Up
    :Direction'Down

    (§ method! #_"Direction" Direction''opposite-1 [#_"Direction" this]
        (case this
            :Direction'Up :Direction'Down
            :Direction'Down :Direction'Up
        )
    )
)

(final-ns LoopEx
    (§ final #_"Loop" :loop nil)
    (§ mutable #_"LoopFragmentInside" :inside nil)
    (§ mutable #_"LoopFragmentWhole" :whole nil)
    (§ mutable #_"CountedLoopInfo" :counted nil)
    (§ mutable #_"LoopsData" :data nil)
    (§ mutable #_"EconomicMap<Node, InductionVariable>" :ivs nil)

    (§ defn #_"LoopEx" LoopEx'new-2 [#_"Loop" loop, #_"LoopsData" data]
        (let [
            #_"LoopEx" this (Object.)
            this (assoc this :loop loop)
            this (assoc this :data data)
        ]
            this
        )
    )

    (§ method! #_"LoopFragmentInside" LoopEx''inside-1 [#_"LoopEx" this]
        (when (nil? (:inside this))
            (§ ass! this (assoc this :inside (LoopFragmentInside'new-1 this)))
        )
        (:inside this)
    )

    (§ method! #_"LoopFragmentWhole" LoopEx''whole-1 [#_"LoopEx" this]
        (when (nil? (:whole this))
            (§ ass! this (assoc this :whole (LoopFragmentWhole'new-1 this)))
        )
        (:whole this)
    )

    (§ method! #_"LoopEx" LoopEx''invalidateFragments-1 [#_"LoopEx" this]
        (let [
            this (assoc this :inside nil)
            this (assoc this :whole nil)
        ]
            this
        )
    )

    #_unused
    (§ method! #_"LoopFragmentInsideFrom" LoopEx''insideFrom-2 [#_"LoopEx" this, #_"FixedNode" point]
        ;; TODO
        nil
    )

    #_unused
    (§ method! #_"LoopFragmentInsideBefore" LoopEx''insideBefore-2 [#_"LoopEx" this, #_"FixedNode" point]
        ;; TODO
        nil
    )

    (§ method! #_"boolean" LoopEx''isOutsideLoop-2 [#_"LoopEx" this, #_"Node" node]
        (not (LoopFragment''contains-2 (LoopEx''whole-1 this), node))
    )

    (§ method! #_"LoopBeginNode" LoopEx''loopBegin-1 [#_"LoopEx" this]
        (:beginNode (:header (:loop this)))
    )

    #_unused
    (§ method! #_"FixedNode" LoopEx''predecessor-1 [#_"LoopEx" this]
        (:predecessor (LoopBeginNode''forwardEnd-1 (LoopEx''loopBegin-1 this)))
    )

    (§ method! #_"FixedNode" LoopEx''entryPoint-1 [#_"LoopEx" this]
        (LoopBeginNode''forwardEnd-1 (LoopEx''loopBegin-1 this))
    )

    (§ method! #_"boolean" LoopEx''isCounted-1 [#_"LoopEx" this]
        (some? (:counted this))
    )

    #_unused
    (§ method! #_"LoopEx" LoopEx''parent-1 [#_"LoopEx" this]
        (when (some? (:parent (:loop this)))
            (LoopsData''loop-2 (:data this), (:parent (:loop this)))
        )
    )

    (§ method! #_"int" LoopEx''size-1 [#_"LoopEx" this]
        (-> (LoopEx''whole-1 this) (LoopFragmentWhole''nodes-1) (NodeBitMap''count-1))
    )

    (§ method! #_"boolean" LoopEx''reassociateInvariants-1 [#_"LoopEx" this]
        (let [
            #_"Graph" graph (:graph (LoopEx''loopBegin-1 this))
            #_"InvariantPredicate" invariant (InvariantPredicate'new-1 this)
        ]
            (loop-when [#_"int" n 0 #_"ISeq" s (seq (NodeIterable''filter-2 (LoopFragmentWhole''nodes-1 (LoopEx''whole-1 this)), BinaryArithmeticNode))] (some? s) => (pos? n)
                (let [
                    #_"BinaryArithmeticNode" binary (first s)
                    n
                        (when (BinaryArithmeticNode''isAssociative-1 binary) => n
                            (let [
                                #_"ValueNode" result (BinaryArithmeticNode'reassociate-4 binary, invariant, (:x binary), (:y binary))
                            ]
                                (when-not (= result binary) => n
                                    (let [
                                        result
                                            (when-not (Node''isAlive-1 result) => result
                                                (Graph''addOrUniqueWithInputs-2 graph, result)
                                            )
                                    ]
                                        (§ ass! binary (Node''replaceAtUsages-2 binary, result))
                                        (GraphUtil'killWithUnusedFloatingInputs-1 binary)
                                        (inc n)
                                    )
                                )
                            )
                        )
                ]
                    (recur n (next s))
                )
            )
        )
    )

    (§ method! #_"boolean" LoopEx''detectCounted-1 [#_"LoopEx" this]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 this)
            #_"FixedNode" next
                (loop-when-recur [next (:next loopBegin)]
                                 (or (instance? FixedGuardNode next) (instance? ValueAnchorNode next))
                                 [(:next next)]
                              => next
                )
        ]
            (and (instance? IfNode next)
                (let [
                    #_"IfNode" ifNode next
                    #_"boolean" negated? false
                ]
                    (when-not (LoopBeginNode''isLoopExit-2 loopBegin, (:falseSuccessor ifNode))
                        (when-not (LoopBeginNode''isLoopExit-2 loopBegin, (:trueSuccessor ifNode))
                            (§ return false)
                        )
                        (§ ass negated? true)
                    )
                    (let [
                        #_"LogicNode" ifTest (:condition ifNode)
                    ]
                        (and (or (instance? IntegerLessThanNode ifTest) (instance? IntegerEqualsNode ifTest))
                            (let [
                                [#_"InductionVariable" iv #_"Condition" condition #_"ValueNode" limit]
                                    (cond
                                        (LoopEx''isOutsideLoop-2 this, (:x ifTest))
                                            (let [
                                                iv (get (LoopEx''getInductionVariables-1 this) (:y ifTest))
                                            ]
                                                (when (some? iv)
                                                    [iv (Condition''mirror-1 (:condition (CompareNode''condition-1 ifTest))) (:x ifTest)]
                                                )
                                            )
                                        (LoopEx''isOutsideLoop-2 this, (:y ifTest))
                                            (let [
                                                iv (get (LoopEx''getInductionVariables-1 this) (:x ifTest))
                                            ]
                                                (when (some? iv)
                                                    [iv (:condition (CompareNode''condition-1 ifTest)) (:y ifTest)]
                                                )
                                            )
                                    )
                            ]
                                (and (some? condition)
                                    (let [
                                        condition (if negated? (Condition''negate-1 condition) condition)
                                        #_"boolean" oneOff (§ tbd )
                                    ]
                                        (condp = condition
                                            Condition'EQ
                                                (§ return false)
                                            Condition'NE
                                            (do
                                                (when-not (and (InductionVariable''isConstantStride-1 iv) (= (abs (InductionVariable''constantStride-1 iv)) 1))
                                                    (§ return false)
                                                )
                                                (let [
                                                    #_"IntegerStamp" initStamp (:stamp (InductionVariable''initNode-1 iv))
                                                    #_"IntegerStamp" limitStamp (:stamp limit)
                                                ]
                                                    (case (InductionVariable''direction-1 iv)
                                                        :Direction'Up
                                                        (do
                                                            (when (< (:lowerBound limitStamp) (:upperBound initStamp))
                                                                (§ return false)
                                                            )
                                                            (§ ass oneOff false)
                                                        )
                                                        :Direction'Down
                                                        (do
                                                            (when (< (:lowerBound initStamp) (:upperBound limitStamp))
                                                                (§ return false)
                                                            )
                                                            (§ ass oneOff false)
                                                        )
                                                        (§ return false)
                                                    )
                                                )
                                            )
                                            Condition'LE
                                            (do
                                                (when-not (= (InductionVariable''direction-1 iv) :Direction'Up)
                                                    (§ return false)
                                                )
                                                (§ ass oneOff true)
                                            )
                                            Condition'LT
                                            (do
                                                (when-not (= (InductionVariable''direction-1 iv) :Direction'Up)
                                                    (§ return false)
                                                )
                                                (§ ass oneOff false)
                                            )
                                            Condition'GE
                                            (do
                                                (when-not (= (InductionVariable''direction-1 iv) :Direction'Down)
                                                    (§ return false)
                                                )
                                                (§ ass oneOff true)
                                            )
                                            Condition'GT
                                            (do
                                                (when-not (= (InductionVariable''direction-1 iv) :Direction'Down)
                                                    (§ return false)
                                                )
                                                (§ ass oneOff false)
                                            )
                                        )
                                        (§ ass! this (assoc this :counted (CountedLoopInfo'new-6 this, iv, ifNode, limit, oneOff, (if negated? (:falseSuccessor ifNode) (:trueSuccessor ifNode)))))
                                        true
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"void" LoopEx''nodesInLoopBranch-3 [#_"LoopEx" this, #_"NodeBitMap" branchNodes, #_"AbstractBeginNode" branch]
        (let [
            #_"EconomicSet<AbstractBeginNode>" blocks (EconomicSet/create)
            #_"Collection<AbstractBeginNode>" exits (LinkedList.)
            #_"Queue<Block>" work (LinkedList.)
        ]
            (#_"Queue" .add work, (ControlFlowGraph''blockFor-2 (:cfg (:data this)), branch))
            (while (not (#_"Queue" .isEmpty work))
                (let [
                    #_"Block" b (#_"Queue" .remove work)
                ]
                    (cond
                        (#_"List" .contains (:exits (:loop this)), b)
                            (#_"Collection" .add exits, (:beginNode b))
                        (#_"EconomicSet" .add blocks, (:beginNode b))
                            (loop-when-recur [#_"Block" d (:dominatedSibling b)] (some? d) [(:dominatedSibling d)]
                                (when (#_"List" .contains (:blocks (:loop this)), d)
                                    (#_"Queue" .add work, d)
                                )
                            )
                    )
                )
            )
            (LoopFragment'computeNodes-4 branchNodes, (:graph branch), blocks, exits)
        )
        nil
    )

    (§ method! #_"EconomicMap<Node, InductionVariable>" LoopEx''getInductionVariables-1 [#_"LoopEx" this]
        (when (nil? (:ivs this))
            (§ ass! this (assoc this :ivs (LoopEx'findInductionVariables-1 this)))
        )
        (:ivs this)
    )

    ;;;
     ; Collect all the basic induction variables for the loop and the find any induction variables
     ; which are derived from the basic ones.
     ;
     ; @return a map from node to induction variable
     ;;
    (§ defn- #_"EconomicMap<Node, InductionVariable>" LoopEx'findInductionVariables-1 [#_"LoopEx" loop]
        (let [
            #_"EconomicMap<Node, InductionVariable>" ivs (EconomicMap/create Equivalence/IDENTITY)
            #_"Queue<InductionVariable>" scanQueue (LinkedList.)
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 loop)
            #_"AbstractEndNode" forwardEnd (LoopBeginNode''forwardEnd-1 loopBegin)
        ]
            (doseq [#_"PhiNode" phi (AbstractMergeNode''valuePhis-1 loopBegin)]
                (let [
                    #_"ValueNode" backValue (PhiNode''singleBackValueOrThis-1 phi)
                ]
                    (when-not (= backValue phi)
                        (let [
                            #_"ValueNode" stride (LoopEx'addSub-3 loop, backValue, phi)
                        ]
                            (when (some? stride)
                                (let [
                                    #_"BasicInductionVariable" biv (BasicInductionVariable'new-5 loop, phi, (PhiNode''valueAt-2 phi, forwardEnd), stride, backValue)
                                ]
                                    (#_"EconomicMap" .put ivs, phi, biv)
                                    (#_"Queue" .add scanQueue, biv)
                                )
                            )
                        )
                    )
                )
            )
            (while (not (#_"Queue" .isEmpty scanQueue))
                (let [
                    #_"InductionVariable" baseIv (#_"Queue" .remove scanQueue)
                    #_"ValueNode" baseIvNode (InductionVariable''valueNode-1 baseIv)
                ]
                    (doseq [#_"ValueNode" op (NodeIterable''filter-2 (Node''usages-1 baseIvNode), ValueNode)]
                        (cond
                            (LoopEx''isOutsideLoop-2 loop, op)
                                nil
                            (and (= (NodeIterable''count-1 (Node''usages-1 op)) 1) (= (NodeIterable''first-1 (Node''usages-1 op)) baseIvNode))
                                nil ;; This is just the base induction variable increment with no other uses, so don't bother reporting it.
                            :else
                                (let [
                                    #_"ValueNode" offset (LoopEx'addSub-3 loop, op, baseIvNode)
                                    #_"InductionVariable" iv
                                        (cond
                                            (some? offset)            (DerivedOffsetInductionVariable'new-4 loop, baseIv, offset, op)
                                            (instance? NegateNode op) (DerivedScaledInductionVariable'new-3 loop, baseIv,         op)
                                            :else
                                                (let [
                                                    #_"ValueNode" scale (LoopEx'mul-3 loop, op, baseIvNode)
                                                ]
                                                    (cond
                                                        (some? scale) (DerivedScaledInductionVariable'new-4 loop, baseIv, scale, op)
                                                        :else
                                                            (let [
                                                                #_"boolean" valid? (or (instance? PiNode op) (instance? SignExtendNode op))
                                                                valid?
                                                                    (when (and (not valid?) (instance? ZeroExtendNode op)) => valid?
                                                                        (or (:inputAlwaysPositive op) (IntegerStamp''isPositive-1 (:stamp op)))
                                                                    )
                                                            ]
                                                                (when valid?
                                                                    (DerivedConvertedInductionVariable'new-4 loop, baseIv, (:stamp op), op)
                                                                )
                                                            )
                                                    )
                                                )
                                        )
                                ]
                                    (when (some? iv)
                                        (#_"EconomicMap" .put ivs, op, iv)
                                        (#_"Queue" .offer scanQueue, iv)
                                    )
                                )
                        )
                    )
                )
            )
            ivs
        )
    )

    (§ defn- #_"ValueNode" LoopEx'addSub-3 [#_"LoopEx" loop, #_"ValueNode" op, #_"ValueNode" base]
        (when (and (instance? IntegerStamp (:stamp op)) (or (instance? AddNode op) (instance? SubNode op)))
            (cond
                (and (= (:x op) base) (LoopEx''isOutsideLoop-2 loop, (:y op))) (:y op)
                (and (= (:y op) base) (LoopEx''isOutsideLoop-2 loop, (:x op))) (:x op)
            )
        )
    )

    (§ defn- #_"ValueNode" LoopEx'mul-3 [#_"LoopEx" loop, #_"ValueNode" op, #_"ValueNode" base]
        (condp instance? op
            MulNode
                (cond
                    (and (= (:x op) base) (LoopEx''isOutsideLoop-2 loop, (:y op))) (:y op)
                    (and (= (:y op) base) (LoopEx''isOutsideLoop-2 loop, (:x op))) (:x op)
                )
            LeftShiftNode
                (when (and (= (:x op) base) (instance? ConstantNode (:y op)))
                    (ConstantNode'forIntegerStamp-3 (:stamp base), (<< 1 (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y op)))), (:graph base))
                )
            nil
        )
    )

    ;;;
     ; Deletes any nodes created within the scope of this object that have no usages.
     ;;
    (§ method! #_"void" LoopEx''deleteUnusedNodes-1 [#_"LoopEx" this]
        (when (some? (:ivs this))
            (doseq [#_"InductionVariable" iv (vals (:ivs this))]
                (InductionVariable''deleteUnusedNodes-1 iv)
            )
        )
        nil
    )

    ;;;
     ; Returns true if all nodes in the loop can be duplicated.
     ;;
    (§ method! #_"boolean" LoopEx''canDuplicateLoop-1 [#_"LoopEx" this]
        (loop-when [#_"ISeq" s (seq (LoopFragmentInside''nodes-1 (LoopEx''inside-1 this)))] (some? s) => true
            (and (not (instance? ControlFlowAnchored (first s)))
                (recur (next s))
            )
        )
    )
)

;;;
 ; @anno LoopEx.InvariantPredicate
 ;;
(final-ns InvariantPredicate (§ implements NodePredicate)
    (§ final #_"LoopEx" :loopEx nil)
    (§ final #_"NodeMark" :mark nil)

    (§ defn #_"InvariantPredicate" InvariantPredicate'new-1 [#_"LoopEx" loopEx]
        (let [
            #_"InvariantPredicate" this (Object.)
            this (assoc this :loopEx loopEx)
            this (assoc this :mark (NodeMark'new-1 (:graph (LoopEx''loopBegin-1 loopEx))))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" InvariantPredicate''apply-2 [#_"InvariantPredicate" this, #_"Node" node]
        (and (< (:id node) (:value (:mark this))) ;; newly created nodes are unknown
            (LoopEx''isOutsideLoop-2 (:loopEx this), node)
        )
    )
)

(class-ns LoopFragment
    ;;;
     ; The original LoopEx for this fragment. For duplicated fragments this is nil.
     ;;
    (§ final #_"LoopEx" :loop nil)
    (§ final #_"LoopFragment" :original nil)
    (§ mutable #_"NodeBitMap" :nodes nil)
    (§ mutable #_"boolean" :nodesReady false)
    (§ mutable #_"EconomicMap<Node, Node>" :duplicationMap nil)

    (§ defn #_"LoopFragment" LoopFragment'new-1 [#_"LoopEx" loop]
        (let [
            #_"LoopFragment" this (LoopFragment'new-2 loop, nil)
            this (assoc this :nodesReady true)
        ]
            this
        )
    )

    (§ defn #_"LoopFragment" LoopFragment'new-2 [#_"LoopEx" loop, #_"LoopFragment" original]
        (let [
            #_"LoopFragment" this (Object.)
            this (assoc this :loop loop)
            this (assoc this :original original)
            this (assoc this :nodesReady false)
        ]
            this
        )
    )

    #_unused
    (§ abstract #_"LoopFragment" LoopFragment''duplicate-1 [#_"LoopFragment" this])

    #_unused
    (§ abstract #_"void" LoopFragment''insertBefore-2 [#_"LoopFragment" this, #_"LoopEx" l])

    #_unused
    (§ method! #_"void" LoopFragment''disconnect-1 [#_"LoopFragment" this]
        ;; TODO possibly abstract
        nil
    )

    (§ method #_"boolean" LoopFragment''contains-2 [#_"LoopFragment" this, #_"Node" node]
        (NodeBitMap''isMarkedAndGrow-2 (LoopFragment''nodes-1 this), node)
    )

    (§ method! #_"<New extends Node, Old extends New> New" LoopFragment''getDuplicatedNode-2 [#_"LoopFragment" this, #_"Old" n]
        (get (:duplicationMap this) n)
    )

    (§ method! #_"<New extends Node, Old extends New> void" LoopFragment''putDuplicatedNode-3 [#_"LoopFragment" this, #_"Old" oldNode, #_"New" newNode]
        (#_"EconomicMap" .put (:duplicationMap this), oldNode, newNode)
        nil
    )

    ;;;
     ; Gets the corresponding value in this fragment. Should be called on duplicate fragments with a
     ; node from the original fragment as argument.
     ;
     ; @param b original value
     ; @return corresponding value in the peel
     ;;
    (§ abstract #_"ValueNode" LoopFragment''prim-2 [#_"LoopFragment" this, #_"ValueNode" b])

    (§ method! #_"boolean" LoopFragment''isDuplicate-1 [#_"LoopFragment" this]
        (some? (:original this))
    )

    (§ abstract #_"NodeBitMap" LoopFragment''nodes-1 [#_"LoopFragment" this])

    (§ method #_"Graph" LoopFragment''graph-1 [#_"LoopFragment" this]
        (:graph (LoopEx''loopBegin-1 (:loop (if (LoopFragment''isDuplicate-1 this) (:original this) this))))
    )

    (§ abstract #_"DuplicationReplacement" LoopFragment''getDuplicationReplacement-1 [#_"LoopFragment" this])

    (§ abstract #_"void" LoopFragment''beforeDuplication-1 [#_"LoopFragment" this])

    (§ abstract #_"void" LoopFragment''finishDuplication-1 [#_"LoopFragment" this])

    (§ method! #_"LoopFragment" LoopFragment''patchNodes-2 [#_"LoopFragment" this, #_"DuplicationReplacement" dataFix]
        (when (and (LoopFragment''isDuplicate-1 this) (not (:nodesReady this))) => this
            (let [
                #_"DuplicationReplacement" cfgFix (LoopFragment''getDuplicationReplacement-1 (:original this))
                #_"DuplicationReplacement" dr
                    (cond
                        (and (nil? cfgFix) (some? dataFix)) dataFix
                        (and (some? cfgFix) (nil? dataFix)) cfgFix
                        (and (some? cfgFix) (some? dataFix))
                            (§ reify #_"DuplicationReplacement" (DuplicationReplacement'reify-0)
                                (§ override! #_"Node" DuplicationReplacement''replacement-2 [#_"DuplicationReplacement" this, #_"Node" o]
                                    (let [
                                        #_"Node" r1 (DuplicationReplacement''replacement-2 dataFix, o)
                                    ]
                                        (if-not (= r1 o)
                                            r1
                                            (let [
                                                #_"Node" r2 (DuplicationReplacement''replacement-2 cfgFix, o)
                                            ]
                                                (if-not (= r2 o)
                                                    r2
                                                    o
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                    )
                _ (LoopFragment''beforeDuplication-1 this)
                #_"NodeIterable<Node>" nodesIterable (LoopFragment''nodes-1 (:original this))
                this (assoc this :duplicationMap (Graph''addDuplicates-5 (LoopFragment''graph-1 this), nodesIterable, (LoopFragment''graph-1 this), (NodeIterable''count-1 nodesIterable), dr))
                _ (LoopFragment''finishDuplication-1 this)
                this (assoc this :nodes (NodeBitMap'new-1 (LoopFragment''graph-1 this)))
            ]
                (NodeBitMap''markAll-2 (:nodes this), (vals (:duplicationMap this)))
                (assoc this :nodesReady true)
            )
        )
    )

    #_unused
    (§ defn #_"NodeBitMap" LoopFragment'computeNodes-2 [#_"Graph" graph, #_"Iterable<AbstractBeginNode>" blocks]
        (LoopFragment'computeNodes-3 graph, blocks, (Collections/emptyList))
    )

    (§ defn #_"NodeBitMap" LoopFragment'computeNodes-3 [#_"Graph" graph, #_"Iterable<AbstractBeginNode>" blocks, #_"Iterable<AbstractBeginNode>" earlyExits]
        (let [
            #_"NodeBitMap" nodes (NodeBitMap'new-1 graph)
        ]
            (LoopFragment'computeNodes-4 nodes, graph, blocks, earlyExits)
            nodes
        )
    )

    (§ defn #_"void" LoopFragment'computeNodes-4 [#_"NodeBitMap" nodes, #_"Graph" graph, #_"Iterable<AbstractBeginNode>" blocks, #_"Iterable<AbstractBeginNode>" earlyExits]
        (doseq [#_"AbstractBeginNode" block blocks]
            (when-not (Node''isDeleted-1 block)
                (doseq [#_"Node" node (AbstractBeginNode''getBlockNodes-1 block)]
                    (when (instance? InvokeNode node)
                        (NodeBitMap''mark-2 nodes, (:callTarget node))
                    )
                    (when (instance? NodeWithState node)
                        (#_"Iterable" .forEach (NodeWithState''states-1 node), (ß state -> (§ fun (FrameState''applyToVirtual-2 state, (ß node -> (NodeBitMap''mark-2 nodes, node))))))
                    )
                    (when (instance? AbstractMergeNode node)
                        ;; if a merge is in the loop, all of its phis are also in the loop
                        (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 node)]
                            (NodeBitMap''mark-2 nodes, phi)
                        )
                    )
                    (NodeBitMap''mark-2 nodes, node)
                )
            )
        )
        (doseq [#_"AbstractBeginNode" earlyExit earlyExits]
            (when-not (Node''isDeleted-1 earlyExit)
                (NodeBitMap''mark-2 nodes, earlyExit)
                (when (instance? LoopExitNode earlyExit)
                    (let [
                        #_"FrameState" stateAfter (BeginStateSplitNode''stateAfter-1 earlyExit)
                    ]
                        (when (some? stateAfter)
                            (FrameState''applyToVirtual-2 stateAfter, (ß node -> (§ fun (NodeBitMap''mark-2 nodes, node))))
                        )
                        (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 earlyExit)]
                            (NodeBitMap''mark-2 nodes, proxy)
                        )
                    )
                )
            )
        )

        (let [
            #_"NodeBitMap" nonLoopNodes (NodeBitMap'new-1 graph)
            #_"Deque<WorkListEntry>" worklist (ArrayDeque.)
        ]
            (doseq [#_"AbstractBeginNode" block blocks]
                (when-not (Node''isDeleted-1 block)
                    (doseq [#_"Node" node (AbstractBeginNode''getBlockNodes-1 block)]
                        (when (instance? CommitAllocationNode node)
                            (doseq [#_"VirtualObjectNode" obj (:virtualObjects node)]
                                (LoopFragment'markFloating-4 worklist, obj, nodes, nonLoopNodes)
                            )
                        )
                        (when (instance? MonitorEnterNode node)
                            (LoopFragment'markFloating-4 worklist, (:monitorId node), nodes, nonLoopNodes)
                        )
                        (when (instance? AbstractMergeNode node)
                            ;; Since we already marked all phi nodes as being in the loop to break cycles,
                            ;; we also have to iterate over their usages here.
                            (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 node)]
                                (doseq [#_"Node" usage (Node''usages-1 phi)]
                                    (LoopFragment'markFloating-4 worklist, usage, nodes, nonLoopNodes)
                                )
                            )
                        )
                        (doseq [#_"Node" usage (Node''usages-1 node)]
                            (LoopFragment'markFloating-4 worklist, usage, nodes, nonLoopNodes)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"TriState" LoopFragment'isLoopNode-3 [#_"Node" node, #_"NodeBitMap" loopNodes, #_"NodeBitMap" nonLoopNodes]
        (cond
            (NodeBitMap''isMarked-2 loopNodes, node)                 TriState/TRUE
            (NodeBitMap''isMarked-2 nonLoopNodes, node)              TriState/FALSE
            ;; phi nodes are treated the same as fixed nodes in this algorithm to break cycles
            (or (instance? FixedNode node) (instance? PhiNode node)) TriState/FALSE
            :else                                                    TriState/UNKNOWN
        )
    )

    (§ defn- #_"void" LoopFragment'markFloating-4 [#_"Deque<WorkListEntry>" workList, #_"Node" start, #_"NodeBitMap" loopNodes, #_"NodeBitMap" nonLoopNodes]
        (when-not (#_"TriState" .isKnown (LoopFragment'isLoopNode-3 start, loopNodes, nonLoopNodes))
            (#_"Deque" .push workList, (WorkListEntry'new-2 start, loopNodes))
            (while (seq workList)
                (let [
                    #_"WorkListEntry" currentEntry (#_"Deque" .peek workList)
                ]
                    (if (#_"Iterator" .hasNext (:usages currentEntry))
                        (let [
                            #_"Node" current (#_"Iterator" .next (:usages currentEntry))
                            #_"TriState" result (LoopFragment'isLoopNode-3 current, loopNodes, nonLoopNodes)
                        ]
                            (if (#_"TriState" .isKnown result)
                                (when (#_"TriState" .toBoolean result)
                                    (§ ass currentEntry (assoc currentEntry :isLoopNode true))
                                )
                                (#_"Deque" .push workList, (WorkListEntry'new-2 current, loopNodes))
                            )
                        )
                        (do
                            (#_"Deque" .pop workList)
                            (let [
                                #_"boolean" isLoopNode (:isLoopNode currentEntry)
                                #_"Node" current (:n currentEntry)
                            ]
                                (when (and (not isLoopNode) (instance? GuardNode current))
                                    ;; this is only OK if we are not going to make loop transforms based on this
                                    (§ ass isLoopNode true)
                                )
                                (if isLoopNode
                                    (do
                                        (NodeBitMap''mark-2 loopNodes, current)
                                        (loop-when-recur [#_"ISeq" s (seq workList)] (some? s) [(next s)]
                                            (let [
                                                #_"WorkListEntry" e (first s)
                                            ]
                                                (§ ass! e (assoc e :isLoopNode true))
                                            )
                                        )
                                    )
                                    (NodeBitMap''mark-2 nonLoopNodes, current)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"NodeIterable<AbstractBeginNode>" LoopFragment'toHirBlocks-1 [#_"Iterable<Block>" blocks]
        (§ reify #_"NodeIterable<AbstractBeginNode>" (NodeIterable'reify-0)
            (§ override! #_"Iterator<AbstractBeginNode>" #_"Iterable" .iterator [#_"NodeIterable<AbstractBeginNode>" this]
                (let [
                    #_"Iterator<Block>" it (#_"Iterable" .iterator blocks)
                ]
                    (§ reify #_"Iterator<AbstractBeginNode>" (Iterator.)
                        (§ override! #_"AbstractBeginNode" #_"Iterator" .next [#_"Iterator<AbstractBeginNode>" this]
                            (:beginNode (#_"Iterator" .next it))
                        )

                        (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<AbstractBeginNode>" this]
                            (#_"Iterator" .hasNext it)
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"NodeIterable<AbstractBeginNode>" LoopFragment'toHirExits-1 [#_"Iterable<Block>" blocks]
        (§ reify #_"NodeIterable<AbstractBeginNode>" (NodeIterable'reify-0)
            (§ override! #_"Iterator<AbstractBeginNode>" #_"Iterable" .iterator [#_"NodeIterable<AbstractBeginNode>" this]
                (let [
                    #_"Iterator<Block>" it (#_"Iterable" .iterator blocks)
                ]
                    (§ reify #_"Iterator<AbstractBeginNode>" (Iterator.)
                        ;;;
                            ; Return the true LoopExitNode for this loop or the BeginNode for the block.
                            ;;
                        (§ override! #_"AbstractBeginNode" #_"Iterator" .next [#_"Iterator<AbstractBeginNode>" this]
                            (let [
                                #_"Block" next (#_"Iterator" .next it)
                            ]
                                (or (Block''getLoopExit-1 next) (:beginNode next))
                            )
                        )

                        (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<AbstractBeginNode>" this]
                            (#_"Iterator" .hasNext it)
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Merges the early exits (i.e. loop exits) that were duplicated as part of this fragment
     ; with the original fragment's exits.
     ;;
    (§ method! #_"void" LoopFragment''mergeEarlyExits-1 [#_"LoopFragment" this]
        (let [
            #_"Graph" graph (LoopFragment''graph-1 this)
        ]
            (doseq [#_"AbstractBeginNode" earlyExit (LoopFragment'toHirBlocks-1 (:exits (:loop (:loop (:original this)))))]
                (let [
                    #_"FixedNode" next (:next earlyExit)
                ]
                    (when (and (not (Node''isDeleted-1 earlyExit)) (LoopFragment''contains-2 (:original this), earlyExit))
                        (let [
                            #_"AbstractBeginNode" newEarlyExit (LoopFragment''getDuplicatedNode-2 this, earlyExit)
                        ]
                            (when (some? newEarlyExit)
                                (let [
                                    #_"MergeNode" merge (Graph''add-2 graph, (MergeNode'new-0))
                                    #_"EndNode" originalEnd (Graph''add-2 graph, (EndNode'new-0))
                                    #_"EndNode" newEnd (Graph''add-2 graph, (EndNode'new-0))
                                ]
                                    (AbstractMergeNode''addForwardEnd-2 merge, originalEnd)
                                    (AbstractMergeNode''addForwardEnd-2 merge, newEnd)
                                    (§ ass! earlyExit (FixedWithNextNode''setNext-2 earlyExit, originalEnd))
                                    (§ ass! newEarlyExit (FixedWithNextNode''setNext-2 newEarlyExit, newEnd))
                                    (§ ass! merge (FixedWithNextNode''setNext-2 merge, next))

                                    (let [
                                        #_"FrameState" finalExitState
                                            (when-some [#_"FrameState" exitState (BeginStateSplitNode''stateAfter-1 earlyExit)]
                                                (let [
                                                    #_"FrameState" originalExitState exitState
                                                    exitState (FrameState''duplicateWithVirtualState-1 exitState)
                                                ]
                                                    (BeginStateSplitNode''setStateAfter-2 earlyExit, exitState)
                                                    (BeginStateSplitNode''setStateAfter-2 merge, originalExitState)
                                                    ;; Using the old exit's state as the merge's state is necessary because some of the VirtualState
                                                    ;; nodes contained in the old exit's state may be shared by other dominated VirtualStates.
                                                    ;; Those dominated virtual states need to see the proxy->phi update that are applied below.
                                                    ;;
                                                    ;; We now update the original fragment's nodes accordingly:
                                                    (FrameState''applyToVirtual-2 originalExitState, (ß node -> (§ fun (§ ass! (:nodes (:original this)) (NodeBitMap''clearAndGrow-2 (:nodes (:original this)), node)))))
                                                    (FrameState''applyToVirtual-2 exitState, (ß node -> (§ fun (§ ass! (:nodes (:original this)) (NodeBitMap''markAndGrow-2 (:nodes (:original this)), node)))))
                                                    exitState
                                                )
                                            )
                                    ]
                                        (doseq [#_"Node" anchored (NodeIterable''snapshot-1 (LoopExitNode''anchored-1 earlyExit))]
                                            (Node''replaceFirstInput-3 anchored, earlyExit, merge)
                                        )

                                        (let [
                                            #_"boolean" newEarlyExitIsLoopExit (instance? LoopExitNode newEarlyExit)
                                        ]
                                            (doseq [#_"ProxyNode" vpn (NodeIterable''snapshot-1 (LoopExitNode''proxies-1 earlyExit))]
                                                (cond
                                                    (Node''hasNoUsages-1 vpn)  nil
                                                    (nil? (ProxyNode''value-1 vpn)) (§ ass! vpn (Node''replaceAtUsages-2 vpn, nil))
                                                    :else
                                                        (let [
                                                            #_"ValueNode" newVpn (LoopFragment''prim-2 this, (if newEarlyExitIsLoopExit vpn (ProxyNode''value-1 vpn)))
                                                            #_"ValueNode" replaceWith
                                                                (when (some? newVpn) => (ProxyNode''value-1 vpn)
                                                                    (let [
                                                                        #_"PhiNode" phi
                                                                            (condp instance? vpn
                                                                                ValueProxyNode (ValuePhiNode'new-2 (:stamp vpn), merge)
                                                                                GuardProxyNode (GuardPhiNode'new-1 merge)
                                                                            )
                                                                    ]
                                                                        (Graph''add-2 graph, phi)
                                                                        (PhiNode''addInput-2 phi, vpn)
                                                                        (PhiNode''addInput-2 phi, newVpn)
                                                                        phi
                                                                    )
                                                                )
                                                        ]
                                                            (§ ass! vpn (Node''replaceAtMatchingUsages-3 vpn, replaceWith, (ß usage ->
                                                                (§ fun
                                                                    (not (or (AbstractMergeNode''isPhiAtMerge-2 merge, usage) (and (instance? VirtualState usage) (some? finalExitState) (FrameState''isPartOfThisState-2 finalExitState, usage))))
                                                                ))
                                                            ))
                                                        )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; @anno LoopFragment.WorkListEntry
 ;;
(final-ns WorkListEntry
    (§ final #_"Iterator<Node>" :usages nil)
    (§ final #_"Node" :n nil)
    (§ mutable #_"boolean" :isLoopNode false)

    (§ defn #_"WorkListEntry" WorkListEntry'new-2 [#_"Node" n, #_"NodeBitMap" loopNodes]
        (let [
            #_"WorkListEntry" this (Object.)
            this (assoc this :n n)
            this (assoc this :usages (#_"Iterable" .iterator (Node''usages-1 n)))
            this (assoc this :isLoopNode (NodeBitMap''isMarked-2 loopNodes, n))
        ]
            this
        )
    )

    (§ override! #_"boolean" #_"Object" .equals [#_"WorkListEntry" this, #_"Object" obj]
        (and (instance? WorkListEntry obj) (= (:n this) (:n obj)))
    )
)

(class-ns LoopFragmentInside (§ extends LoopFragment)
    ;;;
     ; mergedInitializers. When an inside fragment's (loop)ends are merged to create a unique exit
     ; point, some phis must be created : they phis together all the back-values of the loop-phis
     ; These can then be used to update the loop-phis' forward edge value ('initializer') in the
     ; peeling case. In the unrolling case they will be used as the value that replace the loop-phis
     ; of the duplicated inside fragment
     ;;
    (§ mutable #_"EconomicMap<PhiNode, ValueNode>" :mergedInitializers nil)

    (§ defn #_"LoopFragmentInside" LoopFragmentInside'new-1 [#_"LoopEx" loop]
        (LoopFragment'new-1 loop)
    )

    (§ defn #_"LoopFragmentInside" LoopFragmentInside'new-1 [#_"LoopFragmentInside" original]
        (LoopFragment'new-2 nil, original)
    )

    (§ override #_"LoopFragmentInside" LoopFragmentInside''duplicate-1 [#_"LoopFragmentInside" this]
        (LoopFragmentInside'new-1 this)
    )

    #_unused
    (§ method! #_"void" LoopFragmentInside''appendInside-2 [#_"LoopFragmentInside" this, #_"LoopEx" loop]
        ;; TODO
        nil
    )

    (§ override #_"void" LoopFragmentInside''insertBefore-2 [#_"LoopFragmentInside" this, #_"LoopEx" loop]
        (let [
            #_"LoopFragmentInside" fragments this
            #_"DuplicationReplacement" dataFixBefore
                (§ reify #_"DuplicationReplacement" (DuplicationReplacement'reify-0)
                    (§ override! #_"Node" DuplicationReplacement''replacement-2 [#_"DuplicationReplacement" this, #_"Node" oriInput]
                        (if (instance? ValueNode oriInput) (LoopFragmentInside''prim-2 fragments, oriInput) oriInput)
                    )
                )
        ]
            (§ ass! this (LoopFragment''patchNodes-2 this, dataFixBefore))

            (let [
                #_"AbstractBeginNode" end (LoopFragmentInside''mergeEnds-1 this)
            ]
                (LoopFragment''mergeEarlyExits-1 this)

                (LoopFragmentInside''patchPeeling-2 (:original this), this)

                (let [
                    #_"AbstractBeginNode" entry (LoopFragment''getDuplicatedNode-2 this, (LoopEx''loopBegin-1 loop))
                ]
                    (Node''replaceAtPredecessor-2 (LoopEx''entryPoint-1 loop), entry)
                    (§ ass! end (FixedWithNextNode''setNext-2 end, (LoopEx''entryPoint-1 loop)))
                )
            )
        )
        nil
    )

    ;;;
     ; Duplicate the body within the loop after the current copy copy of the body, updating the
     ; iteration limit to account for the duplication.
     ;;
    (§ method! #_"void" LoopFragmentInside''insertWithinAfter-2 [#_"LoopFragmentInside" this, #_"LoopEx" loop]
        (LoopFragmentInside''insertWithinAfter-3 this, loop, true)
        nil
    )

    ;;;
     ; Duplicate the body within the loop after the current copy copy of the body.
     ;
     ; @param updateLimit true if the iteration limit should be adjusted.
     ;;
    (§ method! #_"void" LoopFragmentInside''insertWithinAfter-3 [#_"LoopFragmentInside" this, #_"LoopEx" loop, #_"boolean" updateLimit]
        (let [
            #_"LoopFragmentInside" fragments this
            #_"DuplicationReplacement" dataFixWithinAfter
                (§ reify #_"DuplicationReplacement" (DuplicationReplacement'reify-0)
                    (§ override! #_"Node" DuplicationReplacement''replacement-2 [#_"DuplicationReplacement" this, #_"Node" oriInput]
                        (if (instance? ValueNode oriInput) (LoopFragmentInside''primAfter-2 fragments, oriInput) oriInput)
                    )
                )
        ]
            (§ ass! this (LoopFragment''patchNodes-2 this, dataFixWithinAfter))

            ;; collect any new back edges values before updating them since they might reference each other
            (let [
                #_"LoopBeginNode" mainLoopBegin (LoopEx''loopBegin-1 loop)
                #_"ArrayList<ValueNode>" backedgeValues (ArrayList.)
            ]
                (doseq [#_"PhiNode" mainPhiNode (AbstractMergeNode''phis-1 mainLoopBegin)]
                    (let [
                        #_"ValueNode" duplicatedNode (LoopFragment''getDuplicatedNode-2 this, (PhiNode''valueAt-2 mainPhiNode, 1))
                        duplicatedNode
                            (if (and (nil? duplicatedNode) (AbstractMergeNode''isPhiAtMerge-2 mainLoopBegin, (PhiNode''valueAt-2 mainPhiNode, 1)))
                                (PhiNode''valueAt-2 (PhiNode''valueAt-2 mainPhiNode, 1), 1)
                                duplicatedNode
                            )
                    ]
                        (#_"ArrayList" .add backedgeValues, duplicatedNode)
                    )
                )
                (let [
                    #_"int" index
                        (loop-when [index 0 #_"ISeq" s (seq (AbstractMergeNode''phis-1 mainLoopBegin))] (some? s) => index
                            (let [
                                #_"ValueNode" duplicatedNode (nth backedgeValues index)
                                index (inc index)
                            ]
                                (when (some? duplicatedNode)
                                    (PhiNode''setValueAt-3 (first s), 1, duplicatedNode)
                                )
                                (recur index (next s))
                            )
                        )
                ]
                    (LoopFragmentInside''placeNewSegmentAndCleanup-2 this, loop)

                    ;; remove any safepoints from the original copy leaving only the duplicated one
                    (doseq [#_"SafepointNode" safepoint (NodeIterable''filter-2 (LoopFragmentWhole''nodes-1 (LoopEx''whole-1 loop)), SafepointNode)]
                        (Graph''removeFixed-2 (LoopFragment''graph-1 this), safepoint)
                    )

                    (let [
                        #_"int" unrollFactor (:unrollFactor mainLoopBegin)
                        #_"Graph" graph (:graph mainLoopBegin)
                    ]
                        (when updateLimit
                            ;; use the previous unrollFactor to update the exit condition to power of two
                            (let [
                                #_"InductionVariable" iv (:iv (:counted loop))
                                #_"CompareNode" compareNode (:condition (:ifNode (:counted loop)))
                                #_"ValueNode" compareBound
                                    (condp = (InductionVariable''valueNode-1 iv)
                                        (:x compareNode) (:y compareNode)
                                        (:y compareNode) (:x compareNode)
                                    )
                                #_"long" originalStride (if (= unrollFactor 1) (InductionVariable''constantStride-1 iv) (quot (InductionVariable''constantStride-1 iv) unrollFactor))
                            ]
                                (case (InductionVariable''direction-1 iv)
                                    :Direction'Up
                                    (let [
                                        #_"ConstantNode" aboveVal (Graph''add-2 graph, (ConstantNode'forIntegerStamp-2 (:stamp (InductionVariable''initNode-1 iv)), (* unrollFactor originalStride)))
                                        #_"ValueNode" newLimit (Graph''add-2 graph, (SubNode'new-2 compareBound, aboveVal))
                                    ]
                                        (Node''replaceFirstInput-3 compareNode, compareBound, newLimit)
                                    )
                                    :Direction'Down
                                    (let [
                                        #_"ConstantNode" aboveVal (Graph''add-2 graph, (ConstantNode'forIntegerStamp-2 (:stamp (InductionVariable''initNode-1 iv)), (* unrollFactor (- originalStride))))
                                        #_"ValueNode" newLimit (Graph''add-2 graph, (AddNode'new-2 compareBound, aboveVal))
                                    ]
                                        (Node''replaceFirstInput-3 compareNode, compareBound, newLimit)
                                    )
                                    nil
                                )
                            )
                        )
                        (§ ass! mainLoopBegin (LoopBeginNode''setUnrollFactor-2 mainLoopBegin, (* unrollFactor 2)))
                        (§ ass! mainLoopBegin (LoopBeginNode''setLoopFrequency-2 mainLoopBegin, (/ (:loopFrequency mainLoopBegin) 2)))
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" LoopFragmentInside''placeNewSegmentAndCleanup-2 [#_"LoopFragmentInside" this, #_"LoopEx" loop]
        (let [
            #_"CountedLoopInfo" mainCounted (:counted loop)
            #_"LoopBeginNode" mainLoopBegin (LoopEx''loopBegin-1 loop)
            ;; discard the segment entry and its flow after if merging it into the loop
            #_"Graph" graph (:graph mainLoopBegin)
            #_"IfNode" loopTest (:ifNode mainCounted)
            #_"IfNode" newSegmentTest (LoopFragment''getDuplicatedNode-2 this, loopTest)
            #_"AbstractBeginNode" trueSuccessor (:trueSuccessor loopTest)
            #_"AbstractBeginNode" falseSuccessor (:falseSuccessor loopTest)
            #_"boolean" codeInTrueSide (= trueSuccessor (:body mainCounted))
            #_"FixedNode" firstNode (:next (if codeInTrueSide trueSuccessor falseSuccessor))
            trueSuccessor (:trueSuccessor newSegmentTest)
            falseSuccessor (:falseSuccessor newSegmentTest)
        ]
            (doseq [#_"Node" usage (NodeIterable''snapshot-1 (AbstractBeginNode''anchored-1 falseSuccessor))]
                (Node''replaceFirstInput-3 usage, falseSuccessor, (:falseSuccessor loopTest))
            )
            (doseq [#_"Node" usage (NodeIterable''snapshot-1 (AbstractBeginNode''anchored-1 trueSuccessor))]
                (Node''replaceFirstInput-3 usage, trueSuccessor, (:trueSuccessor loopTest))
            )
            (let [
                #_"AbstractBeginNode" startBlockNode (if codeInTrueSide trueSuccessor falseSuccessor)
                #_"FixedNode" lastNode (LoopFragmentInside'getBlockEnd-1 startBlockNode)
                #_"LoopEndNode" loopEndNode (LoopBeginNode''getSingleLoopEnd-1 mainLoopBegin)
                #_"FixedWithNextNode" lastCodeNode (:predecessor loopEndNode)
                #_"FixedNode" newSegmentFirstNode (LoopFragment''getDuplicatedNode-2 this, firstNode)
                #_"FixedWithNextNode" newSegmentLastNode (LoopFragment''getDuplicatedNode-2 this, lastCodeNode)
            ]
                (if (instance? LoopEndNode firstNode)
                    (GraphUtil'killCFG-1 (LoopFragment''getDuplicatedNode-2 this, mainLoopBegin))
                    (do
                        (Node''clearSuccessors-1 newSegmentLastNode)
                        (§ ass! startBlockNode (FixedWithNextNode''setNext-2 startBlockNode, lastNode))
                        (Node''replaceFirstSuccessor-3 lastCodeNode, loopEndNode, newSegmentFirstNode)
                        (Node''replaceFirstSuccessor-3 newSegmentLastNode, lastNode, loopEndNode)
                        (§ ass! lastCodeNode (FixedWithNextNode''setNext-2 lastCodeNode, newSegmentFirstNode))
                        (§ ass! newSegmentLastNode (FixedWithNextNode''setNext-2 newSegmentLastNode, loopEndNode))
                        (Node''clearSuccessors-1 startBlockNode)
                        (Node''safeDelete-1 lastNode)
                        (let [
                            #_"Node" newSegmentTestStart (:predecessor newSegmentTest)
                            #_"LogicNode" newSegmentIfTest (:condition newSegmentTest)
                        ]
                            (Node''clearSuccessors-1 newSegmentTestStart)
                            (Node''safeDelete-1 newSegmentTest)
                            (Node''safeDelete-1 newSegmentIfTest)
                            (Node''safeDelete-1 trueSuccessor)
                            (Node''safeDelete-1 falseSuccessor)
                            (Node''safeDelete-1 newSegmentTestStart)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"EndNode" LoopFragmentInside'getBlockEnd-1 [#_"FixedNode" node]
        (loop-when-recur node (instance? FixedWithNextNode node) (:next node) => node)
    )

    (§ override #_"NodeBitMap" LoopFragmentInside''nodes-1 [#_"LoopFragmentInside" this]
        (when (nil? (:nodes this))
            (let [
                #_"LoopFragmentWhole" whole (LoopEx''whole-1 (:loop this))
            ]
                (LoopFragmentWhole''nodes-1 whole) ;; init nodes bitmap in whole
                (§ ass! this (assoc this :nodes (NodeBitMap''copy-1 (:nodes whole))))
                ;; remove the phis
                (let [
                    #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop this))
                ]
                    (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 loopBegin)]
                        (NodeBitMap''clear-2 (:nodes this), phi)
                    )
                    (LoopFragmentInside''clearStateNodes-2 this, loopBegin)
                    (doseq [#_"LoopExitNode" exit (LoopFragmentInside''exits-1 this)]
                        (LoopFragmentInside''clearStateNodes-2 this, exit)
                        (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 exit)]
                            (NodeBitMap''clear-2 (:nodes this), proxy)
                        )
                    )
                )
            )
        )
        (:nodes this)
    )

    (§ method- #_"void" LoopFragmentInside''clearStateNodes-2 [#_"LoopFragmentInside" this, #_"StateSplit" stateSplit]
        (let [
            #_"FrameState" loopState (StateSplit''stateAfter-1 stateSplit)
        ]
            (when (some? loopState)
                (FrameState''applyToVirtual-2 loopState, (ß v ->
                    (§ fun
                        (when (NodeIterable''isEmpty-1 (NodeIterable''filter-2 (Node''usages-1 v), (ß n -> (§ fun (and (NodeBitMap''isMarked-2 (:nodes this), n) (not= n stateSplit))))))
                            (NodeBitMap''clear-2 (:nodes this), v)
                        )
                    ))
                )
            )
        )
        nil
    )

    (§ method! #_"NodeIterable<LoopExitNode>" LoopFragmentInside''exits-1 [#_"LoopFragmentInside" this]
        (LoopBeginNode''loopExits-1 (LoopEx''loopBegin-1 (:loop this)))
    )

    #_unused
    (§ override #_"DuplicationReplacement" LoopFragmentInside''getDuplicationReplacement-1 [#_"LoopFragmentInside" this]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop this))
            #_"Graph" graph (LoopFragment''graph-1 this)
        ]
            (§ reify #_"DuplicationReplacement" (DuplicationReplacement'reify-0)
                (§ final #_"EconomicMap<Node, Node>" :seenNode (EconomicMap/create Equivalence/IDENTITY))

                (§ override! #_"Node" DuplicationReplacement''replacement-2 [#_"DuplicationReplacement" this, #_"Node" original]
                    (when (= original loopBegin)
                        (let [
                            #_"Node" value (get (:seenNode this) original)
                        ]
                            (when (some? value)
                                (§ return value)
                            )
                            (let [
                                #_"AbstractBeginNode" newValue (Graph''add-2 graph, (BeginNode'new-0))
                            ]
                                (#_"EconomicMap" .put (:seenNode this), original, newValue)
                                (§ return newValue)
                            )
                        )
                    )
                    (when (and (instance? LoopExitNode original) (= (LoopEx''loopBegin-1 original) loopBegin))
                        (let [
                            #_"Node" value (get (:seenNode this) original)
                        ]
                            (when (some? value)
                                (§ return value)
                            )
                            (let [
                                #_"AbstractBeginNode" newValue (Graph''add-2 graph, (BeginNode'new-0))
                            ]
                                (#_"EconomicMap" .put (:seenNode this), original, newValue)
                                (§ return newValue)
                            )
                        )
                    )
                    (when (and (instance? LoopEndNode original) (= (LoopEx''loopBegin-1 original) loopBegin))
                        (let [
                            #_"Node" value (get (:seenNode this) original)
                        ]
                            (when (some? value)
                                (§ return value)
                            )
                            (let [
                                #_"EndNode" newValue (Graph''add-2 graph, (EndNode'new-0))
                            ]
                                (#_"EconomicMap" .put (:seenNode this), original, newValue)
                                (§ return newValue)
                            )
                        )
                    )
                    original
                )
            )
        )
    )

    #_unused
    (§ override #_"void" LoopFragmentInside''finishDuplication-1 [#_"LoopFragmentInside" this]
        ;; TODO
        nil
    )

    #_unused
    (§ override #_"void" LoopFragmentInside''beforeDuplication-1 [#_"LoopFragmentInside" this]
        ;; Nothing to do
        nil
    )

    (§ defn- #_"PhiNode" LoopFragmentInside'patchPhi-3 [#_"Graph" graph, #_"PhiNode" phi, #_"AbstractMergeNode" merge]
        (let [
            #_"PhiNode" ret
                (condp instance? phi
                    ValuePhiNode  (ValuePhiNode'new-2 (:stamp phi), merge)
                    GuardPhiNode  (GuardPhiNode'new-1 merge)
                    MemoryPhiNode (MemoryPhiNode'new-2 merge, (:locationIdentity phi))
                )
        ]
            (Graph''add-2 graph, ret)
        )
    )

    (§ method- #_"void" LoopFragmentInside''patchPeeling-2 [#_"LoopFragmentInside" this, #_"LoopFragmentInside" peel]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop this))
            #_"Graph" graph (:graph loopBegin)
            #_"List<PhiNode>" newPhis (LinkedList.)
            #_"NodeBitMap" usagesToPatch (NodeBitMap''copy-1 (:nodes this))
        ]
            (doseq [#_"LoopExitNode" exit (LoopFragmentInside''exits-1 this)]
                (LoopFragmentInside'markStateNodes-2 exit, usagesToPatch)
                (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 exit)]
                    (§ ass! usagesToPatch (NodeBitMap''markAndGrow-2 usagesToPatch, proxy))
                )
            )
            (LoopFragmentInside'markStateNodes-2 loopBegin, usagesToPatch)

            (let [
                #_"List<PhiNode>" oldPhis (NodeIterable''snapshot-1 (AbstractMergeNode''phis-1 loopBegin))
            ]
                (doseq [#_"PhiNode" phi oldPhis]
                    (when-not (Node''hasNoUsages-1 phi)
                        (let [
                            #_"ValueNode" first
                                (if (= (NodeIterable''count-1 (LoopBeginNode''loopEnds-1 loopBegin)) 1)
                                    (let [
                                        ;; back edge value
                                        #_"ValueNode" b (PhiNode''valueAt-2 phi, (NodeIterable''first-1 (LoopBeginNode''loopEnds-1 loopBegin)))
                                    ]
                                        (LoopFragmentInside''prim-2 peel, b) ;; corresponding value in the peel
                                    )
                                    (get (:mergedInitializers peel) phi)
                                )
                            ;; create a new phi (we don't patch the old one since some usages of the old one may still be valid)
                            #_"PhiNode" newPhi (LoopFragmentInside'patchPhi-3 graph, phi, loopBegin)
                        ]
                            (PhiNode''addInput-2 newPhi, first)
                            (doseq [#_"LoopEndNode" end (LoopBeginNode''orderedLoopEnds-1 loopBegin)]
                                (PhiNode''addInput-2 newPhi, (PhiNode''valueAt-2 phi, end))
                            )
                            (LoopFragment''putDuplicatedNode-3 peel, phi, newPhi)
                            (#_"List" .add newPhis, newPhi)
                            (doseq [#_"Node" usage (NodeIterable''snapshot-1 (Node''usages-1 phi))]
                                ;; patch only usages that should use the new phi, i.e. usages that were peeled
                                (when (NodeBitMap''isMarkedAndGrow-2 usagesToPatch, usage)
                                    (Node''replaceFirstInput-3 usage, phi, newPhi)
                                )
                            )
                        )
                    )
                )
                ;; check new phis to see if they have as input some old phis, replace those inputs with the new corresponding phis
                (doseq [#_"PhiNode" phi newPhis]
                    (dotimes [#_"int" i (PhiNode''valueCount-1 phi)]
                        (let-when [#_"ValueNode" v (PhiNode''valueAt-2 phi, i)] (AbstractMergeNode''isPhiAtMerge-2 loopBegin, v)
                            (when-some [#_"PhiNode" newV (LoopFragment''getDuplicatedNode-2 peel, v)]
                                (PhiNode''setValueAt-3 phi, i, newV)
                            )
                        )
                    )
                )
                (loop []
                    (let [
                        #_"boolean" progress?
                            (loop-when [progress? false #_"int" i 0] (< i (count oldPhis)) => progress?
                                (let [
                                    [progress? i]
                                        (loop-when [#_"ISeq" s (seq (Node''usages-1 (nth oldPhis i)))] (some? s) => [progress? i]
                                            (let [
                                                #_"Node" usage (first s)
                                            ]
                                                (if (and (instance? PhiNode usage) (#_"List" .contains oldPhis, usage))
                                                    (recur (next s)) ;; Do not mark.
                                                    (do
                                                        ;; Mark alive by removing from delete set.
                                                        (#_"List" .remove oldPhis, i)
                                                        [true (dec i)]
                                                    )
                                                )
                                            )
                                        )
                                ]
                                    (recur progress? (inc i))
                                )
                            )
                    ]
                        (recur-if progress? [])
                    )
                )
                (doseq [#_"PhiNode" deadPhi oldPhis]
                    (Node''clearInputs-1 deadPhi)
                )
                (doseq [#_"PhiNode" deadPhi oldPhis]
                    (when (Node''isAlive-1 deadPhi)
                        (GraphUtil'killWithUnusedFloatingInputs-1 deadPhi)
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" LoopFragmentInside'markStateNodes-2 [#_"StateSplit" stateSplit, #_"NodeBitMap" marks]
        (let [
            #_"FrameState" exitState (StateSplit''stateAfter-1 stateSplit)
        ]
            (when (some? exitState)
                (FrameState''applyToVirtual-2 exitState, (ß v -> (§ fun (§ ass! marks (NodeBitMap''markAndGrow-2 marks, v)))))
            )
        )
        nil
    )

    ;;;
     ; Gets the corresponding value in this fragment.
     ;
     ; @param b original value
     ; @return corresponding value in the peel
     ;;
    (§ override #_"ValueNode" LoopFragmentInside''prim-2 [#_"LoopFragmentInside" this, #_"ValueNode" b]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop (:original this)))
        ]
            (cond
                (AbstractMergeNode''isPhiAtMerge-2 loopBegin, b) (PhiNode''valueAt-2 b, (LoopBeginNode''forwardEnd-1 loopBegin))
                (:nodesReady this)                               (or (LoopFragment''getDuplicatedNode-2 this, b) b)
                :else                                            b
            )
        )
    )

    (§ method! #_"ValueNode" LoopFragmentInside''primAfter-2 [#_"LoopFragmentInside" this, #_"ValueNode" b]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop (:original this)))
        ]
            (cond
                (AbstractMergeNode''isPhiAtMerge-2 loopBegin, b) (PhiNode''valueAt-2 b, 1)
                (:nodesReady this)                               (or (LoopFragment''getDuplicatedNode-2 this, b) b)
                :else                                            b
            )
        )
    )

    (§ method- #_"AbstractBeginNode" LoopFragmentInside''mergeEnds-1 [#_"LoopFragmentInside" this]
        (let [
            #_"List<EndNode>" endsToMerge (LinkedList.)
            ;; map peel exits to the corresponding loop exits
            #_"EconomicMap<AbstractEndNode, LoopEndNode>" reverseEnds (EconomicMap/create Equivalence/IDENTITY)
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop (:original this)))
        ]
            (doseq [#_"LoopEndNode" le (LoopBeginNode''loopEnds-1 loopBegin)]
                (let [
                    #_"AbstractEndNode" duplicate (LoopFragment''getDuplicatedNode-2 this, le)
                ]
                    (when (some? duplicate)
                        (#_"List" .add endsToMerge, (§ cast #_"EndNode" duplicate))
                        (#_"EconomicMap" .put reverseEnds, duplicate, le)
                    )
                )
            )
            (§ ass! this (assoc this :mergedInitializers (EconomicMap/create Equivalence/IDENTITY)))
            (let [
                #_"Graph" graph (LoopFragment''graph-1 this)
            ]
                (if (= (count endsToMerge) 1)
                    (let [
                        #_"AbstractEndNode" end (nth endsToMerge 0)
                        #_"AbstractBeginNode" newExit (Graph''add-2 graph, (BeginNode'new-0))
                    ]
                        (Node''replaceAtPredecessor-2 end, newExit)
                        (Node''safeDelete-1 end)
                        newExit
                    )
                    (let [
                        #_"AbstractMergeNode" newExitMerge (Graph''add-2 graph, (MergeNode'new-0))
                        #_"AbstractBeginNode" newExit newExitMerge
                        #_"FrameState" state (BeginStateSplitNode''stateAfter-1 loopBegin)
                        #_"FrameState" duplicateState
                            (when (some? state)
                                (let [
                                    duplicateState (FrameState''duplicateWithVirtualState-1 state)
                                ]
                                    (BeginStateSplitNode''setStateAfter-2 newExitMerge, duplicateState)
                                    duplicateState
                                )
                            )
                    ]
                        (doseq [#_"EndNode" end endsToMerge]
                            (AbstractMergeNode''addForwardEnd-2 newExitMerge, end)
                        )

                        (doseq [#_"PhiNode" phi (NodeIterable''snapshot-1 (AbstractMergeNode''phis-1 loopBegin))]
                            (when-not (Node''hasNoUsages-1 phi)
                                (let [
                                    #_"PhiNode" firstPhi (LoopFragmentInside'patchPhi-3 graph, phi, newExitMerge)
                                ]
                                    (doseq [#_"AbstractEndNode" end (AbstractMergeNode''forwardEnds-1 newExitMerge)]
                                        (let [
                                            #_"LoopEndNode" loopEnd (get reverseEnds end)
                                            #_"ValueNode" prim (LoopFragmentInside''prim-2 this, (PhiNode''valueAt-2 phi, loopEnd))
                                        ]
                                            (PhiNode''addInput-2 firstPhi, prim)
                                        )
                                    )
                                    (let [
                                        #_"ValueNode" initializer firstPhi
                                    ]
                                        (when (some? duplicateState)
                                            ;; fix the merge's state after
                                            (FrameState''applyToNonVirtual-2 duplicateState,
                                                (§ reify #_"NodeClosure<ValueNode>" (NodeClosure'new-0)
                                                    (§ override! #_"void" NodeClosure''apply-3 [#_"NodeClosure<ValueNode>" this, #_"Node" from, #_"ValueNode" node]
                                                        (when (= node phi)
                                                            (Node''replaceFirstInput-3 from, phi, firstPhi)
                                                        )
                                                        nil
                                                    )
                                                )
                                            )
                                        )
                                        (#_"EconomicMap" .put (:mergedInitializers this), phi, initializer)
                                    )
                                )
                            )
                        )
                        newExit
                    )
                )
            )
        )
    )
)

(final-ns LoopFragmentInsideBefore (§ extends LoopFragmentInside)
    (§ final #_"FixedNode" :point nil)

    #_unused
    (§ defn #_"LoopFragmentInsideBefore" LoopFragmentInsideBefore'new-2 [#_"LoopEx" loop, #_"FixedNode" point]
        (let [
            #_"LoopFragmentInsideBefore" this (LoopFragmentInside'new-1 loop)
            this (assoc this :point point)
        ]
            this
        )
    )

    ;; duplicates lazily
    (§ defn #_"LoopFragmentInsideBefore" LoopFragmentInsideBefore'new-1 [#_"LoopFragmentInsideBefore" original]
        (let [
            #_"LoopFragmentInsideBefore" this (LoopFragmentInside'new-1 original)
            this (assoc this :point (:point original))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"LoopFragmentInsideBefore" LoopFragmentInsideBefore''duplicate-1 [#_"LoopFragmentInsideBefore" this]
        (LoopFragmentInsideBefore'new-1 this)
    )

    #_unused
    (§ override! #_"NodeBitMap" LoopFragmentInsideBefore''nodes-1 [#_"LoopFragmentInsideBefore" this]
        nil
    )
)

(final-ns LoopFragmentInsideFrom (§ extends LoopFragmentInside)
    (§ final #_"FixedNode" :point nil)

    #_unused
    (§ defn #_"LoopFragmentInsideFrom" LoopFragmentInsideFrom'new-2 [#_"LoopEx" loop, #_"FixedNode" point]
        (let [
            #_"LoopFragmentInsideFrom" this (LoopFragmentInside'new-1 loop)
            this (assoc this :point point)
        ]
            this
        )
    )

    ;; duplicates lazily
    (§ defn #_"LoopFragmentInsideFrom" LoopFragmentInsideFrom'new-1 [#_"LoopFragmentInsideFrom" original]
        (let [
            #_"LoopFragmentInsideFrom" this (LoopFragmentInside'new-1 original)
            this (assoc this :point (:point original))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"LoopFragmentInsideFrom" LoopFragmentInsideFrom''duplicate-1 [#_"LoopFragmentInsideFrom" this]
        (LoopFragmentInsideFrom'new-1 this)
    )

    #_unused
    (§ override! #_"NodeBitMap" LoopFragmentInsideFrom''nodes-1 [#_"LoopFragmentInsideFrom" this]
        nil
    )
)

(final-ns LoopFragmentWhole (§ extends LoopFragment)
    (§ defn #_"LoopFragmentWhole" LoopFragmentWhole'new-1 [#_"LoopEx" loop]
        (LoopFragment'new-1 loop)
    )

    (§ defn #_"LoopFragmentWhole" LoopFragmentWhole'new-1 [#_"LoopFragmentWhole" original]
        (LoopFragment'new-2 nil, original)
    )

    (§ override! #_"LoopFragmentWhole" LoopFragmentWhole''duplicate-1 [#_"LoopFragmentWhole" this]
        (let [
            #_"LoopFragmentWhole" copy (LoopFragmentWhole'new-1 this)
            copy (LoopFragment''patchNodes-2 copy, nil)
        ]
            (LoopFragment''mergeEarlyExits-1 copy)
            copy
        )
    )

    (§ override! #_"NodeBitMap" LoopFragmentWhole''nodes-1 [#_"LoopFragmentWhole" this]
        (when (nil? (:nodes this))
            (let [
                #_"Loop" loop (:loop (:loop this))
            ]
                (§ ass! this (assoc this :nodes (LoopFragment'computeNodes-3 (LoopFragment''graph-1 this), (LoopFragment'toHirBlocks-1 (:blocks loop)), (LoopFragment'toHirExits-1 (:exits loop)))))
            )
        )
        (:nodes this)
    )

    #_unused
    (§ override! #_"ValueNode" LoopFragmentWhole''prim-2 [#_"LoopFragmentWhole" this, #_"ValueNode" b]
        (LoopFragment''getDuplicatedNode-2 this, b)
    )

    #_unused
    (§ override! #_"DuplicationReplacement" LoopFragmentWhole''getDuplicationReplacement-1 [#_"LoopFragmentWhole" this]
        (let [
            #_"FixedNode" entry (LoopEx''entryPoint-1 (:loop this))
            #_"Graph" graph (LoopFragment''graph-1 this)
        ]
            (§ reify #_"DuplicationReplacement" (DuplicationReplacement'reify-0)
                (§ mutable #_"EndNode" :endNode nil)

                (§ override! #_"Node" DuplicationReplacement''replacement-2 [#_"DuplicationReplacement" this, #_"Node" o]
                    (when (= o entry) => o
                        (when (nil? (:endNode this))
                            (§ ass! this (assoc this :endNode (Graph''add-2 graph, (EndNode'new-0))))
                        )
                        (:endNode this)
                    )
                )
            )
        )
    )

    (§ method! #_"FixedNode" LoopFragmentWhole''entryPoint-1 [#_"LoopFragmentWhole" this]
        (when (LoopFragment''isDuplicate-1 this) => (LoopEx''entryPoint-1 (:loop this))
            (LoopBeginNode''forwardEnd-1 (LoopFragment''getDuplicatedNode-2 this, (LoopEx''loopBegin-1 (:loop (:original this)))))
        )
    )

    #_unused
    (§ override! #_"void" LoopFragmentWhole''finishDuplication-1 [#_"LoopFragmentWhole" this]
        ;; TODO
        nil
    )

    (§ method! #_"void" LoopFragmentWhole''cleanupLoopExits-1 [#_"LoopFragmentWhole" this]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 (:loop (:original this)))
            #_"Graph" graph (:graph loopBegin)
        ]
            (when (= (:guardsStage graph) GuardsStage'AFTER_FSA)
                ;; After FrameStateAssignment ControlFlowGraph treats loop exits differently which means
                ;; that the LoopExitNodes can be in a block which post dominates the true loop exit. For
                ;; cloning to work right they must agree.
                (let [
                    #_"EconomicSet<LoopExitNode>" exits (EconomicSet/create)
                ]
                    (doseq [#_"Block" exitBlock (:exits (:loop (:loop (:original this))))]
                        (let [
                            #_"LoopExitNode" exitNode (Block''getLoopExit-1 exitBlock)
                        ]
                            (when (nil? exitNode)
                                (§ ass exitNode (Graph''add-2 graph, (LoopExitNode'new-1 loopBegin)))
                                (Graph''addAfterFixed-3 graph, (:beginNode exitBlock), exitNode)
                                (when (some? (:nodes this))
                                    (NodeBitMap''mark-2 (:nodes this), exitNode)
                                )
                            )
                            (#_"EconomicSet" .add exits, exitNode)
                        )
                    )
                    (doseq [#_"LoopExitNode" exitNode (LoopBeginNode''loopExits-1 loopBegin)]
                        (when-not (contains? exits exitNode)
                            (when (some? (:nodes this))
                                (NodeBitMap''clear-2 (:nodes this), exitNode)
                            )
                            (Graph''removeFixed-2 graph, exitNode)
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" LoopFragmentWhole''beforeDuplication-1 [#_"LoopFragmentWhole" this]
        (LoopFragmentWhole''cleanupLoopExits-1 this)
        nil
    )

    #_unused
    (§ override! #_"void" LoopFragmentWhole''insertBefore-2 [#_"LoopFragmentWhole" this, #_"LoopEx" loop]
        ;; TODO auto-generated method stub
        nil
    )
)

(§ interface LoopPolicies
    (§ abstract #_"boolean" LoopPolicies''shouldPeel-3 [#_"LoopPolicies" this, #_"LoopEx" loop, #_"ControlFlowGraph" cfg])

    (§ abstract #_"boolean" LoopPolicies''shouldFullUnroll-2 [#_"LoopPolicies" this, #_"LoopEx" loop])

    (§ abstract #_"boolean" LoopPolicies''shouldPartiallyUnroll-2 [#_"LoopPolicies" this, #_"LoopEx" loop])

    (§ abstract #_"boolean" LoopPolicies''shouldTryUnswitch-2 [#_"LoopPolicies" this, #_"LoopEx" loop])

    (§ abstract #_"boolean" LoopPolicies''shouldUnswitch-3 [#_"LoopPolicies" this, #_"LoopEx" loop, #_"List<ControlSplitNode>" controlSplits])
)

(final-ns LoopsData
    (§ final #_"EconomicMap<LoopBeginNode, LoopEx>" :loopBeginToEx (EconomicMap/create Equivalence/IDENTITY))
    (§ final #_"ControlFlowGraph" :cfg nil)
    (§ final #_"List<LoopEx>" :loops nil)

    (§ defn #_"LoopsData" LoopsData'new-1 [#_"Graph" graph]
        (let [
            #_"LoopsData" this (Object.)
            this (assoc this :cfg (ControlFlowGraph'compute-5 graph, true, true, true, true))
            this (assoc this :loops (ArrayList.))
        ]
            (doseq [#_"Loop" loop (:loops (:cfg this))]
                (let [
                    #_"LoopEx" ex (LoopEx'new-2 loop, this)
                ]
                    (#_"List" .add (:loops this), ex)
                    (#_"EconomicMap" .put (:loopBeginToEx this), (LoopEx''loopBegin-1 ex), ex)
                )
            )
            this
        )
    )

    (§ method! #_"LoopEx" LoopsData''loop-2 [#_"LoopsData" this, #_"Loop" loop]
        (get (:loopBeginToEx this) (:beginNode (:header loop)))
    )

    (§ method! #_"LoopEx" LoopsData''loop-2 [#_"LoopsData" this, #_"LoopBeginNode" loopBegin]
        (get (:loopBeginToEx this) loopBegin)
    )

    (§ method! #_"Collection<LoopEx>" LoopsData''countedLoops-1 [#_"LoopsData" this]
        (let [
            #_"List<LoopEx>" counted (LinkedList.)
        ]
            (doseq [#_"LoopEx" loop (:loops this)]
                (when (LoopEx''isCounted-1 loop)
                    (#_"List" .add counted, loop)
                )
            )
            counted
        )
    )

    (§ method! #_"void" LoopsData''detectedCountedLoops-1 [#_"LoopsData" this]
        (doseq [#_"LoopEx" loop (:loops this)]
            (LoopEx''detectCounted-1 loop)
        )
        nil
    )

    #_unused
    (§ method! #_"InductionVariable" LoopsData''getInductionVariable-2 [#_"LoopsData" this, #_"ValueNode" value]
        (loop-when [#_"InductionVariable" match nil #_"ISeq" s (seq (:loops this))] (some? s) => match
            (let [
                #_"InductionVariable" iv (get (LoopEx''getInductionVariables-1 (first s)) value)
            ]
                (when (some? iv) => (recur match (next s))
                    (when (some? match) => (recur iv (next s))
                        nil
                    )
                )
            )
        )
    )

    ;;;
     ; Deletes any nodes created within the scope of this object that have no usages.
     ;;
    (§ method! #_"void" LoopsData''deleteUnusedNodes-1 [#_"LoopsData" this]
        (doseq [#_"LoopEx" loop (:loops this)]
            (LoopEx''deleteUnusedNodes-1 loop)
        )
        nil
    )
)

;;;
 ; Utility methods to perform integer math with some obvious constant folding first.
 ;;
(value-ns MathUtil
    (§ defn- #_"boolean" MathUtil'isConstantOne-1 [#_"ValueNode" v1]
        (and (instance? ConstantNode v1) (instance? IntegerStamp (:stamp v1)) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 v1)) 1))
    )

    (§ defn- #_"boolean" MathUtil'isConstantZero-1 [#_"ValueNode" v1]
        (and (instance? ConstantNode v1) (instance? IntegerStamp (:stamp v1)) (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 v1))))
    )

    (§ defn #_"ValueNode" MathUtil'add-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (cond
            (MathUtil'isConstantZero-1 v1) v2
            (MathUtil'isConstantZero-1 v2) v1
            :else                          (BinaryArithmeticNode'add-3 graph, v1, v2)
        )
    )

    (§ defn #_"ValueNode" MathUtil'mul-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (cond
            (MathUtil'isConstantOne-1 v1) v2
            (MathUtil'isConstantOne-1 v2) v1
            :else                         (BinaryArithmeticNode'mul-3 graph, v1, v2)
        )
    )

    (§ defn #_"ValueNode" MathUtil'sub-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (cond
            (MathUtil'isConstantZero-1 v2) v1
            :else                          (BinaryArithmeticNode'sub-3 graph, v1, v2)
        )
    )

    #_unused
    (§ defn #_"ValueNode" MathUtil'divBefore-4 [#_"Graph" graph, #_"FixedNode" before, #_"ValueNode" dividend, #_"ValueNode" divisor]
        (MathUtil'fixedDivBefore-5 graph, before, dividend, divisor, (ß (dend, sor) -> (§ fun (SignedDivNode'create-2 dend, sor))))
    )

    (§ defn #_"ValueNode" MathUtil'unsignedDivBefore-4 [#_"Graph" graph, #_"FixedNode" before, #_"ValueNode" dividend, #_"ValueNode" divisor]
        (MathUtil'fixedDivBefore-5 graph, before, dividend, divisor, (ß (dend, sor) -> (§ fun (UnsignedDivNode'create-2 dend, sor))))
    )

    (§ defn- #_"ValueNode" MathUtil'fixedDivBefore-5 [#_"Graph" graph, #_"FixedNode" before, #_"ValueNode" dividend, #_"ValueNode" divisor, #_"BiFunction<ValueNode, ValueNode, ValueNode>" createDiv]
        (when-not (MathUtil'isConstantOne-1 divisor) => dividend
            (let [
                #_"ValueNode" div (Graph''addOrUniqueWithInputs-2 graph, (#_"BiFunction" .apply createDiv, dividend, divisor))
            ]
                (when (instance? FixedBinaryNode div) => div
                    (if (and (instance? FixedBinaryNode (:predecessor before)) (Node''dataFlowEquals-2 div, (:predecessor before)))
                        (do
                            (Node''safeDelete-1 div)
                            (:predecessor before)
                        )
                        (do
                            (Graph''addBeforeFixed-3 graph, before, div)
                            div
                        )
                    )
                )
            )
        )
    )
)

(class-ns ContextlessLoopPhase #_"<P extends LoopPolicies>" (§ extends LoopPhase #_"<P>")
    (§ defn #_"ContextlessLoopPhase" ContextlessLoopPhase'new-1 [#_"P" policies]
        (LoopPhase'new-1 policies)
    )

    #_unused
    (§ method! #_"void" ContextlessLoopPhase''apply-2 [#_"ContextlessLoopPhase<P extends LoopPolicies>" this, #_"Graph" graph]
        (BasePhase''apply-3 this, graph, nil)
        nil
    )

    (§ abstract #_"void" ContextlessLoopPhase''run-2 [#_"ContextlessLoopPhase<P extends LoopPolicies>" this, #_"Graph" graph])

    #_unused
    (§ override! #_"void" ContextlessLoopPhase''run-3 [#_"ContextlessLoopPhase<P extends LoopPolicies>" this, #_"Graph" graph, #_"PhaseContext" context]
        (ContextlessLoopPhase''run-2 this, graph)
        nil
    )
)

(final-ns LoopFullUnrollPhase (§ extends LoopPhase #_"<LoopPolicies>")
    (§ final #_"CanonicalizerPhase" :canonicalizer nil)

    (§ defn #_"LoopFullUnrollPhase" LoopFullUnrollPhase'new-2 [#_"CanonicalizerPhase" canonicalizer, #_"LoopPolicies" policies]
        (let [
            #_"LoopFullUnrollPhase" this (LoopPhase'new-1 policies)
            this (assoc this :canonicalizer canonicalizer)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" LoopFullUnrollPhase''run-3 [#_"LoopFullUnrollPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (when (Graph''hasLoops-1 graph)
            (loop []
                (let [
                    #_"LoopsData" dataCounted (LoopsData'new-1 graph)
                ]
                    (LoopsData''detectedCountedLoops-1 dataCounted)
                    (let [
                        #_"boolean" peeled?
                            (loop-when [#_"ISeq" s (seq (LoopsData''countedLoops-1 dataCounted))] (some? s) => false
                                (let [
                                    #_"LoopEx" loop (first s)
                                ]
                                    (when (LoopPolicies''shouldFullUnroll-2 (:policies this), loop) => (recur (next s))
                                        (LoopTransformations'fullUnroll-3 loop, context, (:canonicalizer this))
                                        true
                                    )
                                )
                            )
                    ]
                        (LoopsData''deleteUnusedNodes-1 dataCounted)
                        (recur-if peeled? [])
                    )
                )
            )
        )
        nil
    )
)

(final-ns LoopPartialUnrollPhase (§ extends LoopPhase #_"<LoopPolicies>")
    (§ final #_"CanonicalizerPhase" :canonicalizer nil)

    (§ defn #_"LoopPartialUnrollPhase" LoopPartialUnrollPhase'new-2 [#_"LoopPolicies" policies, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"LoopPartialUnrollPhase" this (LoopPhase'new-1 policies)
            this (assoc this :canonicalizer canonicalizer)
        ]
            this
        )
    )

    ; @SuppressWarnings("try")
    #_unused
    (§ override! #_"void" LoopPartialUnrollPhase''run-3 [#_"LoopPartialUnrollPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (when (Graph''hasLoops-1 graph)
            (let [
                #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-0)
            ]
                (loop []
                    (let [
                        #_"boolean" changed?
                            (try (§ with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                                (let [
                                    #_"LoopsData" dataCounted (LoopsData'new-1 graph)
                                ]
                                    (LoopsData''detectedCountedLoops-1 dataCounted)
                                    (let [
                                        changed?
                                            (loop-when [changed? false #_"ISeq" s (seq (LoopsData''countedLoops-1 dataCounted))] (some? s) => changed?
                                                (let [
                                                    #_"LoopEx" loop (first s)
                                                    changed?
                                                        (when (and (LoopTransformations'isUnrollableLoop-1 loop) (LoopPolicies''shouldPartiallyUnroll-2 (:policies this), loop)) => changed?
                                                            (if (LoopBeginNode''isSimpleLoop-1 (LoopEx''loopBegin-1 loop))
                                                                ;; First perform the pre/post transformation and do the partial unroll when we come around again.
                                                                (LoopTransformations'insertPrePostLoops-1 loop)
                                                                (LoopTransformations'partialUnroll-1 loop)
                                                            )
                                                            true
                                                        )
                                                ]
                                                    (recur changed? (next s))
                                                )
                                            )
                                    ]
                                        (LoopsData''deleteUnusedNodes-1 dataCounted)

                                        (when (seq (:nodes listener))
                                            (CanonicalizerPhase''applyIncremental-4 (:canonicalizer this), graph, context, (:nodes listener))
                                            (#_"EconomicSet" .clear (:nodes listener))
                                        )
                                        changed?
                                    )
                                )
                            )
                    ]
                        (recur-if changed? [])
                    )
                )
            )
        )
        nil
    )
)

(final-ns LoopPeelingPhase (§ extends LoopPhase #_"<LoopPolicies>")
    (§ defn #_"LoopPeelingPhase" LoopPeelingPhase'new-1 [#_"LoopPolicies" policies]
        (LoopPhase'new-1 policies)
    )

    #_unused
    (§ override! #_"void" LoopPeelingPhase''run-3 [#_"LoopPeelingPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (when (Graph''hasLoops-1 graph)
            (let [
                #_"LoopsData" data (LoopsData'new-1 graph)
            ]
                (doseq [#_"LoopEx" loop (:loops data)]
                    (when (LoopPolicies''shouldPeel-3 (:policies this), loop, (:cfg data))
                        (LoopTransformations'peel-1 loop)
                    )
                )
                (LoopsData''deleteUnusedNodes-1 data)
            )
        )
        nil
    )
)

(class-ns LoopPhase #_"<P extends LoopPolicies>" (§ extends BasePhase #_"<PhaseContext>")
    (§ mutable #_"P" :policies nil)

    (§ defn #_"LoopPhase" LoopPhase'new-1 [#_"P" policies]
        (let [
            #_"LoopPhase" this (BasePhase'new-0)
            this (assoc this :policies policies)
        ]
            this
        )
    )
)

(final-ns LoopSafepointEliminationPhase (§ extends BasePhase #_"<MidTierContext>")
    (§ defn #_"LoopSafepointEliminationPhase" LoopSafepointEliminationPhase'new-0 []
        (BasePhase'new-0)
    )

    #_unused
    (§ override! #_"void" LoopSafepointEliminationPhase''run-3 [#_"LoopSafepointEliminationPhase" this, #_"Graph" graph, #_"MidTierContext" context]
        (let [
            #_"LoopsData" loops (LoopsData'new-1 graph)
        ]
            (when (and (OptimisticOptimizations''useLoopLimitChecks-1 (:optimisticOpts context)) (GuardsStage'allowsFloatingGuards-1 (:guardsStage graph)))
                (LoopsData''detectedCountedLoops-1 loops)
                (doseq [#_"LoopEx" loop (LoopsData''countedLoops-1 loops)]
                    (when (and (empty? (:children (:loop loop))) (<= (:bits (CountedLoopInfo''getStamp-1 (:counted loop))) 32))
                        (let [
                            #_"boolean" hasSafepoint
                                (loop-when-recur [hasSafepoint false #_"ISeq" s (seq (LoopBeginNode''loopEnds-1 (LoopEx''loopBegin-1 loop)))]
                                                 (some? s)
                                                 [(or hasSafepoint (:canSafepoint (first s))) (next s)]
                                              => hasSafepoint
                                )
                        ]
                            (when hasSafepoint
                                (CountedLoopInfo''createOverFlowGuard-1 (:counted loop))
                                (§ ass! (LoopEx''loopBegin-1 loop) (LoopBeginNode''disableSafepoint-1 (LoopEx''loopBegin-1 loop)))
                            )
                        )
                    )
                )
            )
            (doseq [#_"LoopEx" loop (:loops loops) #_"LoopEndNode" loopEnd (LoopBeginNode''loopEnds-1 (LoopEx''loopBegin-1 loop))]
                (loop-when [#_"Block" b (ControlFlowGraph''blockFor-2 (:cfg loops), loopEnd)] (not= b (:header (:loop loop)))
                    (or
                        (loop-when [#_"ISeq" s (seq (Block''getNodes-1 b))] (some? s)
                            (let [
                                #_"FixedNode" node (first s)
                            ]
                                (when (or (instance? InvokeNode node) (and (instance? ForeignCallNode node) (ForeignCallNode''isGuaranteedSafepoint-1 node))) => (recur (next s))
                                    (§ ass! loopEnd (LoopEndNode''disableSafepoint-1 loopEnd))
                                    :done
                                )
                            )
                        )
                        (recur (:dominator b))
                    )
                )
            )
            (LoopsData''deleteUnusedNodes-1 loops)
        )
        nil
    )
)

(value-ns LoopTransformations
    (§ defn #_"void" LoopTransformations'peel-1 [#_"LoopEx" loop]
        (LoopFragmentInside''insertBefore-2 (LoopFragmentInside''duplicate-1 (LoopEx''inside-1 loop)), loop)
        (§ ass! (LoopEx''loopBegin-1 loop) (LoopBeginNode''setLoopFrequency-2 (LoopEx''loopBegin-1 loop), (max 0.0 (dec (:loopFrequency (LoopEx''loopBegin-1 loop))))))
        nil
    )

    (§ defn #_"void" LoopTransformations'fullUnroll-3 [#_"LoopEx" loop, #_"PhaseContext" context, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 loop)
            #_"Graph" graph (:graph loopBegin)
            #_"int" initialNodeCount (Graph''getNodeCount-1 graph)
        ]
            (while (not (Node''isDeleted-1 loopBegin))
                (let [
                    #_"NodeMark" mark (NodeMark'new-1 graph)
                ]
                    (LoopTransformations'peel-1 loop)
                    (CanonicalizerPhase''applyIncremental-4 canonicalizer, graph, context, mark)
                    (§ ass! loop (LoopEx''invalidateFragments-1 loop))
                    (when (< (+ initialNodeCount (* GraalOptions'maximumDesiredSize 2)) (Graph''getNodeCount-1 graph))
                        (throw! "full unroll: graph seems to grow out of proportion")
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"void" LoopTransformations'unswitch-2 [#_"LoopEx" loop, #_"List<ControlSplitNode>" controlSplitNodeSet]
        (let [
            #_"ControlSplitNode" firstNode (#_"Iterator" .next (#_"List" .iterator controlSplitNodeSet))
            #_"LoopFragmentWhole" originalLoop (LoopEx''whole-1 loop)
            #_"Graph" graph (:graph firstNode)
        ]
            (§ ass! (LoopEx''loopBegin-1 loop) (LoopBeginNode''incrementUnswitches-1 (LoopEx''loopBegin-1 loop)))

            ;; create new control split out of loop
            (let [
                #_"ControlSplitNode" newControlSplit (Node''copyWithInputs-1 firstNode)
            ]
                (Node''replaceAtPredecessor-2 (LoopFragmentWhole''entryPoint-1 originalLoop), newControlSplit)

                ;; The code below assumes that all of the control split nodes have the same successor
                ;; structure, which should have been enforced by findUnswitchable.
                (let [
                    #_"Iterator<Position>" successors (#_"Iterable" .iterator (Node''successorPositions-1 firstNode))
                    ;; original loop is used as first successor
                    #_"Position" firstPosition (#_"Iterator" .next successors)
                    #_"AbstractBeginNode" originalLoopBegin (BeginNode'begin-1 (LoopFragmentWhole''entryPoint-1 originalLoop))
                ]
                    (Position''set-3 firstPosition, newControlSplit, originalLoopBegin)

                    (while (#_"Iterator" .hasNext successors)
                        (let [
                            #_"Position" position (#_"Iterator" .next successors)
                            ;; create a new loop duplicate and connect it
                            #_"LoopFragmentWhole" duplicateLoop (LoopFragmentWhole''duplicate-1 originalLoop)
                            #_"AbstractBeginNode" newBegin (BeginNode'begin-1 (LoopFragmentWhole''entryPoint-1 duplicateLoop))
                        ]
                            (Position''set-3 position, newControlSplit, newBegin)

                            ;; for each cloned ControlSplitNode, simplify the proper path
                            (doseq [#_"ControlSplitNode" controlSplitNode controlSplitNodeSet]
                                (let [
                                    #_"ControlSplitNode" duplicatedControlSplit (LoopFragment''getDuplicatedNode-2 duplicateLoop, controlSplitNode)
                                ]
                                    (when (Node''isAlive-1 duplicatedControlSplit)
                                        (let [
                                            #_"AbstractBeginNode" survivingSuccessor (Position''get-2 position, duplicatedControlSplit)
                                        ]
                                            (Node''replaceAtUsages-3 survivingSuccessor, InputType'Guard, newBegin)
                                            (Graph''removeSplitPropagate-3 graph, duplicatedControlSplit, survivingSuccessor)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    ;; original loop is simplified last to avoid deleting controlSplitNode too early
                    (doseq [#_"ControlSplitNode" controlSplitNode controlSplitNodeSet]
                        (when (Node''isAlive-1 controlSplitNode)
                            (let [
                                #_"AbstractBeginNode" survivingSuccessor (Position''get-2 firstPosition, controlSplitNode)
                            ]
                                (Node''replaceAtUsages-3 survivingSuccessor, InputType'Guard, originalLoopBegin)
                                (Graph''removeSplitPropagate-3 graph, controlSplitNode, survivingSuccessor)
                            )
                        )
                    )

                    ;; TODO probabilities need some amount of fixup (probably also in other transforms)
                )
            )
        )
        nil
    )

    (§ defn #_"void" LoopTransformations'partialUnroll-1 [#_"LoopEx" loop]
        (LoopFragmentInside''insertWithinAfter-2 (LoopFragmentInside''duplicate-1 (LoopEx''inside-1 loop)), loop)
        nil
    )

    (§ defn- #_"EndNode" LoopTransformations'getBlockEnd-1 [#_"FixedNode" node]
        (loop-when-recur node (instance? FixedWithNextNode node) (:next node) => node)
    )

    ;;;
     ; Find the end of the block following the LoopExit.
     ;;
    (§ defn- #_"EndNode" LoopTransformations'getBlockEndAfterLoopExit-1 [#_"LoopBeginNode" curLoopBegin]
        ;; find the last node after the exit blocks starts
        (LoopTransformations'getBlockEnd-1 (:next (LoopBeginNode''getSingleLoopExit-1 curLoopBegin)))
    )

    (§ defn- #_"void" LoopTransformations'processPreLoopPhis-3 [#_"LoopEx" preLoop, #_"LoopFragmentWhole" mainLoop, #_"LoopFragmentWhole" postLoop]
        ;; process phis for the post loop
        (doseq [#_"PhiNode" prePhiNode (AbstractMergeNode''phis-1 (LoopEx''loopBegin-1 preLoop))]
            (let [
                #_"PhiNode" postPhiNode (LoopFragment''getDuplicatedNode-2 postLoop, prePhiNode)
                #_"PhiNode" mainPhiNode (LoopFragment''getDuplicatedNode-2 mainLoop, prePhiNode)
            ]
                (PhiNode''setValueAt-3 postPhiNode, 0, mainPhiNode)

                ;; build a work list to update the pre loop phis to the post loops phis
                (doseq [#_"Node" usage (NodeIterable''snapshot-1 (Node''usages-1 prePhiNode))]
                    (when (and (not= usage mainPhiNode) (LoopEx''isOutsideLoop-2 preLoop, usage))
                        (Node''replaceFirstInput-3 usage, prePhiNode, postPhiNode)
                    )
                )
            )
        )
        (doseq [#_"Node" node (LoopFragmentInside''nodes-1 (LoopEx''inside-1 preLoop))]
            (doseq [#_"Node" externalUsage (NodeIterable''snapshot-1 (Node''usages-1 node))]
                (when (LoopEx''isOutsideLoop-2 preLoop, externalUsage)
                    (let [
                        #_"Node" postUsage (LoopFragment''getDuplicatedNode-2 postLoop, node)
                    ]
                        (Node''replaceFirstInput-3 externalUsage, node, postUsage)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Cleanup the merge and remove the predecessors too.
     ;;
    (§ defn- #_"void" LoopTransformations'cleanupMerge-2 [#_"AbstractMergeNode" mergeNode, #_"AbstractBeginNode" landingNode]
        (doseq [#_"EndNode" end (NodeIterable''snapshot-1 (AbstractMergeNode''cfgPredecessors-1 mergeNode))]
            (AbstractMergeNode''removeEnd-2 mergeNode, end)
            (Node''safeDelete-1 end)
        )
        (AbstractBeginNode''prepareDelete-2 mergeNode, landingNode)
        (Node''safeDelete-1 mergeNode)
        nil
    )

    (§ defn- #_"void" LoopTransformations'updateMainLoopLimit-3 [#_"IfNode" preLimit, #_"InductionVariable" preIv, #_"LoopFragmentWhole" mainLoop]
        ;; update the main loops limit test to be different than the post loop
        (let [
            #_"IfNode" mainLimit (LoopFragment''getDuplicatedNode-2 mainLoop, preLimit)
            #_"LogicNode" ifTest (:condition mainLimit)
            #_"ValueNode" prePhi (InductionVariable''valueNode-1 preIv)
            #_"ValueNode" mainPhi (LoopFragment''getDuplicatedNode-2 mainLoop, prePhi)
            #_"ValueNode" preStride (InductionVariable''strideNode-1 preIv)
            #_"ValueNode" mainStride (if (instance? ConstantNode preStride) preStride (LoopFragment''getDuplicatedNode-2 mainLoop, preStride))
            ;; fetch the bounds to pose lowering the range by one
            #_"ValueNode" ub
                (condp = mainPhi
                    (:x ifTest) (:y ifTest)
                    (:y ifTest) (:x ifTest)
                )
            ;; preloop always performs at least one iteration, so remove that from the main loop
            #_"ValueNode" newLimit (MathUtil'sub-3 (:graph preLimit), ub, mainStride)
        ]
            ;; re-wire the condition with the new limit
            (Node''replaceFirstInput-3 ifTest, ub, newLimit)
        )
        nil
    )

    (§ defn- #_"void" LoopTransformations'updatePreLoopLimit-3 [#_"IfNode" preLimit, #_"InductionVariable" preIv, #_"CountedLoopInfo" preCounted]
        ;; update the pre loops limit test
        (let [
            #_"Graph" graph (:graph preLimit)
            #_"LogicNode" ifTest (:condition preLimit)
            #_"ValueNode" prePhi (InductionVariable''valueNode-1 preIv)
            ;; make new limit one iteration
            #_"ValueNode" initIv (CountedLoopInfo''getStart-1 preCounted)
            #_"ValueNode" newLimit (MathUtil'add-3 graph, initIv, (InductionVariable''strideNode-1 preIv))
            ;; fetch the variable we are not replacing and configure the one we are
            #_"ValueNode" ub
                (condp = prePhi
                    (:x ifTest) (:y ifTest)
                    (:y ifTest) (:x ifTest)
                )
        ]
            ;; re-wire the condition with the new limit
            (Node''replaceFirstInput-3 ifTest, ub, (Graph''add-2 graph, (ConditionalNode'new-3 (Graph''add-2 graph, (if (= (InductionVariable''direction-1 preIv) :Direction'Up) (IntegerLessThanNode'new-2 newLimit, ub) (IntegerLessThanNode'new-2 ub, newLimit))), newLimit, ub)))
        )
        nil
    )

    ;; This function splits candidate loops into pre, main and post loops,
    ;; dividing the iteration space to facilitate the majority of iterations
    ;; being executed in a main loop, which will have RCE implemented upon it.
    ;; The initial loop form is constrained to single entry/exit, but can have
    ;; flow. The translation looks like:
    ;;
    ;;       (Simple Loop entry)                   (Pre Loop Entry)
    ;;                |                                  |
    ;;         (LoopBeginNode)                    (LoopBeginNode)
    ;;                |                                  |
    ;;       (Loop Control Test)<------   ==>  (Loop control Test)<------
    ;;         /               \       \         /               \       \
    ;;    (Loop Exit)      (Loop Body) |    (Loop Exit)      (Loop Body) |
    ;;        |                |       |        |                |       |
    ;; (continue code)     (Loop End)  |  if (M < length)*   (Loop End)  |
    ;;                         \       /       /      \           \      /
    ;;                          ----->        /       |            ----->
    ;;                                       /  if ( ... )*
    ;;                                      /     /       \
    ;;                                     /     /         \
    ;;                                    /     /           \
    ;;                                   |     /     (Main Loop Entry)
    ;;                                   |    |             |
    ;;                                   |    |      (LoopBeginNode)
    ;;                                   |    |             |
    ;;                                   |    |     (Loop Control Test)<------
    ;;                                   |    |      /               \        \
    ;;                                   |    |  (Loop Exit)      (Loop Body) |
    ;;                                    \   \      |                |       |
    ;;                                     \   \     |            (Loop End)  |
    ;;                                      \   \    |                \       /
    ;;                                       \   \   |                 ------>
    ;;                                        \   \  |
    ;;                                      (Main Loop Merge)*
    ;;                                               |
    ;;                                      (Post Loop Entry)
    ;;                                               |
    ;;                                        (LoopBeginNode)
    ;;                                               |
    ;;                                       (Loop Control Test)<-----
    ;;                                        /               \       \
    ;;                                    (Loop Exit)     (Loop Body) |
    ;;                                        |               |       |
    ;;                                 (continue code)    (Loop End)  |
    ;;                                                         \      /
    ;;                                                          ----->
    ;;
    ;; Key: "*" = optional.
    ;;
    ;; The value "M" is the maximal value of the loop trip for the original
    ;; loop. The value of "length" is applicable to the number of arrays found
    ;; in the loop but is reduced if some or all of the arrays are known to be
    ;; the same length as "M". The maximum number of tests can be equal to the
    ;; number of arrays in the loop, where multiple instances of an array are
    ;; subsumed into a single test for that arrays length.
    ;;
    ;; If the optional main loop entry tests are absent, the Pre Loop exit
    ;; connects to the Main loops entry and there is no merge hanging off the
    ;; main loops exit to converge flow from said tests. All split use data
    ;; flow is mitigated through phi(s) in the main merge if present and
    ;; passed through the main and post loop phi(s) from the originating pre
    ;; loop with final phi(s) and data flow patched to the "continue code".
    ;; The pre loop is constrained to one iteration for now and will likely
    ;; be updated to produce vector alignment if applicable.

    (§ defn #_"LoopBeginNode" LoopTransformations'insertPrePostLoops-1 [#_"LoopEx" loop]
        (let [
            #_"Graph" graph (:graph (LoopEx''loopBegin-1 loop))
            #_"LoopFragmentWhole" preLoop (LoopEx''whole-1 loop)
            #_"CountedLoopInfo" preCounted (:counted loop)
            #_"IfNode" preLimit (:ifNode preCounted)
            #_"LoopBeginNode" preLoopBegin (LoopEx''loopBegin-1 loop)
            #_"InductionVariable" preIv (:iv preCounted)
            #_"LoopExitNode" preLoopExitNode (LoopBeginNode''getSingleLoopExit-1 preLoopBegin)
            #_"FixedNode" continuationNode (:next preLoopExitNode)
            ;; each duplication is inserted after the original, ergo create the post loop first
            #_"LoopFragmentWhole" mainLoop (LoopFragmentWhole''duplicate-1 preLoop)
            #_"LoopFragmentWhole" postLoop (LoopFragmentWhole''duplicate-1 preLoop)
        ]
            (§ ass! preLoopBegin (LoopBeginNode''incrementSplits-1 preLoopBegin))
            (§ ass! preLoopBegin (LoopBeginNode''incrementSplits-1 preLoopBegin))
            (§ ass! preLoopBegin (LoopBeginNode''setPreLoop-1 preLoopBegin))
            (let [
                #_"LoopBeginNode" mainLoopBegin (LoopFragment''getDuplicatedNode-2 mainLoop, preLoopBegin)
            ]
                (§ ass! mainLoopBegin (LoopBeginNode''setMainLoop-1 mainLoopBegin))
                (let [
                    #_"LoopBeginNode" postLoopBegin (LoopFragment''getDuplicatedNode-2 postLoop, preLoopBegin)
                ]
                    (§ ass! postLoopBegin (LoopBeginNode''setPostLoop-1 postLoopBegin))

                    (let [
                        #_"EndNode" postEndNode (LoopTransformations'getBlockEndAfterLoopExit-1 postLoopBegin)
                        #_"AbstractMergeNode" postMergeNode (AbstractEndNode''merge-1 postEndNode)
                        #_"LoopExitNode" postLoopExitNode (LoopBeginNode''getSingleLoopExit-1 postLoopBegin)
                    ]
                        ;; update the main loop phi initialization to carry from the pre loop
                        (doseq [#_"PhiNode" prePhiNode (AbstractMergeNode''phis-1 preLoopBegin)]
                            (PhiNode''setValueAt-3 (LoopFragment''getDuplicatedNode-2 mainLoop, prePhiNode), 0, prePhiNode)
                        )

                        (let [
                            #_"EndNode" mainEndNode (LoopTransformations'getBlockEndAfterLoopExit-1 mainLoopBegin)
                            #_"AbstractMergeNode" mainMergeNode (AbstractEndNode''merge-1 mainEndNode)
                            #_"AbstractEndNode" postEntryNode (LoopBeginNode''forwardEnd-1 postLoopBegin)
                            ;; in the case of no Bounds tests, we just flow right into the main loop
                            #_"AbstractBeginNode" mainLandingNode (BeginNode'begin-1 postEntryNode)
                            #_"LoopExitNode" mainLoopExitNode (LoopBeginNode''getSingleLoopExit-1 mainLoopBegin)
                        ]
                            (§ ass! mainLoopExitNode (FixedWithNextNode''setNext-2 mainLoopExitNode, mainLandingNode))
                            (§ ass! preLoopExitNode (FixedWithNextNode''setNext-2 preLoopExitNode, (LoopBeginNode''forwardEnd-1 mainLoopBegin)))

                            ;; add and update any phi edges as per merge usage as needed and update usages
                            (LoopTransformations'processPreLoopPhis-3 loop, mainLoop, postLoop)
                            (Node''clearSuccessors-1 (:predecessor continuationNode))
                            (§ ass! postLoopExitNode (FixedWithNextNode''setNext-2 postLoopExitNode, continuationNode))
                            (LoopTransformations'cleanupMerge-2 postMergeNode, postLoopExitNode)
                            (LoopTransformations'cleanupMerge-2 mainMergeNode, mainLandingNode)

                            ;; change the preLoop to execute one iteration for now
                            (LoopTransformations'updateMainLoopLimit-3 preLimit, preIv, mainLoop)
                            (LoopTransformations'updatePreLoopLimit-3 preLimit, preIv, preCounted)
                            (§ ass! preLoopBegin (LoopBeginNode''setLoopFrequency-2 preLoopBegin, 1))
                            (§ ass! mainLoopBegin (LoopBeginNode''setLoopFrequency-2 mainLoopBegin, (max 0.0 (- (:loopFrequency mainLoopBegin) 2))))
                            (§ ass! postLoopBegin (LoopBeginNode''setLoopFrequency-2 postLoopBegin, (max 0.0 (- (:loopFrequency postLoopBegin) 1))))

                            ;; the pre and post loops don't require safepoints at all
                            (doseq [#_"SafepointNode" safepoint (NodeIterable''filter-2 (LoopFragmentWhole''nodes-1 preLoop), SafepointNode)]
                                (Graph''removeFixed-2 graph, safepoint)
                            )
                            (doseq [#_"SafepointNode" safepoint (NodeIterable''filter-2 (LoopFragmentWhole''nodes-1 postLoop), SafepointNode)]
                                (Graph''removeFixed-2 graph, safepoint)
                            )
                            mainLoopBegin
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"List<ControlSplitNode>" LoopTransformations'findUnswitchable-1 [#_"LoopEx" loop]
        (let [
            [#_"ValueNode" invariantValue #_"List<ControlSplitNode>" controls]
                (loop-when [invariantValue nil controls nil #_"ISeq" s (seq (NodeIterable''filter-2 (LoopFragmentWhole''nodes-1 (LoopEx''whole-1 loop)), IfNode))] (some? s) => [invariantValue controls]
                    (let [
                        #_"IfNode" ifNode (first s)
                        [invariantValue controls]
                            (when (LoopEx''isOutsideLoop-2 loop, (:condition ifNode)) => [invariantValue controls]
                                (if (nil? controls)
                                    (let [
                                        controls (ArrayList.)
                                    ]
                                        (#_"List" .add controls, ifNode)
                                        [(:condition ifNode) controls]
                                    )
                                    (do
                                        (when (= (:condition ifNode) invariantValue)
                                            (#_"List" .add controls, ifNode)
                                        )
                                        [invariantValue controls]
                                    )
                                )
                            )
                    ]
                        (recur invariantValue controls (next s))
                    )
                )
        ]
            (or controls
                (loop-when [#_"SwitchNode" firstSwitch nil invariantValue invariantValue controls controls #_"ISeq" s (seq (NodeIterable''filter-2 (LoopFragmentWhole''nodes-1 (LoopEx''whole-1 loop)), SwitchNode))] (some? s) => controls
                    (let [
                        #_"SwitchNode" switchNode (first s)
                        [firstSwitch invariantValue controls]
                            (when (and (< 1 (NodeIterable''count-1 (Node''successors-1 switchNode))) (LoopEx''isOutsideLoop-2 loop, (SwitchNode''value-1 switchNode))) => [firstSwitch invariantValue controls]
                                (if (nil? controls)
                                    (let [
                                        controls (ArrayList.)
                                    ]
                                        (#_"List" .add controls, switchNode)
                                        [switchNode (SwitchNode''value-1 switchNode) controls]
                                    )
                                    (do
                                        (when (and (= (SwitchNode''value-1 switchNode) invariantValue) (SwitchNode''structureEquals-2 firstSwitch, switchNode))
                                            ;; only collect switches which test the same values in the same order
                                            (#_"List" .add controls, switchNode)
                                        )
                                        [firstSwitch invariantValue controls]
                                    )
                                )
                            )
                    ]
                        (recur firstSwitch invariantValue controls (next s))
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" LoopTransformations'isUnrollableLoop-1 [#_"LoopEx" loop]
        (and (LoopEx''isCounted-1 loop)
            (InductionVariable''isConstantStride-1 (:iv (:counted loop)))
            (empty? (:children (:loop loop)))
            (let [
                #_"LoopBeginNode" loopBegin (LoopEx''loopBegin-1 loop)
                #_"LogicNode" logic (:condition (:ifNode (:counted loop)))
            ]
                (and (instance? CompareNode logic)
                    (not (= (CompareNode''condition-1 logic) CanonicalCondition'EQ))
                    (or (LoopBeginNode''isMainLoop-1 loopBegin) (LoopBeginNode''isSimpleLoop-1 loopBegin))
                    ;; Flow-less loops to partial unroll for now. 3 blocks corresponds to an if that either exits
                    ;; or continues the loop. There might be fixed and floating work within the loop as well.
                    (< (count (:blocks (:loop loop))) 3)
                )
            )
        )
    )
)

(final-ns LoopUnswitchingPhase (§ extends ContextlessLoopPhase #_"<LoopPolicies>")
    (§ defn #_"LoopUnswitchingPhase" LoopUnswitchingPhase'new-1 [#_"LoopPolicies" policies]
        (ContextlessLoopPhase'new-1 policies)
    )

    #_unused
    (§ override! #_"void" LoopUnswitchingPhase''run-2 [#_"LoopUnswitchingPhase" this, #_"Graph" graph]
        (when (Graph''hasLoops-1 graph)
            (loop []
                (let [
                    #_"LoopsData" dataUnswitch (LoopsData'new-1 graph)
                    #_"boolean" unswitched?
                        (loop-when [#_"ISeq" s (seq (:loops dataUnswitch))] (some? s) => false
                            (let [
                                #_"LoopEx" loop (first s)
                            ]
                                (when (LoopPolicies''shouldTryUnswitch-2 (:policies this), loop) => (recur (next s))
                                    (let [
                                        #_"List<ControlSplitNode>" controlSplits (LoopTransformations'findUnswitchable-1 loop)
                                    ]
                                        (when (and (some? controlSplits) (LoopPolicies''shouldUnswitch-3 (:policies this), loop, controlSplits)) => (recur (next s))
                                            (LoopTransformations'unswitch-2 loop, controlSplits)
                                            true
                                        )
                                    )
                                )
                            )
                        )
                ]
                    (recur-if unswitched? [])
                )
            )
        )
        nil
    )
)

;;;
 ; Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} so that
 ; invariant parts of the expression can move outside of the loop.
 ;;
(final-ns ReassociateInvariantPhase (§ extends Phase)
    (§ defn #_"ReassociateInvariantPhase" ReassociateInvariantPhase'new-0 []
        (Phase'new-0)
    )

    #_unused
    (§ override! #_"void" ReassociateInvariantPhase''run-2 [#_"ReassociateInvariantPhase" this, #_"Graph" graph]
        (loop [#_"int" iterations 0]
            (let [
                #_"LoopsData" dataReassociate (LoopsData'new-1 graph)
                #_"boolean" changed?
                    (loop-when-recur [changed? false #_"ISeq" s (seq (:loops dataReassociate))]
                                     (some? s)
                                     [(or changed? (LoopEx''reassociateInvariants-1 (first s))) (next s)]
                                  => changed?
                    )
            ]
                (LoopsData''deleteUnusedNodes-1 dataReassociate)
                (recur-if changed? [(inc iterations)])
            )
        )
        nil
    )
)

(value-ns InputType
    ;;;
     ; Inputs that consume an actual value generated by the referenced node.
     ;;
    (§ enum InputType'Value)
    ;;;
     ; Inputs that consume the memory state of the referenced node.
     ;;
    (§ enum InputType'Memory)
    ;;;
     ; Inputs that reference a condition.
     ;;
    (§ enum InputType'ConditionI)
    ;;;
     ; Inputs that reference a frame state.
     ;;
    (§ enum InputType'StateI)
    ;;;
     ; Inputs that reference a guard (guards, begin nodes).
     ;;
    (§ enum InputType'Guard)
    ;;;
     ; Inputs that reference an anchor (begin nodes, value anchors).
     ;;
    (§ enum InputType'Anchor)
    ;;;
     ; Inputs that represent an association between nodes, e.g. a phi and the merge or a loop begin
     ; and loop exits and ends.
     ;;
    (§ enum InputType'Association)
    ;;;
     ; Inputs that connect tightly coupled nodes, e.g. an InvokeNode and its CallTargetNode.
     ;;
    (§ enum InputType'Extension)
    ;;;
     ; Inputs of this type are temporarily exempt from type checking. This should only be used in
     ; exceptional cases and should never survive to later stages of compilation.
     ;;
    (§ enum InputType'Unchecked)
)

;;;
 ; Marker type for describing node inputs in snippets that are not of type InputType#Value.
 ;;
(class-ns StructuralInput
    (§ defn- #_"StructuralInput" StructuralInput'new-0 []
        (Object.)
    )
)

;;;
 ; @anno StructuralInput.MarkerType
 ; @target ElementType.TYPE
 ;;
; @Inherited
(§ annotation MarkerType
    (§ value #_"InputType" value nil)
)

;;;
 ; Marker type for InputType#Memory edges in snippets.
 ;
 ; @anno StructuralInput.Memory
 ;;
; @MarkerType(InputType'Memory)
(final-ns Memory (§ extends StructuralInput)
    #_unused
    (§ defn #_"Memory" Memory'new-0 []
        (StructuralInput'new-0)
    )
)

;;;
 ; Marker type for InputType#ConditionI edges in snippets.
 ;
 ; @anno StructuralInput.ConditionI
 ;;
; @MarkerType(InputType'ConditionI)
(final-ns ConditionI (§ extends StructuralInput)
    #_unused
    (§ defn #_"ConditionI" ConditionI'new-0 []
        (StructuralInput'new-0)
    )
)

;;;
 ; Marker type for InputType#StateI edges in snippets.
 ;
 ; @anno StructuralInput.StateI
 ;;
; @MarkerType(InputType'StateI)
(final-ns StateI (§ extends StructuralInput)
    #_unused
    (§ defn #_"StateI" StateI'new-0 []
        (StructuralInput'new-0)
    )
)

;;;
 ; Marker type for InputType#Guard edges in snippets.
 ;
 ; @anno StructuralInput.Guard
 ;;
; @MarkerType(InputType'Guard)
(final-ns Guard (§ extends StructuralInput)
    #_unused
    (§ defn #_"Guard" Guard'new-0 []
        (StructuralInput'new-0)
    )
)

;;;
 ; Marker type for InputType#Anchor edges in snippets.
 ;
 ; @anno StructuralInput.Anchor
 ;;
; @MarkerType(InputType'Anchor)
(final-ns Anchor (§ extends StructuralInput)
    #_unused
    (§ defn #_"Anchor" Anchor'new-0 []
        (StructuralInput'new-0)
    )
)

;;;
 ; Marker type for InputType#Association edges in snippets.
 ;
 ; @anno StructuralInput.Association
 ;;
; @MarkerType(InputType'Association)
(class-ns Association (§ extends StructuralInput)
    (§ defn #_"Association" Association'new-0 []
        (StructuralInput'new-0)
    )
)

;;;
 ; Marker type for InputType#Extension edges in snippets.
 ;
 ; @anno StructuralInput.Extension
 ;;
; @MarkerType(InputType'Extension)
(final-ns Extension (§ extends StructuralInput)
    #_unused
    (§ defn #_"Extension" Extension'new-0 []
        (StructuralInput'new-0)
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Guard, InputType.Anchor"
(class-ns AbstractBeginNode (§ extends FixedWithNextNode) (§ implements LIRLowerable, GuardingNode, AnchoringNode, IterableNodeType)
    (§ def #_"NodeClass<AbstractBeginNode>" AbstractBeginNode'TYPE (NodeClass'create-1 AbstractBeginNode))

    (§ defn #_"AbstractBeginNode" AbstractBeginNode'new-1 [#_"NodeClass<? extends AbstractBeginNode>" c]
        (AbstractBeginNode'new-2 c, (StampFactory'forVoid-0))
    )

    (§ defn #_"AbstractBeginNode" AbstractBeginNode'new-2 [#_"NodeClass<? extends AbstractBeginNode>" c, #_"Stamp" stamp]
        (FixedWithNextNode'new-2 c, stamp)
    )

    (§ defn #_"AbstractBeginNode" AbstractBeginNode'prevBegin-1 [#_"FixedNode" node]
        (loop-when [node node] (some? node)
            (if (instance? AbstractBeginNode node)
                node
                (recur (:predecessor node))
            )
        )
    )

    (§ method- #_"void" AbstractBeginNode''evacuateGuards-2 [#_"AbstractBeginNode" this, #_"FixedNode" evacuateFrom]
        (when-not (Node''hasNoUsages-1 this)
            (let [
                #_"AbstractBeginNode" prevBegin (AbstractBeginNode'prevBegin-1 evacuateFrom)
            ]
                (doseq [#_"Node" anchored (NodeIterable''snapshot-1 (AbstractBeginNode''anchored-1 this))]
                    (Node''replaceFirstInput-3 anchored, this, prevBegin)
                )
            )
        )
        nil
    )

    (§ method #_"void" AbstractBeginNode''prepareDelete-1 [#_"AbstractBeginNode" this]
        (AbstractBeginNode''prepareDelete-2 this, (:predecessor this))
        nil
    )

    (§ method #_"void" AbstractBeginNode''prepareDelete-2 [#_"AbstractBeginNode" this, #_"FixedNode" evacuateFrom]
        (AbstractBeginNode''evacuateGuards-2 this, evacuateFrom)
        nil
    )

    #_unused
    (§ override #_"void" AbstractBeginNode''generate-2 [#_"AbstractBeginNode" this, #_"LIRBuilder" builder]
        ;; nop
        nil
    )

    (§ method! #_"NodeIterable<GuardNode>" AbstractBeginNode''guards-1 [#_"AbstractBeginNode" this]
        (NodeIterable''filter-2 (Node''usages-1 this), GuardNode)
    )

    (§ method #_"NodeIterable<Node>" AbstractBeginNode''anchored-1 [#_"AbstractBeginNode" this]
        (Node''usages-1 this)
    )

    (§ method! #_"NodeIterable<FixedNode>" AbstractBeginNode''getBlockNodes-1 [#_"AbstractBeginNode" this]
        (let [
            #_"AbstractBeginNode" beginNode this
        ]
            (§ reify #_"NodeIterable<FixedNode>" (NodeIterable'reify-0)
                (§ override! #_"Iterator<FixedNode>" #_"Iterable" .iterator [#_"NodeIterable<FixedNode>" this]
                    (BlockNodeIterator'new-1 beginNode)
                )
            )
        )
    )
)

;;;
 ; @anno AbstractBeginNode.BlockNodeIterator
 ;;
(final-ns BlockNodeIterator (§ implements Iterator #_"<FixedNode>")
    (§ mutable #_"FixedNode" :current nil)

    (§ defn #_"BlockNodeIterator" BlockNodeIterator'new-1 [#_"FixedNode" next]
        (let [
            #_"BlockNodeIterator" this (Object.)
            this (assoc this :current next)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" BlockNodeIterator''hasNext-1 [#_"BlockNodeIterator" this]
        (some? (:current this))
    )

    #_unused
    (§ override! #_"FixedNode" BlockNodeIterator''next-1 [#_"BlockNodeIterator" this]
        (let [
            #_"FixedNode" ret (:current this)
        ]
            (when (some? ret) => (throw (NoSuchElementException.))
                (if (instance? FixedWithNextNode (:current this))
                    (do
                        (§ ass! this (assoc this :current (:next (:current this))))
                        (when (instance? AbstractBeginNode (:current this))
                            (§ ass! this (assoc this :current nil))
                        )
                    )
                    (§ ass! this (assoc this :current nil))
                )
                ret
            )
        )
    )
)

;;;
 ; This node represents an unconditional explicit request for immediate deoptimization.
 ;
 ; After this node, execution will continue using a fallback execution engine (such as an
 ; interpreter) at the position described by the {@link #stateBefore() deoptimization state}.
 ;;
(class-ns AbstractDeoptimizeNode (§ extends ControlSinkNode) (§ implements IterableNodeType, DeoptBefore)
    (§ def #_"NodeClass<AbstractDeoptimizeNode>" AbstractDeoptimizeNode'TYPE (NodeClass'create-1 AbstractDeoptimizeNode))

    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateBefore nil)

    (§ defn #_"AbstractDeoptimizeNode" AbstractDeoptimizeNode'new-2 [#_"NodeClass<? extends AbstractDeoptimizeNode>" c, #_"FrameState" stateBefore]
        (let [
            #_"AbstractDeoptimizeNode" this (ControlSinkNode'new-2 c, (StampFactory'forVoid-0))
            this (assoc this :stateBefore stateBefore)
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" AbstractDeoptimizeNode''canDeoptimize-1 [#_"AbstractDeoptimizeNode" this]
        true
    )

    (§ override #_"FrameState" AbstractDeoptimizeNode''stateBefore-1 [#_"AbstractDeoptimizeNode" this]
        (:stateBefore this)
    )

    (§ override #_"void" AbstractDeoptimizeNode''setStateBefore-2 [#_"AbstractDeoptimizeNode" this, #_"FrameState" f]
        (Node''updateUsages-3 this, (:stateBefore this), f)
        (§ ass! this (assoc this :stateBefore f))
        nil
    )

    (§ abstract #_"ValueNode" AbstractDeoptimizeNode''getActionAndReason-1 [#_"AbstractDeoptimizeNode" this])

    (§ abstract #_"ValueNode" AbstractDeoptimizeNode''getSpeculation-1 [#_"AbstractDeoptimizeNode" this])
)

(class-ns AbstractEndNode (§ extends FixedNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<AbstractEndNode>" AbstractEndNode'TYPE (NodeClass'create-1 AbstractEndNode))

    (§ defn #_"AbstractEndNode" AbstractEndNode'new-1 [#_"NodeClass<? extends AbstractEndNode>" c]
        (FixedNode'new-2 c, (StampFactory'forVoid-0))
    )

    (§ override #_"void" AbstractEndNode''generate-2 [#_"AbstractEndNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''visitEndNode-2 builder, this)
        nil
    )

    (§ method #_"AbstractMergeNode" AbstractEndNode''merge-1 [#_"AbstractEndNode" this]
        (NodeIterable''first-1 (Node''usages-1 this))
    )

    #_unused
    (§ override #_"Iterable<? extends Node>" AbstractEndNode''cfgSuccessors-1 [#_"AbstractEndNode" this]
        (let [
            #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 this)
        ]
            (if (some? merge) (Collections/singletonList merge) (Collections/emptyList))
        )
    )
)

(class-ns AbstractFixedGuardNode (§ extends DeoptimizingFixedWithNextNode) (§ implements Simplifiable, GuardingNode, DeoptimizingGuard)
    (§ def #_"NodeClass<AbstractFixedGuardNode>" AbstractFixedGuardNode'TYPE (NodeClass'create-1 AbstractFixedGuardNode))

    ; @Input(InputType'ConditionI)
    (§ mutable #_"LogicNode" :condition nil)
    (§ mutable #_"DeoptimizationReason" :reason nil)
    (§ mutable #_"DeoptimizationAction" :action nil)
    (§ mutable #_"JavaConstant" :speculation nil)
    (§ mutable #_"boolean" :negated? false)

    (§ override #_"LogicNode" AbstractFixedGuardNode''getCondition-1 [#_"AbstractFixedGuardNode" this]
        (:condition this)
    )

    (§ method #_"LogicNode" AbstractFixedGuardNode''condition-1 [#_"AbstractFixedGuardNode" this]
        (AbstractFixedGuardNode''getCondition-1 this)
    )

    (§ override #_"void" AbstractFixedGuardNode''setCondition-3 [#_"AbstractFixedGuardNode" this, #_"LogicNode" x, #_"boolean" negated?]
        (Node''updateUsages-3 this, (:condition this), x)
        (§ ass! this (assoc this :condition x))
        (§ ass! this (assoc this :negated? negated?))
        nil
    )

    (§ defn #_"AbstractFixedGuardNode" AbstractFixedGuardNode'new-6 [#_"NodeClass<? extends AbstractFixedGuardNode>" c, #_"LogicNode" condition, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"JavaConstant" speculation, #_"boolean" negated?]
        (let [
            #_"AbstractFixedGuardNode" this (DeoptimizingFixedWithNextNode'new-2 c, (StampFactory'forVoid-0))
            this (assoc this :action action)
            this (assoc this :speculation speculation)
            this (assoc this :negated? negated?)
            this (assoc this :condition condition)
            this (assoc this :reason reason)
        ]
            this
        )
    )

    (§ override #_"void" AbstractFixedGuardNode''simplify-2 [#_"AbstractFixedGuardNode" this, #_"SimplifierTool" tool]
        (while (instance? LogicNegationNode (:condition this))
            (AbstractFixedGuardNode''setCondition-3 this, (LogicNegationNode''getValue-1 (:condition this)), (not (:negated? this)))
        )
        nil
    )

    (§ method #_"DeoptimizeNode" AbstractFixedGuardNode''lowerToIf-1 [#_"AbstractFixedGuardNode" this]
        (let [
            #_"FixedNode" currentNext (:next this)
        ]
            (§ ass! this (FixedWithNextNode''setNext-2 this, nil))
            (let [
                #_"DeoptimizeNode" deopt (Graph''add-2 (:graph this), (DeoptimizeNode'new-3 (:action this), (:reason this), (:speculation this)))
            ]
                (AbstractDeoptimizeNode''setStateBefore-2 deopt, (DeoptimizingFixedWithNextNode''stateBefore-1 this))
                (let [
                    [#_"IfNode" ifNode #_"AbstractBeginNode" noDeoptSuccessor]
                        (if (:negated? this)
                            (let [
                                ifNode (Graph''add-2 (:graph this), (IfNode'new-4 (:condition this), deopt, currentNext, 0))
                            ]
                                [ifNode (:falseSuccessor ifNode)]
                            )
                            (let [
                                ifNode (Graph''add-2 (:graph this), (IfNode'new-4 (:condition this), currentNext, deopt, 1))
                            ]
                                [ifNode (:trueSuccessor ifNode)]
                            )
                        )
                ]
                    (§ ass! (:predecessor this) (FixedWithNextNode''setNext-2 (:predecessor this), ifNode))
                    (§ ass! this (Node''replaceAtUsages-2 this, noDeoptSuccessor))
                    (GraphUtil'killWithUnusedFloatingInputs-1 this)

                    deopt
                )
            )
        )
    )

    #_unused
    (§ override #_"boolean" AbstractFixedGuardNode''canDeoptimize-1 [#_"AbstractFixedGuardNode" this]
        true
    )

    #_unused
    (§ override #_"void" AbstractFixedGuardNode''setAction-2 [#_"AbstractFixedGuardNode" this, #_"DeoptimizationAction" action]
        (§ ass! this (assoc this :action action))
        nil
    )

    #_unused
    (§ override #_"void" AbstractFixedGuardNode''setReason-2 [#_"AbstractFixedGuardNode" this, #_"DeoptimizationReason" reason]
        (§ ass! this (assoc this :reason reason))
        nil
    )
)

(class-ns AbstractLocalNode (§ extends FloatingNode)
    (§ def #_"NodeClass<AbstractLocalNode>" AbstractLocalNode'TYPE (NodeClass'create-1 AbstractLocalNode))

    (§ final #_"int" :index 0)

    (§ defn #_"AbstractLocalNode" AbstractLocalNode'new-3 [#_"NodeClass<? extends AbstractLocalNode>" c, #_"int" index, #_"Stamp" stamp]
        (let [
            #_"AbstractLocalNode" this (FloatingNode'new-2 c, stamp)
            this (assoc this :index index)
        ]
            this
        )
    )

    ;;;
     ; Gets the index of this local in the array of parameters. This is NOT the JVM local index.
     ;
     ; @return the index
     ;;
    (§ method #_"int" AbstractLocalNode''index-1 [#_"AbstractLocalNode" this]
        (:index this)
    )
)

;;;
 ; Denotes the merging of multiple control-flow paths.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Association"
(class-ns AbstractMergeNode (§ extends BeginStateSplitNode) (§ implements IterableNodeType, Simplifiable, LIRLowerable)
    (§ def #_"NodeClass<AbstractMergeNode>" AbstractMergeNode'TYPE (NodeClass'create-1 AbstractMergeNode))

    (§ defn #_"AbstractMergeNode" AbstractMergeNode'new-1 [#_"NodeClass<? extends AbstractMergeNode>" c]
        (BeginStateSplitNode'new-1 c)
    )

    ; @Input(InputType'Association)
    (§ mutable #_"NodeInputList<EndNode>" :ends (NodeInputList'new-1 this))

    #_unused
    (§ override #_"void" AbstractMergeNode''generate-2 [#_"AbstractMergeNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''visitMerge-2 builder, this)
        nil
    )

    (§ method! #_"int" AbstractMergeNode''forwardEndIndex-2 [#_"AbstractMergeNode" this, #_"EndNode" end]
        (NodeList''indexOf-2 (:ends this), end)
    )

    (§ method! #_"void" AbstractMergeNode''addForwardEnd-2 [#_"AbstractMergeNode" this, #_"EndNode" end]
        (NodeList''add-2 (:ends this), end)
        nil
    )

    (§ method! #_"int" AbstractMergeNode''forwardEndCount-1 [#_"AbstractMergeNode" this]
        (count (:ends this))
    )

    (§ method! #_"EndNode" AbstractMergeNode''forwardEndAt-2 [#_"AbstractMergeNode" this, #_"int" index]
        (nth (:ends this) index)
    )

    (§ override #_"NodeIterable<EndNode>" AbstractMergeNode''cfgPredecessors-1 [#_"AbstractMergeNode" this]
        (:ends this)
    )

    ;;;
     ; Determines if a given node is a phi whose {@linkplain PhiNode#merge() merge} is this node.
     ;
     ; @param value the instruction to test
     ; @return true if {@code value} is a phi and its merge is {@code this}
     ;;
    (§ method! #_"boolean" AbstractMergeNode''isPhiAtMerge-2 [#_"AbstractMergeNode" this, #_"Node" value]
        (and (instance? PhiNode value) (= (PhiNode''merge-1 value) this))
    )

    ;;;
     ; Removes the given end from the merge, along with the entries corresponding to this end in the
     ; phis connected to the merge.
     ;
     ; @param pred the end to remove
     ;;
    (§ method! #_"void" AbstractMergeNode''removeEnd-2 [#_"AbstractMergeNode" this, #_"AbstractEndNode" pred]
        (let [
            #_"int" predIndex (AbstractMergeNode''phiPredecessorIndex-2 this, pred)
        ]
            (AbstractMergeNode''deleteEnd-2 this, pred)
            (doseq [#_"PhiNode" phi (NodeIterable''snapshot-1 (AbstractMergeNode''phis-1 this))]
                (when-not (Node''isDeleted-1 phi)
                    (let [
                        #_"ValueNode" removedValue (PhiNode''valueAt-2 phi, predIndex)
                    ]
                        (PhiNode''removeInput-2 phi, predIndex)
                        (when (some? removedValue)
                            (GraphUtil'tryKillUnused-1 removedValue)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method #_"void" AbstractMergeNode''deleteEnd-2 [#_"AbstractMergeNode" this, #_"AbstractEndNode" end]
        (NodeList''remove-2 (:ends this), end)
        nil
    )

    #_unused
    (§ method! #_"void" AbstractMergeNode''clearEnds-1 [#_"AbstractMergeNode" this]
        (NodeList''clear-1 (:ends this))
        nil
    )

    (§ method! #_"NodeInputList<EndNode>" AbstractMergeNode''forwardEnds-1 [#_"AbstractMergeNode" this]
        (:ends this)
    )

    (§ method #_"int" AbstractMergeNode''phiPredecessorCount-1 [#_"AbstractMergeNode" this]
        (AbstractMergeNode''forwardEndCount-1 this)
    )

    (§ method #_"int" AbstractMergeNode''phiPredecessorIndex-2 [#_"AbstractMergeNode" this, #_"AbstractEndNode" pred]
        (AbstractMergeNode''forwardEndIndex-2 this, pred)
    )

    (§ method #_"AbstractEndNode" AbstractMergeNode''phiPredecessorAt-2 [#_"AbstractMergeNode" this, #_"int" index]
        (AbstractMergeNode''forwardEndAt-2 this, index)
    )

    (§ method! #_"NodeIterable<PhiNode>" AbstractMergeNode''phis-1 [#_"AbstractMergeNode" this]
        (NodeIterable''filter-2 (NodeIterable''filter-2 (Node''usages-1 this), PhiNode), (ß this(§ ffun )AbstractMergeNode''isPhiAtMerge-2))
    )

    (§ method! #_"NodeIterable<ValuePhiNode>" AbstractMergeNode''valuePhis-1 [#_"AbstractMergeNode" this]
        (NodeIterable''filter-2 (Node''usages-1 this), ValuePhiNode)
    )

    (§ method! #_"NodeIterable<MemoryPhiNode>" AbstractMergeNode''memoryPhis-1 [#_"AbstractMergeNode" this]
        (NodeIterable''filter-2 (Node''usages-1 this), MemoryPhiNode)
    )

    (§ override #_"NodeIterable<Node>" AbstractMergeNode''anchored-1 [#_"AbstractMergeNode" this]
        (NodeIterable''filter-2 (AbstractBeginNode''anchored-1 (§ super )), (ß n -> (§ fun (not (AbstractMergeNode''isPhiAtMerge-2 this, n)))))
    )

    ;;;
     ; This simplify method can deal with a nil value for tool, so that it can be used outside of canonicalization.
     ;;
    #_unused
    (§ override #_"void" AbstractMergeNode''simplify-2 [#_"AbstractMergeNode" this, #_"SimplifierTool" tool]
        (let [
            #_"FixedNode" node (:next this)
        ]
            (condp instance? node
                AbstractEndNode
                    (let [
                        #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 node)
                    ]
                        (or
                            (when (and (instance? LoopBeginNode merge) (not (instance? LoopEndNode node)))
                                :done
                            )
                            ;; In order to move anchored values to the other merge we would need to check
                            ;; if the anchors are used by phis of the other merge.
                            (when (NodeIterable''isNotEmpty-1 (AbstractMergeNode''anchored-1 this))
                                :done
                            )
                            ;; We hold a state, but the succeeding merge does not => do not combine.
                            (when (and (nil? (BeginStateSplitNode''stateAfter-1 merge)) (some? (BeginStateSplitNode''stateAfter-1 this)))
                                :done
                            )
                            (loop-when [#_"ISeq" s (seq (AbstractMergeNode''phis-1 this))] (some? s)
                                (let [
                                    #_"PhiNode" phi (first s)
                                ]
                                    (or
                                        (loop-when [#_"ISeq" s (seq (Node''usages-1 phi))] (some? s)
                                            (let [
                                                #_"Node" usage (first s)
                                            ]
                                                (if (and (not (instance? VirtualState usage)) (not (AbstractMergeNode''isPhiAtMerge-2 merge, usage)))
                                                    :done
                                                    (recur (next s))
                                                )
                                            )
                                        )
                                        (recur (next s))
                                    )
                                )
                            )
                            (let [
                                #_"int" n (dec (AbstractMergeNode''forwardEndCount-1 this))
                            ]
                                (dotimes [#_"int" i n]
                                    (let [
                                        #_"AbstractEndNode" end (AbstractMergeNode''forwardEndAt-2 this, (- n i))
                                    ]
                                        (when (some? tool)
                                            (SimplifierTool''addToWorkList-2 tool, end)
                                        )
                                        (let [
                                            #_"AbstractEndNode" newEnd
                                                (if (instance? LoopBeginNode merge)
                                                    (Graph''add-2 (:graph this), (LoopEndNode'new-1 merge))
                                                    (let [
                                                        newEnd (Graph''add-2 (:graph this), (EndNode'new-0))
                                                    ]
                                                        (AbstractMergeNode''addForwardEnd-2 merge, newEnd)
                                                        newEnd
                                                    )
                                                )
                                        ]
                                            (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 merge)]
                                                (let [
                                                    #_"ValueNode" v (PhiNode''valueAt-2 phi, node)
                                                ]
                                                    (PhiNode''addInput-2 phi, (if (AbstractMergeNode''isPhiAtMerge-2 this, v) (PhiNode''valueAt-2 v, end) v))
                                                )
                                            )
                                            (AbstractMergeNode''removeEnd-2 this, end)
                                            (Node''replaceAtPredecessor-2 end, newEnd)
                                            (Node''safeDelete-1 end)
                                            (when (some? tool)
                                                (SimplifierTool''addToWorkList-2 tool, (:predecessor newEnd))
                                            )
                                        )
                                    )
                                )
                                (Graph''reduceTrivialMerge-2 (:graph this), this)
                            )
                        )
                    )
                ReturnNode
                    (when-not (or (NodeIterable''isNotEmpty-1 (AbstractMergeNode''anchored-1 this)) (some? (:memoryMap node)))
                        (let [
                            #_"List<PhiNode>" phis (NodeIterable''snapshot-1 (AbstractMergeNode''phis-1 this))
                        ]
                            (or
                                (loop-when [#_"ISeq" s (seq phis)] (some? s)
                                    (let [
                                        #_"PhiNode" phi (first s)
                                    ]
                                        (or
                                            (loop-when [#_"ISeq" s (seq (Node''usages-1 phi))] (some? s)
                                                (let [
                                                    #_"Node" usage (first s)
                                                ]
                                                    (if (and (not (= usage node)) (not (instance? FrameState usage)))
                                                        :done
                                                        (recur (next s))
                                                    )
                                                )
                                            )
                                            (recur (next s))
                                        )
                                    )
                                )
                                (let [
                                    #_"ValuePhiNode" returnValuePhi (when-not (or (nil? (:result node)) (not (AbstractMergeNode''isPhiAtMerge-2 this, (:result node)))) (:result node))
                                    #_"List<EndNode>" endNodes (NodeList''snapshot-1 (AbstractMergeNode''forwardEnds-1 this))
                                ]
                                    (doseq [#_"EndNode" end endNodes]
                                        (let [
                                            #_"ReturnNode" newReturn (Graph''add-2 (:graph this), (ReturnNode'new-1 (if (nil? returnValuePhi) (:result node) (PhiNode''valueAt-2 returnValuePhi, end))))
                                        ]
                                            (when (some? tool)
                                                (SimplifierTool''addToWorkList-2 tool, (:predecessor end))
                                            )
                                            (Node''replaceAtPredecessor-2 end, newReturn)
                                        )
                                    )
                                    (GraphUtil'killCFG-1 this)
                                    (doseq [#_"EndNode" end endNodes]
                                        (Node''safeDelete-1 end)
                                    )
                                    (doseq [#_"PhiNode" phi phis]
                                        (when (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''isAlive-1 phi) (Node''hasNoUsages-1 phi))
                                            (GraphUtil'killWithUnusedFloatingInputs-1 phi)
                                        )
                                    )
                                )
                            )
                        )
                    )
                nil
            )
        )
        nil
    )
)

;;;
 ; Provides an implementation of StateSplit.
 ;;
(class-ns AbstractStateSplit (§ extends FixedWithNextNode) (§ implements StateSplit)
    (§ def #_"NodeClass<AbstractStateSplit>" AbstractStateSplit'TYPE (NodeClass'create-1 AbstractStateSplit))

    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)

    (§ override #_"FrameState" AbstractStateSplit''stateAfter-1 [#_"AbstractStateSplit" this]
        (:stateAfter this)
    )

    (§ override #_"void" AbstractStateSplit''setStateAfter-2 [#_"AbstractStateSplit" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    #_unused
    (§ override #_"boolean" AbstractStateSplit''hasSideEffect-1 [#_"AbstractStateSplit" this]
        true
    )

    (§ defn #_"AbstractStateSplit" AbstractStateSplit'new-2 [#_"NodeClass<? extends AbstractStateSplit>" c, #_"Stamp" stamp]
        (AbstractStateSplit'new-3 c, stamp, nil)
    )

    (§ defn #_"AbstractStateSplit" AbstractStateSplit'new-3 [#_"NodeClass<? extends AbstractStateSplit>" c, #_"Stamp" stamp, #_"FrameState" stateAfter]
        (let [
            #_"AbstractStateSplit" this (FixedWithNextNode'new-2 c, stamp)
            this (assoc this :stateAfter stateAfter)
        ]
            this
        )
    )
)

;;;
 ; An ArithmeticOperation is an operation that does primitive value arithmetic without side effect.
 ;;
(§ interface ArithmeticOperation
    #_unused
    (§ abstract #_"ArithmeticOp" ArithmeticOperation''getArithmeticOp-1 [#_"ArithmeticOperation" this])
)

(final-ns BeginNode (§ extends AbstractBeginNode) (§ implements Simplifiable)
    (§ def #_"NodeClass<BeginNode>" BeginNode'TYPE (NodeClass'create-1 BeginNode))

    (§ defn #_"BeginNode" BeginNode'new-0 []
        (AbstractBeginNode'new-2 BeginNode'TYPE, (StampFactory'forVoid-0))
    )

    #_unused
    (§ defn #_"BeginNode" BeginNode'new-1 [#_"Stamp" stamp]
        (AbstractBeginNode'new-2 BeginNode'TYPE, stamp)
    )

    #_unused
    (§ method! #_"void" BeginNode''trySimplify-1 [#_"BeginNode" this]
        (let [
            #_"FixedNode" prev (:predecessor this)
        ]
            (if (instance? ControlSplitNode prev)
                nil ;; This begin node is necessary.
                (do
                    ;; This begin node can be removed and all guards moved up to the preceding begin node.
                    (AbstractBeginNode''prepareDelete-1 this)
                    (Graph''removeFixed-2 (:graph this), this)
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" BeginNode''simplify-2 [#_"BeginNode" this, #_"SimplifierTool" tool]
        (let [
            #_"FixedNode" prev (:predecessor this)
        ]
            (cond
                (nil? prev)
                    nil ;; This is the start node.
                (instance? ControlSplitNode prev)
                    nil ;; This begin node is necessary.
                :else
                    (do
                        ;; This begin node can be removed and all guards moved up to the preceding begin node.
                        (AbstractBeginNode''prepareDelete-1 this)
                        (SimplifierTool''addToWorkList-2 tool, (:next this))
                        (Graph''removeFixed-2 (:graph this), this)
                    )
            )
        )
        nil
    )

    (§ defn #_"AbstractBeginNode" BeginNode'begin-1 [#_"FixedNode" with]
        (when-not (instance? AbstractBeginNode with) => with
            (let [
                #_"BeginNode" begin (Graph''add-2 (:graph with), (BeginNode'new-0))
            ]
                (§ ass! begin (FixedWithNextNode''setNext-2 begin, with))
                begin
            )
        )
    )
)

;;;
 ; Base class for AbstractBeginNodes that are associated with a frame state.
 ;
 ; TODO this not needed until AbstractBeginNode no longer implements StateSplit
 ; which is not possible until loop peeling works without requiring begin nodes to have frames states.
 ;;
(class-ns BeginStateSplitNode (§ extends AbstractBeginNode) (§ implements StateSplit)
    (§ def #_"NodeClass<BeginStateSplitNode>" BeginStateSplitNode'TYPE (NodeClass'create-1 BeginStateSplitNode))

    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)

    (§ defn #_"BeginStateSplitNode" BeginStateSplitNode'new-1 [#_"NodeClass<? extends BeginStateSplitNode>" c]
        (AbstractBeginNode'new-1 c)
    )

    #_unused
    (§ defn #_"BeginStateSplitNode" BeginStateSplitNode'new-2 [#_"NodeClass<? extends BeginStateSplitNode>" c, #_"Stamp" stamp]
        (AbstractBeginNode'new-2 c, stamp)
    )

    (§ override #_"FrameState" BeginStateSplitNode''stateAfter-1 [#_"BeginStateSplitNode" this]
        (:stateAfter this)
    )

    (§ override #_"void" BeginStateSplitNode''setStateAfter-2 [#_"BeginStateSplitNode" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    ;;;
     ; A begin node has no side effect.
     ;;
    #_unused
    (§ override #_"boolean" BeginStateSplitNode''hasSideEffect-1 [#_"BeginStateSplitNode" this]
        false
    )
)

(class-ns BinaryOpLogicNode (§ extends LogicNode) (§ implements LIRLowerable, Binary #_"<ValueNode>")
    (§ def #_"NodeClass<BinaryOpLogicNode>" BinaryOpLogicNode'TYPE (NodeClass'create-1 BinaryOpLogicNode))

    ; @Input
    (§ mutable #_"ValueNode" :x nil)
    ; @Input
    (§ mutable #_"ValueNode" :y nil)

    (§ defn #_"BinaryOpLogicNode" BinaryOpLogicNode'new-3 [#_"NodeClass<? extends BinaryOpLogicNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOpLogicNode" this (LogicNode'new-1 c)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override #_"void" BinaryOpLogicNode''generate-2 [#_"BinaryOpLogicNode" this, #_"LIRBuilder" builder]
        nil
    )

    ;;;
     ; Ensure a canonical ordering of inputs for commutative nodes to improve GVN results. Order the inputs
     ; by increasing Node#id and call Graph#findDuplicate(Node) on the node if it's currently in a graph.
     ;
     ; @return the original node or another node with the same inputs, ignoring ordering
     ;;
    (§ method #_"LogicNode" BinaryOpLogicNode''maybeCommuteInputs-1 [#_"BinaryOpLogicNode" this]
        (when (and (not (instance? ConstantNode (:y this))) (or (instance? ConstantNode (:x this)) (< (:id (:y this)) (:id (:x this))))) => this
            (assoc this :x (:y this) :y (:x this))
        )
    )

    (§ abstract #_"Stamp" BinaryOpLogicNode''getSucceedingStampForX-4 [#_"BinaryOpLogicNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp])

    (§ abstract #_"Stamp" BinaryOpLogicNode''getSucceedingStampForY-4 [#_"BinaryOpLogicNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp])

    (§ abstract #_"TriState" BinaryOpLogicNode''tryFold-3 [#_"BinaryOpLogicNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp])
)

(class-ns AddNode (§ extends BinaryArithmeticNode #_"<Add>") (§ implements NarrowableArithmeticNode, BinaryCommutative #_"<ValueNode>")
    (§ def #_"NodeClass<AddNode>" AddNode'TYPE (NodeClass'create-1 AddNode))

    (§ defn #_"AddNode" AddNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (AddNode'new-3 AddNode'TYPE, x, y)
    )

    (§ defn #_"AddNode" AddNode'new-3 [#_"NodeClass<? extends AddNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (BinaryArithmeticNode'new-4 c, :add, x, y)
    )

    (§ defn #_"ValueNode" AddNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Add>" op (:add (ArithmeticOpTable'forStamp-1 (:stamp x)))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, (BinaryOp''foldStamp-3 op, (:stamp x), (:stamp y)))
                (if (and (instance? ConstantNode x) (not (instance? ConstantNode y)))
                    (AddNode'canonical-4 nil, op, y, x)
                    (AddNode'canonical-4 nil, op, x, y)
                )
            )
        )
    )

    (§ defn- #_"ValueNode" AddNode'canonical-4 [#_"AddNode" self, #_"BinaryOp<Add>" op, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"boolean" associative? (BinaryOp''isAssociative-1 op)
        ]
            (when associative?
                (when (and (instance? SubNode forX) (= (:y forX) forY)) ;; (a - b) + b
                    (§ return (:x forX))
                )
                (when (and (instance? SubNode forY) (= (:y forY) forX)) ;; b + (a - b)
                    (§ return (:x forY))
                )
            )
            (when (instance? ConstantNode forY)
                (when (BinaryOp''isNeutral-2 op, (:value forY))
                    (§ return forX)
                )
                (when (and associative? (some? self))
                    ;; canonicalize expressions like "(a + 1) + 2"
                    (let [
                        #_"ValueNode" reassociated (BinaryArithmeticNode'reassociate-4 self, (ValueNode'isConstantPredicate-0), forX, forY)
                    ]
                        (when-not (= reassociated self)
                            (§ return reassociated)
                        )
                    )
                )
            )
            (cond
                (instance? NegateNode forX) (BinaryArithmeticNode'sub-2 forY, (UnaryNode''getValue-1 forX))
                (instance? NegateNode forY) (BinaryArithmeticNode'sub-2 forX, (UnaryNode''getValue-1 forY))
                :else                       (or self (BinaryArithmeticNode''maybeCommuteInputs-1 (AddNode'new-2 forX, forY)))
            )
        )
    )

    #_unused
    (§ override #_"ValueNode" AddNode''canonical-4 [#_"AddNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (BinaryArithmeticNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (if (and (instance? ConstantNode forX) (not (instance? ConstantNode forY)))
                    ;; we try to swap and canonicalize
                    (let [
                        #_"ValueNode" improvement (BinaryArithmeticNode''canonical-4 this, tool, forY, forX)
                    ]
                        (when (= improvement this) => improvement
                            ;; if this fails we only swap
                            (AddNode'new-2 forY, forX)
                        )
                    )
                    (AddNode'canonical-4 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), forX, forY)
                )
            )
        )
    )

    #_unused
    (§ override #_"void" AddNode''generate-2 [#_"AddNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value" op1 (LIRBuilder''operand-2 builder, (:x this))
            #_"Value" op2 (LIRBuilder''operand-2 builder, (:y this))
            [op1 op2]
                (when (BinaryArithmeticNode''shouldSwapInputs-2 this, builder) => [op1 op2]
                    [op2 op1]
                )
        ]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAdd-4 (:gen builder), op1, op2, false))
        )
        nil
    )
)

(final-ns AndNode (§ extends BinaryArithmeticNode #_"<And>") (§ implements NarrowableArithmeticNode, BinaryCommutative #_"<ValueNode>")
    (§ def #_"NodeClass<AndNode>" AndNode'TYPE (NodeClass'create-1 AndNode))

    (§ defn #_"AndNode" AndNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (BinaryArithmeticNode'new-4 AndNode'TYPE, :and, x, y)
    )

    (§ defn #_"ValueNode" AndNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<And>" op (:and (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp)
                (AndNode'canonical-5 nil, op, stamp, x, y)
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" AndNode''canonical-4 [#_"AndNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (BinaryArithmeticNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (AndNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
            )
        )
    )

    (§ defn- #_"ValueNode" AndNode'canonical-5 [#_"AndNode" self, #_"BinaryOp<And>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1 forX) (GraphUtil'unproxify-1 forY))
                forX
            (and (instance? ConstantNode forX) (not (instance? ConstantNode forY)))
                (AndNode'new-2 forY, forX)
            (instance? ConstantNode forY)
                (let [
                    #_"Constant" c (:value forY)
                ]
                    (when-not (BinaryOp''isNeutral-2 op, c) => forX
                        (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                            (let [
                                #_"long" rawY (#_"PrimitiveConstant" .asLong c)
                            ]
                                (when (zero? (& rawY (CodeUtil/mask (PrimitiveStamp'getBits-1 stamp))))
                                    (§ return (ConstantNode'forIntegerStamp-2 stamp, 0))
                                )
                                (when (and (instance? SignExtendNode forX) (= rawY (dec (<< 1 (IntegerConvertNode''getInputBits-1 forX)))))
                                    (§ return (ZeroExtendNode'new-2 (UnaryNode''getValue-1 forX), (IntegerConvertNode''getResultBits-1 forX)))
                                )
                                (when (zero? (& (| (:upMask (:stamp forX)) (:downMask (:stamp forX))) (bit-not rawY)))
                                    ;; No bits are set which are outside the mask, so the mask will have no effect.
                                    (§ return forX)
                                )
                            )
                        )
                        (BinaryArithmeticNode'reassociate-4 (or self (BinaryArithmeticNode''maybeCommuteInputs-1 (AndNode'new-2 forX, forY))), (ValueNode'isConstantPredicate-0), forX, forY)
                    )
                )
            (and (instance? NotNode forX) (instance? NotNode forY))
                (NotNode'new-1 (OrNode'create-2 (UnaryNode''getValue-1 forX), (UnaryNode''getValue-1 forY)))
            :else
                (or self (BinaryArithmeticNode''maybeCommuteInputs-1 (AndNode'new-2 forX, forY)))
        )
    )

    #_unused
    (§ override! #_"void" AndNode''generate-2 [#_"AndNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAnd-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )
)

(class-ns BinaryArithmeticNode #_"<OP>" (§ extends BinaryNode) (§ implements ArithmeticOperation, LIRLowerable, Binary #_"<ValueNode>")
    (§ def #_"NodeClass<BinaryArithmeticNode>" BinaryArithmeticNode'TYPE (NodeClass'create-1 BinaryArithmeticNode))

    (§ final #_"SerializableBinaryFunction<OP>" :getOp nil)

    (§ defn #_"BinaryArithmeticNode" BinaryArithmeticNode'new-4 [#_"NodeClass<? extends BinaryArithmeticNode<OP>>" c, #_"SerializableBinaryFunction<OP>" getOp, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryArithmeticNode" this (BinaryNode'new-4 c, (BinaryOp''foldStamp-3 (Function''apply-2 getOp, (ArithmeticOpTable'forStamp-1 (:stamp x))), (:stamp x), (:stamp y)), x, y)
            this (assoc this :getOp getOp)
        ]
            this
        )
    )

    (§ method! #_"BinaryOp<OP>" BinaryArithmeticNode''getOp-3 [#_"BinaryArithmeticNode<OP>" this, #_"ValueNode" forX, #_"ValueNode" forY]
        (Function''apply-2 (:getOp this), (ArithmeticOpTable'forStamp-1 (:stamp forX)))
    )

    (§ override! #_"BinaryOp<OP>" BinaryArithmeticNode''getArithmeticOp-1 [#_"BinaryArithmeticNode<OP>" this]
        (BinaryArithmeticNode''getOp-3 this, (:x this), (:y this))
    )

    (§ method #_"boolean" BinaryArithmeticNode''isAssociative-1 [#_"BinaryArithmeticNode<OP>" this]
        (BinaryOp''isAssociative-1 (BinaryArithmeticNode''getArithmeticOp-1 this))
    )

    (§ override #_"ValueNode" BinaryArithmeticNode''canonical-4 [#_"BinaryArithmeticNode<OP>" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (BinaryArithmeticNode'tryConstantFold-4 (BinaryArithmeticNode''getOp-3 this, forX, forY), forX, forY, (:stamp this))
            this
        )
    )

    (§ defn #_"<OP> ConstantNode" BinaryArithmeticNode'tryConstantFold-4 [#_"BinaryOp<OP>" op, #_"ValueNode" forX, #_"ValueNode" forY, #_"Stamp" stamp]
        (when (and (instance? ConstantNode forX) (instance? ConstantNode forY))
            (let [
                #_"Constant" constant (BinaryOp''foldConstant-3 op, (:value forX), (:value forY))
            ]
                (when (some? constant)
                    (ConstantNode'forPrimitive-2 stamp, constant)
                )
            )
        )
    )

    (§ override #_"Stamp" BinaryArithmeticNode''foldStamp-3 [#_"BinaryArithmeticNode<OP>" this, #_"Stamp" stampX, #_"Stamp" stampY]
        (BinaryOp''foldStamp-3 (BinaryArithmeticNode''getArithmeticOp-1 this), stampX, stampY)
    )

    (§ defn #_"ValueNode" BinaryArithmeticNode'add-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (Graph''addOrUniqueWithInputs-2 graph, (AddNode'create-2 v1, v2))
    )

    (§ defn #_"ValueNode" BinaryArithmeticNode'add-2 [#_"ValueNode" v1, #_"ValueNode" v2]
        (AddNode'create-2 v1, v2)
    )

    (§ defn #_"ValueNode" BinaryArithmeticNode'mul-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (Graph''addOrUniqueWithInputs-2 graph, (MulNode'create-2 v1, v2))
    )

    (§ defn #_"ValueNode" BinaryArithmeticNode'mul-2 [#_"ValueNode" v1, #_"ValueNode" v2]
        (MulNode'create-2 v1, v2)
    )

    (§ defn #_"ValueNode" BinaryArithmeticNode'sub-3 [#_"Graph" graph, #_"ValueNode" v1, #_"ValueNode" v2]
        (Graph''addOrUniqueWithInputs-2 graph, (SubNode'create-2 v1, v2))
    )

    (§ defn #_"ValueNode" BinaryArithmeticNode'sub-2 [#_"ValueNode" v1, #_"ValueNode" v2]
        (SubNode'create-2 v1, v2)
    )

    (§ defn- #_"ReassociateMatch" BinaryArithmeticNode'findReassociate-2 [#_"BinaryNode" binary, #_"NodePredicate" criterion]
        (let [
            #_"boolean" resultX (NodePredicate''apply-2 criterion, (:x binary))
            #_"boolean" resultY (NodePredicate''apply-2 criterion, (:y binary))
        ]
            (cond
                (and resultX (not resultY)) :ReassociateMatch'x
                (and (not resultX) resultY) :ReassociateMatch'y
            )
        )
    )

    ;; In reassociate, complexity comes from the handling of IntegerSub (non commutative) which can
    ;; be mixed with IntegerAdd. It first tries to find m1, m2 which match the criterion :
    ;; (a o m2) o m1
    ;; (m2 o a) o m1
    ;; m1 o (a o m2)
    ;; m1 o (m2 o a)
    ;; It then produces 4 boolean for the -/+ cases:
    ;; invertA : should the final expression be like *-a (rather than a+*)
    ;; aSub : should the final expression be like a-* (rather than a+*)
    ;; invertM1 : should the final expression contain -m1
    ;; invertM2 : should the final expression contain -m2

    ;;;
     ; Tries to re-associate values which satisfy the criterion. For example with a constantness
     ; criterion: {@code (a + 2) + 1 => a + (1 + 2)}.
     ;
     ; This method accepts only {@linkplain BinaryOp#isAssociative() associative}
     ; operations such as +, -, *, &, | and ^.
     ;;
    (§ defn #_"ValueNode" BinaryArithmeticNode'reassociate-4 [#_"BinaryArithmeticNode" self, #_"NodePredicate" criterion, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ReassociateMatch" match1 (BinaryArithmeticNode'findReassociate-2 self, criterion)
        ]
            (when (some? match1) => self
                (let [
                    #_"ValueNode" other (ReassociateMatch''getOtherValue-2 match1, self)
                    [#_"boolean" addSub #_"boolean" subAdd]
                        (when-not (= (#_"Object" .getClass other) (#_"Object" .getClass self)) => [false false]
                            (cond
                                (and (instance? AddNode self) (instance? SubNode other)) [true false]
                                (and (instance? SubNode self) (instance? AddNode other)) [false true]
                                :else
                                    (§ return self)
                            )
                        )
                ]
                    (let [
                        #_"ReassociateMatch" match2 (BinaryArithmeticNode'findReassociate-2 other, criterion)
                    ]
                        (when (some? match2) => self
                            (let [
                                [#_"boolean" invertA #_"boolean" aSub #_"boolean" invertM1 #_"boolean" invertM2]
                                    (cond
                                        addSub
                                            (let [
                                                invertM2 (= match2 :ReassociateMatch'y)
                                            ]
                                                [(not invertM2) false false invertM2]
                                            )
                                        subAdd
                                            (let [
                                                invertM2 (= match1 :ReassociateMatch'x)
                                            ]
                                                [invertM2 false (not invertM2) invertM2]
                                            )
                                        (and (instance? SubNode self) (instance? SubNode other))
                                            [
                                                (bit-xor (= match1 :ReassociateMatch'x) (= match2 :ReassociateMatch'x))
                                                (and     (= match1 :ReassociateMatch'y) (= match2 :ReassociateMatch'y))
                                                (and     (= match1 :ReassociateMatch'y) (= match2 :ReassociateMatch'x))
                                                (and     (= match1 :ReassociateMatch'x) (= match2 :ReassociateMatch'x))
                                            ]
                                        :else
                                            [false false false false]
                                    )
                                #_"ValueNode" m1 (ReassociateMatch''getValue-2 match1, self)
                                #_"ValueNode" m2 (ReassociateMatch''getValue-2 match2, other)
                                #_"ValueNode" a (ReassociateMatch''getOtherValue-2 match2, other)
                            ]
                                (if (or (instance? AddNode self) (instance? SubNode self))
                                    (let [
                                        #_"ValueNode" associated
                                            (cond
                                                invertM1 (BinaryArithmeticNode'sub-2 m2, m1)
                                                invertM2 (BinaryArithmeticNode'sub-2 m1, m2)
                                                :else    (BinaryArithmeticNode'add-2 m1, m2)
                                            )
                                    ]
                                        (cond
                                            invertA (BinaryArithmeticNode'sub-2 associated, a)
                                            aSub    (BinaryArithmeticNode'sub-2 a, associated)
                                            :else   (BinaryArithmeticNode'add-2 a, associated)
                                        )
                                    )
                                    (condp instance? self
                                        MulNode (BinaryArithmeticNode'mul-2 a, (BinaryArithmeticNode'mul-2 m1, m2))
                                        AndNode (AndNode'new-2 a, (AndNode'new-2 m1, m2))
                                        OrNode  (OrNode'new-2 a, (OrNode'new-2 m1, m2))
                                        XorNode (XorNode'new-2 a, (XorNode'new-2 m1, m2))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Ensure a canonical ordering of inputs for commutative nodes to improve GVN results. Order the
     ; inputs by increasing Node#id and call Graph#findDuplicate(Node) on the node
     ; if it's currently in a graph. It's assumed that if there was a constant on the left it's been
     ; moved to the right by other code and that ordering is left alone.
     ;
     ; @return the original node or another node with the same input ordering
     ;;
    (§ method #_"BinaryNode" BinaryArithmeticNode''maybeCommuteInputs-1 [#_"BinaryArithmeticNode<OP>" this]
        (when (and (not (instance? ConstantNode (:y this))) (or (instance? ConstantNode (:x this)) (< (:id (:y this)) (:id (:x this))))) => this
            (assoc this :x (:y this) :y (:x this))
        )
    )

    ;;;
     ; Determines if it would be better to swap the inputs in order to produce better assembly code.
     ; First we try to pick a value which is dead after this use. If both values are dead at this
     ; use then we try pick an induction variable phi to encourage the phi to live in a single register.
     ;
     ; @return true if inputs should be swapped, false otherwise
     ;;
    (§ method! #_"boolean" BinaryArithmeticNode''shouldSwapInputs-2 [#_"BinaryArithmeticNode<OP>" this, #_"LIRBuilder" builder]
        (let [
            #_"boolean" xHasOtherUsages (ValueNode''hasUsagesOtherThan-3 (:x this), this, builder)
            #_"boolean" yHasOtherUsages (ValueNode''hasUsagesOtherThan-3 (:y this), this, builder)
        ]
            (and (not (instance? ConstantNode (:y this)))
                 (not yHasOtherUsages)
                (or (not (= xHasOtherUsages yHasOtherUsages))
                    (and (instance? ValuePhiNode (:y this))
                         (NodeIterable''contains-2 (Node''inputs-1 (:y this)), this)
                    )
                )
            )
        )
    )
)

;;;
 ; @anno BinaryArithmeticNode.SerializableBinaryFunction
 ;;
(§ interface SerializableBinaryFunction #_"<T>" (§ extends Function #_"<ArithmeticOpTable, BinaryOp<T>>")
)

;;;
 ; @anno BinaryArithmeticNode.ReassociateMatch
 ;;
(value-ns ReassociateMatch
    :ReassociateMatch'x
    :ReassociateMatch'y

    (§ method! #_"ValueNode" ReassociateMatch''getValue-2 [#_"ReassociateMatch" this, #_"BinaryNode" binary]
        (condp = this
            :ReassociateMatch'x (:x binary)
            :ReassociateMatch'y (:y binary)
        )
    )

    (§ method! #_"ValueNode" ReassociateMatch''getOtherValue-2 [#_"ReassociateMatch" this, #_"BinaryNode" binary]
        (condp = this
            :ReassociateMatch'x (:y binary)
            :ReassociateMatch'y (:x binary)
        )
    )
)

;;;
 ; The BinaryNode class is the base of arithmetic and logic operations with two inputs.
 ;;
(class-ns BinaryNode (§ extends FloatingNode) (§ implements Binary #_"<ValueNode>")
    (§ def #_"NodeClass<BinaryNode>" BinaryNode'TYPE (NodeClass'create-1 BinaryNode))

    ; @Input
    (§ mutable #_"ValueNode" :x nil)
    ; @Input
    (§ mutable #_"ValueNode" :y nil)

    #_unused
    (§ method! #_"BinaryNode" BinaryNode''setX-2 [#_"BinaryNode" this, #_"ValueNode" x]
        (Node''updateUsages-3 this, (:x this), x)
        (assoc this :x x)
    )

    #_unused
    (§ method! #_"BinaryNode" BinaryNode''setY-2 [#_"BinaryNode" this, #_"ValueNode" y]
        (Node''updateUsages-3 this, (:y this), y)
        (assoc this :y y)
    )

    ;;;
     ; Creates a new BinaryNode instance.
     ;
     ; @param stamp the result type of this instruction
     ; @param x the first input instruction
     ; @param y the second input instruction
     ;;
    (§ defn #_"BinaryNode" BinaryNode'new-4 [#_"NodeClass<? extends BinaryNode>" c, #_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryNode" this (FloatingNode'new-2 c, stamp)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" BinaryNode''inferStamp-1 [#_"BinaryNode" this]
        (ValueNode''updateStamp-2 this, (BinaryNode''foldStamp-3 this, (:stamp (:x this)), (:stamp (:y this))))
    )

    ;;;
     ; Compute an improved for this node using the passed in stamps. The stamps must be compatible
     ; with the current values of #x and #y. This code is used to provide the
     ; default implementation of #inferStamp() and may be used by external optimizations.
     ;;
    (§ abstract #_"Stamp" BinaryNode''foldStamp-3 [#_"BinaryNode" this, #_"Stamp" stampX, #_"Stamp" stampY])
)

(class-ns CompareNode (§ extends BinaryOpLogicNode) (§ implements Binary #_"<ValueNode>")
    (§ def #_"NodeClass<CompareNode>" CompareNode'TYPE (NodeClass'create-1 CompareNode))

    (§ final #_"CanonicalCondition" :condition nil)

    ;;;
     ; Constructs a new Compare instruction.
     ;
     ; @param x the instruction producing the first input to the instruction
     ; @param y the instruction that produces the second input to this instruction
     ;;
    (§ defn #_"CompareNode" CompareNode'new-4 [#_"NodeClass<? extends CompareNode>" c, #_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"CompareNode" this (BinaryOpLogicNode'new-3 c, x, y)
            this (assoc this :condition condition)
        ]
            this
        )
    )

    ;;;
     ; Gets the condition (comparison operation) for this instruction.
     ;
     ; @return the condition
     ;;
    (§ method! #_"CanonicalCondition" CompareNode''condition-1 [#_"CompareNode" this]
        (:condition this)
    )

    (§ defn #_"LogicNode" CompareNode'tryConstantFold-3 [#_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (and (instance? ConstantNode forX) (instance? ConstantNode forY) (or (some? HotSpot'constantReflection) (instance? PrimitiveConstant (:value forX))))
            (LogicConstantNode'forBoolean-1 (Condition''foldCondition-3 (:condition condition), (:value forX), (:value forY)))
        )
    )

    (§ defn #_"LogicNode" CompareNode'tryConstantFoldPrimitive-3 [#_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (and (instance? PrimitiveConstant (ValueNode''asConstant-1 forX)) (instance? PrimitiveConstant (ValueNode''asConstant-1 forY)))
            (LogicConstantNode'forBoolean-1 (Condition''foldCondition-3 (:condition condition), (ValueNode''asConstant-1 forX), (ValueNode''asConstant-1 forY)))
        )
    )

    ;;;
     ; Does this operation represent an identity check such that for x == y,
     ; x is exactly the same thing as y.
     ;
     ; @return true for identity comparisons
     ;;
    (§ method! #_"boolean" CompareNode''isIdentityComparison-1 [#_"CompareNode" this]
        (= (:condition this) CanonicalCondition'EQ)
    )

    (§ defn #_"LogicNode" CompareNode'createCompareNode-4 [#_"Graph" graph, #_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"LogicNode" result (CompareNode'createCompareNode-3 condition, x, y)
        ]
            (if (nil? (:graph result)) (Graph''addOrUniqueWithInputs-2 graph, result) result)
        )
    )

    (§ defn #_"LogicNode" CompareNode'createCompareNode-3 [#_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (condp = condition
            CanonicalCondition'EQ
                (condp instance? (:stamp x)
                    AbstractObjectStamp  (ObjectEqualsNode'create-2 x, y)
                    AbstractPointerStamp (PointerEqualsNode'create-2 x, y)
                                         (IntegerEqualsNode'create-2 x, y)
                )
            CanonicalCondition'LT (IntegerLessThanNode'create-2 x, y)
                                  (IntegerBelowNode'create-2 x, y)
        )
    )

    #_unused
    (§ defn #_"LogicNode" CompareNode'createCompareNode-5 [#_"Graph" graph, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"LogicNode" result (CompareNode'createCompareNode-4 smallestCompareWidth, condition, x, y)
        ]
            (if (nil? (:graph result)) (Graph''addOrUniqueWithInputs-2 graph, result) result)
        )
    )

    (§ defn #_"LogicNode" CompareNode'createCompareNode-4 [#_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (condp = condition
            CanonicalCondition'EQ
                (condp instance? (:stamp x)
                    AbstractObjectStamp  (ObjectEqualsNode'createCanonical-2 x, y)
                    AbstractPointerStamp (PointerEqualsNode'create-2 x, y)
                                         (IntegerEqualsNode'create-3 smallestCompareWidth, x, y)
                )
            CanonicalCondition'LT (IntegerLessThanNode'create-3 smallestCompareWidth, x, y)
                                  (IntegerBelowNode'create-3 smallestCompareWidth, x, y)
        )
    )
)

;;;
 ; @anno CompareNode.CompareOp
 ;;
(class-ns CompareOp
    (§ defn #_"CompareOp" CompareOp'new-0 []
        (Object.)
    )

    (§ method #_"LogicNode" CompareOp''canonical-5 [#_"CompareOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (CompareNode'tryConstantFold-3 condition, forX, forY)
            (cond
                (instance? ConstantNode forX)
                    (CompareOp''canonicalizeSymmetricConstant-6 this, smallestCompareWidth, condition, (:value forX), forY, true)
                (instance? ConstantNode forY)
                    (CompareOp''canonicalizeSymmetricConstant-6 this, smallestCompareWidth, condition, (:value forY), forX, false)
                (and (instance? ConvertNode forX) (instance? ConvertNode forY))
                    (when (and (ConvertNode''preservesOrder-2 forX, condition) (ConvertNode''preservesOrder-2 forY, condition) (Stamp''isCompatible-2 (:stamp (ConvertNode''getValue-1 forX)), (:stamp (ConvertNode''getValue-1 forY))))
                        (let [
                            #_"boolean" supported?
                                (when (instance? IntegerStamp (:stamp (ConvertNode''getValue-1 forX))) => true
                                    (and (some? smallestCompareWidth) (<= smallestCompareWidth (:bits (:stamp (ConvertNode''getValue-1 forX)))))
                                )
                        ]
                            (when supported?
                                ;; do not perform for zero or sign extend if there are multiple usages of the value
                                (when-not (and (or (instance? ZeroExtendNode forX) (instance? SignExtendNode forX)) (or (Node''hasMoreThanOneUsage-1 forX) (Node''hasMoreThanOneUsage-1 forY)))
                                    (CompareOp''duplicateModified-3 this, (ConvertNode''getValue-1 forX), (ConvertNode''getValue-1 forY))
                                )
                            )
                        )
                    )
            )
        )
    )

    (§ method #_"LogicNode" CompareOp''canonicalizeSymmetricConstant-6 [#_"CompareOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"Constant" constant, #_"ValueNode" node, #_"boolean" mirrored?]
        (condp instance? node
            ConditionalNode
                (CompareOp'optimizeConditional-3 constant, node, (if mirrored? (Condition''mirror-1 (:condition condition)) (:condition condition)))
            NormalizeCompareNode
                (CompareOp''optimizeNormalizeCompare-5 this, smallestCompareWidth, constant, node, mirrored?)
            ConvertNode
                ;; do not perform for zero or sign extend if it could introduce new live values
                (when-not (and (or (instance? ZeroExtendNode node) (instance? SignExtendNode node)) (Node''hasMoreThanOneUsage-1 node) (Node''hasExactlyOneUsage-1 (ConvertNode''getValue-1 node)))
                    (let [
                        #_"Stamp" stamp (:stamp (ConvertNode''getValue-1 node))
                        #_"boolean" supported?
                            (when (instance? IntegerStamp stamp) => true
                                (and (some? smallestCompareWidth) (< smallestCompareWidth (:bits stamp)))
                            )
                    ]
                        (when supported?
                            (let [
                                #_"ConstantNode" newConstant (CompareOp'canonicalConvertConstant-3 condition, node, constant)
                            ]
                                (when (some? newConstant)
                                    (if mirrored?
                                        (CompareOp''duplicateModified-3 this, newConstant, (ConvertNode''getValue-1 node))
                                        (CompareOp''duplicateModified-3 this, (ConvertNode''getValue-1 node), newConstant)
                                    )
                                )
                            )
                        )
                    )
                )
            nil
        )
    )

    (§ defn- #_"ConstantNode" CompareOp'canonicalConvertConstant-3 [#_"CanonicalCondition" condition, #_"ConvertNode" convert, #_"Constant" constant]
        (when (ConvertNode''preservesOrder-3 convert, condition, constant)
            (let [
                #_"Constant" reverseConverted (ConvertNode''reverse-2 convert, constant)
            ]
                (when (and (some? reverseConverted) (= (ConvertNode''convert-2 convert, reverseConverted) constant))
                    (ConstantNode'forConstant-2 (:stamp (ConvertNode''getValue-1 convert)), reverseConverted)
                )
            )
        )
    )

    (§ method #_"LogicNode" CompareOp''optimizeNormalizeCompare-5 [#_"CompareOp" this, #_"Integer" smallestCompareWidth, #_"Constant" constant, #_"NormalizeCompareNode" normalizeNode, #_"boolean" mirrored?]
        (throw! (str "NormalizeCompareNode connected to " this " (" constant " " normalizeNode " " mirrored? ")"))
    )

    (§ defn- #_"LogicNode" CompareOp'optimizeConditional-3 [#_"Constant" constant, #_"ConditionalNode" conditionalNode, #_"Condition" condition]
        (let [
            #_"Constant" trueConstant (ValueNode''asConstant-1 (:trueValue conditionalNode))
            #_"Constant" falseConstant (ValueNode''asConstant-1 (:falseValue conditionalNode))
        ]
            (when (and (some? falseConstant) (some? trueConstant) (some? HotSpot'constantReflection))
                (let [
                    #_"boolean" trueResult (Condition''foldCondition-3 condition, trueConstant, constant)
                    #_"boolean" falseResult (Condition''foldCondition-3 condition, falseConstant, constant)
                ]
                    (cond
                        (= trueResult falseResult) (LogicConstantNode'forBoolean-1 trueResult)
                        trueResult                 (:condition conditionalNode)
                        :else                      (LogicNegationNode'create-1 (:condition conditionalNode))
                    )
                )
            )
        )
    )

    (§ abstract #_"LogicNode" CompareOp''duplicateModified-3 [#_"CompareOp" this, #_"ValueNode" newW, #_"ValueNode" newY])
)

;;;
 ; The ConditionalNode class represents a comparison that yields one of two (eagerly
 ; evaluated) values.
 ;;
(final-ns ConditionalNode (§ extends FloatingNode) (§ implements Canonicalizable, LIRLowerable)
    (§ def #_"NodeClass<ConditionalNode>" ConditionalNode'TYPE (NodeClass'create-1 ConditionalNode))

    ; @Input(InputType'ConditionI)
    (§ mutable #_"LogicNode" :condition nil)
    ; @Input(InputType'Value)
    (§ mutable #_"ValueNode" :trueValue nil)
    ; @Input(InputType'Value)
    (§ mutable #_"ValueNode" :falseValue nil)

    (§ defn #_"ConditionalNode" ConditionalNode'new-1 [#_"LogicNode" condition]
        (ConditionalNode'new-3 condition, (ConstantNode'forInt-2 1, (:graph condition)), (ConstantNode'forInt-2 0, (:graph condition)))
    )

    (§ defn #_"ConditionalNode" ConditionalNode'new-3 [#_"LogicNode" condition, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (let [
            #_"ConditionalNode" this (FloatingNode'new-2 ConditionalNode'TYPE, (Stamp''meet-2 (:stamp trueValue), (:stamp falseValue)))
            this (assoc this :condition condition)
            this (assoc this :trueValue trueValue)
            this (assoc this :falseValue falseValue)
        ]
            this
        )
    )

    (§ defn #_"ValueNode" ConditionalNode'create-1 [#_"LogicNode" condition]
        (ConditionalNode'create-3 condition, (ConstantNode'forInt-2 1, (:graph condition)), (ConstantNode'forInt-2 0, (:graph condition)))
    )

    (§ defn #_"ValueNode" ConditionalNode'create-3 [#_"LogicNode" condition, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (or (ConditionalNode'findSynonym-3 condition, trueValue, falseValue)
            (ConditionalNode'canonicalizeConditional-4 condition, trueValue, falseValue, (Stamp''meet-2 (:stamp trueValue), (:stamp falseValue)))
            (ConditionalNode'new-3 condition, trueValue, falseValue)
        )
    )

    #_unused
    (§ override! #_"boolean" ConditionalNode''inferStamp-1 [#_"ConditionalNode" this]
        (let [
            #_"Stamp" valueStamp (Stamp''meet-2 (:stamp (:trueValue this)), (:stamp (:falseValue this)))
        ]
            (when (instance? IntegerLessThanNode (:condition this))
                (let [
                    #_"IntegerLessThanNode" lessThan (:condition this)
                ]
                    (cond
                        (and (= (:x lessThan) (:trueValue this)) (= (:y lessThan) (:falseValue this)))
                            ;; this encodes a min operation
                            (let [
                                #_"JavaConstant" constant
                                    (or (ValueNode''asJavaConstant-1 (:x lessThan))
                                        (ValueNode''asJavaConstant-1 (:y lessThan))
                                    )
                            ]
                                (when (some? constant)
                                    (let [
                                        #_"IntegerStamp" bounds (StampFactory'forInteger-3 (#_"JavaConstant" .getJavaKind constant), (#_"JavaKind" .getMinValue (#_"JavaConstant" .getJavaKind constant)), (#_"JavaConstant" .asLong constant))
                                    ]
                                        (§ ass valueStamp (Stamp''join-2 valueStamp, bounds))
                                    )
                                )
                            )
                        (and (= (:x lessThan) (:falseValue this)) (= (:y lessThan) (:trueValue this)))
                            ;; this encodes a max operation
                            (let [
                                #_"JavaConstant" constant
                                    (or (ValueNode''asJavaConstant-1 (:x lessThan))
                                        (ValueNode''asJavaConstant-1 (:y lessThan))
                                    )
                            ]
                                (when (some? constant)
                                    (let [
                                        #_"IntegerStamp" bounds (StampFactory'forInteger-3 (#_"JavaConstant" .getJavaKind constant), (#_"JavaConstant" .asLong constant), (#_"JavaKind" .getMaxValue (#_"JavaConstant" .getJavaKind constant)))
                                    ]
                                        (§ ass valueStamp (Stamp''join-2 valueStamp, bounds))
                                    )
                                )
                            )
                    )
                )
            )
            (ValueNode''updateStamp-2 this, valueStamp)
        )
    )

    #_unused
    (§ override! #_"ValueNode" ConditionalNode''canonical-2 [#_"ConditionalNode" this, #_"CanonicalizerTool" tool]
        (or (ConditionalNode'findSynonym-3 (:condition this), (:trueValue this), (:falseValue this))
            (ConditionalNode'canonicalizeConditional-4 (:condition this), (:trueValue this), (:falseValue this), (:stamp this))
            this
        )
    )

    (§ defn #_"ValueNode" ConditionalNode'canonicalizeConditional-4 [#_"LogicNode" logic, #_"ValueNode" trueValue, #_"ValueNode" falseValue, #_"Stamp" stamp]
        (cond
            (= trueValue falseValue)
                trueValue
            ;; optimize the pattern (x == y) ? x : y
            (and (instance? CompareNode logic)
                 (CompareNode''isIdentityComparison-1 logic)
                 (or (and (= (:x logic) trueValue) (= (:y logic) falseValue))
                     (and (= (:x logic) falseValue) (= (:y logic) trueValue))
                 )
            )
                falseValue
            (instance? IntegerStamp (:stamp trueValue))
                (do
                    ;; check if the conditional is redundant
                    (when (instance? IntegerLessThanNode logic)
                        (cond
                            (and (= (:x logic) trueValue) (= (:y logic) falseValue))
                                ;; return "x" for "x < y ? x : y" in case that we know "x <= y"
                                (when (<= (:upperBound (:stamp trueValue)) (:lowerBound (:stamp falseValue)))
                                    (§ return trueValue)
                                )
                            (and (= (:x logic) falseValue) (= (:y logic) trueValue))
                                ;; return "y" for "x < y ? y : x" in case that we know "x <= y"
                                (when (<= (:upperBound (:stamp falseValue)) (:lowerBound (:stamp trueValue)))
                                    (§ return trueValue)
                                )
                        )
                    )
                    ;; this optimizes the case where a value from the range 0 - 1 is mapped to the range 0 - 1
                    (when (and (instance? ConstantNode trueValue) (instance? ConstantNode falseValue))
                        (let [
                            #_"long" constTrueValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 trueValue))
                            #_"long" constFalseValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 falseValue))
                        ]
                            (condp instance? logic
                                IntegerEqualsNode
                                    (when (and (instance? ConstantNode (:y logic)) (instance? IntegerStamp (:stamp (:x logic))) (= (:upMask (:stamp (:x logic))) 1))
                                        (let [
                                            #_"long" equalsY (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y logic)))
                                        ]
                                            (cond
                                                (zero? equalsY)
                                                    (cond
                                                        (and (zero? constTrueValue) (= constFalseValue 1))
                                                            ;; return x when: x == 0 ? 0 : 1;
                                                            (§ return (IntegerConvertNode'convertUnsigned-2 (:x logic), stamp))
                                                        (and (= constTrueValue 1) (zero? constFalseValue))
                                                            ;; negate a boolean value via xor
                                                            (§ return (IntegerConvertNode'convertUnsigned-2 (XorNode'create-2 (:x logic), (ConstantNode'forIntegerStamp-2 (:stamp (:x logic)), 1)), stamp))
                                                    )
                                                (= equalsY 1)
                                                    (cond
                                                        (and (= constTrueValue 1) (zero? constFalseValue))
                                                            ;; return x when: x == 1 ? 1 : 0;
                                                            (§ return (IntegerConvertNode'convertUnsigned-2 (:x logic), stamp))
                                                        (and (zero? constTrueValue) (= constFalseValue 1))
                                                            ;; negate a boolean value via xor
                                                            (§ return (IntegerConvertNode'convertUnsigned-2 (XorNode'create-2 (:x logic), (ConstantNode'forIntegerStamp-2 (:stamp (:x logic)), 1)), stamp))
                                                    )
                                            )
                                        )
                                    )
                                IntegerTestNode
                                    ;; replace IntegerTestNode with AndNode for the following patterns:
                                    ;; (value & 1) == 0 ? 0 : 1
                                    ;; (value & 1) == 1 ? 1 : 0
                                    (when (instance? ConstantNode (:y logic))
                                        (let [
                                            #_"long" testY (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y logic)))
                                        ]
                                            (when (and (= testY 1) (zero? constTrueValue) (= constFalseValue 1))
                                                (§ return (IntegerConvertNode'convertUnsigned-2 (AndNode'create-2 (:x logic), (:y logic)), stamp))
                                            )
                                        )
                                    )
                                nil
                            )
                        )
                    )
                    ;; convert a conditional add ((x < 0) ? (x + y) : x) into (x + (y & (x >> (bits - 1)))) to avoid the test
                    (when (instance? IntegerLessThanNode logic)
                        (when (and (instance? ConstantNode (:y logic)) (#_"Constant" .isDefaultForKind (:value (:y logic))) (= falseValue (:x logic)) (instance? AddNode trueValue) (= (:x trueValue) falseValue))
                            (AddNode'new-2 (:x trueValue), (AndNode'new-2 (RightShiftNode'new-2 (:x logic), (ConstantNode'forIntegerBits-2 32, (dec (:bits (:stamp trueValue))))), (:y trueValue)))
                        )
                    )
                )
        )
    )

    (§ defn- #_"ValueNode" ConditionalNode'findSynonym-3 [#_"ValueNode" condition, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (condp instance? condition
            LogicNegationNode (ConditionalNode'create-3 (LogicNegationNode''getValue-1 condition), falseValue, trueValue)
            LogicConstantNode (if (:value condition) trueValue falseValue)
            nil
        )
    )

    #_unused
    (§ override! #_"void" ConditionalNode''generate-2 [#_"ConditionalNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''emitConditional-2 builder, this)
        nil
    )

    #_unused
    (§ defn #_"ConditionalNode" ConditionalNode'new-4 [#_"Graph" graph, #_"CanonicalCondition" condition, #_"ValueNode" x, #_"ValueNode" y]
        (ConditionalNode'new-1 (CompareNode'createCompareNode-4 graph, condition, x, y))
    )
)

;;;
 ; Represents a conversion between primitive types.
 ;;
(§ interface ConvertNode
    (§ abstract #_"ValueNode" ConvertNode''getValue-1 [#_"ConvertNode" this])

    (§ abstract #_"Constant" ConvertNode''convert-2 [#_"ConvertNode" this, #_"Constant" constant])

    (§ abstract #_"Constant" ConvertNode''reverse-2 [#_"ConvertNode" this, #_"Constant" constant])

    ;;;
     ; Checks whether a nil-check may skip the conversion. This is true if in the conversion NULL
     ; is converted to NULL and if it is the only value converted to NULL.
     ;
     ; @return whether a nil-check may skip the conversion
     ;;
    (§ abstract #_"boolean" ConvertNode''mayNullCheckSkipConversion-1 [#_"ConvertNode" this])

    ;;;
     ; Check whether a conversion is lossless.
     ;
     ; @return true iff reverse(convert(c)) == c for all c
     ;;
    (§ abstract #_"boolean" ConvertNode''isLossless-1 [#_"ConvertNode" this])

    ;;;
     ; Check whether a conversion preserves comparison order.
     ;
     ; @param op a comparison operator
     ; @return true iff (c1 op c2) == (convert(c1) op convert(c2)) for all c1, c2
     ;;
    (§ default #_"boolean" ConvertNode''preservesOrder-2 [#_"ConvertNode" this, #_"CanonicalCondition" op]
        (ConvertNode''isLossless-1 this)
    )

    ;;;
     ; Check whether a conversion preserves comparison order against a particular constant value.
     ;
     ; @param op a comparison operator
     ; @return true iff (c1 op value) == (convert(c1) op convert(value)) for value and all c1
     ;;
    (§ default #_"boolean" ConvertNode''preservesOrder-3 [#_"ConvertNode" this, #_"CanonicalCondition" op, #_"Constant" value]
        (ConvertNode''preservesOrder-2 this, op)
    )
)

(class-ns FixedBinaryNode (§ extends DeoptimizingFixedWithNextNode) (§ implements Binary #_"<ValueNode>")
    (§ def #_"NodeClass<FixedBinaryNode>" FixedBinaryNode'TYPE (NodeClass'create-1 FixedBinaryNode))

    ; @Input
    (§ mutable #_"ValueNode" :x nil)
    ; @Input
    (§ mutable #_"ValueNode" :y nil)

    (§ defn #_"FixedBinaryNode" FixedBinaryNode'new-4 [#_"NodeClass<? extends FixedBinaryNode>" c, #_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"FixedBinaryNode" this (DeoptimizingFixedWithNextNode'new-2 c, stamp)
            this (assoc this :x x)
            this (assoc this :y y)
        ]
            this
        )
    )
)

(class-ns FloatingNode (§ extends ValueNode)
    (§ def #_"NodeClass<FloatingNode>" FloatingNode'TYPE (NodeClass'create-1 FloatingNode))

    (§ defn #_"FloatingNode" FloatingNode'new-2 [#_"NodeClass<? extends FloatingNode>" c, #_"Stamp" stamp]
        (ValueNode'new-2 c, stamp)
    )
)

(final-ns IntegerBelowNode (§ extends IntegerLowerThanNode)
    (§ def #_"NodeClass<IntegerBelowNode>" IntegerBelowNode'TYPE (NodeClass'create-1 IntegerBelowNode))

    (§ def- #_"BelowOp" IntegerBelowNode'OP (BelowOp'new-0))

    (§ defn #_"IntegerBelowNode" IntegerBelowNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (IntegerLowerThanNode'new-4 IntegerBelowNode'TYPE, x, y, IntegerBelowNode'OP)
    )

    (§ defn #_"LogicNode" IntegerBelowNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (LowerOp''create-3 IntegerBelowNode'OP, x, y)
    )

    (§ defn #_"LogicNode" IntegerBelowNode'create-3 [#_"Integer" smallestCompareWidth, #_"ValueNode" x, #_"ValueNode" y]
        (or (CompareOp''canonical-5 IntegerBelowNode'OP, smallestCompareWidth, (BelowOp''getCondition-1 IntegerBelowNode'OP), x, y)
            (IntegerBelowNode'create-2 x, y)
        )
    )

    #_unused
    (§ override! #_"Node" IntegerBelowNode''canonical-4 [#_"IntegerBelowNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (CompareOp''canonical-5 IntegerBelowNode'OP, (CanonicalizerTool''smallestCompareWidth-1 tool), (BelowOp''getCondition-1 IntegerBelowNode'OP), forX, forY)
            this
        )
    )
)

;;;
 ; @anno IntegerBelowNode.BelowOp
 ;;
(final-ns BelowOp (§ extends LowerOp)
    (§ defn #_"BelowOp" BelowOp'new-0 []
        (LowerOp'new-0)
    )

    #_unused
    (§ override! #_"CompareNode" BelowOp''duplicateModified-3 [#_"BelowOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
        (IntegerBelowNode'new-2 newX, newY)
    )

    #_unused
    (§ override! #_"long" BelowOp''upperBound-2 [#_"BelowOp" this, #_"IntegerStamp" stamp]
        (IntegerStamp''unsignedUpperBound-1 stamp)
    )

    #_unused
    (§ override! #_"long" BelowOp''lowerBound-2 [#_"BelowOp" this, #_"IntegerStamp" stamp]
        (IntegerStamp''unsignedLowerBound-1 stamp)
    )

    #_unused
    (§ override! #_"int" BelowOp''compare-3 [#_"BelowOp" this, #_"long" a, #_"long" b]
        (Long/compareUnsigned a, b)
    )

    #_unused
    (§ override! #_"long" BelowOp''min-3 [#_"BelowOp" this, #_"long" a, #_"long" b]
        (NumUtil'minUnsigned-2 a, b)
    )

    #_unused
    (§ override! #_"long" BelowOp''max-3 [#_"BelowOp" this, #_"long" a, #_"long" b]
        (NumUtil'maxUnsigned-2 a, b)
    )

    #_unused
    (§ override! #_"long" BelowOp''cast-3 [#_"BelowOp" this, #_"long" a, #_"int" bits]
        (CodeUtil/zeroExtend a, bits)
    )

    #_unused
    (§ override! #_"long" BelowOp''minValue-2 [#_"BelowOp" this, #_"int" bits]
        0
    )

    #_unused
    (§ override! #_"long" BelowOp''maxValue-2 [#_"BelowOp" this, #_"int" bits]
        (NumUtil'maxValueUnsigned-1 bits)
    )

    #_unused
    (§ override! #_"IntegerStamp" BelowOp''forInteger-4 [#_"BelowOp" this, #_"int" bits, #_"long" min, #_"long" max]
        (StampFactory'forUnsignedInteger-3 bits, min, max)
    )

    (§ override! #_"CanonicalCondition" BelowOp''getCondition-1 [#_"BelowOp" this]
        CanonicalCondition'BT
    )

    #_unused
    (§ override! #_"IntegerLowerThanNode" BelowOp''createNode-3 [#_"BelowOp" this, #_"ValueNode" x, #_"ValueNode" y]
        (IntegerBelowNode'new-2 x, y)
    )
)

;;;
 ; An IntegerConvert converts an integer to an integer of different width.
 ;;
(class-ns IntegerConvertNode #_"<OP, REV>" (§ extends UnaryNode) (§ implements ArithmeticOperation, ConvertNode, LIRLowerable, StampInverter)
    (§ def #_"NodeClass<IntegerConvertNode>" IntegerConvertNode'TYPE (NodeClass'create-1 IntegerConvertNode))

    (§ final #_"SerializableIntegerConvertFunction<OP>" :getOp nil)
    (§ final #_"SerializableIntegerConvertFunction<REV>" :getReverseOp nil)

    (§ final #_"int" :inputBits 0)
    (§ final #_"int" :resultBits 0)

    (§ defn #_"IntegerConvertNode" IntegerConvertNode'new-6 [#_"NodeClass<? extends IntegerConvertNode<OP, REV>>" c, #_"SerializableIntegerConvertFunction<OP>" getOp, #_"SerializableIntegerConvertFunction<REV>" getReverseOp, #_"int" inputBits, #_"int" resultBits, #_"ValueNode" input]
        (let [
            #_"IntegerConvertNode" this (UnaryNode'new-3 c, (IntegerConvertOp''foldStamp-4 (Function''apply-2 getOp, (ArithmeticOpTable'forStamp-1 (:stamp input))), inputBits, resultBits, (:stamp input)), input)
            this (assoc this :getOp getOp)
            this (assoc this :getReverseOp getReverseOp)
            this (assoc this :inputBits inputBits)
            this (assoc this :resultBits resultBits)
        ]
            this
        )
    )

    (§ method! #_"int" IntegerConvertNode''getInputBits-1 [#_"IntegerConvertNode<OP, REV>" this]
        (:inputBits this)
    )

    (§ method! #_"int" IntegerConvertNode''getResultBits-1 [#_"IntegerConvertNode<OP, REV>" this]
        (:resultBits this)
    )

    (§ method! #_"IntegerConvertOp<OP>" IntegerConvertNode''getOp-2 [#_"IntegerConvertNode<OP, REV>" this, #_"ValueNode" value]
        (Function''apply-2 (:getOp this), (ArithmeticOpTable'forStamp-1 (:stamp value)))
    )

    (§ override! #_"IntegerConvertOp<OP>" IntegerConvertNode''getArithmeticOp-1 [#_"IntegerConvertNode<OP, REV>" this]
        (IntegerConvertNode''getOp-2 this, (UnaryNode''getValue-1 this))
    )

    #_unused
    (§ override #_"Constant" IntegerConvertNode''convert-2 [#_"IntegerConvertNode<OP, REV>" this, #_"Constant" constant]
        (IntegerConvertOp''foldConstant-4 (IntegerConvertNode''getArithmeticOp-1 this), (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this), constant)
    )

    #_unused
    (§ override #_"Constant" IntegerConvertNode''reverse-2 [#_"IntegerConvertNode<OP, REV>" this, #_"Constant" constant]
        (let [
            #_"IntegerConvertOp<REV>" reverse (Function''apply-2 (:getReverseOp this), (ArithmeticOpTable'forStamp-1 (:stamp this)))
        ]
            (IntegerConvertOp''foldConstant-4 reverse, (IntegerConvertNode''getResultBits-1 this), (IntegerConvertNode''getInputBits-1 this), constant)
        )
    )

    #_unused
    (§ override #_"Stamp" IntegerConvertNode''foldStamp-2 [#_"IntegerConvertNode<OP, REV>" this, #_"Stamp" stamp]
        (IntegerConvertOp''foldStamp-4 (IntegerConvertNode''getArithmeticOp-1 this), (:inputBits this), (:resultBits this), stamp)
    )

    (§ override #_"ValueNode" IntegerConvertNode''canonical-3 [#_"IntegerConvertNode<OP, REV>" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (or (IntegerConvertNode'findSynonym-5 (IntegerConvertNode''getOp-2 this, value), value, (:inputBits this), (:resultBits this), (:stamp this))
            this
        )
    )

    (§ defn #_"<T> ValueNode" IntegerConvertNode'findSynonym-5 [#_"IntegerConvertOp<T>" operation, #_"ValueNode" value, #_"int" inputBits, #_"int" resultBits, #_"Stamp" stamp]
        (cond
            (= inputBits resultBits)       value
            (instance? ConstantNode value) (ConstantNode'forPrimitive-2 stamp, (IntegerConvertOp''foldConstant-4 operation, inputBits, resultBits, (:value value)))
        )
    )

    #_unused
    (§ defn #_"ValueNode" IntegerConvertNode'convert-2 [#_"ValueNode" input, #_"Stamp" stamp]
        (IntegerConvertNode'convert-3 input, stamp, false)
    )

    (§ defn #_"ValueNode" IntegerConvertNode'convert-3 [#_"ValueNode" input, #_"Stamp" stamp, #_"Graph" graph]
        (let [
            #_"ValueNode" convert (IntegerConvertNode'convert-3 input, stamp, false)
        ]
            (when-not (Node''isAlive-1 convert) => convert
                (Graph''addOrUniqueWithInputs-2 graph, convert)
            )
        )
    )

    (§ defn #_"ValueNode" IntegerConvertNode'convertUnsigned-2 [#_"ValueNode" input, #_"Stamp" stamp]
        (IntegerConvertNode'convert-3 input, stamp, true)
    )

    #_unused
    (§ defn #_"ValueNode" IntegerConvertNode'convertUnsigned-3 [#_"ValueNode" input, #_"Stamp" stamp, #_"Graph" graph]
        (let [
            #_"ValueNode" convert (IntegerConvertNode'convert-3 input, stamp, true)
        ]
            (when-not (Node''isAlive-1 convert) => convert
                (Graph''addOrUniqueWithInputs-2 graph, convert)
            )
        )
    )

    (§ defn #_"ValueNode" IntegerConvertNode'convert-3 [#_"ValueNode" input, #_"Stamp" stamp, #_"boolean" zeroExtend]
        (let [
            #_"IntegerStamp" fromStamp (:stamp input)
            #_"IntegerStamp" toStamp stamp
        ]
            (cond
                (= (:bits toStamp) (:bits fromStamp)) input
                (< (:bits toStamp) (:bits fromStamp)) (NarrowNode'new-3 input, (:bits fromStamp), (:bits toStamp))
                zeroExtend                            (ZeroExtendNode'create-2 input, (:bits toStamp))
                :else                                 (SignExtendNode'create-2 input, (:bits toStamp))
            )
        )
    )

    #_unused
    (§ override #_"Stamp" IntegerConvertNode''invertStamp-2 [#_"IntegerConvertNode<OP, REV>" this, #_"Stamp" outStamp]
        (IntegerConvertOp''invertStamp-4 (IntegerConvertNode''getArithmeticOp-1 this), (:inputBits this), (:resultBits this), outStamp)
    )
)

;;;
 ; @anno IntegerConvertNode.SerializableIntegerConvertFunction
 ;;
(§ interface SerializableIntegerConvertFunction #_"<T>" (§ extends Function #_"<ArithmeticOpTable, IntegerConvertOp<T>>")
)

(class-ns IntegerDivRemNode (§ extends FixedBinaryNode) (§ implements Lowerable)
    (§ def #_"NodeClass<IntegerDivRemNode>" IntegerDivRemNode'TYPE (NodeClass'create-1 IntegerDivRemNode))

    (§ final #_"DivRemOp" :op nil)
    (§ final #_"Signedness" :type nil)
    (§ final #_"boolean" :canDeopt false)

    (§ defn #_"IntegerDivRemNode" IntegerDivRemNode'new-6 [#_"NodeClass<? extends IntegerDivRemNode>" c, #_"Stamp" stamp, #_"DivRemOp" op, #_"Signedness" type, #_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"IntegerDivRemNode" this (FixedBinaryNode'new-4 c, stamp, x, y)
            this (assoc this :op op)
            this (assoc this :type type)
            ;; Assigning canDeopt during constructor, because it must never change during lifetime of the node.
            #_"IntegerStamp" yStamp (:stamp (:y this))
            this (assoc this :canDeopt (or (IntegerStamp''contains-2 yStamp, 0) (IntegerStamp''contains-2 yStamp, -1)))
        ]
            this
        )
    )

    (§ method! #_"DivRemOp" IntegerDivRemNode''getOp-1 [#_"IntegerDivRemNode" this]
        (:op this)
    )

    (§ method! #_"Signedness" IntegerDivRemNode''getType-1 [#_"IntegerDivRemNode" this]
        (:type this)
    )

    #_unused
    (§ override #_"void" IntegerDivRemNode''lower-2 [#_"IntegerDivRemNode" this, #_"LoweringTool" lowerer]
        nil ;; Nothing to do for division nodes. The HotSpot signal handler catches divisions by zero and the MIN_VALUE / -1 cases.
    )

    #_unused
    (§ override #_"boolean" IntegerDivRemNode''canDeoptimize-1 [#_"IntegerDivRemNode" this]
        (:canDeopt this)
    )
)

;;;
 ; @anno IntegerDivRemNode.DivRemOp
 ;;
(value-ns DivRemOp
    (§ enum DivRemOp'DIV)
    (§ enum DivRemOp'REM)
)

;;;
 ; @anno IntegerDivRemNode.Signedness
 ;;
(value-ns Signedness
    (§ enum Signedness'SIGNED)
    (§ enum Signedness'UNSIGNED)
)

(final-ns IntegerEqualsNode (§ extends CompareNode) (§ implements BinaryCommutative #_"<ValueNode>")
    (§ def #_"NodeClass<IntegerEqualsNode>" IntegerEqualsNode'TYPE (NodeClass'create-1 IntegerEqualsNode))

    (§ def- #_"IntegerEqualsOp" IntegerEqualsNode'OP (IntegerEqualsOp'new-0))

    (§ defn #_"IntegerEqualsNode" IntegerEqualsNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (CompareNode'new-4 IntegerEqualsNode'TYPE, CanonicalCondition'EQ, x, y)
    )

    (§ defn #_"LogicNode" IntegerEqualsNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (or (CompareNode'tryConstantFoldPrimitive-3 CanonicalCondition'EQ, x, y)
            (do
                (cond
                    (instance? ConditionalNode x)
                        (condp = y
                            (:trueValue x)
                                (§ return (:condition x))
                            (:falseValue x)
                                (§ return (LogicNegationNode'create-1 (:condition x)))
                            nil
                        )
                    (instance? ConditionalNode y)
                        (condp = x
                            (:trueValue y)
                                (§ return (:condition y))
                            (:falseValue y)
                                (§ return (LogicNegationNode'create-1 (:condition y)))
                            nil
                        )
                )
                (BinaryOpLogicNode''maybeCommuteInputs-1 (IntegerEqualsNode'new-2 x, y))
            )
        )
    )

    (§ defn #_"LogicNode" IntegerEqualsNode'create-3 [#_"Integer" smallestCompareWidth, #_"ValueNode" x, #_"ValueNode" y]
        (or (IntegerEqualsOp''canonical-5 IntegerEqualsNode'OP, smallestCompareWidth, CanonicalCondition'EQ, x, y)
            (IntegerEqualsNode'create-2 x, y)
        )
    )

    #_unused
    (§ override! #_"Node" IntegerEqualsNode''canonical-4 [#_"IntegerEqualsNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (IntegerEqualsOp''canonical-5 IntegerEqualsNode'OP, (CanonicalizerTool''smallestCompareWidth-1 tool), CanonicalCondition'EQ, forX, forY)
            this
        )
    )

    #_unused
    (§ override! #_"Stamp" IntegerEqualsNode''getSucceedingStampForX-4 [#_"IntegerEqualsNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when-not negated? (Stamp''join-2 xStamp, yStamp))
    )

    #_unused
    (§ override! #_"Stamp" IntegerEqualsNode''getSucceedingStampForY-4 [#_"IntegerEqualsNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when-not negated? (Stamp''join-2 xStamp, yStamp))
    )

    #_unused
    (§ override! #_"TriState" IntegerEqualsNode''tryFold-3 [#_"IntegerEqualsNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when (and (instance? IntegerStamp xStamp) (instance? IntegerStamp yStamp)) => TriState/UNKNOWN
            (cond
                (Stamp''alwaysDistinct-2 xStamp, yStamp) TriState/FALSE
                (Stamp''neverDistinct-2 xStamp, yStamp)  TriState/TRUE
                :else                                    TriState/UNKNOWN
            )
        )
    )
)

;;;
 ; @anno IntegerEqualsNode.IntegerEqualsOp
 ;;
(final-ns IntegerEqualsOp (§ extends CompareOp)
    (§ defn #_"IntegerEqualsOp" IntegerEqualsOp'new-0 []
        (CompareOp'new-0)
    )

    #_unused
    (§ override! #_"LogicNode" IntegerEqualsOp''optimizeNormalizeCompare-5 [#_"IntegerEqualsOp" this, #_"Integer" smallestCompareWidth, #_"Constant" constant, #_"NormalizeCompareNode" normalizeNode, #_"boolean" mirrored?]
        (let [
            #_"ValueNode" a (:x normalizeNode)
            #_"ValueNode" b (:y normalizeNode)
        ]
            (condp = (#_"PrimitiveConstant" .asLong constant)
                0 (IntegerEqualsNode'create-3   smallestCompareWidth, a, b)
                1 (IntegerLessThanNode'create-3 smallestCompareWidth, b, a)
               -1 (IntegerLessThanNode'create-3 smallestCompareWidth, a, b)
                  (LogicConstantNode'contradiction-0)
            )
        )
    )

    #_unused
    (§ override! #_"CompareNode" IntegerEqualsOp''duplicateModified-3 [#_"IntegerEqualsOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
        (cond
            (and (instance? IntegerStamp (:stamp newX)) (instance? IntegerStamp (:stamp newY)))                 (IntegerEqualsNode'new-2 newX, newY)
            (and (instance? AbstractPointerStamp (:stamp newX)) (instance? AbstractPointerStamp (:stamp newY))) (IntegerEqualsNode'new-2 newX, newY)
            :else                                                                                               (throw! "should not reach here")
        )
    )

    (§ override! #_"LogicNode" IntegerEqualsOp''canonical-5 [#_"IntegerEqualsOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1 forX) (GraphUtil'unproxify-1 forY)) (LogicConstantNode'tautology-0)
            (Stamp''alwaysDistinct-2 (:stamp forX), (:stamp forY))        (LogicConstantNode'contradiction-0)
            :else
                (do
                    (when (and (instance? AddNode forX) (instance? AddNode forY))
                        (let [
                            [#_"ValueNode" v1 #_"ValueNode" v2]
                                (cond
                                    (= (:x forX) (:x forY)) [(:y forX) (:y forY)]
                                    (= (:x forX) (:y forY)) [(:y forX) (:x forY)]
                                    (= (:y forX) (:x forY)) [(:x forX) (:y forY)]
                                    (= (:y forX) (:y forY)) [(:x forX) (:x forY)]
                                )
                        ]
                            (when (some? v1)
                                (§ return (IntegerEqualsNode'create-2 v1, v2))
                            )
                        )
                    )

                    (CompareOp''canonical-5 (§ super ), smallestCompareWidth, condition, forX, forY)
                )
        )
    )

    #_unused
    (§ override! #_"LogicNode" IntegerEqualsOp''canonicalizeSymmetricConstant-6 [#_"IntegerEqualsOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"Constant" constant, #_"ValueNode" node, #_"boolean" mirrored?]
        (or
            (when (instance? PrimitiveConstant constant)
                (or
                    (cond
                        (or (and (= (UnsignedLong''asLong-1 constant)  1) (= (:upperBound (:stamp node)) 1) (= (:lowerBound (:stamp node))  0))
                            (and (= (UnsignedLong''asLong-1 constant) -1) (= (:upperBound (:stamp node)) 0) (= (:lowerBound (:stamp node)) -1))
                        )
                            ;; nonConstant can only be 0 or 1 (respective -1), test against 0 instead of 1 (respective -1)
                            ;; for a more canonical graph and also to allow for faster execution on specific platforms
                            (LogicNegationNode'create-1 (IntegerEqualsNode'create-3 smallestCompareWidth, node, (ConstantNode'forIntegerKind-2 (ValueNode''getStackKind-1 node), 0)))
                        (zero? (UnsignedLong''asLong-1 constant))
                            (cond
                                (instance? AndNode node)
                                    (IntegerTestNode'new-2 (:x node), (:y node))
                                (instance? SubNode node)
                                    (IntegerEqualsNode'create-3 smallestCompareWidth, (:x node), (:y node))
                                (and (instance? ShiftNode node) (instance? IntegerStamp (:stamp node)))
                                    (let [
                                        #_"int" mask (ShiftNode''getShiftAmountMask-1 node)
                                        #_"int" amount (& (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y node))) mask)
                                    ]
                                        (condp instance? node
                                            LeftShiftNode
                                                (when (instance? ConstantNode (:y node))
                                                    (if (= (ValueNode''getStackKind-1 (:x node)) JavaKind/Int)
                                                        (IntegerTestNode'new-2 (:x node), (ConstantNode'forInt-1 (>>> -1 amount)))
                                                        (IntegerTestNode'new-2 (:x node), (ConstantNode'forLong-1 (>>> -1 amount)))
                                                    )
                                                )
                                            RightShiftNode
                                                (when (and (instance? ConstantNode (:y node)) (IntegerStamp''isPositive-1 (:stamp (:x node))))
                                                    (if (= (ValueNode''getStackKind-1 (:x node)) JavaKind/Int)
                                                        (IntegerTestNode'new-2 (:x node), (ConstantNode'forInt-1 (<< -1 amount)))
                                                        (IntegerTestNode'new-2 (:x node), (ConstantNode'forLong-1 (<< -1 amount)))
                                                    )
                                                )
                                            UnsignedRightShiftNode
                                                (when (instance? ConstantNode (:y node))
                                                    (if (= (ValueNode''getStackKind-1 (:x node)) JavaKind/Int)
                                                        (IntegerTestNode'new-2 (:x node), (ConstantNode'forInt-1 (<< -1 amount)))
                                                        (IntegerTestNode'new-2 (:x node), (ConstantNode'forLong-1 (<< -1 amount)))
                                                    )
                                                )
                                            nil
                                        )
                                    )
                            )
                    )
                    (when (and (instance? AddNode node) (ValueNode''isJavaConstant-1 (:y node)))
                        (IntegerEqualsNode'new-2 (:x node), (ConstantNode'forIntegerStamp-2 (:stamp node), (- (UnsignedLong''asLong-1 constant) (UnsignedLong''asLong-1 (ValueNode''asJavaConstant-1 (:y node))))))
                    )
                    ;; a & c == c is the same as a & c != 0, if c is a single bit
                    (when (and (instance? AndNode node) (= (Long/bitCount (UnsignedLong''asLong-1 constant)) 1) (instance? ConstantNode (:y node)) (= (ValueNode''asJavaConstant-1 (:y node)) constant))
                        (LogicNegationNode'new-1 (IntegerTestNode'new-2 (:x node), (:y node)))
                    )
                    ;; x ^ 1 == 0 is the same as x == 1 if x in [0, 1]
                    ;; x ^ 1 == 1 is the same as x == 0 if x in [0, 1]
                    (when (and (instance? XorNode node) (instance? IntegerStamp (:stamp node)) (ValueNode''isJavaConstant-1 (:y node)) (= (UnsignedLong''asLong-1 (ValueNode''asJavaConstant-1 (:y node))) 1) (= (:upMask (:stamp (:x node))) 1))
                        (IntegerEqualsNode'new-2 (:x node), (ConstantNode'forIntegerStamp-2 (:stamp (:x node)), (bit-xor (UnsignedLong''asLong-1 constant) 1)))
                    )
                )
            )
            (CompareOp''canonicalizeSymmetricConstant-6 (§ super ), smallestCompareWidth, condition, constant, node, mirrored?)
        )
    )
)

(final-ns IntegerLessThanNode (§ extends IntegerLowerThanNode)
    (§ def #_"NodeClass<IntegerLessThanNode>" IntegerLessThanNode'TYPE (NodeClass'create-1 IntegerLessThanNode))

    (§ def- #_"LessThanOp" IntegerLessThanNode'OP (LessThanOp'new-0))

    (§ defn #_"IntegerLessThanNode" IntegerLessThanNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (IntegerLowerThanNode'new-4 IntegerLessThanNode'TYPE, x, y, IntegerLessThanNode'OP)
    )

    (§ defn #_"LogicNode" IntegerLessThanNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (LowerOp''create-3 IntegerLessThanNode'OP, x, y)
    )

    (§ defn #_"LogicNode" IntegerLessThanNode'create-3 [#_"Integer" smallestCompareWidth, #_"ValueNode" x, #_"ValueNode" y]
        (or (CompareOp''canonical-5 IntegerLessThanNode'OP, smallestCompareWidth, (LessThanOp''getCondition-1 IntegerLessThanNode'OP), x, y)
            (IntegerLessThanNode'create-2 x, y)
        )
    )

    #_unused
    (§ override! #_"Node" IntegerLessThanNode''canonical-4 [#_"IntegerLessThanNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (CompareOp''canonical-5 IntegerLessThanNode'OP, (CanonicalizerTool''smallestCompareWidth-1 tool), (LessThanOp''getCondition-1 IntegerLessThanNode'OP), forX, forY)
            this
        )
    )

    (§ defn #_"boolean" IntegerLessThanNode'subtractMayUnderflow-3 [#_"long" x, #_"long" y, #_"long" minValue]
        (let [
            #_"long" z (- x y)
        ]
            ;; HD 2-12 Overflow iff the arguments have different signs and
            ;; the sign of the result is different than the sign of x
            (or (neg? (& (bit-xor x y) (bit-xor x z))) (<= z minValue))
        )
    )

    (§ defn #_"boolean" IntegerLessThanNode'subtractMayOverflow-3 [#_"long" x, #_"long" y, #_"long" maxValue]
        (let [
            #_"long" z (- x y)
        ]
            ;; HD 2-12 Overflow iff the arguments have different signs and
            ;; the sign of the result is different than the sign of x
            (or (neg? (& (bit-xor x y) (bit-xor x z))) (< maxValue z))
        )
    )
)

;;;
 ; @anno IntegerLessThanNode.LessThanOp
 ;;
(final-ns LessThanOp (§ extends LowerOp)
    (§ defn #_"LessThanOp" LessThanOp'new-0 []
        (LowerOp'new-0)
    )

    #_unused
    (§ override! #_"CompareNode" LessThanOp''duplicateModified-3 [#_"LessThanOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
        (when (and (instance? IntegerStamp (:stamp newX)) (instance? IntegerStamp (:stamp newY))) => (throw! "should not reach here")
            (IntegerLessThanNode'new-2 newX, newY)
        )
    )

    #_unused
    (§ override! #_"LogicNode" LessThanOp''optimizeNormalizeCompare-5 [#_"LessThanOp" this, #_"Integer" smallestCompareWidth, #_"Constant" constant, #_"NormalizeCompareNode" normalizeNode, #_"boolean" mirrored?]
        ;; a NC b < c  (not mirrored)
        ;; cases for c:
        ;;  0         -> a < b
        ;;  [MIN, -1] -> false
        ;;  1         -> a <= b
        ;;  [2, MAX]  -> true
        ;; unordered-is-less means unordered-is-true.
        ;;
        ;; c < a NC b  (mirrored)
        ;; cases for c:
        ;;  0         -> a > b
        ;;  [1, MAX]  -> false
        ;;  -1        -> a >= b
        ;;  [MIN, -2] -> true
        ;; unordered-is-less means unordered-is-false.
        ;;
        ;; We can handle mirroring by swapping a & b and negating the constant.
        (let [
            #_"ValueNode" a (if mirrored? (:y normalizeNode) (:x normalizeNode))
            #_"ValueNode" b (if mirrored? (:x normalizeNode) (:y normalizeNode))
            #_"long" cst (if mirrored? (- (#_"PrimitiveConstant" .asLong constant)) (#_"PrimitiveConstant" .asLong constant))
        ]
            (cond
                (= cst 0)   (IntegerLessThanNode'create-3 smallestCompareWidth, a, b)
                            ;; a <= b <=> !(a > b)
                (= cst 1)   (LogicNegationNode'create-1 (IntegerLessThanNode'create-3 smallestCompareWidth, b, a))
                (<= cst -1) (LogicConstantNode'contradiction-0)
                :else       (LogicConstantNode'tautology-0)
            )
        )
    )

    #_unused
    (§ override! #_"LogicNode" LessThanOp''findSynonym-3 [#_"LessThanOp" this, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (LowerOp''findSynonym-3 (§ super ), forX, forY)
            (when (and (instance? IntegerStamp (:stamp forX)) (instance? IntegerStamp (:stamp forY)) (IntegerStamp'sameSign-2 (:stamp forX), (:stamp forY)))
                (IntegerBelowNode'new-2 forX, forY)
            )
            (when (and (instance? ConstantNode forY) (instance? SubNode forX))
                (let [
                    [#_"ValueNode" vx #_"ValueNode" vy #_"boolean" negate?]
                        (cond
                            (#_"Constant" .isDefaultForKind (:value forY))
                                [(:x forX) (:y forX) false] ;; (x - y) < 0 when x - y is known not to underflow <=> x < y
                            (and (ValueNode''isJavaConstant-1 forY) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)) 1))
                                [(:y forX) (:x forX) true]  ;; (x - y) < 1 when x - y is known not to underflow <=> !(y < x)
                        )
                ]
                    (when (some? vx)
                        (let [
                            #_"IntegerStamp" sx (:stamp (:x forX))
                            #_"IntegerStamp" sy (:stamp (:y forX))
                        ]
                            (when (and (not (IntegerLessThanNode'subtractMayUnderflow-3 (:lowerBound sx), (:upperBound sy), (CodeUtil/minValue (:bits sx))))
                                       (not (IntegerLessThanNode'subtractMayOverflow-3  (:upperBound sx), (:lowerBound sy), (CodeUtil/maxValue (:bits sx))))
                                  )
                                (let [
                                    #_"LogicNode" logic (IntegerLessThanNode'new-2 vx, vy)
                                ]
                                    (if negate? (LogicNegationNode'create-1 logic) logic)
                                )
                            )
                        )
                    )
                )
            )
            (when (instance? IntegerStamp (:stamp forX))
                (let [
                    #_"int" bits (:bits (:stamp forX))
                    #_"long" min (LessThanOp''minValue-2 IntegerLessThanNode'OP, bits)
                    #_"long" xResidue 0
                    #_"ValueNode" left nil
                    #_"JavaConstant" leftCst nil
                ]
                    (cond
                        (instance? AddNode forX)
                            (when (ValueNode''isJavaConstant-1 (:y forX))
                                (§ ass xResidue (- (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y forX))) min))
                                (§ ass left (:x forX))
                            )
                        (ValueNode''isJavaConstant-1 forX)
                            (§ ass leftCst (ValueNode''asJavaConstant-1 forX))
                    )
                    (when (or (some? left) (some? leftCst))
                        (let [
                            #_"long" yResidue 0
                            #_"ValueNode" right nil
                            #_"JavaConstant" rightCst nil
                        ]
                            (cond
                                (instance? AddNode forY)
                                    (when (ValueNode''isJavaConstant-1 (:y forY))
                                        (§ ass yResidue (- (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y forY))) min))
                                        (§ ass right (:x forY))
                                    )
                                (ValueNode''isJavaConstant-1 forY)
                                    (§ ass rightCst (ValueNode''asJavaConstant-1 forY))
                            )
                            (when (and (or (some? right) (some? rightCst)) (or (and (zero? xResidue) (some? left)) (and (zero? yResidue) (some? right))))
                                (cond
                                    (nil? left)
                                        (§ ass left (ConstantNode'forIntegerBits-2 bits, (- (#_"JavaConstant" .asLong leftCst) min)))
                                    (not= xResidue 0)
                                        (§ ass left (AddNode'create-2 left, (ConstantNode'forIntegerBits-2 bits, xResidue)))
                                )
                                (cond
                                    (nil? right)
                                        (§ ass right (ConstantNode'forIntegerBits-2 bits, (- (#_"JavaConstant" .asLong rightCst) min)))
                                    (not= yResidue 0)
                                        (§ ass right (AddNode'create-2 right, (ConstantNode'forIntegerBits-2 bits, yResidue)))
                                )
                                (IntegerBelowNode'new-2 left, right)
                            )
                        )
                    )
                )
            )
        )
    )

    (§ override! #_"CanonicalCondition" LessThanOp''getCondition-1 [#_"LessThanOp" this]
        CanonicalCondition'LT
    )

    #_unused
    (§ override! #_"IntegerLowerThanNode" LessThanOp''createNode-3 [#_"LessThanOp" this, #_"ValueNode" x, #_"ValueNode" y]
        (IntegerLessThanNode'new-2 x, y)
    )

    #_unused
    (§ override! #_"long" LessThanOp''upperBound-2 [#_"LessThanOp" this, #_"IntegerStamp" stamp]
        (:upperBound stamp)
    )

    #_unused
    (§ override! #_"long" LessThanOp''lowerBound-2 [#_"LessThanOp" this, #_"IntegerStamp" stamp]
        (:lowerBound stamp)
    )

    #_unused
    (§ override! #_"int" LessThanOp''compare-3 [#_"LessThanOp" this, #_"long" a, #_"long" b]
        (Long/compare a, b)
    )

    #_unused
    (§ override! #_"long" LessThanOp''min-3 [#_"LessThanOp" this, #_"long" a, #_"long" b]
        (min a b)
    )

    #_unused
    (§ override! #_"long" LessThanOp''max-3 [#_"LessThanOp" this, #_"long" a, #_"long" b]
        (max a b)
    )

    (§ override! #_"long" LessThanOp''cast-3 [#_"LessThanOp" this, #_"long" a, #_"int" bits]
        (CodeUtil/signExtend a, bits)
    )

    (§ override! #_"long" LessThanOp''minValue-2 [#_"LessThanOp" this, #_"int" bits]
        (NumUtil'minValue-1 bits)
    )

    #_unused
    (§ override! #_"long" LessThanOp''maxValue-2 [#_"LessThanOp" this, #_"int" bits]
        (NumUtil'maxValue-1 bits)
    )

    #_unused
    (§ override! #_"IntegerStamp" LessThanOp''forInteger-4 [#_"LessThanOp" this, #_"int" bits, #_"long" min, #_"long" max]
        (StampFactory'forInteger-3 bits, (LessThanOp''cast-3 this, min, bits), (LessThanOp''cast-3 this, max, bits))
    )
)

;;;
 ; Common super-class for "a < b" comparisons both signed and unsigned.
 ;;
(class-ns IntegerLowerThanNode (§ extends CompareNode)
    (§ def #_"NodeClass<IntegerLowerThanNode>" IntegerLowerThanNode'TYPE (NodeClass'create-1 IntegerLowerThanNode))

    (§ final #_"LowerOp" :op nil)

    (§ defn #_"IntegerLowerThanNode" IntegerLowerThanNode'new-4 [#_"NodeClass<? extends CompareNode>" c, #_"ValueNode" x, #_"ValueNode" y, #_"LowerOp" op]
        (let [
            #_"IntegerLowerThanNode" this (CompareNode'new-4 c, (LowerOp''getCondition-1 op), x, y)
            this (assoc this :op op)
        ]
            this
        )
    )

    (§ method #_"LowerOp" IntegerLowerThanNode''getOp-1 [#_"IntegerLowerThanNode" this]
        (:op this)
    )

    #_unused
    (§ override #_"Stamp" IntegerLowerThanNode''getSucceedingStampForX-4 [#_"IntegerLowerThanNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (IntegerLowerThanNode''getSucceedingStampForX-7 this, negated?, (not negated?), xStamp, yStamp, (:x this), (:y this))
    )

    #_unused
    (§ override #_"Stamp" IntegerLowerThanNode''getSucceedingStampForY-4 [#_"IntegerLowerThanNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (IntegerLowerThanNode''getSucceedingStampForX-7 this, (not negated?), (not negated?), yStamp, xStamp, (:y this), (:x this))
    )

    (§ method- #_"Stamp" IntegerLowerThanNode''getSucceedingStampForX-7 [#_"IntegerLowerThanNode" this, #_"boolean" mirror?, #_"boolean" strict?, #_"Stamp" xStamp, #_"Stamp" yStamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"Stamp" s (IntegerLowerThanNode''getSucceedingStampForX-5 this, mirror?, strict?, xStamp, yStamp)
            s (if (and (some? s) (Stamp''isUnrestricted-1 s)) nil s)
        ]
            (when (and (instance? AddNode forY) (instance? IntegerStamp xStamp)) => s
                (let [
                    #_"IntegerStamp" aStamp
                        (cond
                            (and (= (:x forY) forX) (instance? IntegerStamp (:stamp (:y forY)))) (:stamp (:y forY)) ;; x < x + a
                            (and (= (:y forY) forX) (instance? IntegerStamp (:stamp (:x forY)))) (:stamp (:x forY)) ;; x < a + x
                        )
                ]
                    (when (some? aStamp) => s
                        (let [
                            aStamp (Stamp''tryImproveWith-2 xStamp, (LowerOp''getSucceedingStampForXLowerXPlusA-4 (IntegerLowerThanNode''getOp-1 this), mirror?, strict?, aStamp))
                        ]
                            (when (some? aStamp) => s
                                (when (some? s) => aStamp
                                    (Stamp''improveWith-2 s, aStamp)
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method- #_"Stamp" IntegerLowerThanNode''getSucceedingStampForX-5 [#_"IntegerLowerThanNode" this, #_"boolean" mirror?, #_"boolean" strict?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when (and (instance? IntegerStamp xStamp) (instance? IntegerStamp yStamp))
            (LowerOp''getSucceedingStampForX-5 (IntegerLowerThanNode''getOp-1 this), xStamp, yStamp, mirror?, strict?)
        )
    )

    #_unused
    (§ override #_"TriState" IntegerLowerThanNode''tryFold-3 [#_"IntegerLowerThanNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (LowerOp''tryFold-3 (IntegerLowerThanNode''getOp-1 this), xStamp, yStamp)
    )
)

;;;
 ; @anno IntegerLowerThanNode.LowerOp
 ;;
(class-ns LowerOp (§ extends CompareOp)
    (§ defn #_"LowerOp" LowerOp'new-0 []
        (CompareOp'new-0)
    )

    #_unused
    (§ override #_"LogicNode" LowerOp''canonical-5 [#_"LowerOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (CompareOp''canonical-5 (§ super ), smallestCompareWidth, condition, forX, forY)
            (LowerOp''findSynonym-3 this, forX, forY)
        )
    )

    (§ abstract #_"long" LowerOp''upperBound-2 [#_"LowerOp" this, #_"IntegerStamp" stamp])

    (§ abstract #_"long" LowerOp''lowerBound-2 [#_"LowerOp" this, #_"IntegerStamp" stamp])

    (§ abstract #_"int" LowerOp''compare-3 [#_"LowerOp" this, #_"long" a, #_"long" b])

    (§ abstract #_"long" LowerOp''min-3 [#_"LowerOp" this, #_"long" a, #_"long" b])

    (§ abstract #_"long" LowerOp''max-3 [#_"LowerOp" this, #_"long" a, #_"long" b])

    (§ method #_"long" LowerOp''min-4 [#_"LowerOp" this, #_"long" a, #_"long" b, #_"int" bits]
        (LowerOp''min-3 this, (LowerOp''cast-3 this, a, bits), (LowerOp''cast-3 this, b, bits))
    )

    (§ method #_"long" LowerOp''max-4 [#_"LowerOp" this, #_"long" a, #_"long" b, #_"int" bits]
        (LowerOp''max-3 this, (LowerOp''cast-3 this, a, bits), (LowerOp''cast-3 this, b, bits))
    )

    (§ abstract #_"long" LowerOp''cast-3 [#_"LowerOp" this, #_"long" a, #_"int" bits])

    (§ abstract #_"long" LowerOp''minValue-2 [#_"LowerOp" this, #_"int" bits])

    (§ abstract #_"long" LowerOp''maxValue-2 [#_"LowerOp" this, #_"int" bits])

    (§ abstract #_"IntegerStamp" LowerOp''forInteger-4 [#_"LowerOp" this, #_"int" bits, #_"long" min, #_"long" max])

    (§ abstract #_"CanonicalCondition" LowerOp''getCondition-1 [#_"LowerOp" this])

    (§ abstract #_"IntegerLowerThanNode" LowerOp''createNode-3 [#_"LowerOp" this, #_"ValueNode" x, #_"ValueNode" y])

    (§ method #_"LogicNode" LowerOp''create-3 [#_"LowerOp" this, #_"ValueNode" x, #_"ValueNode" y]
        (or (CompareNode'tryConstantFoldPrimitive-3 (LowerOp''getCondition-1 this), x, y)
            (LowerOp''findSynonym-3 this, x, y)
            (LowerOp''createNode-3 this, x, y)
        )
    )

    (§ method #_"LogicNode" LowerOp''findSynonym-3 [#_"LowerOp" this, #_"ValueNode" forX, #_"ValueNode" forY]
        (when-not (= (GraphUtil'unproxify-1 forX) (GraphUtil'unproxify-1 forY)) => (LogicConstantNode'contradiction-0)
            (let [
                #_"TriState" fold (LowerOp''tryFold-3 this, (:stamp forX), (:stamp forY))
            ]
                (cond
                    (#_"TriState" .isTrue fold)  (LogicConstantNode'tautology-0)
                    (#_"TriState" .isFalse fold) (LogicConstantNode'contradiction-0)
                    (instance? IntegerStamp (:stamp forY))
                        (let [
                            #_"IntegerStamp" yStamp (:stamp forY)
                            #_"int" bits (:bits yStamp)
                        ]
                            (when (and (ValueNode''isJavaConstant-1 forX) (not (instance? ConstantNode forY)))
                                ;; bring the constant on the right
                                (let [
                                    #_"long" xValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX))
                                ]
                                    (when-not (= xValue (LowerOp''maxValue-2 this, bits))
                                        ;; c < x <=> !(c >= x) <=> !(x <= c) <=> !(x < c + 1)
                                        (§ return (LogicNegationNode'create-1 (LowerOp''create-3 this, forY, (ConstantNode'forIntegerStamp-2 yStamp, (inc xValue)))))
                                    )
                                )
                            )
                            (cond
                                (ValueNode''isJavaConstant-1 forY)
                                    (let [
                                        #_"long" yValue (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                                    ]
                                        (when (= yValue (LowerOp''maxValue-2 this, bits))
                                            ;; x < MAX <=> x != MAX
                                            (§ return (LogicNegationNode'create-1 (IntegerEqualsNode'create-2 forX, forY)))
                                        )
                                        (when (= yValue (inc (LowerOp''minValue-2 this, bits)))
                                            ;; x < MIN + 1 <=> x <= MIN <=> x == MIN
                                            (§ return (IntegerEqualsNode'create-2 forX, (ConstantNode'forIntegerStamp-2 yStamp, (LowerOp''minValue-2 this, bits))))
                                        )
                                    )
                                (instance? AddNode forY)
                                    (let [
                                        #_"LogicNode" canonical (LowerOp''canonicalizeXLowerXPlusA-5 this, forX, forY, false, true)
                                    ]
                                        (when (some? canonical)
                                            (§ return canonical)
                                        )
                                    )
                            )
                            (when (instance? AddNode forX)
                                (LowerOp''canonicalizeXLowerXPlusA-5 this, forY, forX, true, false)
                            )
                        )
                )
            )
        )
    )

    (§ method- #_"LogicNode" LowerOp''canonicalizeXLowerXPlusA-5 [#_"LowerOp" this, #_"ValueNode" forX, #_"AddNode" addNode, #_"boolean" mirrored?, #_"boolean" strict?]
        ;; x < x + a
        (let [
            [#_"IntegerStamp" succeedingXStamp #_"boolean" exact?]
                (cond
                    (and (= (:x addNode) forX) (instance? IntegerStamp (:stamp (:y addNode))))
                        [(LowerOp''getSucceedingStampForXLowerXPlusA-4 this, mirrored?, strict?, (:stamp (:y addNode))) (= (:lowerBound (:stamp (:y addNode))) (:upperBound (:stamp (:y addNode))))]
                    (and (= (:y addNode) forX) (instance? IntegerStamp (:stamp (:x addNode))))
                        [(LowerOp''getSucceedingStampForXLowerXPlusA-4 this, mirrored?, strict?, (:stamp (:x addNode))) (= (:lowerBound (:stamp (:x addNode))) (:upperBound (:stamp (:x addNode))))]
                    :else
                        (§ return nil)
                )
        ]
            (cond
                (Stamp''isEmpty-1 (IntegerStamp''join-2 succeedingXStamp, (:stamp forX)))
                    (LogicConstantNode'contradiction-0)
                (and exact? (not (Stamp''isEmpty-1 succeedingXStamp)))
                    (cond
                        (pos? (LowerOp''compare-3 this, (LowerOp''lowerBound-2 this, succeedingXStamp), (LowerOp''minValue-2 this, (:bits succeedingXStamp))))
                            ;; x must be in [L..MAX] <=> x >= L <=> !(x < L)
                            (LogicNegationNode'create-1 (LowerOp''create-3 this, forX, (ConstantNode'forIntegerStamp-2 succeedingXStamp, (LowerOp''lowerBound-2 this, succeedingXStamp))))
                        (neg? (LowerOp''compare-3 this, (LowerOp''upperBound-2 this, succeedingXStamp), (LowerOp''maxValue-2 this, (:bits succeedingXStamp))))
                            ;; x must be in [MIN..H] <=> x <= H <=> !(H < x)
                            (LogicNegationNode'create-1 (LowerOp''create-3 this, (ConstantNode'forIntegerStamp-2 succeedingXStamp, (LowerOp''upperBound-2 this, succeedingXStamp)), forX))
                    )
            )
        )
    )

    (§ method #_"TriState" LowerOp''tryFold-3 [#_"LowerOp" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when (and (instance? IntegerStamp xStamp) (instance? IntegerStamp yStamp)) => TriState/UNKNOWN
            (cond
                (<    (LowerOp''compare-3 this, (LowerOp''upperBound-2 this, xStamp), (LowerOp''lowerBound-2 this, yStamp)) 0) TriState/TRUE
                (<= 0 (LowerOp''compare-3 this, (LowerOp''lowerBound-2 this, xStamp), (LowerOp''upperBound-2 this, yStamp))  ) TriState/FALSE
                :else                                                                                                          TriState/UNKNOWN
            )
        )
    )

    (§ method #_"IntegerStamp" LowerOp''getSucceedingStampForX-5 [#_"LowerOp" this, #_"IntegerStamp" xStamp, #_"IntegerStamp" yStamp, #_"boolean" mirror, #_"boolean" strict?]
        (let [
            #_"int" bits (:bits xStamp)
        ]
            (if mirror
                (let [
                    #_"long" low (LowerOp''lowerBound-2 this, yStamp)
                ]
                    (when strict?
                        (when (= low (LowerOp''maxValue-2 this, bits))
                            (§ return nil)
                        )
                        (§ ass low (inc low))
                    )
                    (when (or (pos? (LowerOp''compare-3 this, low, (LowerOp''lowerBound-2 this, xStamp))) (not= (LowerOp''upperBound-2 this, xStamp) (& (:upperBound xStamp) (CodeUtil/mask (:bits xStamp)))))
                        (LowerOp''forInteger-4 this, bits, low, (LowerOp''upperBound-2 this, xStamp))
                    )
                )
                ;; x < y, i.e. x < y <= Y_UPPER_BOUND, so x <= Y_UPPER_BOUND - 1
                (let [
                    #_"long" low (LowerOp''upperBound-2 this, yStamp)
                ]
                    (when strict?
                        (when (= low (LowerOp''minValue-2 this, bits))
                            (§ return nil)
                        )
                        (§ ass low (dec low))
                    )
                    (when (or (neg? (LowerOp''compare-3 this, low, (LowerOp''upperBound-2 this, xStamp))) (not= (LowerOp''lowerBound-2 this, xStamp) (& (:lowerBound xStamp) (CodeUtil/mask (:bits xStamp)))))
                        (LowerOp''forInteger-4 this, bits, (LowerOp''lowerBound-2 this, xStamp), low)
                    )
                )
            )
        )
    )

    (§ method! #_"IntegerStamp" LowerOp''getSucceedingStampForXLowerXPlusA-4 [#_"LowerOp" this, #_"boolean" mirrored?, #_"boolean" strict?, #_"IntegerStamp" a]
        (let [
            #_"int" bits (:bits a)
            #_"long" min (LowerOp''minValue-2 this, bits)
            #_"long" max (LowerOp''maxValue-2 this, bits)
        ]
            ;; if x < x + a <=> x + a didn't overflow:
            ;;
            ;; x is outside ]MAX - a, MAX], i.e. inside [MIN, MAX - a]
            ;;
            ;; if a is negative those bounds wrap around correctly.
            ;;
            ;; If a is exactly zero this gives an unbounded stamp (any integer) in the positive case
            ;; and an empty stamp in the negative case: if x |<| x is true, then either x has no
            ;; value or any value...
            ;;
            ;; This does not use upper/lowerBound from LowerOp, because it's about
            ;; the (signed) addition not the comparison.
            (if mirrored?
                (if (IntegerStamp''contains-2 a, 0)
                    (IntegerStamp''unrestricted-1 a) ;; a may be zero
                    (LowerOp''forInteger-4 this, bits, (LowerOp''min-4 this, (inc (- max (:lowerBound a))), (inc (- max (:upperBound a))), bits), max)
                )
                (let [
                    #_"long" aLower (:lowerBound a)
                    #_"long" aUpper (:upperBound a)
                ]
                    (when strict?
                        (when (zero? aLower)
                            (§ ass aLower 1)
                        )
                        (when (zero? aUpper)
                            (§ ass aUpper -1)
                        )
                        (when (< aUpper aLower)
                            ;; impossible
                            (§ return (IntegerStamp''empty-1 a))
                        )
                    )
                    (if (and (neg? aLower) (pos? aUpper))
                        (IntegerStamp''unrestricted-1 a) ;; a may be zero
                        (LowerOp''forInteger-4 this, bits, min, (LowerOp''max-4 this, (- max aLower), (- max aUpper), bits))
                    )
                )
            )
        )
    )
)

;;;
 ; This node will perform a "test" operation on its arguments. Its result is equivalent to the
 ; expression "(x & y) == 0", meaning that it will return true if (and only if) no bit is set in
 ; both x and y.
 ;;
(final-ns IntegerTestNode (§ extends BinaryOpLogicNode) (§ implements BinaryCommutative #_"<ValueNode>")
    (§ def #_"NodeClass<IntegerTestNode>" IntegerTestNode'TYPE (NodeClass'create-1 IntegerTestNode))

    (§ defn #_"IntegerTestNode" IntegerTestNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (BinaryOpLogicNode'new-3 IntegerTestNode'TYPE, x, y)
    )

    #_unused
    (§ override! #_"ValueNode" IntegerTestNode''canonical-4 [#_"IntegerTestNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (and (instance? ConstantNode forX) (instance? ConstantNode forY))
                (LogicConstantNode'forBoolean-1 (zero? (& (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)) (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)))))
            (and (instance? IntegerStamp (:stamp forX)) (instance? IntegerStamp (:stamp forY)))
                (let [
                    #_"IntegerStamp" xStamp (:stamp forX)
                    #_"IntegerStamp" yStamp (:stamp forY)
                ]
                    (cond
                        (zero? (& (:upMask xStamp) (:upMask yStamp)))           (LogicConstantNode'tautology-0)
                        (not (zero? (& (:downMask xStamp) (:downMask yStamp)))) (LogicConstantNode'contradiction-0)
                        :else                                                   this
                    )
                )
            :else
                this
        )
    )

    #_unused
    (§ override! #_"Stamp" IntegerTestNode''getSucceedingStampForX-4 [#_"IntegerTestNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (IntegerTestNode'getSucceedingStamp-3 negated?, xStamp, yStamp)
    )

    (§ defn- #_"Stamp" IntegerTestNode'getSucceedingStamp-3 [#_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" otherStamp]
        (when (and (instance? IntegerStamp xStamp) (instance? IntegerStamp otherStamp))
            (if negated?
                (when (= (Long/bitCount (:upMask otherStamp)) 1)
                    (let [
                        #_"long" newDownMask (| (:downMask xStamp) (:upMask otherStamp))
                    ]
                        (when-not (= (:downMask xStamp) newDownMask)
                            (IntegerStamp''join-2 (IntegerStamp'stampForMask-3 (:bits xStamp), newDownMask, (:upMask xStamp)), xStamp)
                        )
                    )
                )
                (let [
                    #_"long" restrictedUpMask (& (bit-not (:downMask otherStamp)) (:upMask xStamp))
                ]
                    (when-not (= (:upMask xStamp) restrictedUpMask)
                        (IntegerStamp''join-2 (IntegerStamp'stampForMask-3 (:bits xStamp), (:downMask xStamp), restrictedUpMask), xStamp)
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"Stamp" IntegerTestNode''getSucceedingStampForY-4 [#_"IntegerTestNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (IntegerTestNode'getSucceedingStamp-3 negated?, yStamp, xStamp)
    )

    #_unused
    (§ override! #_"TriState" IntegerTestNode''tryFold-3 [#_"IntegerTestNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when (and (instance? IntegerStamp xStamp) (instance? IntegerStamp yStamp)) => TriState/UNKNOWN
            (cond
                (zero? (& (:upMask xStamp) (:upMask yStamp)))           TriState/TRUE
                (not (zero? (& (:downMask xStamp) (:downMask yStamp)))) TriState/FALSE
                :else                                                   TriState/UNKNOWN
            )
        )
    )
)

;;;
 ; An IsNullNode will be true if the supplied value is nil, and false if it is non-nil.
 ;;
(final-ns IsNullNode (§ extends UnaryOpLogicNode) (§ implements LIRLowerable, Virtualizable)
    (§ def #_"NodeClass<IsNullNode>" IsNullNode'TYPE (NodeClass'create-1 IsNullNode))

    (§ defn #_"IsNullNode" IsNullNode'new-1 [#_"ValueNode" object]
        (UnaryOpLogicNode'new-2 IsNullNode'TYPE, object)
    )

    (§ defn #_"LogicNode" IsNullNode'create-1 [#_"ValueNode" value]
        (IsNullNode'canonicalized-2 nil, value)
    )

    (§ defn #_"LogicNode" IsNullNode'tryCanonicalize-1 [#_"ValueNode" value]
        (cond
            (StampTool'isPointerAlwaysNull-1 (:stamp value)) (LogicConstantNode'tautology-0)
            (StampTool'isPointerNeverNull-1 (:stamp value))  (LogicConstantNode'contradiction-0)
        )
    )

    #_unused
    (§ override! #_"void" IsNullNode''generate-2 [#_"IsNullNode" this, #_"LIRBuilder" builder]
        ;; Nothing to do.
        nil
    )

    #_unused
    (§ override! #_"ValueNode" IsNullNode''canonical-3 [#_"IsNullNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (IsNullNode'canonicalized-2 this, value)
    )

    (§ defn- #_"LogicNode" IsNullNode'canonicalized-2 [#_"IsNullNode" self, #_"ValueNode" value]
        (or (IsNullNode'tryCanonicalize-1 value)
            (cond
                (instance? PiNode value)                                                              (IsNullNode'create-1 (GraphUtil'skipPi-1 value))
                (and (instance? ConvertNode value) (ConvertNode''mayNullCheckSkipConversion-1 value)) (IsNullNode'create-1 (ConvertNode''getValue-1 value))
                :else                                                                                 (or self (IsNullNode'new-1 (GraphUtil'skipPi-1 value)))
            )
        )
    )

    #_unused
    (§ override! #_"void" IsNullNode''virtualize-2 [#_"IsNullNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"TriState" fold (IsNullNode''tryFold-2 this, (:stamp (VirtualizerTool''getAlias-2 tool, (UnaryOpLogicNode''getValue-1 this))))
        ]
            (when-not (= fold TriState/UNKNOWN)
                (VirtualizerTool''replaceWithValue-2 tool, (LogicConstantNode'forBoolean-2 (#_"TriState" .isTrue fold), (:graph this)))
            )
        )
        nil
    )

    #_unused
    (§ override! #_"Stamp" IsNullNode''getSucceedingStampForValue-2 [#_"IsNullNode" this, #_"boolean" negated?]
        ;; ignore any more precise input stamp, since canonicalization will skip through PiNodes
        (let [
            #_"AbstractPointerStamp" stamp (Stamp''unrestricted-1 (:stamp (UnaryOpLogicNode''getValue-1 this)))
        ]
            (if negated? (AbstractPointerStamp''asNonNull-1 stamp) (AbstractPointerStamp''asAlwaysNull-1 stamp))
        )
    )

    (§ override! #_"TriState" IsNullNode''tryFold-2 [#_"IsNullNode" this, #_"Stamp" stamp]
        (when (instance? ObjectStamp stamp) => TriState/UNKNOWN
            (cond
                (:always-nil? stamp) TriState/TRUE
                (:never-nil? stamp)  TriState/FALSE
                :else                TriState/UNKNOWN
            )
        )
    )
)

(final-ns LeftShiftNode (§ extends ShiftNode #_"<Shl>")
    (§ def #_"NodeClass<LeftShiftNode>" LeftShiftNode'TYPE (NodeClass'create-1 LeftShiftNode))

    (§ defn #_"LeftShiftNode" LeftShiftNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (ShiftNode'new-4 LeftShiftNode'TYPE, :shl, x, y)
    )

    (§ defn #_"ValueNode" LeftShiftNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"ShiftOp<Shl>" op (:shl (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (ShiftOp''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (ShiftNode'canonical-4 op, stamp, x, y) (LeftShiftNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    #_unused
    (§ override! #_"ValueNode" LeftShiftNode''canonical-4 [#_"LeftShiftNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (ShiftNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (LeftShiftNode'canonical-5 this, (ShiftNode''getArithmeticOp-1 this), (:stamp this), forX, forY)
            )
        )
    )

    (§ defn- #_"ValueNode" LeftShiftNode'canonical-5 [#_"LeftShiftNode" self, #_"ShiftOp<Shl>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (instance? ConstantNode forY)
            (let [
                #_"int" amount (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 forY))
                #_"int" o'amount amount
                #_"int" mask (ShiftOp''getShiftAmountMask-2 op, stamp)
                amount (& amount mask)
            ]
                (when (zero? amount)
                    (§ return forX)
                )
                (when (and (instance? ShiftNode forX) (instance? ConstantNode (:y forX)))
                    (let [
                        #_"int" amount' (& (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y forX))) mask)
                    ]
                        (cond
                            (instance? LeftShiftNode forX)
                                (let [
                                    #_"int" total (+ amount amount')
                                ]
                                    (if (= total (& total mask))
                                        (§ return (LeftShiftNode'new-2 (:x forX), (ConstantNode'forInt-1 total)))
                                        (§ return (ConstantNode'forIntegerKind-2 (Stamp''getStackKind-1 stamp), 0))
                                    )
                                )
                            (and (or (instance? RightShiftNode forX) (instance? UnsignedRightShiftNode forX)) (= amount amount'))
                                (if (= (Stamp''getStackKind-1 stamp) JavaKind/Long)
                                    (§ return (AndNode'new-2 (:x forX), (ConstantNode'forLong-1 (<< -1 amount))))
                                    (§ return (AndNode'new-2 (:x forX), (ConstantNode'forInt-1 (<< -1 amount))))
                                )
                        )
                    )
                )
                (when-not (= o'amount amount)
                    (§ return (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 amount)))
                )
            )
        )
        (or self (LeftShiftNode'new-2 forX, forY))
    )

    #_unused
    (§ override! #_"void" LeftShiftNode''generate-2 [#_"LeftShiftNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitShl-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )
)

(class-ns MulNode (§ extends BinaryArithmeticNode #_"<Mul>") (§ implements NarrowableArithmeticNode, BinaryCommutative #_"<ValueNode>")
    (§ def #_"NodeClass<MulNode>" MulNode'TYPE (NodeClass'create-1 MulNode))

    (§ defn #_"MulNode" MulNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (MulNode'new-3 MulNode'TYPE, x, y)
    )

    (§ defn #_"MulNode" MulNode'new-3 [#_"NodeClass<? extends MulNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (BinaryArithmeticNode'new-4 c, :mul, x, y)
    )

    (§ defn #_"ValueNode" MulNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Mul>" op (:mul (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp) (MulNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    #_unused
    (§ override #_"ValueNode" MulNode''canonical-4 [#_"MulNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (BinaryArithmeticNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (if (and (instance? ConstantNode forX) (not (instance? ConstantNode forY)))
                    ;; we try to swap and canonicalize
                    (let [
                        #_"ValueNode" improvement (BinaryArithmeticNode''canonical-4 this, tool, forY, forX)
                    ]
                        (when (= improvement this) => improvement
                            ;; if this fails we only swap
                            (MulNode'new-2 forY, forX)
                        )
                    )
                    (MulNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
                )
            )
        )
    )

    (§ defn- #_"ValueNode" MulNode'canonical-5 [#_"MulNode" self, #_"BinaryOp<Mul>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (instance? ConstantNode forY)
            (let [
                #_"Constant" c (:value forY)
            ]
                (when (BinaryOp''isNeutral-2 op, c)
                    (§ return forX)
                )

                (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                    (let [
                        #_"ValueNode" result (MulNode'canonical-3 stamp, forX, (#_"PrimitiveConstant" .asLong c))
                    ]
                        (when (some? result)
                            (§ return result)
                        )
                    )
                )

                (when (BinaryOp''isAssociative-1 op)
                    ;; canonicalize expressions like "(a * 1) * 2"
                    (§ return (BinaryArithmeticNode'reassociate-4 (or self (BinaryArithmeticNode''maybeCommuteInputs-1 (MulNode'new-2 forX, forY))), (ValueNode'isConstantPredicate-0), forX, forY))
                )
            )
        )
        (or self (BinaryArithmeticNode''maybeCommuteInputs-1 (MulNode'new-2 forX, forY)))
    )

    (§ defn #_"ValueNode" MulNode'canonical-3 [#_"Stamp" stamp, #_"ValueNode" forX, #_"long" i]
        (cond
            (zero? i) (ConstantNode'forIntegerStamp-2 stamp, 0)
            (= i 1)   forX
            (= i -1)  (NegateNode'create-1 forX)
            (pos? i)
                (cond
                    (CodeUtil/isPowerOf2 i)       (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 i)))
                    (CodeUtil/isPowerOf2 (dec i)) (AddNode'create-2 (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 (dec i)))), forX)
                    (CodeUtil/isPowerOf2 (inc i)) (SubNode'create-2 (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 (inc i)))), forX)
                    :else
                        (let [
                            #_"long" highestBitValue (Long/highestOneBit i)
                        ]
                            (if (= (Long/bitCount i) 2)
                                ;; e.g. 0b1000_0010
                                (let [
                                    #_"long" lowerBitValue (- i highestBitValue)
                                    #_"ValueNode" left (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 highestBitValue)))
                                    #_"ValueNode" right (if (= lowerBitValue 1) forX (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 lowerBitValue))))
                                ]
                                    (AddNode'create-2 left, right)
                                )
                                ;; e.g. 0b1111_1101
                                (let [
                                    #_"int" shiftToRoundUpToPowerOf2 (inc (CodeUtil/log2 highestBitValue))
                                    #_"long" subValue (- (<< 1 shiftToRoundUpToPowerOf2) i)
                                ]
                                    (when (and (CodeUtil/isPowerOf2 subValue) (< shiftToRoundUpToPowerOf2 (:bits stamp)))
                                        (let [
                                            #_"ValueNode" left (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 shiftToRoundUpToPowerOf2))
                                            #_"ValueNode" right (LeftShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 subValue)))
                                        ]
                                            (SubNode'create-2 left, right)
                                        )
                                    )
                                )
                            )
                        )
                )
            (neg? i)
                (when (CodeUtil/isPowerOf2 (- i))
                    (NegateNode'create-1 (LeftShiftNode'create-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 (- i)))))
                )
        )
    )

    #_unused
    (§ override #_"void" MulNode''generate-2 [#_"MulNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value" op1 (LIRBuilder''operand-2 builder, (:x this))
            #_"Value" op2 (LIRBuilder''operand-2 builder, (:y this))
            [op1 op2] (if (BinaryArithmeticNode''shouldSwapInputs-2 this, builder) [op2 op1] [op1 op2])
        ]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitMul-4 (:gen builder), op1, op2, false))
        )
        nil
    )
)

;;;
 ; Marker interface for nodes where it is valid to apply a NarrowNode to its inputs and do a
 ; narrow operation instead of doing the wide operation and applying the NarrowNode to the result.
 ;;
(§ interface NarrowableArithmeticNode
    ;;;
     ; Check whether this operation can be narrowed to {@code resultBits} bit without loss of precision.
     ;;
    #_unused
    (§ default #_"boolean" NarrowableArithmeticNode''isNarrowable-2 [#_"NarrowableArithmeticNode" this, #_"int" resultBits]
        true
    )
)

;;;
 ; The NarrowNode converts an integer to a narrower integer.
 ;;
(final-ns NarrowNode (§ extends IntegerConvertNode #_"<Narrow, SignExtend>")
    (§ def #_"NodeClass<NarrowNode>" NarrowNode'TYPE (NodeClass'create-1 NarrowNode))

    (§ defn #_"NarrowNode" NarrowNode'new-2 [#_"ValueNode" input, #_"int" resultBits]
        (NarrowNode'new-3 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits)
    )

    (§ defn #_"NarrowNode" NarrowNode'new-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (IntegerConvertNode'new-6 NarrowNode'TYPE, :narrow, :signExtend, inputBits, resultBits, input)
    )

    (§ defn #_"ValueNode" NarrowNode'create-2 [#_"ValueNode" input, #_"int" resultBits]
        (NarrowNode'create-3 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits)
    )

    (§ defn #_"ValueNode" NarrowNode'create-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (let [
            #_"IntegerConvertOp<Narrow>" signExtend (:narrow (ArithmeticOpTable'forStamp-1 (:stamp input)))
        ]
            (or (IntegerConvertNode'findSynonym-5 signExtend, input, inputBits, resultBits, (IntegerConvertOp''foldStamp-4 signExtend, inputBits, resultBits, (:stamp input)))
                (NarrowNode'new-3 input, inputBits, resultBits)
            )
        )
    )

    #_unused
    (§ override! #_"boolean" NarrowNode''isLossless-1 [#_"NarrowNode" this]
        false
    )

    #_unused
    (§ override! #_"ValueNode" NarrowNode''canonical-3 [#_"NarrowNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (let [
            #_"ValueNode" canon (IntegerConvertNode''canonical-3 (§ super ), tool, value)
        ]
            (when (= canon this) => canon
                (condp instance? value
                    NarrowNode
                        ;; zzzzzzzz yyyyxxxx -(narrow)-> yyyyxxxx -(narrow)-> xxxx
                        ;; ==> zzzzzzzz yyyyxxxx -(narrow)-> xxxx
                        (NarrowNode'new-3 (UnaryNode''getValue-1 value), (IntegerConvertNode''getInputBits-1 value), (IntegerConvertNode''getResultBits-1 this))
                    IntegerConvertNode
                        ;; SignExtendNode or ZeroExtendNode
                        (cond
                            (and (Node''hasExactlyOneUsage-1 (UnaryNode''getValue-1 value)) (Node''hasMoreThanOneUsage-1 value))
                                ;; Do not perform if this will introduce a new live value.
                                ;; If the original value's usage count is > 1, there is already another user.
                                ;; If the convert's usage count is <=1, it will be dead code eliminated.
                                this
                            (= (IntegerConvertNode''getResultBits-1 this) (IntegerConvertNode''getInputBits-1 value))
                                ;; xxxx -(extend)-> yyyy xxxx -(narrow)-> xxxx
                                ;; ==> no-op
                                (UnaryNode''getValue-1 value)
                            (< (IntegerConvertNode''getResultBits-1 this) (IntegerConvertNode''getInputBits-1 value))
                                ;; yyyyxxxx -(extend)-> zzzzzzzz yyyyxxxx -(narrow)-> xxxx
                                ;; ==> yyyyxxxx -(narrow)-> xxxx
                                (NarrowNode'new-3 (UnaryNode''getValue-1 value), (IntegerConvertNode''getInputBits-1 value), (IntegerConvertNode''getResultBits-1 this))
                            :else
                                (condp instance? value
                                    SignExtendNode
                                        ;; sxxx -(sign-extend)-> ssssssss sssssxxx -(narrow)-> sssssxxx
                                        ;; ==> sxxx -(sign-extend)-> sssssxxx
                                        (SignExtendNode'create-3 (UnaryNode''getValue-1 value), (IntegerConvertNode''getInputBits-1 value), (IntegerConvertNode''getResultBits-1 this))
                                    ZeroExtendNode
                                        ;; xxxx -(zero-extend)-> 00000000 0000xxxx -(narrow)-> 0000xxxx
                                        ;; ==> xxxx -(zero-extend)-> 0000xxxx
                                        (ZeroExtendNode'new-4 (UnaryNode''getValue-1 value), (IntegerConvertNode''getInputBits-1 value), (IntegerConvertNode''getResultBits-1 this), (:inputAlwaysPositive value))
                                    this
                                )
                        )
                    AndNode
                        (let [
                            #_"long" relevantMask (CodeUtil/mask (IntegerConvertNode''getResultBits-1 this))
                        ]
                            (condp = relevantMask
                                (& relevantMask (:downMask (:stamp (:y value)))) (NarrowNode'create-2 (:x value), (IntegerConvertNode''getResultBits-1 this))
                                (& relevantMask (:downMask (:stamp (:x value)))) (NarrowNode'create-2 (:y value), (IntegerConvertNode''getResultBits-1 this))
                                this
                            )
                        )
                    this
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" NarrowNode''generate-2 [#_"NarrowNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitNarrow-3 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this)), (IntegerConvertNode''getResultBits-1 this)))
        nil
    )

    #_unused
    (§ override! #_"boolean" NarrowNode''mayNullCheckSkipConversion-1 [#_"NarrowNode" this]
        false
    )
)

;;;
 ; The NegateNode node negates its operand.
 ;;
(final-ns NegateNode (§ extends UnaryArithmeticNode #_"<Neg>") (§ implements NarrowableArithmeticNode, StampInverter)
    (§ def #_"NodeClass<NegateNode>" NegateNode'TYPE (NodeClass'create-1 NegateNode))

    (§ defn #_"NegateNode" NegateNode'new-1 [#_"ValueNode" value]
        (UnaryArithmeticNode'new-3 NegateNode'TYPE, :neg, value)
    )

    (§ defn #_"ValueNode" NegateNode'create-1 [#_"ValueNode" value]
        (or (NegateNode'findSynonym-1 value)
            (NegateNode'new-1 value)
        )
    )

    #_unused
    (§ override! #_"ValueNode" NegateNode''canonical-3 [#_"NegateNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (or (UnaryArithmeticNode'findSynonym-2 value, (UnaryArithmeticNode''getOp-2 this, value))
            this
        )
    )

    (§ defn #_"ValueNode" NegateNode'findSynonym-1 [#_"ValueNode" value]
        (or (UnaryArithmeticNode'findSynonym-2 value, (:neg (ArithmeticOpTable'forStamp-1 (:stamp value))))
            (condp instance? value
                NegateNode (UnaryNode''getValue-1 value)
                SubNode    (SubNode'create-2 (:y value), (:x value))
                nil
            )
        )
    )

    #_unused
    (§ override! #_"void" NegateNode''generate-2 [#_"NegateNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitNegate-2 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this))))
        nil
    )

    #_unused
    (§ override! #_"Stamp" NegateNode''invertStamp-2 [#_"NegateNode" this, #_"Stamp" outStamp]
        (UnaryOp''foldStamp-2 (UnaryArithmeticNode''getArithmeticOp-1 this), outStamp)
    )
)

;;;
 ; Returns -1, 0, or 1 if either x < y, x == y, or x > y.
 ;;
(final-ns NormalizeCompareNode (§ extends BinaryNode) (§ implements IterableNodeType)
    (§ def #_"NodeClass<NormalizeCompareNode>" NormalizeCompareNode'TYPE (NodeClass'create-1 NormalizeCompareNode))

    (§ defn #_"NormalizeCompareNode" NormalizeCompareNode'new-3 [#_"ValueNode" x, #_"ValueNode" y, #_"JavaKind" kind]
        (BinaryNode'new-4 NormalizeCompareNode'TYPE, (StampFactory'forInteger-3 kind, -1, 1), x, y)
    )

    (§ defn #_"ValueNode" NormalizeCompareNode'create-3 [#_"ValueNode" x, #_"ValueNode" y, #_"JavaKind" kind]
        (or (NormalizeCompareNode'tryConstantFold-3 x, y, kind)
            (NormalizeCompareNode'new-3 x, y, kind)
        )
    )

    (§ defn #_"ValueNode" NormalizeCompareNode'tryConstantFold-3 [#_"ValueNode" x, #_"ValueNode" y, #_"JavaKind" kind]
        (let [
            #_"LogicNode" result (CompareNode'tryConstantFold-3 CanonicalCondition'EQ, x, y)
        ]
            (when (instance? LogicConstantNode result)
                (let [
                    #_"LogicNode" resultLT (CompareNode'tryConstantFold-3 CanonicalCondition'LT, x, y)
                ]
                    (when (instance? LogicConstantNode resultLT)
                        (cond
                            (:value resultLT) (ConstantNode'forIntegerKind-2 kind, -1)
                            (:value result)   (ConstantNode'forIntegerKind-2 kind,  0)
                            :else             (ConstantNode'forIntegerKind-2 kind,  1)
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" NormalizeCompareNode''canonical-4 [#_"NormalizeCompareNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (NormalizeCompareNode'tryConstantFold-3 (:x this), (:y this), (Stamp''getStackKind-1 (:stamp this)))
            this
        )
    )

    #_unused
    (§ override! #_"boolean" NormalizeCompareNode''inferStamp-1 [#_"NormalizeCompareNode" this]
        false
    )

    #_unused
    (§ override! #_"Stamp" NormalizeCompareNode''foldStamp-3 [#_"NormalizeCompareNode" this, #_"Stamp" stampX, #_"Stamp" stampY]
        (:stamp this)
    )
)

;;;
 ; Binary negation of long or integer values.
 ;;
(final-ns NotNode (§ extends UnaryArithmeticNode #_"<Not>") (§ implements LIRLowerable, NarrowableArithmeticNode, StampInverter)
    (§ def #_"NodeClass<NotNode>" NotNode'TYPE (NodeClass'create-1 NotNode))

    (§ defn #_"NotNode" NotNode'new-1 [#_"ValueNode" x]
        (UnaryArithmeticNode'new-3 NotNode'TYPE, :not, x)
    )

    #_unused
    (§ defn #_"ValueNode" NotNode'create-1 [#_"ValueNode" x]
        (NotNode'canonicalize-2 nil, x)
    )

    #_unused
    (§ override! #_"ValueNode" NotNode''canonical-3 [#_"NotNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (let [
            #_"ValueNode" ret (UnaryArithmeticNode''canonical-3 (§ super ), tool, value)
        ]
            (when (= ret this) => ret
                (NotNode'canonicalize-2 this, value)
            )
        )
    )

    (§ defn- #_"ValueNode" NotNode'canonicalize-2 [#_"NotNode" node, #_"ValueNode" x]
        (cond
            (instance? NotNode x) (UnaryNode''getValue-1 x)
            (some? node)          node
            :else                 (NotNode'new-1 x)
        )
    )

    #_unused
    (§ override! #_"void" NotNode''generate-2 [#_"NotNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitNot-2 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this))))
        nil
    )

    #_unused
    (§ override! #_"Stamp" NotNode''invertStamp-2 [#_"NotNode" this, #_"Stamp" outStamp]
        (UnaryOp''foldStamp-2 (UnaryArithmeticNode''getArithmeticOp-1 this), outStamp)
    )
)

(final-ns ObjectEqualsNode (§ extends PointerEqualsNode) (§ implements Virtualizable)
    (§ def #_"NodeClass<ObjectEqualsNode>" ObjectEqualsNode'TYPE (NodeClass'create-1 ObjectEqualsNode))

    (§ def- #_"ObjectEqualsOp" ObjectEqualsNode'OP (ObjectEqualsOp'new-0))

    (§ defn #_"ObjectEqualsNode" ObjectEqualsNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (PointerEqualsNode'new-3 ObjectEqualsNode'TYPE, x, y)
    )

    (§ defn #_"LogicNode" ObjectEqualsNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (or (CompareNode'tryConstantFold-3 CanonicalCondition'EQ, x, y)
            (PointerEqualsNode'findSynonym-2 x, y)
            (ObjectEqualsNode'new-2 x, y)
        )
    )

    (§ defn #_"LogicNode" ObjectEqualsNode'createCanonical-2 [#_"ValueNode" x, #_"ValueNode" y]
        (or (CompareOp''canonical-5 ObjectEqualsNode'OP, nil, CanonicalCondition'EQ, x, y)
            (ObjectEqualsNode'create-2 x, y)
        )
    )

    #_unused
    (§ override! #_"ValueNode" ObjectEqualsNode''canonical-4 [#_"ObjectEqualsNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (CompareOp''canonical-5 ObjectEqualsNode'OP, (CanonicalizerTool''smallestCompareWidth-1 tool), CanonicalCondition'EQ, forX, forY)
            this
        )
    )

    (§ method- #_"void" ObjectEqualsNode''virtualizeNonVirtualComparison-4 [#_"ObjectEqualsNode" this, #_"VirtualObjectNode" virtual, #_"ValueNode" other, #_"VirtualizerTool" tool]
        (when (and (instance? VirtualBoxingNode virtual) (instance? ConstantNode other) (= (:boxingKind virtual) JavaKind/Boolean))
            (let [
                #_"JavaConstant" otherUnboxed (#_"ConstantReflectionProvider" .unboxPrimitive HotSpot'constantReflection, (ValueNode''asJavaConstant-1 other))
            ]
                (if (and (some? otherUnboxed) (= (#_"JavaConstant" .getJavaKind otherUnboxed) JavaKind/Boolean))
                    (let [
                        #_"int" expectedValue (if (#_"JavaConstant" .asBoolean otherUnboxed) 1 0)
                        #_"IntegerEqualsNode" equals (IntegerEqualsNode'new-2 (VirtualBoxingNode''getBoxedValue-2 virtual, tool), (ConstantNode'forInt-2 expectedValue, (:graph this)))
                    ]
                        (VirtualizerTool''addNode-2 tool, equals)
                        (VirtualizerTool''replaceWithValue-2 tool, equals)
                    )
                    (VirtualizerTool''replaceWithValue-2 tool, (LogicConstantNode'contradiction-1 (:graph this)))
                )
            )
        )
        (when (VirtualObjectNode''hasIdentity-1 virtual)
            ;; one of them is virtual: they can never be the same objects
            (VirtualizerTool''replaceWithValue-2 tool, (LogicConstantNode'contradiction-1 (:graph this)))
        )
        nil
    )

    #_unused
    (§ override! #_"void" ObjectEqualsNode''virtualize-2 [#_"ObjectEqualsNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" xAlias (VirtualizerTool''getAlias-2 tool, (:x this))
            #_"ValueNode" yAlias (VirtualizerTool''getAlias-2 tool, (:y this))
            #_"VirtualObjectNode" xVirtual (when (instance? VirtualObjectNode xAlias) xAlias)
            #_"VirtualObjectNode" yVirtual (when (instance? VirtualObjectNode yAlias) yAlias)
        ]
            (cond
                (and (some? xVirtual) (nil? yVirtual))
                    (ObjectEqualsNode''virtualizeNonVirtualComparison-4 this, xVirtual, yAlias, tool)
                (and (nil? xVirtual) (some? yVirtual))
                    (ObjectEqualsNode''virtualizeNonVirtualComparison-4 this, yVirtual, xAlias, tool)
                (and (some? xVirtual) (some? yVirtual))
                    (cond
                        (bit-xor (VirtualObjectNode''hasIdentity-1 xVirtual) (VirtualObjectNode''hasIdentity-1 yVirtual))
                            ;; One of the two objects has identity, the other doesn't. In code, this looks like
                            ;; "Integer.valueOf(a) == new Integer(b)", which is always false.
                            ;;
                            ;; In other words: an object created via valueOf can never be equal to one created
                            ;; by new in the same compilation unit.
                            (VirtualizerTool''replaceWithValue-2 tool, (LogicConstantNode'contradiction-1 (:graph this)))
                        (and (not (VirtualObjectNode''hasIdentity-1 xVirtual)) (not (VirtualObjectNode''hasIdentity-1 yVirtual)))
                            (let [
                                #_"ResolvedJavaType" type (VirtualObjectNode''type-1 xVirtual)
                            ]
                                (when (and (= type (VirtualObjectNode''type-1 yVirtual)) (any = type (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Integer) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Long)))
                                    ;; both are virtual without identity: check contents
                                    (let [
                                        #_"IntegerEqualsNode" equals (IntegerEqualsNode'new-2 (VirtualizerTool''getEntry-3 tool, xVirtual, 0), (VirtualizerTool''getEntry-3 tool, yVirtual, 0))
                                    ]
                                        (VirtualizerTool''addNode-2 tool, equals)
                                        (VirtualizerTool''replaceWithValue-2 tool, equals)
                                    )
                                )
                            )
                        :else
                            ;; both are virtual with identity: check if they refer to the same object
                            (VirtualizerTool''replaceWithValue-2 tool, (LogicConstantNode'forBoolean-2 (= xVirtual yVirtual), (:graph this)))
                    )
            )
        )
        nil
    )
)

;;;
 ; @anno ObjectEqualsNode.ObjectEqualsOp
 ;;
(final-ns ObjectEqualsOp (§ extends PointerEqualsOp)
    (§ defn #_"ObjectEqualsOp" ObjectEqualsOp'new-0 []
        (PointerEqualsOp'new-0)
    )

    #_unused
    (§ override! #_"LogicNode" ObjectEqualsOp''canonicalizeSymmetricConstant-6 [#_"ObjectEqualsOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"Constant" constant, #_"ValueNode" node, #_"boolean" mirrored?]
        (let [
            #_"ResolvedJavaType" type (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, constant)
        ]
            (if (and (some? type) (instance? GetClassNode node))
                (if (and (not (#_"ResolvedJavaType" .isPrimitive type)) (or (#_"ResolvedJavaType" .isConcrete type) (#_"ResolvedJavaType" .isArray type)))
                    (InstanceOfNode'create-2 (TypeReference'createExactTrusted-1 type), (:object node))
                    (LogicConstantNode'forBoolean-1 false)
                )
                (CompareOp''canonicalizeSymmetricConstant-6 (§ super ), smallestCompareWidth, condition, constant, node, mirrored?)
            )
        )
    )

    #_unused
    (§ override! #_"CompareNode" ObjectEqualsOp''duplicateModified-3 [#_"ObjectEqualsOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
        (cond
            (and (instance? ObjectStamp (:stamp newX)) (instance? ObjectStamp (:stamp newY)))                   (ObjectEqualsNode'new-2 newX, newY)
            (and (instance? AbstractPointerStamp (:stamp newX)) (instance? AbstractPointerStamp (:stamp newY))) (PointerEqualsNode'new-2 newX, newY)
            :else                                                                                               (throw! "should not reach here")
        )
    )
)

(final-ns OrNode (§ extends BinaryArithmeticNode #_"<Or>") (§ implements BinaryCommutative #_"<ValueNode>", NarrowableArithmeticNode)
    (§ def #_"NodeClass<OrNode>" OrNode'TYPE (NodeClass'create-1 OrNode))

    (§ defn #_"OrNode" OrNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (BinaryArithmeticNode'new-4 OrNode'TYPE, :or, x, y)
    )

    (§ defn #_"ValueNode" OrNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Or>" op (:or (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp)
                (OrNode'canonical-5 nil, op, stamp, x, y)
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" OrNode''canonical-4 [#_"OrNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (BinaryArithmeticNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (OrNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
            )
        )
    )

    (§ defn- #_"ValueNode" OrNode'canonical-5 [#_"OrNode" self, #_"BinaryOp<Or>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1 forX) (GraphUtil'unproxify-1 forY))
                forX
            (and (instance? ConstantNode forX) (not (instance? ConstantNode forY)))
                (OrNode'new-2 forY, forX)
            (instance? ConstantNode forY)
                (let [
                    #_"Constant" c (:value forY)
                ]
                    (if (BinaryOp''isNeutral-2 op, c)
                        forX
                        (do
                            (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                                (let [
                                    #_"long" rawY (#_"PrimitiveConstant" .asLong c)
                                    #_"long" mask (CodeUtil/mask (PrimitiveStamp'getBits-1 stamp))
                                ]
                                    (when (= (& rawY mask) mask)
                                        (§ return (ConstantNode'forIntegerStamp-2 stamp, mask))
                                    )
                                )
                            )
                            (BinaryArithmeticNode'reassociate-4 (or self (BinaryArithmeticNode''maybeCommuteInputs-1 (OrNode'new-2 forX, forY))), (ValueNode'isConstantPredicate-0), forX, forY)
                        )
                    )
                )
            (and (instance? NotNode forX) (instance? NotNode forY))
                (NotNode'new-1 (AndNode'create-2 (UnaryNode''getValue-1 forX), (UnaryNode''getValue-1 forY)))
            :else
                (or self (BinaryArithmeticNode''maybeCommuteInputs-1 (OrNode'new-2 forX, forY)))
        )
    )

    #_unused
    (§ override! #_"void" OrNode''generate-2 [#_"OrNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitOr-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )
)

(class-ns PointerEqualsNode (§ extends CompareNode) (§ implements BinaryCommutative #_"<ValueNode>")
    (§ def #_"NodeClass<PointerEqualsNode>" PointerEqualsNode'TYPE (NodeClass'create-1 PointerEqualsNode))

    (§ def- #_"PointerEqualsOp" PointerEqualsNode'OP (PointerEqualsOp'new-0))

    (§ defn #_"PointerEqualsNode" PointerEqualsNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (PointerEqualsNode'new-3 PointerEqualsNode'TYPE, x, y)
    )

    (§ defn #_"LogicNode" PointerEqualsNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (or (PointerEqualsNode'findSynonym-2 x, y) (PointerEqualsNode'new-2 x, y))
    )

    (§ defn #_"PointerEqualsNode" PointerEqualsNode'new-3 [#_"NodeClass<? extends PointerEqualsNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (CompareNode'new-4 c, CanonicalCondition'EQ, x, y)
    )

    #_unused
    (§ override #_"Node" PointerEqualsNode''canonical-4 [#_"PointerEqualsNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (PointerEqualsOp''canonical-5 PointerEqualsNode'OP, (CanonicalizerTool''smallestCompareWidth-1 tool), CanonicalCondition'EQ, forX, forY)
            this
        )
    )

    (§ defn #_"LogicNode" PointerEqualsNode'findSynonym-2 [#_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1 forX) (GraphUtil'unproxify-1 forY)) (LogicConstantNode'tautology-0)
            (Stamp''alwaysDistinct-2 (:stamp forX), (:stamp forY))        (LogicConstantNode'contradiction-0)
            (:always-nil? (:stamp forX))                                  (IsNullNode'create-1 forY)
            (:always-nil? (:stamp forY))                                  (IsNullNode'create-1 forX)
        )
    )

    #_unused
    (§ override #_"Stamp" PointerEqualsNode''getSucceedingStampForX-4 [#_"PointerEqualsNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when-not negated?
            (let [
                #_"Stamp" newStamp (Stamp''join-2 xStamp, yStamp)
            ]
                (when-not (= newStamp xStamp)
                    newStamp
                )
            )
        )
    )

    #_unused
    (§ override #_"Stamp" PointerEqualsNode''getSucceedingStampForY-4 [#_"PointerEqualsNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when-not negated?
            (let [
                #_"Stamp" newStamp (Stamp''join-2 yStamp, xStamp)
            ]
                (when-not (= newStamp yStamp)
                    newStamp
                )
            )
        )
    )

    #_unused
    (§ override #_"TriState" PointerEqualsNode''tryFold-3 [#_"PointerEqualsNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
        (when (and (instance? ObjectStamp xStamp) (instance? ObjectStamp yStamp)) => TriState/UNKNOWN
            (cond
                (Stamp''alwaysDistinct-2 xStamp, yStamp) TriState/FALSE
                (Stamp''neverDistinct-2 xStamp, yStamp)  TriState/TRUE
                :else                                    TriState/UNKNOWN
            )
        )
    )
)

;;;
 ; @anno PointerEqualsNode.PointerEqualsOp
 ;;
(class-ns PointerEqualsOp (§ extends CompareOp)
    (§ defn #_"PointerEqualsOp" PointerEqualsOp'new-0 []
        (CompareOp'new-0)
    )

    ;;;
     ; Determines if this is a comparison used to determine whether dispatching on a receiver
     ; could select a certain method and if so, returns true if the answer is guaranteed
     ; to be false. Otherwise, returns false.
     ;;
    (§ defn- #_"boolean" PointerEqualsOp'isAlwaysFailingVirtualDispatchTest-3 [#_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
        (and (= condition CanonicalCondition'EQ) (instance? LoadMethodNode forX) (instance? ConstantNode forY) (= (#_"ResolvedJavaMethod" .getEncoding (:method forX)) (:value forY)) (instance? LoadHubNode (:hub forX))
            (let [
                #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp (:value (:hub forX))))
                #_"ResolvedJavaType" declaringClass (#_"ResolvedJavaMethod" .getDeclaringClass (:method forX))
            ]
                (and (some? type) (not (= type declaringClass)) (#_"ResolvedJavaType" .isAssignableFrom declaringClass, type)
                    (let [
                        #_"ResolvedJavaMethod" override (#_"ResolvedJavaType" .resolveMethod type, (:method forX), (:callerType forX))
                    ]
                        (and (some? override) (not (= override (:method forX))))
                    )
                )
            )
        )
    )

    (§ override #_"LogicNode" PointerEqualsOp''canonical-5 [#_"PointerEqualsOp" this, #_"Integer" smallestCompareWidth, #_"CanonicalCondition" condition, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (PointerEqualsNode'findSynonym-2 forX, forY)
            (if (PointerEqualsOp'isAlwaysFailingVirtualDispatchTest-3 condition, forX, forY)
                (LogicConstantNode'contradiction-0)
                (CompareOp''canonical-5 (§ super ), smallestCompareWidth, condition, forX, forY)
            )
        )
    )

    #_unused
    (§ override #_"CompareNode" PointerEqualsOp''duplicateModified-3 [#_"PointerEqualsOp" this, #_"ValueNode" newX, #_"ValueNode" newY]
        (PointerEqualsNode'new-2 newX, newY)
    )
)

;;;
 ; The ReinterpretNode class represents a reinterpreting conversion that changes the stamp
 ; of a primitive value to some other incompatible stamp. The new stamp must have the same width as
 ; the old stamp.
 ;;
(final-ns ReinterpretNode (§ extends UnaryNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<ReinterpretNode>" ReinterpretNode'TYPE (NodeClass'create-1 ReinterpretNode))

    (§ defn #_"ReinterpretNode" ReinterpretNode'new-2 [#_"JavaKind" to, #_"ValueNode" value]
        (ReinterpretNode'new-2 (StampFactory'forKind-1 to), value)
    )

    (§ defn #_"ReinterpretNode" ReinterpretNode'new-2 [#_"Stamp" to, #_"ValueNode" value]
        (UnaryNode'new-3 ReinterpretNode'TYPE, (ReinterpretNode'getReinterpretStamp-2 to, (:stamp value)), value)
    )

    (§ defn #_"ValueNode" ReinterpretNode'create-2 [#_"JavaKind" to, #_"ValueNode" value]
        (ReinterpretNode'create-2 (StampFactory'forKind-1 to), value)
    )

    (§ defn #_"ValueNode" ReinterpretNode'create-2 [#_"Stamp" to, #_"ValueNode" value]
        (ReinterpretNode'canonical-3 nil, to, value)
    )

    (§ defn- #_"SerializableConstant" ReinterpretNode'evalConst-2 [#_"Stamp" stamp, #_"SerializableConstant" constant]
        ;; We don't care about byte order here. Either would produce the correct result.
        (let [
            #_"ByteBuffer" buffer (#_"ByteBuffer" .order (ByteBuffer/wrap (byte-array (#_"SerializableConstant" .getSerializedSize constant))), (ByteOrder/nativeOrder))
        ]
            (#_"SerializableConstant" .serialize constant, buffer)
            (#_"ByteBuffer" .rewind buffer)
            (ArithmeticStamp''deserialize-2 stamp, buffer)
        )
    )

    #_unused
    (§ override! #_"ValueNode" ReinterpretNode''canonical-3 [#_"ReinterpretNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (ReinterpretNode'canonical-3 this, (:stamp this), value)
    )

    (§ defn #_"ValueNode" ReinterpretNode'canonical-3 [#_"ReinterpretNode" node, #_"Stamp" stamp, #_"ValueNode" value]
        (cond
            (instance? ConstantNode value)
                (ConstantNode'forConstant-2 stamp, (ReinterpretNode'evalConst-2 stamp, (:value value)))
            (Stamp''isCompatible-2 stamp, (:stamp value))
                value
            (instance? ReinterpretNode value)
                (ReinterpretNode'new-2 stamp, (UnaryNode''getValue-1 value))
            :else
                (or node (ReinterpretNode'new-2 stamp, value))
        )
    )

    (§ defn- #_"Stamp" ReinterpretNode'getReinterpretStamp-2 [#_"Stamp" toStamp, #_"Stamp" fromStamp]
        toStamp
    )

    #_unused
    (§ override! #_"boolean" ReinterpretNode''inferStamp-1 [#_"ReinterpretNode" this]
        (ValueNode''updateStamp-2 this, (ReinterpretNode'getReinterpretStamp-2 (:stamp this), (:stamp (UnaryNode''getValue-1 this))))
    )

    #_unused
    (§ override! #_"void" ReinterpretNode''generate-2 [#_"ReinterpretNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitReinterpret-3 (:gen builder), (Stamp''getLIRKind-1 (:stamp this)), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this))))
        nil
    )

    #_unused
    (§ defn #_"ValueNode" ReinterpretNode'reinterpret-2 [#_"JavaKind" toKind, #_"ValueNode" value]
        (Graph''add-2 (:graph value), (ReinterpretNode'new-2 toKind, value))
    )
)

(final-ns RemNode (§ extends BinaryArithmeticNode #_"<Rem>") (§ implements Lowerable)
    (§ def #_"NodeClass<RemNode>" RemNode'TYPE (NodeClass'create-1 RemNode))

    (§ defn #_"RemNode" RemNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (RemNode'new-3 RemNode'TYPE, x, y)
    )

    (§ defn #_"RemNode" RemNode'new-3 [#_"NodeClass<? extends RemNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (BinaryArithmeticNode'new-4 c, :rem, x, y)
    )

    #_unused
    (§ defn #_"ValueNode" RemNode'create-2 [#_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"BinaryOp<Rem>" op (:rem (ArithmeticOpTable'forStamp-1 (:stamp forX)))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, forX, forY, (BinaryOp''foldStamp-3 op, (:stamp forX), (:stamp forY)))
                (RemNode'new-2 forX, forY)
            )
        )
    )

    #_unused
    (§ override! #_"void" RemNode''lower-2 [#_"RemNode" this, #_"LoweringTool" lowerer]
        nil ;; No lowering, we generate LIR directly for this node.
    )

    #_unused
    (§ override! #_"void" RemNode''generate-2 [#_"RemNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitRem-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )
)

(final-ns RightShiftNode (§ extends ShiftNode #_"<Shr>")
    (§ def #_"NodeClass<RightShiftNode>" RightShiftNode'TYPE (NodeClass'create-1 RightShiftNode))

    (§ defn #_"RightShiftNode" RightShiftNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (ShiftNode'new-4 RightShiftNode'TYPE, :shr, x, y)
    )

    (§ defn #_"ValueNode" RightShiftNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"ShiftOp<Shr>" op (:shr (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (ShiftOp''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (ShiftNode'canonical-4 op, stamp, x, y) (RightShiftNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    #_unused
    (§ override! #_"ValueNode" RightShiftNode''canonical-4 [#_"RightShiftNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (ShiftNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (RightShiftNode'canonical-5 this, (ShiftNode''getArithmeticOp-1 this), (:stamp this), forX, forY)
            )
        )
    )

    (§ defn- #_"ValueNode" RightShiftNode'canonical-5 [#_"RightShiftNode" self, #_"ShiftOp<Shr>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (if (and (instance? IntegerStamp (:stamp forX)) (IntegerStamp''isPositive-1 (:stamp forX)))
            (UnsignedRightShiftNode'new-2 forX, forY)
            (when (instance? ConstantNode forY) => (or self (RightShiftNode'new-2 forX, forY))
                (let [
                    #_"int" amount (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 forY))
                    #_"int" o'amount amount
                    #_"int" mask (ShiftOp''getShiftAmountMask-2 op, stamp)
                    amount (& amount mask)
                ]
                    (if (zero? amount)
                        forX
                        (if (and (instance? ShiftNode forX) (instance? ConstantNode (:y forX)) (instance? RightShiftNode forX))
                            (let [
                                #_"int" total (+ amount (& (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y forX))) mask))
                            ]
                                (cond
                                    (= total (& total mask))                                (RightShiftNode'new-2 (:x forX), (ConstantNode'forInt-1 total))
                                    (IntegerStamp''isPositive-1 (:stamp (:x forX)))         (ConstantNode'forIntegerKind-2 (Stamp''getStackKind-1 stamp), 0)
                                    (IntegerStamp''isStrictlyNegative-1 (:stamp (:x forX))) (ConstantNode'forIntegerKind-2 (Stamp''getStackKind-1 stamp), -1)
                                    ;; if we cannot replace both shifts with a constant, replace them by a full shift for this kind
                                    :else                                                   (RightShiftNode'new-2 (:x forX), (ConstantNode'forInt-1 mask))
                                )
                            )
                            (when-not (= amount o'amount) => (or self (RightShiftNode'new-2 forX, forY))
                                (RightShiftNode'new-2 forX, (ConstantNode'forInt-1 amount))
                            )
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" RightShiftNode''generate-2 [#_"RightShiftNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitShr-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )

    #_unused
    (§ override! #_"boolean" RightShiftNode''isNarrowable-2 [#_"RightShiftNode" this, #_"int" resultBits]
        (and (ShiftNode''isNarrowable-2 (§ super ), resultBits)
            ;; For signed right shifts, the narrow can be done before the shift if the cut off bits
            ;; are all equal to the sign bit of the input. That's equivalent to the condition that
            ;; the input is in the signed range of the narrow type.
            (<= (CodeUtil/minValue resultBits) (:lowerBound (:stamp (:x this)))) (<= (:upperBound (:stamp (:x this))) (CodeUtil/maxValue resultBits))
        )
    )
)

;;;
 ; The ShiftOp class represents shift operations.
 ;;
(class-ns ShiftNode #_"<OP>" (§ extends BinaryNode) (§ implements ArithmeticOperation, LIRLowerable, NarrowableArithmeticNode)
    (§ def #_"NodeClass<ShiftNode>" ShiftNode'TYPE (NodeClass'create-1 ShiftNode))

    (§ final #_"SerializableShiftFunction<OP>" :getOp nil)

    ;;;
     ; Creates a new shift operation.
     ;
     ; @param x the first input value
     ; @param s the second input value
     ;;
    (§ defn #_"ShiftNode" ShiftNode'new-4 [#_"NodeClass<? extends ShiftNode<OP>>" c, #_"SerializableShiftFunction<OP>" getOp, #_"ValueNode" x, #_"ValueNode" s]
        (let [
            #_"ShiftNode" this (BinaryNode'new-4 c, (ShiftOp''foldStamp-3 (Function''apply-2 getOp, (ArithmeticOpTable'forStamp-1 (:stamp x))), (:stamp x), (:stamp s)), x, s)
            this (assoc this :getOp getOp)
        ]
            this
        )
    )

    (§ method! #_"ShiftOp<OP>" ShiftNode''getOp-2 [#_"ShiftNode<OP>" this, #_"ValueNode" value]
        (Function''apply-2 (:getOp this), (ArithmeticOpTable'forStamp-1 (:stamp value)))
    )

    (§ override! #_"ShiftOp<OP>" ShiftNode''getArithmeticOp-1 [#_"ShiftNode<OP>" this]
        (ShiftNode''getOp-2 this, (:x this))
    )

    #_unused
    (§ override #_"Stamp" ShiftNode''foldStamp-3 [#_"ShiftNode<OP>" this, #_"Stamp" stampX, #_"Stamp" stampY]
        (ShiftOp''foldStamp-3 (ShiftNode''getArithmeticOp-1 this), stampX, stampY)
    )

    (§ override #_"ValueNode" ShiftNode''canonical-4 [#_"ShiftNode<OP>" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (or (ShiftNode'canonical-4 (ShiftNode''getOp-2 this, forX), (:stamp this), forX, forY)
            this
        )
    )

    (§ defn #_"<OP> ValueNode" ShiftNode'canonical-4 [#_"ShiftOp<OP>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (and (instance? ConstantNode forX) (instance? ConstantNode forY))
            (ConstantNode'forPrimitive-2 stamp, (ShiftOp''foldConstant-3 op, (:value forX), (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 forY))))
        )
    )

    (§ method! #_"int" ShiftNode''getShiftAmountMask-1 [#_"ShiftNode<OP>" this]
        (ShiftOp''getShiftAmountMask-2 (ShiftNode''getArithmeticOp-1 this), (:stamp this))
    )

    (§ override #_"boolean" ShiftNode''isNarrowable-2 [#_"ShiftNode<OP>" this, #_"int" resultBits]
        (let [
            #_"int" narrowMask (dec resultBits)
            #_"int" wideMask (ShiftNode''getShiftAmountMask-1 this)
            ;; Shifts are special because narrowing them also changes the implicit mask of the shift amount.
            ;; We can narrow only if (y & wideMask) == (y & narrowMask) for all possible values of y.
            #_"IntegerStamp" yStamp (:stamp (:y this))
        ]
            (zero? (& (:upMask yStamp) wideMask (bit-not narrowMask)))
        )
    )
)

;;;
 ; @anno ShiftNode.SerializableShiftFunction
 ;;
(§ interface SerializableShiftFunction #_"<T>" (§ extends Function #_"<ArithmeticOpTable, ShiftOp<T>>")
)

(final-ns SignedDivNode (§ extends IntegerDivRemNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<SignedDivNode>" SignedDivNode'TYPE (NodeClass'create-1 SignedDivNode))

    (§ defn #_"SignedDivNode" SignedDivNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (SignedDivNode'new-3 SignedDivNode'TYPE, x, y)
    )

    (§ defn #_"SignedDivNode" SignedDivNode'new-3 [#_"NodeClass<? extends SignedDivNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (IntegerDivRemNode'new-6 c, (BinaryOp''foldStamp-3 (:div IntegerStamp'OPS), (:stamp x), (:stamp y)), DivRemOp'DIV, Signedness'SIGNED, x, y)
    )

    (§ defn #_"ValueNode" SignedDivNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (SignedDivNode'canonical-3 (§ cast #_"SignedDivNode" nil), x, y)
    )

    #_unused
    (§ override! #_"boolean" SignedDivNode''inferStamp-1 [#_"SignedDivNode" this]
        (ValueNode''updateStamp-2 this, (BinaryOp''foldStamp-3 (:div IntegerStamp'OPS), (:stamp (:x this)), (:stamp (:y this))))
    )

    #_unused
    (§ override! #_"ValueNode" SignedDivNode''canonical-4 [#_"SignedDivNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (SignedDivNode'canonical-3 this, forX, forY)
    )

    (§ defn #_"ValueNode" SignedDivNode'canonical-3 [#_"SignedDivNode" self, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"Stamp" stamp (if (some? self) (:stamp self) (BinaryOp''foldStamp-3 (:div IntegerStamp'OPS), (:stamp forX), (:stamp forY)))
        ]
            (cond
                (and (instance? ConstantNode forX) (instance? ConstantNode forY))
                    (let [
                        #_"long" y (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                    ]
                        (if (zero? y)
                            (§ return (or self (SignedDivNode'new-2 forX, forY))) ;; this will trap, can not canonicalize
                            (§ return (ConstantNode'forIntegerStamp-2 stamp, (quot (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)) y)))
                        )
                    )
                (instance? ConstantNode forY)
                    (§ return (SignedDivNode'canonical-2 forX, (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))))
            )

            ;; convert the expression ((a - a % b) / b) into (a / b)
            (when (and (instance? SubNode forX) (instance? SignedRemNode (:y forX)) (Stamp''isCompatible-2 (:stamp forX), stamp) (Stamp''isCompatible-2 (:stamp (:y forX)), stamp) (= (:x forX) (:x (:y forX))) (= forY (:y (:y forX))))
                (§ return (assoc (SignedDivNode'new-2 (:x forX), forY) :stateBefore (when (some? self) (:stateBefore self))))
            )

            (when (and (some? self) (instance? SignedDivNode (:next self)) (= (#_"Object" .getClass (:next self)) (#_"Object" .getClass self)) (NodeClass''equalInputs-3 (:nodeClass self), self, (:next self)) (Node''valueEquals-2 self, (:next self)))
                (§ return (:next self))
            )

            (or self (SignedDivNode'new-2 forX, forY))
        )
    )

    (§ defn #_"ValueNode" SignedDivNode'canonical-2 [#_"ValueNode" forX, #_"long" c]
        (case c 1 forX -1 (NegateNode'create-1 forX)
            (let [
                #_"long" a (abs c)
            ]
                (when (and (CodeUtil/isPowerOf2 a) (instance? IntegerStamp (:stamp forX)))
                    (let [
                        #_"ValueNode" dividend forX
                        #_"int" log2 (CodeUtil/log2 a)
                        ;; no rounding if dividend is positive or if its low bits are always 0
                        dividend
                            (when (or (IntegerStamp''canBeNegative-1 (:stamp forX)) (not (zero? (& (:upMask (:stamp forX)) (dec a))))) => dividend
                                (let [
                                    #_"int" bits (PrimitiveStamp'getBits-1 (:stamp forX))
                                    #_"RightShiftNode" sign (RightShiftNode'new-2 forX, (ConstantNode'forInt-1 (dec bits)))
                                ]
                                    (BinaryArithmeticNode'add-2 dividend, (UnsignedRightShiftNode'new-2 sign, (ConstantNode'forInt-1 (- bits log2))))
                                )
                            )
                        #_"RightShiftNode" shift (RightShiftNode'new-2 dividend, (ConstantNode'forInt-1 log2))
                    ]
                        (if (neg? c) (NegateNode'create-1 shift) shift)
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" SignedDivNode''generate-2 [#_"SignedDivNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitDiv-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )
)

(final-ns SignedRemNode (§ extends IntegerDivRemNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<SignedRemNode>" SignedRemNode'TYPE (NodeClass'create-1 SignedRemNode))

    (§ defn #_"SignedRemNode" SignedRemNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (SignedRemNode'new-3 SignedRemNode'TYPE, x, y)
    )

    (§ defn #_"SignedRemNode" SignedRemNode'new-3 [#_"NodeClass<? extends SignedRemNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (IntegerDivRemNode'new-6 c, (BinaryOp''foldStamp-3 (:rem IntegerStamp'OPS), (:stamp x), (:stamp y)), DivRemOp'REM, Signedness'SIGNED, x, y)
    )

    (§ defn #_"ValueNode" SignedRemNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"Stamp" stamp (BinaryOp''foldStamp-3 (:rem IntegerStamp'OPS), (:stamp x), (:stamp y))
        ]
            (SignedRemNode'canonical-4 nil, x, y, stamp)
        )
    )

    #_unused
    (§ override! #_"boolean" SignedRemNode''inferStamp-1 [#_"SignedRemNode" this]
        (ValueNode''updateStamp-2 this, (BinaryOp''foldStamp-3 (:rem IntegerStamp'OPS), (:stamp (:x this)), (:stamp (:y this))))
    )

    #_unused
    (§ override! #_"ValueNode" SignedRemNode''canonical-4 [#_"SignedRemNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (SignedRemNode'canonical-4 this, forX, forY, (:stamp this))
    )

    (§ defn- #_"ValueNode" SignedRemNode'canonical-4 [#_"SignedRemNode" self, #_"ValueNode" forX, #_"ValueNode" forY, #_"Stamp" stamp]
        (cond
            (and (instance? ConstantNode forX) (instance? ConstantNode forY))
                (let [
                    #_"long" y (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                ]
                    (if (zero? y)
                        (or self (SignedRemNode'new-2 forX, forY)) ;; this will trap, can not canonicalize
                        (ConstantNode'forIntegerStamp-2 stamp, (% (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)) y))
                    )
                )
            (and (instance? ConstantNode forY) (instance? IntegerStamp (:stamp forX)) (instance? IntegerStamp (:stamp forY)))
                (let [
                    #_"long" constY (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                    #_"IntegerStamp" xStamp (:stamp forX)
                    #_"IntegerStamp" yStamp (:stamp forY)
                ]
                    (cond
                        (and (neg? constY) (not= constY (CodeUtil/minValue (:bits yStamp))))
                            (SignedRemNode'canonical-4 nil, forX, (ConstantNode'forIntegerStamp-2 yStamp, (- constY)), (BinaryOp''foldStamp-3 (:rem IntegerStamp'OPS), (:stamp forX), (:stamp forY)))
                        (= constY 1)
                            (ConstantNode'forIntegerStamp-2 stamp, 0)
                        (CodeUtil/isPowerOf2 constY)
                            (cond
                                (IntegerStamp''isPositive-1 xStamp) ;; x & (y - 1)
                                    (AndNode'new-2 forX, (ConstantNode'forIntegerStamp-2 stamp, (dec constY)))
                                (IntegerStamp''isNegative-1 xStamp) ;; -((-x) & (y - 1))
                                    (NegateNode'new-1 (AndNode'new-2 (NegateNode'new-1 forX), (ConstantNode'forIntegerStamp-2 stamp, (dec constY))))
                                :else                               ;; x - ((x / y) << log2(y))
                                    (SubNode'create-2 forX, (LeftShiftNode'create-2 (SignedDivNode'canonical-2 forX, constY), (ConstantNode'forInt-1 (CodeUtil/log2 constY))))
                            )
                        :else
                            (or self (SignedRemNode'new-2 forX, forY))
                    )
                )
            :else
                (or self (SignedRemNode'new-2 forX, forY))
        )
    )

    #_unused
    (§ override! #_"void" SignedRemNode''generate-2 [#_"SignedRemNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitRem-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )
)

;;;
 ; The SignExtendNode converts an integer to a wider integer using sign extension.
 ;;
(final-ns SignExtendNode (§ extends IntegerConvertNode #_"<SignExtend, Narrow>")
    (§ def #_"NodeClass<SignExtendNode>" SignExtendNode'TYPE (NodeClass'create-1 SignExtendNode))

    (§ defn #_"SignExtendNode" SignExtendNode'new-2 [#_"ValueNode" input, #_"int" resultBits]
        (SignExtendNode'new-3 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits)
    )

    (§ defn #_"SignExtendNode" SignExtendNode'new-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (IntegerConvertNode'new-6 SignExtendNode'TYPE, :signExtend, :narrow, inputBits, resultBits, input)
    )

    (§ defn #_"ValueNode" SignExtendNode'create-2 [#_"ValueNode" input, #_"int" resultBits]
        (SignExtendNode'create-3 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits)
    )

    (§ defn #_"ValueNode" SignExtendNode'create-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (let [
            #_"IntegerConvertOp<SignExtend>" signExtend (:signExtend (ArithmeticOpTable'forStamp-1 (:stamp input)))
        ]
            (or (IntegerConvertNode'findSynonym-5 signExtend, input, inputBits, resultBits, (IntegerConvertOp''foldStamp-4 signExtend, inputBits, resultBits, (:stamp input)))
                (SignExtendNode'canonical-4 nil, input, inputBits, resultBits)
            )
        )
    )

    #_unused
    (§ override! #_"boolean" SignExtendNode''isLossless-1 [#_"SignExtendNode" this]
        true
    )

    #_unused
    (§ override! #_"ValueNode" SignExtendNode''canonical-3 [#_"SignExtendNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (let [
            #_"ValueNode" ret (IntegerConvertNode''canonical-3 (§ super ), tool, value)
        ]
            (when (= ret this) => ret
                (SignExtendNode'canonical-4 this, value, (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this))
            )
        )
    )

    (§ defn- #_"ValueNode" SignExtendNode'canonical-4 [#_"SignExtendNode" self, #_"ValueNode" forValue, #_"int" inputBits, #_"int" resultBits]
        (condp instance? forValue
            SignExtendNode
                ;; sxxx -(sign-extend)-> ssss sxxx -(sign-extend)-> ssssssss sssssxxx
                ;; ==> sxxx -(sign-extend)-> ssssssss sssssxxx
                (§ return (SignExtendNode'create-3 (UnaryNode''getValue-1 forValue), (IntegerConvertNode''getInputBits-1 forValue), resultBits))
            ZeroExtendNode
                (when (< (IntegerConvertNode''getInputBits-1 forValue) (IntegerConvertNode''getResultBits-1 forValue))
                    ;; sxxx -(zero-extend)-> 0000 sxxx -(sign-extend)-> 00000000 0000sxxx
                    ;; ==> sxxx -(zero-extend)-> 00000000 0000sxxx
                    (§ return (ZeroExtendNode'create-4 (UnaryNode''getValue-1 forValue), (IntegerConvertNode''getInputBits-1 forValue), resultBits, (:inputAlwaysPositive forValue)))
                )
            nil
        )

        (when (and (instance? IntegerStamp (:stamp forValue)) (zero? (& (:upMask (:stamp forValue)) (<< 1 (dec inputBits))))) => (or self (SignExtendNode'new-3 forValue, inputBits, resultBits))
            ;; 0xxx -(sign-extend)-> 0000 0xxx
            ;; ==> 0xxx -(zero-extend)-> 0000 0xxx
            (ZeroExtendNode'create-4 forValue, inputBits, resultBits, true)
        )
    )

    #_unused
    (§ override! #_"void" SignExtendNode''generate-2 [#_"SignExtendNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitSignExtend-4 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this)), (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this)))
        nil
    )

    #_unused
    (§ override! #_"boolean" SignExtendNode''mayNullCheckSkipConversion-1 [#_"SignExtendNode" this]
        true
    )
)

(class-ns SubNode (§ extends BinaryArithmeticNode #_"<Sub>") (§ implements NarrowableArithmeticNode)
    (§ def #_"NodeClass<SubNode>" SubNode'TYPE (NodeClass'create-1 SubNode))

    (§ defn #_"SubNode" SubNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (SubNode'new-3 SubNode'TYPE, x, y)
    )

    (§ defn #_"SubNode" SubNode'new-3 [#_"NodeClass<? extends SubNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (BinaryArithmeticNode'new-4 c, :sub, x, y)
    )

    (§ defn #_"ValueNode" SubNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Sub>" op (:sub (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp)
                (SubNode'canonical-5 nil, op, stamp, x, y)
            )
        )
    )

    (§ defn- #_"ValueNode" SubNode'canonical-5 [#_"SubNode" self, #_"BinaryOp<Sub>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (= (GraphUtil'unproxify-1 forX) (GraphUtil'unproxify-1 forY))
            (let [
                #_"Constant" zero (BinaryOp''getZero-2 op, (:stamp forX))
            ]
                (when (some? zero)
                    (§ return (ConstantNode'forPrimitive-2 stamp, zero))
                )
            )
        )
        (let [
            #_"boolean" associative? (BinaryOp''isAssociative-1 op)
        ]
            (when associative?
                (condp instance? forX
                    AddNode
                        (do
                            (when (= (:y forX) forY) ;; (a + b) - b
                                (§ return (:x forX))
                            )
                            (when (= (:x forX) forY) ;; (a + b) - a
                                (§ return (:y forX))
                            )
                        )
                    SubNode
                        (do
                            (when (= (:x forX) forY) ;; (a - b) - a
                                (§ return (NegateNode'create-1 (:y forX)))
                            )
                        )
                    nil
                )
                (condp instance? forY
                    AddNode
                        (do
                            (when (= (:x forY) forX) ;; a - (a + b)
                                (§ return (NegateNode'create-1 (:y forY)))
                            )
                            (when (= (:y forY) forX) ;; b - (a + b)
                                (§ return (NegateNode'create-1 (:x forY)))
                            )
                        )
                    SubNode
                        (do
                            (when (= (:x forY) forX) ;; a - (a - b)
                                (§ return (:y forY))
                            )
                        )
                    nil
                )
            )
            (cond
                (instance? ConstantNode forY)
                    (let [
                        #_"Constant" c (:value forY)
                    ]
                        (when (BinaryOp''isNeutral-2 op, c)
                            (§ return forX)
                        )
                        (when (and associative? (some? self))
                            (let [
                                #_"ValueNode" reassociated (BinaryArithmeticNode'reassociate-4 self, (ValueNode'isConstantPredicate-0), forX, forY)
                            ]
                                (when-not (= reassociated self)
                                    (§ return reassociated)
                                )
                            )
                        )
                        (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                            (let [
                                #_"long" i (#_"PrimitiveConstant" .asLong c)
                            ]
                                (when (or (neg? i) (IntegerStamp''contains-2 (StampFactory'forKind-1 (ValueNode''getStackKind-1 forY)), (- i)))
                                    ;; Adding a negative is more friendly to the backend since adds are
                                    ;; commutative, so prefer add when it fits.
                                    (§ return (BinaryArithmeticNode'add-2 forX, (ConstantNode'forIntegerStamp-2 stamp, (- i))))
                                )
                            )
                        )
                    )
                (instance? ConstantNode forX)
                    (let [
                        #_"Constant" c (:value forX)
                    ]
                        (when (BinaryOp''isNeutral-2 (:add (ArithmeticOpTable'forStamp-1 stamp)), c)
                            ;; Note that for floating point numbers, + and - have different neutral elements.
                            ;; We have to test for the neutral element of +, because we are doing this
                            ;; transformation: 0 - x == (-x) + 0 == -x.
                            (§ return (NegateNode'create-1 forY))
                        )
                        (when (and associative? (some? self))
                            (§ return (BinaryArithmeticNode'reassociate-4 self, (ValueNode'isConstantPredicate-0), forX, forY))
                        )
                    )
            )
            (if (instance? NegateNode forY)
                (BinaryArithmeticNode'add-2 forX, (UnaryNode''getValue-1 forY))
                (or self (SubNode'new-2 forX, forY))
            )
        )
    )

    #_unused
    (§ override #_"ValueNode" SubNode''canonical-4 [#_"SubNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (BinaryArithmeticNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (SubNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
            )
        )
    )

    #_unused
    (§ override #_"void" SubNode''generate-2 [#_"SubNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitSub-4 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this)), false))
        nil
    )
)

(class-ns UnaryArithmeticNode #_"<OP>" (§ extends UnaryNode) (§ implements ArithmeticOperation, LIRLowerable)
    (§ def #_"NodeClass<UnaryArithmeticNode>" UnaryArithmeticNode'TYPE (NodeClass'create-1 UnaryArithmeticNode))

    (§ final #_"SerializableUnaryFunction<OP>" :getOp nil)

    (§ defn #_"UnaryArithmeticNode" UnaryArithmeticNode'new-3 [#_"NodeClass<? extends UnaryArithmeticNode<OP>>" c, #_"SerializableUnaryFunction<OP>" getOp, #_"ValueNode" value]
        (let [
            #_"UnaryArithmeticNode" this (UnaryNode'new-3 c, (UnaryOp''foldStamp-2 (Function''apply-2 getOp, (ArithmeticOpTable'forStamp-1 (:stamp value))), (:stamp value)), value)
            this (assoc this :getOp getOp)
        ]
            this
        )
    )

    (§ method! #_"UnaryOp<OP>" UnaryArithmeticNode''getOp-2 [#_"UnaryArithmeticNode<OP>" this, #_"ValueNode" value]
        (Function''apply-2 (:getOp this), (ArithmeticOpTable'forStamp-1 (:stamp value)))
    )

    (§ override! #_"UnaryOp<OP>" UnaryArithmeticNode''getArithmeticOp-1 [#_"UnaryArithmeticNode<OP>" this]
        (UnaryArithmeticNode''getOp-2 this, (UnaryNode''getValue-1 this))
    )

    #_unused
    (§ override #_"Stamp" UnaryArithmeticNode''foldStamp-2 [#_"UnaryArithmeticNode<OP>" this, #_"Stamp" stamp]
        (UnaryOp''foldStamp-2 (UnaryArithmeticNode''getOp-2 this, (UnaryNode''getValue-1 this)), stamp)
    )

    (§ override #_"ValueNode" UnaryArithmeticNode''canonical-3 [#_"UnaryArithmeticNode<OP>" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (or (UnaryArithmeticNode'findSynonym-2 value, (UnaryArithmeticNode''getOp-2 this, value))
            this
        )
    )

    (§ defn #_"<OP> ValueNode" UnaryArithmeticNode'findSynonym-2 [#_"ValueNode" value, #_"UnaryOp<OP>" op]
        (when (instance? ConstantNode value)
            (ConstantNode'forPrimitive-2 (UnaryOp''foldStamp-2 op, (:stamp value)), (UnaryOp''foldConstant-2 op, (:value value)))
        )
    )
)

;;;
 ; @anno UnaryArithmeticNode.SerializableUnaryFunction
 ;;
(§ interface SerializableUnaryFunction #_"<T>" (§ extends Function #_"<ArithmeticOpTable, UnaryOp<T>>")
)

;;;
 ; The UnaryNode class is the base of arithmetic and bit logic operations with exactly one input.
 ;;
(class-ns UnaryNode (§ extends FloatingNode) (§ implements Unary #_"<ValueNode>")
    (§ def #_"NodeClass<UnaryNode>" UnaryNode'TYPE (NodeClass'create-1 UnaryNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)

    (§ override #_"ValueNode" UnaryNode''getValue-1 [#_"UnaryNode" this]
        (:value this)
    )

    #_unused
    (§ method #_"void" UnaryNode''setValue-2 [#_"UnaryNode" this, #_"ValueNode" value]
        (Node''updateUsages-3 this, (:value this), value)
        (§ ass! this (assoc this :value value))
        nil
    )

    ;;;
     ; Creates a new UnaryNode instance.
     ;
     ; @param stamp the result type of this instruction
     ; @param value the input instruction
     ;;
    (§ defn #_"UnaryNode" UnaryNode'new-3 [#_"NodeClass<? extends UnaryNode>" c, #_"Stamp" stamp, #_"ValueNode" value]
        (let [
            #_"UnaryNode" this (FloatingNode'new-2 c, stamp)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" UnaryNode''inferStamp-1 [#_"UnaryNode" this]
        (ValueNode''updateStamp-2 this, (UnaryNode''foldStamp-2 this, (:stamp (:value this))))
    )

    ;;;
     ; Compute an improved for this node using the passed in stamp. The stamp must be compatible
     ; with the current value of #value. This code is used to provide the default
     ; implementation of #inferStamp() and may be used by external optimizations.
     ;;
    (§ method #_"Stamp" UnaryNode''foldStamp-2 [#_"UnaryNode" this, #_"Stamp" stamp]
        (:stamp this)
    )
)

;;;
 ; Produces the platform dependent first or second half of a long or double value as an int.
 ;;
(final-ns UnpackEndianHalfNode (§ extends UnaryNode) (§ implements Lowerable)
    (§ def #_"NodeClass<UnpackEndianHalfNode>" UnpackEndianHalfNode'TYPE (NodeClass'create-1 UnpackEndianHalfNode))

    (§ final #_"boolean" :firstHalf false)

    (§ defn #_"UnpackEndianHalfNode" UnpackEndianHalfNode'new-2 [#_"ValueNode" value, #_"boolean" firstHalf]
        (let [
            #_"UnpackEndianHalfNode" this (UnaryNode'new-3 UnpackEndianHalfNode'TYPE, (StampFactory'forKind-1 JavaKind/Int), value)
            this (assoc this :firstHalf firstHalf)
        ]
            this
        )
    )

    (§ defn #_"ValueNode" UnpackEndianHalfNode'create-2 [#_"ValueNode" value, #_"boolean" firstHalf]
        (if (and (instance? ConstantNode value) (#_"Constant" .isDefaultForKind (:value value)))
            (ConstantNode'defaultForKind-1 JavaKind/Int)
            (UnpackEndianHalfNode'new-2 value, firstHalf)
        )
    )

    #_unused
    (§ override! #_"Node" UnpackEndianHalfNode''canonical-3 [#_"UnpackEndianHalfNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (if (and (instance? ConstantNode value) (#_"Constant" .isDefaultForKind (:value value)))
            (ConstantNode'defaultForKind-1 (Stamp''getStackKind-1 (:stamp this)))
            this
        )
    )

    (§ override! #_"void" UnpackEndianHalfNode''lower-2 [#_"UnpackEndianHalfNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerSecondHalf-1 this)
        nil
    )

    (§ method! #_"void" UnpackEndianHalfNode''lower-2 [#_"UnpackEndianHalfNode" this, #_"ByteOrder" byteOrder]
        (let [
            #_"ValueNode" result
                (when (= (= byteOrder ByteOrder/BIG_ENDIAN) (:firstHalf this)) => (:value this)
                    (Graph''add-2 (:graph this), (UnsignedRightShiftNode'new-2 (:value this), (ConstantNode'forInt-2 32, (:graph this))))
                )
        ]
            (Node''replaceAtUsagesAndDelete-2 this, (IntegerConvertNode'convert-3 result, (StampFactory'forKind-1 JavaKind/Int), (:graph this)))
        )
        nil
    )
)

(final-ns UnsignedDivNode (§ extends IntegerDivRemNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<UnsignedDivNode>" UnsignedDivNode'TYPE (NodeClass'create-1 UnsignedDivNode))

    (§ defn #_"UnsignedDivNode" UnsignedDivNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (UnsignedDivNode'new-3 UnsignedDivNode'TYPE, x, y)
    )

    (§ defn #_"UnsignedDivNode" UnsignedDivNode'new-3 [#_"NodeClass<? extends UnsignedDivNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (IntegerDivRemNode'new-6 c, (Stamp''unrestricted-1 (:stamp x)), DivRemOp'DIV, Signedness'UNSIGNED, x, y)
    )

    (§ defn #_"ValueNode" UnsignedDivNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (UnsignedDivNode'canonical-4 nil, x, y, (Stamp''unrestricted-1 (:stamp x)))
    )

    #_unused
    (§ override! #_"ValueNode" UnsignedDivNode''canonical-4 [#_"UnsignedDivNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (UnsignedDivNode'canonical-4 this, forX, forY, (:stamp this))
    )

    (§ defn- #_"ValueNode" UnsignedDivNode'canonical-4 [#_"UnsignedDivNode" self, #_"ValueNode" forX, #_"ValueNode" forY, #_"Stamp" stamp]
        (let [
            #_"int" bits (:bits stamp)
        ]
            (cond
                (and (instance? ConstantNode forX) (instance? ConstantNode forY))
                    (let [
                        #_"long" yConst (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)), bits)
                    ]
                        (if (zero? yConst)
                            (§ return (or self (UnsignedDivNode'new-2 forX, forY))) ;; this will trap, cannot canonicalize
                            (§ return (ConstantNode'forIntegerStamp-2 stamp, (Long/divideUnsigned (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)), bits), yConst)))
                        )
                    )
                (instance? ConstantNode forY)
                    (let [
                        #_"long" c (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)), bits)
                    ]
                        (when (= c 1)
                            (§ return forX)
                        )
                        (when (CodeUtil/isPowerOf2 c)
                            (§ return (UnsignedRightShiftNode'new-2 forX, (ConstantNode'forInt-1 (CodeUtil/log2 c))))
                        )
                    )
            )
            (or self (UnsignedDivNode'new-2 forX, forY))
        )
    )

    #_unused
    (§ override! #_"void" UnsignedDivNode''generate-2 [#_"UnsignedDivNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitUDiv-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )
)

(final-ns UnsignedRemNode (§ extends IntegerDivRemNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<UnsignedRemNode>" UnsignedRemNode'TYPE (NodeClass'create-1 UnsignedRemNode))

    (§ defn #_"UnsignedRemNode" UnsignedRemNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (UnsignedRemNode'new-3 UnsignedRemNode'TYPE, x, y)
    )

    (§ defn #_"UnsignedRemNode" UnsignedRemNode'new-3 [#_"NodeClass<? extends UnsignedRemNode>" c, #_"ValueNode" x, #_"ValueNode" y]
        (IntegerDivRemNode'new-6 c, (Stamp''unrestricted-1 (:stamp x)), DivRemOp'REM, Signedness'UNSIGNED, x, y)
    )

    #_unused
    (§ defn #_"ValueNode" UnsignedRemNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (UnsignedRemNode'canonical-4 nil, x, y, (Stamp''unrestricted-1 (:stamp x)))
    )

    #_unused
    (§ override! #_"ValueNode" UnsignedRemNode''canonical-4 [#_"UnsignedRemNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (UnsignedRemNode'canonical-4 this, forX, forY, (:stamp this))
    )

    (§ defn #_"ValueNode" UnsignedRemNode'canonical-4 [#_"UnsignedRemNode" self, #_"ValueNode" forX, #_"ValueNode" forY, #_"Stamp" stamp]
        (let [
            #_"int" bits (:bits stamp)
        ]
            (cond
                (and (instance? ConstantNode forX) (instance? ConstantNode forY))
                    (let [
                        #_"long" yConst (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)), bits)
                    ]
                        (if (zero? yConst)
                            (§ return (or self (UnsignedRemNode'new-2 forX, forY))) ;; this will trap, cannot canonicalize
                            (§ return (ConstantNode'forIntegerStamp-2 stamp, (Long/remainderUnsigned (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forX)), bits), yConst)))
                        )
                    )
                (instance? ConstantNode forY)
                    (let [
                        #_"long" c (CodeUtil/zeroExtend (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)), bits)
                    ]
                        (cond
                            (= c 1)
                                (§ return (ConstantNode'forIntegerStamp-2 stamp, 0))
                            (CodeUtil/isPowerOf2 c)
                                (§ return (AndNode'new-2 forX, (ConstantNode'forIntegerStamp-2 stamp, (dec c))))
                        )
                    )
            )
            (or self (UnsignedRemNode'new-2 forX, forY))
        )
    )

    #_unused
    (§ override! #_"void" UnsignedRemNode''generate-2 [#_"UnsignedRemNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitURem-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )
)

(final-ns UnsignedRightShiftNode (§ extends ShiftNode #_"<UShr>")
    (§ def #_"NodeClass<UnsignedRightShiftNode>" UnsignedRightShiftNode'TYPE (NodeClass'create-1 UnsignedRightShiftNode))

    (§ defn #_"UnsignedRightShiftNode" UnsignedRightShiftNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (ShiftNode'new-4 UnsignedRightShiftNode'TYPE, :ushr, x, y)
    )

    (§ defn #_"ValueNode" UnsignedRightShiftNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"ShiftOp<UShr>" op (:ushr (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (ShiftOp''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (ShiftNode'canonical-4 op, stamp, x, y) (UnsignedRightShiftNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    #_unused
    (§ override! #_"ValueNode" UnsignedRightShiftNode''canonical-4 [#_"UnsignedRightShiftNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (ShiftNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (UnsignedRightShiftNode'canonical-5 this, (ShiftNode''getArithmeticOp-1 this), (:stamp this), forX, forY)
            )
        )
    )

    (§ defn- #_"ValueNode" UnsignedRightShiftNode'canonical-5 [#_"UnsignedRightShiftNode" self, #_"ShiftOp<UShr>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (instance? ConstantNode forY) => (or self (UnsignedRightShiftNode'new-2 forX, forY))
            (let [
                #_"int" amount (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 forY))
                #_"int" o'amount amount
                #_"int" mask (ShiftOp''getShiftAmountMask-2 op, stamp)
                amount (& amount mask)
            ]
                (if (zero? amount)
                    forX
                    (do
                        (when (and (instance? ShiftNode forX) (instance? ConstantNode (:y forX)))
                            (let [
                                #_"int" otherAmount (& (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:y forX))) mask)
                            ]
                                (cond
                                    (instance? UnsignedRightShiftNode forX)
                                        (let [
                                            #_"int" total (+ amount otherAmount)
                                        ]
                                            (if (= total (& total mask))
                                                (§ return (UnsignedRightShiftNode'new-2 (:x forX), (ConstantNode'forInt-1 total)))
                                                (§ return (ConstantNode'forIntegerKind-2 (Stamp''getStackKind-1 stamp), 0))
                                            )
                                        )
                                    (and (instance? LeftShiftNode forX) (= amount otherAmount))
                                        (if (= (Stamp''getStackKind-1 stamp) JavaKind/Long)
                                            (§ return (AndNode'new-2 (:x forX), (ConstantNode'forLong-1 (>>> -1 amount))))
                                            (§ return (AndNode'new-2 (:x forX), (ConstantNode'forInt-1 (>>> -1 amount))))
                                        )
                                )
                            )
                        )
                        (when-not (= amount o'amount) => (or self (UnsignedRightShiftNode'new-2 forX, forY))
                            (UnsignedRightShiftNode'new-2 forX, (ConstantNode'forInt-1 amount))
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" UnsignedRightShiftNode''generate-2 [#_"UnsignedRightShiftNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitUShr-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )

    #_unused
    (§ override! #_"boolean" UnsignedRightShiftNode''isNarrowable-2 [#_"UnsignedRightShiftNode" this, #_"int" resultBits]
        (and (ShiftNode''isNarrowable-2 (§ super ), resultBits)
            ;; For unsigned right shifts, the narrow can be done before the shift if the cut off bits are all zero.
            (zero? (& (:upMask (:stamp (:x this))) (bit-not (dec resultBits))))
        )
    )
)

(final-ns XorNode (§ extends BinaryArithmeticNode #_"<Xor>") (§ implements BinaryCommutative #_"<ValueNode>", NarrowableArithmeticNode)
    (§ def #_"NodeClass<XorNode>" XorNode'TYPE (NodeClass'create-1 XorNode))

    (§ defn #_"XorNode" XorNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (BinaryArithmeticNode'new-4 XorNode'TYPE, :xor, x, y)
    )

    (§ defn #_"ValueNode" XorNode'create-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"BinaryOp<Xor>" op (:xor (ArithmeticOpTable'forStamp-1 (:stamp x)))
            #_"Stamp" stamp (BinaryOp''foldStamp-3 op, (:stamp x), (:stamp y))
        ]
            (or (BinaryArithmeticNode'tryConstantFold-4 op, x, y, stamp) (XorNode'canonical-5 nil, op, stamp, x, y))
        )
    )

    #_unused
    (§ override! #_"ValueNode" XorNode''canonical-4 [#_"XorNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (BinaryArithmeticNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (XorNode'canonical-5 this, (BinaryArithmeticNode''getOp-3 this, forX, forY), (:stamp this), forX, forY)
            )
        )
    )

    (§ defn- #_"ValueNode" XorNode'canonical-5 [#_"XorNode" self, #_"BinaryOp<Xor>" op, #_"Stamp" stamp, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1 forX) (GraphUtil'unproxify-1 forY))
                (ConstantNode'forPrimitive-2 stamp, (BinaryOp''getZero-2 op, (:stamp forX)))
            (and (instance? ConstantNode forX) (not (instance? ConstantNode forY)))
                (XorNode'new-2 forY, forX)
            (instance? ConstantNode forY)
                (let [
                    #_"Constant" c (:value forY)
                ]
                    (if (BinaryOp''isNeutral-2 op, c)
                        forX
                        (do
                            (when (and (instance? PrimitiveConstant c) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind c)))
                                (let [
                                    #_"long" mask (CodeUtil/mask (PrimitiveStamp'getBits-1 stamp))
                                ]
                                    (when (= (& (#_"PrimitiveConstant" .asLong c) mask) mask)
                                        (§ return (NotNode'new-1 forX))
                                    )
                                )
                            )
                            (BinaryArithmeticNode'reassociate-4 (or self (BinaryArithmeticNode''maybeCommuteInputs-1 (XorNode'new-2 forX, forY))), (ValueNode'isConstantPredicate-0), forX, forY)
                        )
                    )
                )
            :else
                (or self (BinaryArithmeticNode''maybeCommuteInputs-1 (XorNode'new-2 forX, forY)))
        )
    )

    #_unused
    (§ override! #_"void" XorNode''generate-2 [#_"XorNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitXor-3 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this))))
        nil
    )
)

;;;
 ; The ZeroExtendNode converts an integer to a wider integer using zero extension.
 ;;
(final-ns ZeroExtendNode (§ extends IntegerConvertNode #_"<ZeroExtend, Narrow>")
    (§ def #_"NodeClass<ZeroExtendNode>" ZeroExtendNode'TYPE (NodeClass'create-1 ZeroExtendNode))

    (§ final #_"boolean" :inputAlwaysPositive false)

    (§ defn #_"ZeroExtendNode" ZeroExtendNode'new-2 [#_"ValueNode" input, #_"int" resultBits]
        (ZeroExtendNode'new-4 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits, false)
    )

    (§ defn #_"ZeroExtendNode" ZeroExtendNode'new-4 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits, #_"boolean" inputAlwaysPositive]
        (let [
            #_"ZeroExtendNode" this (IntegerConvertNode'new-6 ZeroExtendNode'TYPE, :zeroExtend, :narrow, inputBits, resultBits, input)
            this (assoc this :inputAlwaysPositive inputAlwaysPositive)
        ]
            this
        )
    )

    (§ defn #_"ValueNode" ZeroExtendNode'create-2 [#_"ValueNode" input, #_"int" resultBits]
        (ZeroExtendNode'create-4 input, (PrimitiveStamp'getBits-1 (:stamp input)), resultBits, false)
    )

    #_unused
    (§ defn #_"ValueNode" ZeroExtendNode'create-3 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits]
        (ZeroExtendNode'create-4 input, inputBits, resultBits, false)
    )

    (§ defn #_"ValueNode" ZeroExtendNode'create-4 [#_"ValueNode" input, #_"int" inputBits, #_"int" resultBits, #_"boolean" alwaysPositive]
        (let [
            #_"IntegerConvertOp<ZeroExtend>" signExtend (:zeroExtend (ArithmeticOpTable'forStamp-1 (:stamp input)))
        ]
            (or (IntegerConvertNode'findSynonym-5 signExtend, input, inputBits, resultBits, (IntegerConvertOp''foldStamp-4 signExtend, inputBits, resultBits, (:stamp input)))
                (ZeroExtendNode'canonical-5 nil, input, inputBits, resultBits, alwaysPositive)
            )
        )
    )

    #_unused
    (§ override! #_"boolean" ZeroExtendNode''isLossless-1 [#_"ZeroExtendNode" this]
        true
    )

    #_unused
    (§ override! #_"boolean" ZeroExtendNode''preservesOrder-2 [#_"ZeroExtendNode" this, #_"CanonicalCondition" condition]
        (not= condition CanonicalCondition'LT)
    )

    #_unused
    (§ override! #_"ValueNode" ZeroExtendNode''canonical-3 [#_"ZeroExtendNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (let [
            #_"ValueNode" ret (IntegerConvertNode''canonical-3 (§ super ), tool, value)
        ]
            (when (= ret this) => ret
                (ZeroExtendNode'canonical-5 this, value, (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this), (:inputAlwaysPositive this))
            )
        )
    )

    (§ defn- #_"ValueNode" ZeroExtendNode'canonical-5 [#_"ZeroExtendNode" self, #_"ValueNode" forValue, #_"int" inputBits, #_"int" resultBits, #_"boolean" alwaysPositive]
        (condp instance? forValue
            ZeroExtendNode
                ;; xxxx -(zero-extend)-> 0000 xxxx -(zero-extend)-> 00000000 0000xxxx
                ;; ==> xxxx -(zero-extend)-> 00000000 0000xxxx
                (ZeroExtendNode'new-4 (UnaryNode''getValue-1 forValue), (IntegerConvertNode''getInputBits-1 forValue), resultBits, (:inputAlwaysPositive forValue))
            NarrowNode
                (let [
                    #_"ValueNode" inputValue (UnaryNode''getValue-1 forValue)
                    #_"Stamp" inputStamp (:stamp inputValue)
                ]
                    (if (and (instance? IntegerStamp inputStamp) (zero? (& (:upMask inputStamp) (bit-not (CodeUtil/mask (PrimitiveStamp'getBits-1 (:stamp forValue)))))))
                        ;; The original value cannot change because of the narrow and zero extend.
                        (cond
                            ;; Need to keep the zero extend, skip the narrow.
                            (< (:bits inputStamp) resultBits) (ZeroExtendNode'create-2 inputValue, resultBits)
                            ;; Need to keep the narrow, skip the zero extend.
                            (< resultBits (:bits inputStamp)) (NarrowNode'create-2 inputValue, resultBits)
                            ;; Just return the original value.
                            :else                             inputValue
                        )
                        (or self (ZeroExtendNode'new-4 forValue, inputBits, resultBits, alwaysPositive))
                    )
                )
            (or self (ZeroExtendNode'new-4 forValue, inputBits, resultBits, alwaysPositive))
        )
    )

    #_unused
    (§ override! #_"void" ZeroExtendNode''generate-2 [#_"ZeroExtendNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitZeroExtend-4 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this)), (IntegerConvertNode''getInputBits-1 this), (IntegerConvertNode''getResultBits-1 this)))
        nil
    )

    #_unused
    (§ override! #_"boolean" ZeroExtendNode''mayNullCheckSkipConversion-1 [#_"ZeroExtendNode" this]
        true
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Extension"
(class-ns CallTargetNode (§ extends ValueNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<CallTargetNode>" CallTargetNode'TYPE (NodeClass'create-1 CallTargetNode))

    ; @Input
    (§ mutable #_"NodeInputList<ValueNode>" :arguments nil)
    (§ mutable #_"ResolvedJavaMethod" :targetMethod nil)
    (§ mutable #_"InvokeKind" :invokeKind nil)
    (§ final #_"StampPair" :returnStamp nil)

    (§ defn #_"CallTargetNode" CallTargetNode'new-5 [#_"NodeClass<? extends CallTargetNode>" c, #_"ValueNode[]" arguments, #_"ResolvedJavaMethod" targetMethod, #_"InvokeKind" invokeKind, #_"StampPair" returnStamp]
        (let [
            #_"CallTargetNode" this (ValueNode'new-2 c, (StampFactory'forVoid-0))
            this (assoc this :targetMethod targetMethod)
            this (assoc this :invokeKind invokeKind)
            this (assoc this :arguments (NodeInputList'new-2 this, arguments))
            this (assoc this :returnStamp returnStamp)
        ]
            this
        )
    )

    (§ method! #_"NodeInputList<ValueNode>" CallTargetNode''arguments-1 [#_"CallTargetNode" this]
        (:arguments this)
    )

    (§ method! #_"StampPair" CallTargetNode''returnStamp-1 [#_"CallTargetNode" this]
        (:returnStamp this)
    )

    ;;;
     ; A human-readable representation of the target, used for debug printing only.
     ;;
    #_unused
    (§ abstract #_"String" CallTargetNode''targetName-1 [#_"CallTargetNode" this])

    #_unused
    (§ override #_"void" CallTargetNode''generate-2 [#_"CallTargetNode" this, #_"LIRBuilder" builder]
        ;; nop
        nil
    )

    (§ method! #_"CallTargetNode" CallTargetNode''setTargetMethod-2 [#_"CallTargetNode" this, #_"ResolvedJavaMethod" method]
        (assoc this :targetMethod method)
    )

    ;;;
     ; Gets the target method for this invocation instruction.
     ;
     ; @return the target method
     ;;
    (§ method! #_"ResolvedJavaMethod" CallTargetNode''targetMethod-1 [#_"CallTargetNode" this]
        (:targetMethod this)
    )

    (§ method! #_"InvokeKind" CallTargetNode''invokeKind-1 [#_"CallTargetNode" this]
        (:invokeKind this)
    )

    (§ method! #_"CallTargetNode" CallTargetNode''setInvokeKind-2 [#_"CallTargetNode" this, #_"InvokeKind" kind]
        (assoc this :invokeKind kind)
    )
)

;;;
 ; @anno CallTargetNode.InvokeKind
 ;;
(final-ns InvokeKind
    (§ enum (InvokeKind'Interface false))
    (§ enum (InvokeKind'Special true))
    (§ enum (InvokeKind'Static true))
    (§ enum (InvokeKind'Virtual false))

    (§ final #_"boolean" :direct false)

    #_unused
    (§ defn #_"InvokeKind" InvokeKind'new-1 [#_"boolean" direct]
        (let [
            #_"InvokeKind" this (Object.)
            this (assoc this :direct direct)
        ]
            this
        )
    )

    (§ method! #_"boolean" InvokeKind''hasReceiver-1 [#_"InvokeKind" this]
        (not= this InvokeKind'Static)
    )

    (§ method! #_"boolean" InvokeKind''isIndirect-1 [#_"InvokeKind" this]
        (not (:direct this))
    )

    #_unused
    (§ method! #_"boolean" InvokeKind''isInterface-1 [#_"InvokeKind" this]
        (= this InvokeKind'Interface)
    )
)

(§ interface CanonicalizableLocation
    (§ abstract #_"ValueNode" CanonicalizableLocation''canonicalizeRead-5 [#_"CanonicalizableLocation" this, #_"ValueNode" read, #_"AddressNode" location, #_"ValueNode" object, #_"CanonicalizerTool" tool])
)

(final-ns Block
    (§ def #_"Block[]" Block'EMPTY_ARRAY (make-array Block 0))

    (§ mutable #_"int" :id 0)
    ;;;
     ; Level in the dominator tree starting with 0 for the start block.
     ;;
    (§ mutable #_"int" :domDepth 0)

    (§ mutable #_"Block[]" :predecessors nil)
    (§ mutable #_"Block[]" :successors nil)

    (§ mutable #_"Block" :dominator nil)
    (§ mutable #_"Block" :firstDominated nil)
    (§ mutable #_"Block" :dominatedSibling nil)
    (§ mutable #_"int" :domNumber 0)
    (§ mutable #_"int" :maxChildDomNumber 0)

    (§ mutable #_"boolean" :aligned? false)
    (§ mutable #_"int" :linearScanNumber 0)

    (§ final #_"AbstractBeginNode" :beginNode nil)

    (§ mutable #_"FixedNode" :endNode nil)

    (§ mutable #_"double" :probability 0.0)
    (§ mutable #_"Loop" :loop nil)

    (§ mutable #_"Block" :postdominator nil)
    (§ mutable #_"LocationSet" :killLocations nil)
    (§ mutable #_"LocationSet" :killLocationsBetweenThisAndDominator nil)

    (§ defn #_"Block" Block'new-1 [#_"AbstractBeginNode" node]
        (let [
            #_"Block" this (Object.)
            this (assoc this :id ControlFlowGraph'BLOCK_ID_INITIAL)
            this (assoc this :linearScanNumber -1)
            this (assoc this :domNumber -1)
            this (assoc this :maxChildDomNumber -1)
            this (assoc this :beginNode node)
        ]
            this
        )
    )

    (§ method! #_"Block" Block''setDominatorNumber-2 [#_"Block" this, #_"int" domNumber]
        (assoc this :domNumber domNumber)
    )

    (§ method! #_"Block" Block''setMaxChildDomNumber-2 [#_"Block" this, #_"int" maxChildDomNumber]
        (assoc this :maxChildDomNumber maxChildDomNumber)
    )

    (§ method! #_"Block" Block''setId-2 [#_"Block" this, #_"int" id]
        (assoc this :id id)
    )

    (§ method! #_"Block" Block''setPredecessors-2 [#_"Block" this, #_"Block[]" predecessors]
        (assoc this :predecessors predecessors)
    )

    (§ method! #_"Block" Block''setSuccessors-2 [#_"Block" this, #_"Block[]" successors]
        (assoc this :successors successors)
    )

    (§ method! #_"Block" Block''setDominator-2 [#_"Block" this, #_"Block" dominator]
        (let [
            this (assoc this :dominator dominator)
            this (assoc this :domDepth (inc (:domDepth dominator)))
        ]
            this
        )
    )

    (§ method! #_"Block" Block''setFirstDominated-2 [#_"Block" this, #_"Block" block]
        (assoc this :firstDominated block)
    )

    (§ method! #_"Block" Block''setDominatedSibling-2 [#_"Block" this, #_"Block" block]
        (assoc this :dominatedSibling block)
    )

    (§ method! #_"Block" Block''setLinearScanNumber-2 [#_"Block" this, #_"int" linearScanNumber]
        (assoc this :linearScanNumber linearScanNumber)
    )

    (§ method! #_"Block" Block''setAlign-2 [#_"Block" this, #_"boolean" aligned?]
        (assoc this :aligned? aligned?)
    )

    ;;;
     ; Return the LoopExitNode for this block if it exists.
     ;;
    (§ method! #_"LoopExitNode" Block''getLoopExit-1 [#_"Block" this]
        (condp instance? (:beginNode this)
            BeginNode
                (when (instance? LoopExitNode (:next (:beginNode this)))
                    (:next (:beginNode this))
                )
            LoopExitNode
                (:beginNode this)
            nil
        )
    )

    (§ method! #_"Block" Block''setLoop-2 [#_"Block" this, #_"Loop" loop]
        (assoc this :loop loop)
    )

    (§ method! #_"int" Block''getLoopDepth-1 [#_"Block" this]
        (if (some? (:loop this)) (:depth (:loop this)) 0)
    )

    (§ method! #_"boolean" Block''isLoopHeader-1 [#_"Block" this]
        (instance? LoopBeginNode (:beginNode this))
    )

    (§ method! #_"boolean" Block''isLoopEnd-1 [#_"Block" this]
        (instance? LoopEndNode (:endNode this))
    )

    (§ method! #_"Block" Block''getFirstPredecessor-1 [#_"Block" this]
        (nth (:predecessors this) 0)
    )

    (§ method! #_"Block" Block''getFirstSuccessor-1 [#_"Block" this]
        (nth (:successors this) 0)
    )

    #_unused
    (§ method! #_"Block" Block''getEarliestPostDominated-1 [#_"Block" this]
        (loop [#_"Block" b this]
            (let [
                #_"Block" dom (:dominator b)
            ]
                (recur-if (and (some? dom) (= (:postdominator dom) b)) [dom] => b)
            )
        )
    )

    (§ method! #_"Iterable<FixedNode>" Block''getNodes-1 [#_"Block" this]
        (let [
            #_"Block" block this
        ]
            (§ reify #_"Iterable<FixedNode>" (Iterable.)
                (§ override! #_"Iterator<FixedNode>" #_"Iterable" .iterator [#_"Iterable<FixedNode>" this]
                    (FixedNodeIterator'new-1 block)
                )
            )
        )
    )

    (§ method! #_"Block" Block''setProbability-2 [#_"Block" this, #_"double" probability]
        (assoc this :probability probability)
    )

    (§ method! #_"Block" Block''getDominator-2 [#_"Block" this, #_"int" distance]
        (loop-when-recur [#_"Block" block this #_"int" i 0] (< i distance) [(:dominator block) (inc i)] => block)
    )

    (§ method! #_"boolean" Block''canKill-2 [#_"Block" this, #_"LocationIdentity" location]
        (and (not (#_"LocationIdentity" .isImmutable location))
            (LocationSet''contains-2 (Block''getKillLocations-1 this), location)
        )
    )

    (§ method! #_"LocationSet" Block''getKillLocations-1 [#_"Block" this]
        (when (nil? (:killLocations this))
            (§ ass! this (assoc this :killLocations (Block''calcKillLocations-1 this)))
        )
        (:killLocations this)
    )

    (§ method- #_"LocationSet" Block''calcKillLocations-1 [#_"Block" this]
        (let [
            #_"LocationSet" result (LocationSet'new-0)
        ]
            (loop-when [#_"ISeq" s (seq (Block''getNodes-1 this))] (some? s)
                (let [
                    #_"FixedNode" node (first s)
                ]
                    (condp instance? node
                        Single
                            (let [
                                #_"LocationIdentity" identity (Single''getLocationIdentity-1 node)
                            ]
                                (§ ass! result (LocationSet''add-2 result, identity))
                            )
                        Multi
                            (doseq [#_"LocationIdentity" identity (Multi''getLocationIdentities-1 node)]
                                (§ ass! result (LocationSet''add-2 result, identity))
                            )
                        nil
                    )
                    (when-not (LocationSet''isAny-1 result)
                        (recur (next s))
                    )
                )
            )
            result
        )
    )

    (§ method! #_"boolean" Block''canKillBetweenThisAndDominator-2 [#_"Block" this, #_"LocationIdentity" location]
        (and (not (#_"LocationIdentity" .isImmutable location))
            (LocationSet''contains-2 (Block''getKillLocationsBetweenThisAndDominator-1 this), location)
        )
    )

    (§ method- #_"LocationSet" Block''getKillLocationsBetweenThisAndDominator-1 [#_"Block" this]
        (when (nil? (:killLocationsBetweenThisAndDominator this))
            (let [
                #_"LocationSet" dominatorResult (LocationSet'new-0)
                #_"Block" stopBlock (:dominator this)
            ]
                (if (Block''isLoopHeader-1 this)
                    (§ ass! dominatorResult (LocationSet''addAll-2 dominatorResult, (Loop''getKillLocations-1 (:loop this))))
                    (loop-when [#_"ISeq" s (seq (:predecessors this))] (some? s)
                        (let [
                            #_"Block" b (first s)
                        ]
                            (or
                                (when-not (= b stopBlock)
                                    (or
                                        (do
                                            (§ ass! dominatorResult (LocationSet''addAll-2 dominatorResult, (Block''getKillLocations-1 b)))
                                            (when (LocationSet''isAny-1 dominatorResult)
                                                :done
                                            )
                                        )
                                        (do
                                            (Block''calcKillLocationsBetweenThisAndTarget-3 b, dominatorResult, stopBlock)
                                            (when (LocationSet''isAny-1 dominatorResult)
                                                :done
                                            )
                                        )
                                    )
                                )
                                (recur (next s))
                            )
                        )
                    )
                )
                (§ ass! this (assoc this :killLocationsBetweenThisAndDominator dominatorResult))
            )
        )
        (:killLocationsBetweenThisAndDominator this)
    )

    (§ method- #_"void" Block''calcKillLocationsBetweenThisAndTarget-3 [#_"Block" this, #_"LocationSet" result, #_"Block" stopBlock]
        (if (or (= stopBlock this) (LocationSet''isAny-1 result))
            nil ;; We reached the stop block => nothing to do.
            (if (= stopBlock (:dominator this))
                (§ ass! result (LocationSet''addAll-2 result, (Block''getKillLocationsBetweenThisAndDominator-1 this)))
                (do
                    ;; Divide and conquer: Aggregate kill locations from this to the dominator and then
                    ;; from the dominator onwards.
                    (Block''calcKillLocationsBetweenThisAndTarget-3 this, result, (:dominator this))
                    (§ ass! result (LocationSet''addAll-2 result, (Block''getKillLocations-1 (:dominator this))))
                    (when-not (LocationSet''isAny-1 result)
                        (Block''calcKillLocationsBetweenThisAndTarget-3 (:dominator this), result, stopBlock)
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" Block''delete-1 [#_"Block" this]
        ;; adjust successor and predecessor lists
        (let [
            #_"Block" next (nth (:successors this) 0)
        ]
            (doseq [#_"Block" pred (:predecessors this)]
                (let [
                    #_"Block[]" predSuccs (:successors pred)
                    #_"Block[]" newPredSuccs (make-array Block (count predSuccs))
                ]
                    (dotimes [#_"int" i (count predSuccs)]
                        (aset newPredSuccs i (if (= (nth predSuccs i) this) next (nth predSuccs i)))
                    )
                    (§ ass! pred (Block''setSuccessors-2 pred, newPredSuccs))
                )
            )

            (let [
                #_"ArrayList<Block>" newPreds (ArrayList.)
            ]
                (dotimes [#_"int" i (count (:predecessors next))]
                    (let [
                        #_"Block" curPred (nth (:predecessors next) i)
                    ]
                        (if (= curPred this)
                            (doseq [#_"Block" b (:predecessors this)]
                                (#_"ArrayList" .add newPreds, b)
                            )
                            (#_"ArrayList" .add newPreds, curPred)
                        )
                    )
                )

                (§ ass! next (Block''setPredecessors-2 next, (#_"ArrayList" .toArray newPreds, (make-array Block 0))))
            )
        )
        nil
    )

    (§ method! #_"Block" Block''setPostDominator-2 [#_"Block" this, #_"Block" postdominator]
        (assoc this :postdominator postdominator)
    )
)

;;;
 ; @anno Block.FixedNodeIterator
 ;;
(final-ns FixedNodeIterator (§ implements Iterator #_"<FixedNode>")
    (§ mutable #_"FixedNode" :cur nil)

    (§ defn #_"FixedNodeIterator" FixedNodeIterator'new-1 [#_"Block" block]
        (let [
            #_"FixedNodeIterator" this (Object.)
            this (assoc this :cur (:beginNode block))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" FixedNodeIterator''hasNext-1 [#_"FixedNodeIterator" this]
        (some? (:cur this))
    )

    #_unused
    (§ override! #_"FixedNode" FixedNodeIterator''next-1 [#_"FixedNodeIterator" this]
        (let [
            #_"FixedNode" result (:cur this)
        ]
            (if (instance? FixedWithNextNode result)
                (let [
                    #_"FixedNode" next (:next result)
                ]
                    (§ ass! this (assoc this :cur (when-not (instance? AbstractBeginNode next) next)))
                )
                (§ ass! this (assoc this :cur nil))
            )
            result
        )
    )
)

(final-ns ControlFlowGraph
    (def #_"int" ControlFlowGraph'BLOCK_ID_INITIAL -1)
    (def #_"int" ControlFlowGraph'BLOCK_ID_VISITED -2)

    ;;;
     ; Don't allow probability values to be become too small or too high as this makes frequency
     ; calculations over- or underflow the range of a double. This commonly happens with infinite
     ; loops within infinite loops. The value is chosen a bit lower than half the maximum exponent
     ; supported by double. That way we can never overflow to infinity when multiplying two
     ; probability values.
     ;;
    (def #_"double" ControlFlowGraph'MIN_PROBABILITY #_"0x1.0p-500" 3.0549363634996047e-151)
    (def #_"double" ControlFlowGraph'MAX_PROBABILITY (/ 1.0 ControlFlowGraph'MIN_PROBABILITY))

    (§ final #_"Graph" :graph nil)

    (§ mutable #_"NodeMap<Block>" :nodeToBlock nil)
    ;;;
     ; The list of blocks contained in this control flow graph.
     ;
     ; It is guaranteed that the blocks are numbered and ordered according
     ; to a reverse post order traversal of the control flow graph.
     ;;
    (§ mutable #_"Block[]" :reversePostOrder nil)
    (§ mutable #_"List<Loop>" :loops nil)
    (§ mutable #_"int" :maxDominatorDepth 0)

    (§ defn- #_"ControlFlowGraph" ControlFlowGraph'new-1 [#_"Graph" graph]
        (let [
            #_"ControlFlowGraph" this (Object.)
            this (assoc this :graph graph)
            this (assoc this :nodeToBlock (NodeMap'new-1 graph))
        ]
            this
        )
    )

    (§ defn #_"ControlFlowGraph" ControlFlowGraph'compute-5 [#_"Graph" graph, #_"boolean" connectBlocks, #_"boolean" computeLoops, #_"boolean" computeDominators, #_"boolean" computePostdominators]
        (let [
            #_"ControlFlowGraph" cfg (ControlFlowGraph'new-1 graph)
        ]
            (§ ass! cfg (ControlFlowGraph''identifyBlocks-1 cfg))
            (ControlFlowGraph''computeProbabilities-1 cfg)

            (when computeLoops
                (§ ass! cfg (ControlFlowGraph''computeLoopInformation-1 cfg))
            )
            (when computeDominators
                (§ ass! cfg (ControlFlowGraph''computeDominators-1 cfg))
            )
            (when computePostdominators
                (ControlFlowGraph''computePostdominators-1 cfg)
            )

            cfg
        )
    )

    (§ method! #_"<V> void" ControlFlowGraph''visitDominatorTreeDefault-2 [#_"ControlFlowGraph" this, #_"RecursiveVisitor<V>" visitor]
        (let [
            #_"Block[]" stack (make-array Block (inc (:maxDominatorDepth this)))
        ]
            (loop-when [#_"Block" block (ControlFlowGraph''getStartBlock-1 this) #_"Object[]" values nil #_"int" j 0 #_"int" i 0] (<= 0 i)
                (let [
                    #_"Block" state (nth stack i)
                ]
                    (when-not (and (some? state) (some? (:dominator state)) (= (:postdominator (:dominator state)) state))
                        (if (nil? state)
                            ;; We enter this block for the first time.
                            (let [
                                #_"V" value (RecursiveVisitor''enter-2 visitor, block)
                            ]
                                (when (or (some? value) (some? values))
                                    (when (nil? values)
                                        (§ ass values (make-array Object (inc (:maxDominatorDepth this))))
                                    )
                                    (aset values j value)
                                    (§ ass j (inc j))
                                )

                                (let [
                                    #_"Block" dominated (ControlFlowGraph'skipPostDom-1 (:firstDominated block))
                                ]
                                    (when (some? dominated)
                                        ;; Descend into dominated.
                                        (aset stack i dominated)
                                        (§ ass block dominated)
                                        (§ ass i (inc i))
                                        (aset stack i nil)
                                        (§ continue )
                                    )
                                )
                            )
                            (let [
                                #_"Block" next (ControlFlowGraph'skipPostDom-1 (:dominatedSibling state))
                            ]
                                (when (some? next)
                                    ;; Descend into dominated.
                                    (aset stack i next)
                                    (§ ass block next)
                                    (§ ass i (inc i))
                                    (aset stack i nil)
                                    (§ continue )
                                )
                            )
                        )

                        ;; Finished processing all normal dominators.
                        (let [
                            #_"Block" postDom (:postdominator block)
                        ]
                            (when (and (some? postDom) (= (:dominator postDom) block))
                                ;; Descend into post dominator.
                                (aset stack i postDom)
                                (§ ass block postDom)
                                (§ ass i (inc i))
                                (aset stack i nil)
                                (§ continue )
                            )
                        )
                    )

                    ;; Finished processing this node, exit and pop from stack.
                    (let [
                        [j #_"V" value]
                            (when (and (some? values) (pos? j)) => [j nil]
                                (let [
                                    j (dec j)
                                ]
                                    [j (§ cast #_"V" (nth values j))]
                                )
                            )
                    ]
                        (RecursiveVisitor''exit-3 visitor, block, value)
                        (recur (:dominator block) values j (dec i))
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"Block" ControlFlowGraph'skipPostDom-1 [#_"Block" block]
        (when (and (some? block) (= (:postdominator (:dominator block)) block)) => block
            ;; This is an always reached block.
            (:dominatedSibling block)
        )
    )

    (§ defn #_"void" ControlFlowGraph'addDeferredExit-2 [#_"DeferredExit[]" deferredExits, #_"Block" block]
        (let [
            #_"Loop" exitBlockLoop (:loop block)
            #_"int" i
                (loop-when-recur [#_"Loop" outermostExited (:loop (:dominator block))]
                                 (and (some? (:parent outermostExited)) (not= (:parent outermostExited) exitBlockLoop))
                                 [(:parent outermostExited)]
                              => (:index outermostExited)
                )
        ]
            (aset deferredExits i (DeferredExit'new-2 block, (nth deferredExits i)))
        )
        nil
    )

    (§ method! #_"<V> void" ControlFlowGraph''visitDominatorTreeDeferLoopExits-2 [#_"ControlFlowGraph" this, #_"RecursiveVisitor<V>" visitor]
        (let [
            #_"Block[]" stack (make-array Block (count (:reversePostOrder this)))
            _ (aset stack 0 (ControlFlowGraph''getStartBlock-1 this))
            #_"BitSet" visited (BitSet. (count (:reversePostOrder this)))
            #_"DeferredExit[]" deferredExits (make-array DeferredExit (count (:loops this)))
        ]
            (loop-when [#_"Object[]" values nil #_"int" j 0 #_"int" i 0] (<= 0 i)
                (let [
                    #_"Block" block (nth stack i)
                ]
                    (if (#_"BitSet" .get visited, (:id block))
                        (let [
                            [j #_"V" value]
                                (when (and (some? values) (pos? j)) => [j nil]
                                    (let [
                                        j (dec j)
                                    ]
                                        [j (nth values j)]
                                    )
                                )
                            _ (RecursiveVisitor''exit-3 visitor, block, value)
                            i (dec i)
                            i
                                (when (Block''isLoopHeader-1 block) => i
                                    (let [
                                        #_"int" loopIndex (:index (:loop block))
                                        #_"DeferredExit" deferredExit (nth deferredExits loopIndex)
                                    ]
                                        (when (some? deferredExit) => i
                                            (let [
                                                i
                                                    (loop-when [i i deferredExit deferredExit] (some? deferredExit) => i
                                                        (let [
                                                            i (inc i)
                                                        ]
                                                            (aset stack i (:block deferredExit))
                                                            (recur i (:next deferredExit))
                                                        )
                                                    )
                                            ]
                                                (aset deferredExits loopIndex nil)
                                                i
                                            )
                                        )
                                    )
                                )
                        ]
                            (recur values j i)
                        )
                        (let [
                            _ (#_"BitSet" .set visited, (:id block))
                            #_"V" value (RecursiveVisitor''enter-2 visitor, block)
                            [values j]
                                (when (or (some? value) (some? values)) => [values j]
                                    (let [
                                        values (or values (make-array Object (inc (:maxDominatorDepth this))))
                                    ]
                                        (aset values j value)
                                        [values (inc j)]
                                    )
                                )
                            #_"Block" alwaysReached (:postdominator block)
                            [alwaysReached i]
                                (when (and (some? alwaysReached) (= (:dominator alwaysReached) block)) => [nil i]
                                    (if (ControlFlowGraph'isDominatorTreeLoopExit-1 alwaysReached)
                                        (do
                                            (ControlFlowGraph'addDeferredExit-2 deferredExits, alwaysReached)
                                            [alwaysReached i]
                                        )
                                        (let [
                                            i (inc i)
                                        ]
                                            (aset stack i alwaysReached)
                                            [alwaysReached i]
                                        )
                                    )
                                )
                            i
                                (loop-when [i i #_"Block" b (:firstDominated block)] (some? b) => i
                                    (let [
                                        i
                                            (when-not (= b alwaysReached) => i
                                                (if (ControlFlowGraph'isDominatorTreeLoopExit-1 b)
                                                    (do
                                                        (ControlFlowGraph'addDeferredExit-2 deferredExits, b)
                                                        i
                                                    )
                                                    (let [
                                                        i (inc i)
                                                    ]
                                                        (aset stack i b)
                                                        i
                                                    )
                                                )
                                            )
                                    ]
                                        (recur i (:dominatedSibling b))
                                    )
                                )
                        ]
                            (recur values j i)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"<V> void" ControlFlowGraph''visitDominatorTree-3 [#_"ControlFlowGraph" this, #_"RecursiveVisitor<V>" visitor, #_"boolean" deferLoopExits]
        (if (and deferLoopExits (seq (:loops this)))
            (ControlFlowGraph''visitDominatorTreeDeferLoopExits-2 this, visitor)
            (ControlFlowGraph''visitDominatorTreeDefault-2 this, visitor)
        )
        nil
    )

    (§ defn #_"boolean" ControlFlowGraph'isDominatorTreeLoopExit-1 [#_"Block" b]
        (let [
            #_"Block" dominator (:dominator b)
        ]
            (and (some? dominator) (not= (:loop b) (:loop dominator)) (or (not (Block''isLoopHeader-1 b)) (<= (Block''getLoopDepth-1 b) (Block''getLoopDepth-1 dominator))))
        )
    )

    (§ method- #_"ControlFlowGraph" ControlFlowGraph''computeDominators-1 [#_"ControlFlowGraph" this]
        (let [
            #_"Block[]" blocks (:reversePostOrder this)
            #_"int" curMaxDominatorDepth
                (loop-when [curMaxDominatorDepth 0 #_"int" i 1] (< i (count blocks)) => curMaxDominatorDepth
                    (let [
                        #_"Block" block (nth blocks i)
                        #_"Block" dominator
                            (loop-when [dominator nil #_"ISeq" s (seq (:predecessors block))] (some? s) => dominator
                                (let [
                                    #_"Block" pred (first s)
                                    dominator
                                        (when-not (Block''isLoopEnd-1 pred) => dominator
                                            (if (some? dominator) (ControlFlowGraph'commonDominatorRaw-2 dominator, pred) pred)
                                        )
                                ]
                                    (recur dominator (next s))
                                )
                            )
                    ]
                        ;; Set dominator.
                        (§ ass! block (Block''setDominator-2 block, dominator))

                        ;; Keep dominated linked list sorted by block ID such that predecessor blocks are always
                        ;; before successor blocks.
                        (let [
                            #_"Block" currentDominated (:firstDominated dominator)
                        ]
                            (if (and (some? currentDominated) (< (:id currentDominated) (:id block)))
                                (let [
                                    currentDominated
                                        (loop-when-recur currentDominated
                                                         (and (some? (:dominatedSibling currentDominated)) (< (:id (:dominatedSibling currentDominated)) (:id block)))
                                                         (:dominatedSibling currentDominated)
                                                      => currentDominated
                                        )
                                ]
                                    (§ ass! block (Block''setDominatedSibling-2 block, (:dominatedSibling currentDominated)))
                                    (§ ass! currentDominated (Block''setDominatedSibling-2 currentDominated, block))
                                )
                                (do
                                    (§ ass! block (Block''setDominatedSibling-2 block, (:firstDominated dominator)))
                                    (§ ass! dominator (Block''setFirstDominated-2 dominator, block))
                                )
                            )

                            (recur (max curMaxDominatorDepth (:domDepth block)) (inc i))
                        )
                    )
                )
            this (assoc this :maxDominatorDepth curMaxDominatorDepth)
        ]
            (ControlFlowGraph'calcDominatorRanges-2 (ControlFlowGraph''getStartBlock-1 this), (count (:reversePostOrder this)))
            this
        )
    )

    (§ defn- #_"void" ControlFlowGraph'calcDominatorRanges-2 [#_"Block" block, #_"int" size]
        (let [
            #_"Block[]" stack (make-array Block size)
        ]
            (aset stack 0 block)
            (let [
                #_"int" tos 0
                #_"int" n 0
            ]
                (loop []
                    (let [
                        #_"Block" cur (nth stack tos)
                        #_"Block" dominated (:firstDominated cur)
                    ]
                        (if (= (:domNumber cur) -1)
                            (do
                                (§ ass! cur (Block''setDominatorNumber-2 cur, n))
                                (if (some? dominated)
                                    (do
                                        ;; Push children onto stack.
                                        (loop []
                                            (§ ass tos (inc tos))
                                            (aset stack tos dominated)
                                            (§ ass dominated (:dominatedSibling dominated))
                                            (recur-if (some? dominated) [])
                                        )
                                    )
                                    (do
                                        (§ ass! cur (Block''setMaxChildDomNumber-2 cur, n))
                                        (§ ass tos (dec tos))
                                    )
                                )
                                (§ ass n (inc n))
                            )
                            (do
                                (§ ass! cur (Block''setMaxChildDomNumber-2 cur, (:maxChildDomNumber dominated)))
                                (§ ass tos (dec tos))
                            )
                        )
                        (recur-if (<= 0 tos) [])
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"Block" ControlFlowGraph'commonDominatorRaw-2 [#_"Block" a, #_"Block" b]
        (if (< (:domDepth b) (:domDepth a))
            (ControlFlowGraph'commonDominatorRawSameDepth-2 (Block''getDominator-2 a, (- (:domDepth a) (:domDepth b))), b)
            (ControlFlowGraph'commonDominatorRawSameDepth-2 a, (Block''getDominator-2 b, (- (:domDepth b) (:domDepth a))))
        )
    )

    (§ defn- #_"Block" ControlFlowGraph'commonDominatorRawSameDepth-2 [#_"Block" a, #_"Block" b]
        (loop-when-recur [a a b b] (not= a b) [(:dominator a) (:dominator b)] => a)
    )

    (§ method! #_"Block" ControlFlowGraph''getStartBlock-1 [#_"ControlFlowGraph" this]
        (nth (:reversePostOrder this) 0)
    )

    (§ method! #_"Block" ControlFlowGraph''blockFor-2 [#_"ControlFlowGraph" this, #_"Node" node]
        (NodeMap''get-2 (:nodeToBlock this), node)
    )

    (§ method- #_"void" ControlFlowGraph''identifyBlock-2 [#_"ControlFlowGraph" this, #_"Block" block]
        (loop [#_"FixedWithNextNode" node (:beginNode block)]
            (NodeMap''set-3 (:nodeToBlock this), node, block)
            (let [
                #_"FixedNode" next (:next node)
            ]
                (condp instance? next
                    AbstractBeginNode
                        (§ ass! block (assoc block :endNode node))
                    FixedWithNextNode
                        (recur next)
                    (do
                        (NodeMap''set-3 (:nodeToBlock this), next, block)
                        (§ ass! block (assoc block :endNode next))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Identify and connect blocks (including loop backward edges). Predecessors need to be in the
     ; order expected when iterating phi inputs.
     ;;
    (§ method- #_"ControlFlowGraph" ControlFlowGraph''identifyBlocks-1 [#_"ControlFlowGraph" this]
        ;; Find all block headers.
        (let [
            #_"int" numBlocks
                (loop-when-recur [numBlocks 0 #_"ISeq" s (seq (Graph''getNodes-2 (:graph this), AbstractBeginNode'TYPE))] (some? s) [(inc numBlocks) (next s)] => numBlocks
                    (ControlFlowGraph''identifyBlock-2 this, (Block'new-1 (first s)))
                )
            ;; Compute reverse post order.
            #_"NodeMap<Block>" nodeMap (:nodeToBlock this)
            #_"Block[]" stack (make-array Block numBlocks)
            #_"Block" startBlock (ControlFlowGraph''blockFor-2 this, (:start (:graph this)))
            _ (aset stack 0 startBlock)
            startBlock (Block''setPredecessors-2 startBlock, Block'EMPTY_ARRAY)
        ]
            (loop [#_"int" tos 0 #_"int" total 0]
                (let [
                    #_"Block" block (nth stack tos)
                    [tos total]
                        (condp = (:id block)
                            ControlFlowGraph'BLOCK_ID_INITIAL
                                ;; First time we see this block: push all successors.
                                (let [
                                    #_"FixedNode" end (:endNode block)
                                    tos
                                        (condp instance? end
                                            EndNode
                                                (let [
                                                    #_"Block" suxBlock (NodeMap''get-2 nodeMap, (AbstractEndNode''merge-1 end))
                                                ]
                                                    (when (= (:id suxBlock) ControlFlowGraph'BLOCK_ID_INITIAL)
                                                        (§ ass tos (inc tos))
                                                        (aset stack tos suxBlock)
                                                    )
                                                    (§ ass! block (Block''setSuccessors-2 block, (into-array Block [ suxBlock ])))
                                                    tos
                                                )
                                            IfNode
                                                (let [
                                                    #_"Block" trueSucc (NodeMap''get-2 nodeMap, (:trueSuccessor end))
                                                ]
                                                    (§ ass tos (inc tos))
                                                    (aset stack tos trueSucc)
                                                    (let [
                                                        #_"Block" falseSucc (NodeMap''get-2 nodeMap, (:falseSuccessor end))
                                                    ]
                                                        (§ ass tos (inc tos))
                                                        (aset stack tos falseSucc)
                                                        (§ ass! block (Block''setSuccessors-2 block, (into-array Block [ trueSucc, falseSucc ])))
                                                        (let [
                                                            #_"Block[]" ifPred (into-array Block [ block ])
                                                        ]
                                                            (§ ass! trueSucc (Block''setPredecessors-2 trueSucc, ifPred))
                                                            (§ ass! falseSucc (Block''setPredecessors-2 falseSucc, ifPred))
                                                        )
                                                        tos
                                                    )
                                                )
                                            LoopEndNode
                                                (do
                                                    (§ ass! block (Block''setSuccessors-2 block, (into-array Block [ (NodeMap''get-2 nodeMap, (:loopBegin end)) ])))
                                                    tos
                                                )
                                            ControlSinkNode
                                                (do
                                                    (§ ass! block (Block''setSuccessors-2 block, Block'EMPTY_ARRAY))
                                                    tos
                                                )
                                            #_else
                                                (let [
                                                    #_"int" startTos tos
                                                    #_"Block[]" ifPred (into-array Block [ block ])
                                                    tos
                                                        (loop-when [tos tos #_"ISeq" s (seq (Node''successors-1 end))] (some? s) => tos
                                                            (let [
                                                                #_"Block" sux (NodeMap''get-2 nodeMap, (first s))
                                                                tos (inc tos)
                                                            ]
                                                                (aset stack tos sux)
                                                                (§ ass! sux (Block''setPredecessors-2 sux, ifPred))
                                                                (recur tos (next s))
                                                            )
                                                        )
                                                    #_"int" n (- tos startTos)
                                                    #_"Block[]" successors (make-array Block n)
                                                ]
                                                    (System/arraycopy stack, (inc startTos), successors, 0, n)
                                                    (§ ass! block (Block''setSuccessors-2 block, successors))
                                                    tos
                                                )
                                        )
                                ]
                                    (§ ass! block (Block''setId-2 block, ControlFlowGraph'BLOCK_ID_VISITED))
                                    (let [
                                        #_"AbstractBeginNode" beginNode (:beginNode block)
                                    ]
                                        (condp instance? beginNode
                                            LoopBeginNode
                                                (ControlFlowGraph'computeLoopPredecessors-3 nodeMap, block, beginNode)
                                            MergeNode
                                                (let [
                                                    #_"int" n (AbstractMergeNode''forwardEndCount-1 beginNode)
                                                    #_"Block[]" predecessors (make-array Block n)
                                                ]
                                                    (dotimes [#_"int" i n]
                                                        (aset predecessors i (NodeMap''get-2 nodeMap, (AbstractMergeNode''forwardEndAt-2 beginNode, i)))
                                                    )
                                                    (§ ass! block (Block''setPredecessors-2 block, predecessors))
                                                )
                                            nil
                                        )
                                    )
                                    [tos total]
                                )
                            ControlFlowGraph'BLOCK_ID_VISITED
                                ;; Second time we see this block: All successors have been processed,
                                ;; so add block to result list. Can safely reuse the stack for this.
                                (let [
                                    tos (dec tos)
                                    total (inc total)
                                    #_"int" i (- numBlocks total)
                                ]
                                    (aset stack i block)
                                    (§ ass! block (Block''setId-2 block, i))
                                    [tos total]
                                )
                        )
                ]
                    (recur-if (<= 0 tos) [tos total])
                )
            )
            ;; Compute reverse postorder and number blocks.
            (assoc this :reversePostOrder stack)
        )
    )

    (§ defn- #_"void" ControlFlowGraph'computeLoopPredecessors-3 [#_"NodeMap<Block>" nodeMap, #_"Block" block, #_"LoopBeginNode" loopBeginNode]
        (let [
            #_"int" forwardEndCount (AbstractMergeNode''forwardEndCount-1 loopBeginNode)
            #_"LoopEndNode[]" loopEnds (LoopBeginNode''orderedLoopEnds-1 loopBeginNode)
            #_"Block[]" predecessors (make-array Block (+ forwardEndCount (count loopEnds)))
        ]
            (dotimes [#_"int" i forwardEndCount]
                (aset predecessors i (NodeMap''get-2 nodeMap, (AbstractMergeNode''forwardEndAt-2 loopBeginNode, i)))
            )
            (dotimes [#_"int" i (count loopEnds)]
                (aset predecessors (+ i forwardEndCount) (NodeMap''get-2 nodeMap, (nth loopEnds i)))
            )
            (§ ass! block (Block''setPredecessors-2 block, predecessors))
        )
        nil
    )

    (§ method- #_"void" ControlFlowGraph''computeProbabilities-1 [#_"ControlFlowGraph" this]
        (doseq [#_"Block" block (:reversePostOrder this)]
            (let [
                #_"Block[]" predecessors (:predecessors block)
                #_"double" probability
                    (case (count predecessors)
                        0   1.0
                        1   (let [
                                #_"Block" pred (nth predecessors 0)
                            ]
                                (when (< 1 (count (:successors pred))) => (:probability pred)
                                    (let [
                                        #_"ControlSplitNode" controlSplit (:endNode pred)
                                    ]
                                        (ControlFlowGraph'multiplyProbabilities-2 (:probability pred), (ControlSplitNode''probability-2 controlSplit, (:beginNode block)))
                                    )
                                )
                            )
                            (let [
                                probability
                                    (loop-when-recur [probability (:probability (nth predecessors 0)) #_"int" i 1]
                                                     (< i (count predecessors))
                                                     [(+ probability (:probability (nth predecessors i))) (inc i)]
                                                  => probability
                                    )
                            ]
                                (when (instance? LoopBeginNode (:beginNode block)) => probability
                                    (ControlFlowGraph'multiplyProbabilities-2 probability, (:loopFrequency (:beginNode block)))
                                )
                            )
                    )
                probability
                    (cond
                        (< probability ControlFlowGraph'MIN_PROBABILITY) ControlFlowGraph'MIN_PROBABILITY
                        (< ControlFlowGraph'MAX_PROBABILITY probability) ControlFlowGraph'MAX_PROBABILITY
                        :else                                            probability
                    )
            ]
                (§ ass! block (Block''setProbability-2 block, probability))
            )
        )
        nil
    )

    (§ method- #_"ControlFlowGraph" ControlFlowGraph''computeLoopInformation-1 [#_"ControlFlowGraph" this]
        (let [
            this (assoc this :loops (ArrayList.))
        ]
            (when (Graph''hasLoops-1 (:graph this))
                (let [
                    #_"Block[]" stack (make-array Block (count (:reversePostOrder this)))
                ]
                    (doseq [#_"Block" block (:reversePostOrder this)]
                        (let [
                            #_"AbstractBeginNode" beginNode (:beginNode block)
                        ]
                            (when (instance? LoopBeginNode beginNode)
                                (let [
                                    #_"Loop" parent (:loop block)
                                    #_"Loop" loop (Loop'new-3 parent, (count (:loops this)), block)
                                ]
                                    (when (some? parent)
                                        (#_"List" .add (:children parent), loop)
                                    )
                                    (#_"List" .add (:loops this), loop)
                                    (§ ass! block (Block''setLoop-2 block, loop))
                                    (#_"List" .add (:blocks loop), block)

                                    (doseq [#_"LoopEndNode" end (LoopBeginNode''loopEnds-1 beginNode)]
                                        (ControlFlowGraph'computeLoopBlocks-4 (NodeMap''get-2 (:nodeToBlock this), end), loop, stack, true)
                                    )

                                    (when-not (= (:guardsStage (:graph this)) GuardsStage'AFTER_FSA)
                                        (doseq [#_"LoopExitNode" exit (LoopBeginNode''loopExits-1 beginNode)]
                                            (let [
                                                #_"Block" exitBlock (NodeMap''get-2 (:nodeToBlock this), exit)
                                            ]
                                                (ControlFlowGraph'computeLoopBlocks-4 (Block''getFirstPredecessor-1 exitBlock), loop, stack, true)
                                                (Loop''addExit-2 loop, exitBlock)
                                            )
                                        )

                                        ;; The following loop can add new blocks to the end of the loop's block list.
                                        (dotimes [#_"int" i (count (:blocks loop))]
                                            (doseq [#_"Block" sux (:successors (nth (:blocks loop) i))]
                                                (when-not (or (= (:loop sux) loop) (and (instance? LoopExitNode (:beginNode sux)) (= (:loopBegin (:beginNode sux)) beginNode)))
                                                    (ControlFlowGraph'computeLoopBlocks-4 sux, loop, stack, false)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )

            ;; Compute the loop exit blocks after FSA.
            (when (= (:guardsStage (:graph this)) GuardsStage'AFTER_FSA)
                (doseq [#_"Block" b (:reversePostOrder this)]
                    (when (some? (:loop b))
                        (doseq [#_"Block" succ (:successors b)]
                            ;; if the loop of the succ is a different one (or none)
                            (when-not (= (:loop b) (:loop succ))
                                ;; and the succ loop is not a child loop of the curr one
                                (if (nil? (:loop succ))
                                    ;; we might exit multiple loops if b.loops is not a loop at depth 0
                                    (loop-when-recur [#_"Loop" curr (:loop b)] (some? curr) [(:parent curr)]
                                        (Loop''addExit-2 curr, succ)
                                    )
                                    ;; succ also has a loop, might be a child loop
                                    ;;
                                    ;; if it is a child loop, we do not exit a loop. if it is a loop
                                    ;; different than b.loop and not a child loop, it must be a parent
                                    ;; loop, thus we exit all loops between b.loop and succ.loop
                                    ;;
                                    ;; if we exit multiple loops immediately after each other, the bytecode parser
                                    ;; might generate loop exit nodes after another and the CFG will identify them
                                    ;; as separate blocks, we just take the first one and exit all loops at this one
                                    (when-not (= (:parent (:loop succ)) (:loop b))
                                        ;; b.loop must not be a transitive parent of succ.loop
                                        (loop-when-recur [#_"Loop" curr (:loop b)] (and (some? curr) (not= curr (:loop succ))) [(:parent curr)]
                                            (Loop''addExit-2 curr, succ)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            this
        )
    )

    (§ defn- #_"void" ControlFlowGraph'computeLoopBlocks-4 [#_"Block" start, #_"Loop" loop, #_"Block[]" stack, #_"boolean" usePred]
        (when-not (= (:loop start) loop)
            (§ ass! start (Block''setLoop-2 start, loop))
            (aset stack 0 start)
            (#_"List" .add (:blocks loop), start)
            (loop [#_"int" tos 0]
                (let [
                    #_"Block" block (nth stack tos)
                    tos (dec tos)
                    ;; Add predecessors or successors to the loop.
                    tos
                        (loop-when [tos tos #_"ISeq" s (seq (if usePred (:predecessors block) (:successors block)))] (some? s) => tos
                            (let [
                                #_"Block" b (first s)
                                tos
                                    (when-not (= (:loop b) loop) => tos
                                        (let [
                                            tos (inc tos)
                                        ]
                                            (aset stack tos b)
                                            (§ ass! b (Block''setLoop-2 b, loop))
                                            (#_"List" .add (:blocks loop), b)
                                            tos
                                        )
                                    )
                            ]
                                (recur tos (next s))
                            )
                        )
                ]
                    (recur-if (<= 0 tos) [tos])
                )
            )
        )
        nil
    )

    (§ method! #_"void" ControlFlowGraph''computePostdominators-1 [#_"ControlFlowGraph" this]
        (loop-when [#_"int" i (dec (count (:reversePostOrder this)))] (<= 0 i)
            (let [
                #_"Block" block (nth (:reversePostOrder this) i)
            ]
                ;; => We do not want the loop header registered as the postdominator of the loop end. ;; => No successors => no postdominator.
                (when (and (not (Block''isLoopEnd-1 block)) (seq (:successors block)))
                    (let [
                        #_"Block" firstSucc (nth (:successors block) 0)
                    ]
                        (if (= (count (:successors block)) 1)
                            (§ ass! block (assoc block :postdominator firstSucc))
                            (loop-when [#_"Block" postdominator firstSucc #_"ISeq" s (seq (:successors block))] (some? s) => (§ ass! block (Block''setPostDominator-2 block, postdominator))
                                (let [
                                    postdominator (ControlFlowGraph'commonPostdominator-2 postdominator, (first s))
                                ]
                                    (when (some? postdominator) ;; => There is a dead end => no postdominator available.
                                        (recur postdominator (next s))
                                    )
                                )
                            )
                        )
                    )
                )
                (recur (dec i))
            )
        )
        nil
    )

    (§ defn- #_"Block" ControlFlowGraph'commonPostdominator-2 [#_"Block" a, #_"Block" b]
        (loop-when [a a b b] (not= a b) => a
            (if (< (:id a) (:id b))
                (let [
                    a (:postdominator a)
                ]
                    (recur-if (some? a) [a b])
                )
                (let [
                    b (:postdominator b)
                ]
                    (recur-if (some? b) [a b])
                )
            )
        )
    )

    (§ method! #_"ControlFlowGraph" ControlFlowGraph''setNodeToBlock-2 [#_"ControlFlowGraph" this, #_"NodeMap<Block>" nodeMap]
        (assoc this :nodeToBlock nodeMap)
    )

    ;;;
     ; Multiplies a and b and clamps the between ControlFlowGraph#MIN_PROBABILITY and
     ; ControlFlowGraph#MAX_PROBABILITY.
     ;;
    (§ defn #_"double" ControlFlowGraph'multiplyProbabilities-2 [#_"double" a, #_"double" b]
        (let [
            #_"double" r (* a b)
        ]
            (cond
                (< ControlFlowGraph'MAX_PROBABILITY r) ControlFlowGraph'MAX_PROBABILITY
                (< r ControlFlowGraph'MIN_PROBABILITY) ControlFlowGraph'MIN_PROBABILITY
                :else                                  r
            )
        )
    )

    ;;;
     ; True if block {@code a} is dominated by block {@code b}.
     ;;
    (§ defn #_"boolean" ControlFlowGraph'isDominatedBy-2 [#_"Block" a, #_"Block" b]
        (<= (:domNumber b) (:domNumber a) (:maxChildDomNumber b))
    )

    ;;;
     ; True if block {@code a} dominates block {@code b} and {@code a} is not identical block to {@code b}.
     ;;
    #_unused
    (§ defn #_"boolean" ControlFlowGraph'strictlyDominates-2 [#_"Block" a, #_"Block" b]
        (and (not= a b) (ControlFlowGraph'dominates-2 a, b))
    )

    ;;;
     ; True if block {@code a} dominates block {@code b}.
     ;;
    (§ defn #_"boolean" ControlFlowGraph'dominates-2 [#_"Block" a, #_"Block" b]
        (ControlFlowGraph'isDominatedBy-2 b, a)
    )

    ;;;
     ; Calculates the common dominator of two blocks.
     ;
     ; Note that this algorithm makes use of special properties regarding the numbering of blocks.
     ;;
    (§ defn #_"Block" ControlFlowGraph'commonDominator-2 [#_"Block" a, #_"Block" b]
        (cond
            (nil? a) b (nil? b) a (= a b) a
            :else
                (let [
                    [a b] (if (< (:domDepth b) (:domDepth a)) [a b] [b a])
                    b (loop-when-recur b (< (:domNumber a)         (:domNumber b)) (:dominator b) => b)
                    b (loop-when-recur b (< (:maxChildDomNumber b) (:domNumber a)) (:dominator b) => b)
                ]
                    b
                )
        )
    )
)

;;;
 ; @anno ControlFlowGraph.RecursiveVisitor
 ;;
(§ interface RecursiveVisitor #_"<V>"
    (§ abstract #_"V" RecursiveVisitor''enter-2 [#_"RecursiveVisitor<V>" this, #_"Block" b])

    (§ abstract #_"void" RecursiveVisitor''exit-3 [#_"RecursiveVisitor<V>" this, #_"Block" b, #_"V" value])
)

;;;
 ; @anno ControlFlowGraph.DeferredExit
 ;;
(final-ns DeferredExit
    (§ final #_"Block" :block nil)
    (§ final #_"DeferredExit" :next nil)

    (§ defn #_"DeferredExit" DeferredExit'new-2 [#_"Block" block, #_"DeferredExit" next]
        (let [
            #_"DeferredExit" this (Object.)
            this (assoc this :block block)
            this (assoc this :next next)
        ]
            this
        )
    )
)

(final-ns LocationSet
    (§ mutable #_"LocationIdentity" :firstLocation nil)
    (§ mutable #_"List<LocationIdentity>" :list nil)

    (§ defn #_"LocationSet" LocationSet'new-0 []
        (let [
            #_"LocationSet" this (Object.)
            this (assoc this :list nil)
        ]
            this
        )
    )

    #_unused
    (§ defn #_"LocationSet" LocationSet'new-1 [#_"LocationSet" other]
        (let [
            #_"LocationSet" this (Object.)
            this (assoc this :firstLocation (:firstLocation other))
            this
                (when (seq (:list other)) => this
                    (assoc this :list (ArrayList. (:list other)))
                )
        ]
            this
        )
    )

    (§ method- #_"LocationSet" LocationSet''initList-1 [#_"LocationSet" this]
        (when (nil? (:list this)) => this
            (assoc this :list (ArrayList.))
        )
    )

    #_unused
    (§ method! #_"boolean" LocationSet''isEmpty-1 [#_"LocationSet" this]
        (nil? (:firstLocation this))
    )

    (§ method! #_"boolean" LocationSet''isAny-1 [#_"LocationSet" this]
        (and (some? (:firstLocation this)) (#_"LocationIdentity" .isAny (:firstLocation this)))
    )

    (§ method! #_"LocationSet" LocationSet''add-2 [#_"LocationSet" this, #_"LocationIdentity" location]
        (cond
            (LocationSet''isAny-1 this)                this
            (LocationSet''isAny-1 location)            (assoc this :firstLocation location :list nil)
            (#_"LocationIdentity" .isImmutable location) this
            (nil? (:firstLocation this))               (assoc this :firstLocation location)
            (= location (:firstLocation this))         this
            :else
                (let [
                    this (LocationSet''initList-1 this)
                ]
                    (loop-when [#_"int" i 0] (< i (count (:list this))) => (#_"List" .add (:list this), location)
                        (when-not (= (nth (:list this) i) location)
                            (recur (inc i))
                        )
                    )
                    this
                )
        )
    )

    (§ method! #_"LocationSet" LocationSet''addAll-2 [#_"LocationSet" this, #_"LocationSet" other]
        (let [
            this
                (when (some? (:firstLocation other)) => this
                    (LocationSet''add-2 this, (:firstLocation other))
                )
        ]
            (doseq [#_"LocationIdentity" l (:list other)]
                (§ ass! this (LocationSet''add-2 this, l))
            )
            this
        )
    )

    (§ method! #_"boolean" LocationSet''contains-2 [#_"LocationSet" this, #_"LocationIdentity" locationIdentity]
        (or (any = (:firstLocation this) (LocationIdentity/any) locationIdentity)
            (and (some? (:list this))
                (loop-when [#_"int" i 0] (< i (count (:list this))) => false
                    (or (= locationIdentity (nth (:list this) i))
                        (recur (inc i))
                    )
                )
            )
        )
    )
)

;;;
 ; Compress or uncompress an oop or metaspace pointer.
 ;;
(class-ns CompressionNode (§ extends UnaryNode) (§ implements ConvertNode, LIRLowerable)
    (§ def #_"NodeClass<CompressionNode>" CompressionNode'TYPE (NodeClass'create-1 CompressionNode))

    (§ final #_"CompressionOp" :op nil)
    (§ final #_"CompressEncoding" :encoding nil)

    (§ defn #_"CompressionNode" CompressionNode'new-5 [#_"NodeClass<? extends UnaryNode>" c, #_"CompressionOp" op, #_"ValueNode" input, #_"Stamp" stamp, #_"CompressEncoding" encoding]
        (let [
            #_"CompressionNode" this (UnaryNode'new-3 c, stamp, input)
            this (assoc this :op op)
            this (assoc this :encoding encoding)
        ]
            this
        )
    )

    #_unused
    (§ override #_"Stamp" CompressionNode''foldStamp-2 [#_"CompressionNode" this, #_"Stamp" stamp]
        (CompressionNode''mkStamp-2 this, stamp)
    )

    (§ abstract #_"Constant" CompressionNode''compress-2 [#_"CompressionNode" this, #_"Constant" constant])

    (§ abstract #_"Constant" CompressionNode''uncompress-2 [#_"CompressionNode" this, #_"Constant" constant])

    (§ override #_"Constant" CompressionNode''convert-2 [#_"CompressionNode" this, #_"Constant" constant]
        (condp = (:op this)
            CompressionOp'Compress   (CompressionNode''compress-2 this, constant)
            CompressionOp'Uncompress (CompressionNode''uncompress-2 this, constant)
        )
    )

    #_unused
    (§ override #_"Constant" CompressionNode''reverse-2 [#_"CompressionNode" this, #_"Constant" constant]
        (condp = (:op this)
            CompressionOp'Compress   (CompressionNode''uncompress-2 this, constant)
            CompressionOp'Uncompress (CompressionNode''compress-2 this, constant)
        )
    )

    #_unused
    (§ override #_"boolean" CompressionNode''isLossless-1 [#_"CompressionNode" this]
        true
    )

    (§ abstract #_"Stamp" CompressionNode''mkStamp-2 [#_"CompressionNode" this, #_"Stamp" input])

    (§ method #_"CompressionOp" CompressionNode''getOp-1 [#_"CompressionNode" this]
        (:op this)
    )

    (§ method #_"CompressEncoding" CompressionNode''getEncoding-1 [#_"CompressionNode" this]
        (:encoding this)
    )

    #_unused
    (§ override #_"ValueNode" CompressionNode''canonical-3 [#_"CompressionNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (cond
            (instance? ConstantNode value)
                (ConstantNode'forConstant-4 (:stamp this), (CompressionNode''convert-2 this, (:value value)), (:stableDimension value), (:isDefaultStable value))
            (instance? CompressionNode value)
                (when (and (not= (:op this) (:op value)) (= (:encoding this) (:encoding value))) => this
                    (UnaryNode''getValue-1 value)
                )
            :else
                this
        )
    )

    #_unused
    (§ override #_"void" CompressionNode''generate-2 [#_"CompressionNode" this, #_"LIRBuilder" builder]
        (let [
            #_"boolean" never-nil?
                (if (instance? AbstractObjectStamp (:stamp (:value this)))
                    (StampTool'isPointerNeverNull-1 (:stamp (:value this)))
                    true ;; metaspace pointers are never nil
                )
            #_"Value" result
                (condp = (:op this)
                    CompressionOp'Compress
                        (LIRGenerator''emitCompress-4 (:gen builder), (LIRBuilder''operand-2 builder, (:value this)), (:encoding this), never-nil?)
                    CompressionOp'Uncompress
                        (LIRGenerator''emitUncompress-4 (:gen builder), (LIRBuilder''operand-2 builder, (:value this)), (:encoding this), never-nil?)
                )
        ]
            (LIRBuilder''setResult-3 builder, this, result)
        )
        nil
    )

    #_unused
    (§ override #_"boolean" CompressionNode''mayNullCheckSkipConversion-1 [#_"CompressionNode" this]
        true
    )
)

;;;
 ; @anno CompressionNode.CompressionOp
 ;;
(value-ns CompressionOp
    (§ enum CompressionOp'Compress)
    (§ enum CompressionOp'Uncompress)
)

;; @NodeInfo.allowedUsageTypes "InputType.Guard"
(final-ns ConditionAnchorNode (§ extends FixedWithNextNode) (§ implements Unary #_"<Node>", Lowerable, GuardingNode)
    (§ def #_"NodeClass<ConditionAnchorNode>" ConditionAnchorNode'TYPE (NodeClass'create-1 ConditionAnchorNode))

    ; @Input(InputType'ConditionI)
    (§ mutable #_"LogicNode" :condition nil)
    (§ mutable #_"boolean" :negated? false)

    #_unused
    (§ defn #_"ConditionAnchorNode" ConditionAnchorNode'new-1 [#_"LogicNode" condition]
        (ConditionAnchorNode'new-2 condition, false)
    )

    (§ defn #_"ConditionAnchorNode" ConditionAnchorNode'new-2 [#_"LogicNode" condition, #_"boolean" negated?]
        (let [
            #_"ConditionAnchorNode" this (FixedWithNextNode'new-2 ConditionAnchorNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :negated? negated?)
            this (assoc this :condition condition)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Node" ConditionAnchorNode''canonical-3 [#_"ConditionAnchorNode" this, #_"CanonicalizerTool" tool, #_"Node" value]
        (condp instance? value
            LogicNegationNode
                (ConditionAnchorNode'new-2 (LogicNegationNode''getValue-1 value), (not (:negated? this)))
            LogicConstantNode
                (when (= (:value value) (:negated? this))
                    (ValueAnchorNode'new-1 nil)
                )
            (when-not (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                this
            )
        )
    )

    #_unused
    (§ override! #_"void" ConditionAnchorNode''lower-2 [#_"ConditionAnchorNode" this, #_"LoweringTool" lowerer]
        (let [
            #_"Graph" graph (:graph this)
        ]
            (when (= (:guardsStage graph) GuardsStage'FIXED_DEOPTS)
                (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, this, (Graph''add-2 graph, (ValueAnchorNode'new-1 nil))))
            )
        )
        nil
    )

    #_unused
    (§ override! #_"Node" ConditionAnchorNode''getValue-1 [#_"ConditionAnchorNode" this]
        (:condition this)
    )
)

;;;
 ; The ConstantNode represents a {@link Constant constant}.
 ;;
(final-ns ConstantNode (§ extends FloatingNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<ConstantNode>" ConstantNode'TYPE (NodeClass'create-1 ConstantNode))

    ;;;
     ; the constant value represented by this node
     ;;
    (§ final #_"Constant" :value nil)
    ;;;
     ; the number of stable dimensions if this is a stable array, otherwise 0
     ;;
    (§ final #_"int" :stableDimension 0)
    ;;;
     ; true if this is a stable array and the default elements are considered stable
     ;;
    (§ final #_"boolean" :isDefaultStable false)

    (§ defn- #_"ConstantNode" ConstantNode'new-4 [#_"Constant" value, #_"Stamp" stamp, #_"int" stableDimension, #_"boolean" isDefaultStable]
        (let [
            #_"ConstantNode" this (FloatingNode'new-2 ConstantNode'TYPE, stamp)
            this (assoc this :value value)
            this (assoc this :stableDimension stableDimension)
            ;; Ensure that isDefaultStable has a canonical value to avoid having two constant nodes that only differ
            ;; in this field. The value of isDefaultStable is only used when we have a stable array dimension.
            this (assoc this :isDefaultStable (and isDefaultStable (not (zero? stableDimension))))
        ]
            this
        )
    )

    ;;;
     ; Constructs a new node representing the specified constant.
     ;
     ; @param value the constant
     ;;
    (§ defn #_"ConstantNode" ConstantNode'new-2 [#_"Constant" value, #_"Stamp" stamp]
        (ConstantNode'new-4 value, stamp, 0, false)
    )

    ;;;
     ; Gathers all the ConstantNodes that are inputs to the
     ; {@linkplain Graph#getNodes() live nodes} in a given graph.
     ;;
    #_unused
    (§ defn #_"NodeIterable<ConstantNode>" ConstantNode'getConstantNodes-1 [#_"Graph" graph]
        (NodeIterable''filter-2 (Graph''getNodes-1 graph), ConstantNode)
    )

    ;;;
     ; Replaces this node at its usages with another node.
     ;;
    #_unused
    (§ method! #_"void" ConstantNode''replace-3 [#_"ConstantNode" this, #_"Graph" graph, #_"Node" replacement]
        (Node''replaceAtUsagesAndDelete-2 this, replacement)
        nil
    )

    #_unused
    (§ override! #_"void" ConstantNode''generate-2 [#_"ConstantNode" this, #_"LIRBuilder" builder]
        (let [
            #_"LIRKind" kind (Stamp''getLIRKind-1 (:stamp this))
        ]
            (if (ConstantNode''onlyUsedInVirtualState-1 this)
                (LIRBuilder''setResult-3 builder, this, (ConstantValue'new-2 kind, (:value this)))
                (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitConstant-3 (:gen builder), kind, (:value this)))
            )
        )
        nil
    )

    (§ method- #_"boolean" ConstantNode''onlyUsedInVirtualState-1 [#_"ConstantNode" this]
        (loop-when [#_"ISeq" s (seq (Node''usages-1 this))] (some? s) => true
            (and (instance? VirtualState (first s))
                (recur (next s))
            )
        )
    )

    (§ defn- #_"ConstantNode" ConstantNode'createPrimitive-1 [#_"JavaConstant" value]
        (ConstantNode'new-2 value, (StampFactory'forPrimitiveConstant-1 value))
    )

    (§ defn #_"ConstantNode" ConstantNode'forConstant-2 [#_"JavaConstant" constant, #_"Graph" graph]
        (cond
            (and (= (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind constant)) JavaKind/Int) (not= (#_"JavaConstant" .getJavaKind constant) JavaKind/Int))
                (ConstantNode'forInt-2 (#_"JavaConstant" .asInt constant), graph)
            (= (#_"JavaConstant" .getJavaKind constant) JavaKind/Object)
                (Graph''add-2 graph, (ConstantNode'new-2 constant, (StampFactory'forConstant-1 constant)))
            :else
                (Graph''add-2 graph, (ConstantNode'createPrimitive-1 constant))
        )
    )

    (§ defn #_"ConstantNode" ConstantNode'forConstant-3 [#_"JavaConstant" constant, #_"int" stableDimension, #_"boolean" isDefaultStable]
        (cond
            (and (= (#_"JavaKind" .getStackKind (#_"JavaConstant" .getJavaKind constant)) JavaKind/Int) (not= (#_"JavaConstant" .getJavaKind constant) JavaKind/Int))
                (ConstantNode'forInt-1 (#_"JavaConstant" .asInt constant))
            (= (#_"JavaConstant" .getJavaKind constant) JavaKind/Object)
                (ConstantNode'new-4 constant, (StampFactory'forConstant-1 constant), stableDimension, isDefaultStable)
            :else
                (ConstantNode'createPrimitive-1 constant)
        )
    )

    (§ defn #_"ConstantNode" ConstantNode'forConstant-1 [#_"JavaConstant" array]
        (ConstantNode'forConstant-3 array, 0, false)
    )

    (§ defn #_"ConstantNode" ConstantNode'forConstant-3 [#_"Stamp" stamp, #_"Constant" constant, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'new-2 constant, (Stamp''constant-2 stamp, constant)))
    )

    (§ defn #_"ConstantNode" ConstantNode'forConstant-4 [#_"Stamp" stamp, #_"Constant" constant, #_"int" stableDimension, #_"boolean" isDefaultStable]
        (ConstantNode'new-4 constant, (Stamp''constant-2 stamp, constant), stableDimension, isDefaultStable)
    )

    (§ defn #_"ConstantNode" ConstantNode'forConstant-2 [#_"Stamp" stamp, #_"Constant" constant]
        (ConstantNode'new-2 constant, (Stamp''constant-2 stamp, constant))
    )

    ;;;
     ; Returns a node for a Java primitive.
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forPrimitive-2 [#_"JavaConstant" constant, #_"Graph" graph]
        (ConstantNode'forConstant-2 constant, graph)
    )

    ;;;
     ; Returns a node for a Java primitive.
     ;;
    #_unused
    (§ defn #_"ConstantNode" ConstantNode'forPrimitive-1 [#_"JavaConstant" constant]
        (ConstantNode'forConstant-1 constant)
    )

    ;;;
     ; Returns a node for a primitive of a given type.
     ;;
    #_unused
    (§ defn #_"ConstantNode" ConstantNode'forPrimitive-3 [#_"Stamp" stamp, #_"JavaConstant" constant, #_"Graph" graph]
        (if (instance? IntegerStamp stamp)
            (ConstantNode'forIntegerBits-3 (:bits stamp), constant, graph)
            (ConstantNode'forPrimitive-2 constant, graph)
        )
    )

    ;;;
     ; Returns a node for a primitive of a given type.
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forPrimitive-2 [#_"Stamp" stamp, #_"Constant" constant]
        (if (instance? IntegerStamp stamp)
            (ConstantNode'forIntegerBits-2 (:bits stamp), constant)
            (ConstantNode'new-2 constant, (Stamp''constant-2 stamp, constant))
        )
    )

    ;;;
     ; Returns a node for an long constant.
     ;
     ; @param i the long value for which to create the instruction
     ; @return a node for an long constant
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forLong-2 [#_"long" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forLong i)))
    )

    ;;;
     ; Returns a node for an long constant.
     ;
     ; @param i the long value for which to create the instruction
     ; @return a node for an long constant
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forLong-1 [#_"long" i]
        (ConstantNode'createPrimitive-1 (JavaConstant/forLong i))
    )

    ;;;
     ; Returns a node for an integer constant.
     ;
     ; @param i the integer value for which to create the instruction
     ; @return a node for an integer constant
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forInt-2 [#_"int" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt i)))
    )

    ;;;
     ; Returns a node for an integer constant.
     ;
     ; @param i the integer value for which to create the instruction
     ; @return a node for an integer constant
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forInt-1 [#_"int" i]
        (ConstantNode'createPrimitive-1 (JavaConstant/forInt i))
    )

    ;;;
     ; Returns a node for a boolean constant.
     ;
     ; @param i the boolean value for which to create the instruction
     ; @return a node representing the boolean
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forBoolean-2 [#_"boolean" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt (if i 1 0))))
    )

    ;;;
     ; Returns a node for a boolean constant.
     ;
     ; @param i the boolean value for which to create the instruction
     ; @return a node representing the boolean
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forBoolean-1 [#_"boolean" i]
        (ConstantNode'createPrimitive-1 (JavaConstant/forInt (if i 1 0)))
    )

    ;;;
     ; Returns a node for a byte constant.
     ;
     ; @param i the byte value for which to create the instruction
     ; @return a node representing the byte
     ;;
    #_unused
    (§ defn #_"ConstantNode" ConstantNode'forByte-2 [#_"byte" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt i)))
    )

    ;;;
     ; Returns a node for a char constant.
     ;
     ; @param i the char value for which to create the instruction
     ; @return a node representing the char
     ;;
    #_unused
    (§ defn #_"ConstantNode" ConstantNode'forChar-2 [#_"char" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt i)))
    )

    ;;;
     ; Returns a node for a short constant.
     ;
     ; @param i the short value for which to create the instruction
     ; @return a node representing the short
     ;;
    #_unused
    (§ defn #_"ConstantNode" ConstantNode'forShort-2 [#_"short" i, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'createPrimitive-1 (JavaConstant/forInt i)))
    )

    (§ defn- #_"ConstantNode" ConstantNode'forIntegerBits-3 [#_"int" bits, #_"JavaConstant" constant, #_"Graph" graph]
        (let [
            #_"long" bounds (CodeUtil/signExtend (#_"JavaConstant" .asLong constant), bits)
        ]
            (Graph''add-2 graph, (ConstantNode'new-2 constant, (StampFactory'forInteger-3 bits, bounds, bounds)))
        )
    )

    ;;;
     ; Returns a node for a constant integer that's not directly representable as Java primitive (e.g. short).
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forIntegerBits-3 [#_"int" bits, #_"long" value, #_"Graph" graph]
        (ConstantNode'forIntegerBits-3 bits, (JavaConstant/forPrimitiveInt bits, value), graph)
    )

    (§ defn- #_"ConstantNode" ConstantNode'forIntegerBits-2 [#_"int" bits, #_"JavaConstant" constant]
        (let [
            #_"long" bounds (CodeUtil/signExtend (#_"JavaConstant" .asLong constant), bits)
        ]
            (ConstantNode'new-2 constant, (StampFactory'forInteger-3 bits, bounds, bounds))
        )
    )

    ;;;
     ; Returns a node for a constant integer that's not directly representable as Java primitive (e.g. short).
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forIntegerBits-2 [#_"int" bits, #_"long" value]
        (ConstantNode'forIntegerBits-2 bits, (JavaConstant/forPrimitiveInt bits, value))
    )

    ;;;
     ; Returns a node for a constant integer that's compatible to a given stamp.
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forIntegerStamp-3 [#_"Stamp" stamp, #_"long" value, #_"Graph" graph]
        (if (instance? IntegerStamp stamp)
            (ConstantNode'forIntegerBits-3 (:bits stamp), value, graph)
            (ConstantNode'forIntegerKind-3 (Stamp''getStackKind-1 stamp), value, graph)
        )
    )

    ;;;
     ; Returns a node for a constant integer that's compatible to a given stamp.
     ;;
    (§ defn #_"ConstantNode" ConstantNode'forIntegerStamp-2 [#_"Stamp" stamp, #_"long" value]
        (if (instance? IntegerStamp stamp)
            (ConstantNode'forIntegerBits-2 (:bits stamp), value)
            (ConstantNode'forIntegerKind-2 (Stamp''getStackKind-1 stamp), value)
        )
    )

    (§ defn #_"ConstantNode" ConstantNode'forIntegerKind-3 [#_"JavaKind" kind, #_"long" value, #_"Graph" graph]
        (condp =? kind
           [JavaKind/Byte JavaKind/Short JavaKind/Int] (ConstantNode'forInt-2 (int value), graph)
            JavaKind/Long                              (ConstantNode'forLong-2 value, graph)
        )
    )

    (§ defn #_"ConstantNode" ConstantNode'forIntegerKind-2 [#_"JavaKind" kind, #_"long" value]
        (condp =? kind
           [JavaKind/Byte JavaKind/Short JavaKind/Int] (ConstantNode'createPrimitive-1 (JavaConstant/forInt (int value)))
            JavaKind/Long                              (ConstantNode'createPrimitive-1 (JavaConstant/forLong value))
        )
    )

    (§ defn #_"ConstantNode" ConstantNode'defaultForKind-2 [#_"JavaKind" kind, #_"Graph" graph]
        (Graph''add-2 graph, (ConstantNode'defaultForKind-1 kind))
    )

    (§ defn #_"ConstantNode" ConstantNode'defaultForKind-1 [#_"JavaKind" kind]
        (condp =? kind
           [JavaKind/Boolean JavaKind/Byte JavaKind/Char JavaKind/Short JavaKind/Int] (ConstantNode'forInt-1 0)
            JavaKind/Long                                                             (ConstantNode'forLong-1 0)
            JavaKind/Object                                                           (ConstantNode'forConstant-1 JavaConstant/NULL_POINTER)
            nil
        )
    )
)

(class-ns ControlSinkNode (§ extends FixedNode)
    (§ def #_"NodeClass<ControlSinkNode>" ControlSinkNode'TYPE (NodeClass'create-1 ControlSinkNode))

    (§ defn #_"ControlSinkNode" ControlSinkNode'new-2 [#_"NodeClass<? extends ControlSinkNode>" c, #_"Stamp" stamp]
        (FixedNode'new-2 c, stamp)
    )
)

;;;
 ; The ControlSplitNode is a base class for all instructions that split the control flow
 ; (i.e. have more than one successor).
 ;;
(class-ns ControlSplitNode (§ extends FixedNode) (§ implements IterableNodeType)
    (§ def #_"NodeClass<ControlSplitNode>" ControlSplitNode'TYPE (NodeClass'create-1 ControlSplitNode))

    (§ defn #_"ControlSplitNode" ControlSplitNode'new-2 [#_"NodeClass<? extends ControlSplitNode>" c, #_"Stamp" stamp]
        (FixedNode'new-2 c, stamp)
    )

    (§ abstract #_"double" ControlSplitNode''probability-2 [#_"ControlSplitNode" this, #_"AbstractBeginNode" successor])

    ;;;
     ; Attempts to set the probability for the given successor to the passed value (which has to be
     ; in the range of 0.0 and 1.0). Returns whether setting the probability was successful.
     ;;
    (§ abstract #_"boolean" ControlSplitNode''setProbability-3 [#_"ControlSplitNode" this, #_"AbstractBeginNode" successor, #_"double" value])

    ;;;
     ; Primary successor of the control split. Data dependencies on the node have to be scheduled in
     ; the primary successor. Returns nil if data dependencies are not expected.
     ;
     ; @return the primary successor
     ;;
    (§ abstract #_"AbstractBeginNode" ControlSplitNode''getPrimarySuccessor-1 [#_"ControlSplitNode" this])

    ;;;
     ; Returns the number of successors.
     ;;
    (§ abstract #_"int" ControlSplitNode''getSuccessorCount-1 [#_"ControlSplitNode" this])
)

(final-ns BindToRegisterNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<BindToRegisterNode>" BindToRegisterNode'TYPE (NodeClass'create-1 BindToRegisterNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)

    #_unused
    (§ defn #_"BindToRegisterNode" BindToRegisterNode'new-1 [#_"ValueNode" value]
        (let [
            #_"BindToRegisterNode" this (FixedWithNextNode'new-2 BindToRegisterNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" BindToRegisterNode''generate-2 [#_"BindToRegisterNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''append-2 (:gen builder), (BindToRegisterOp'new-1 (LIRGenerator''asAllocatable-2 (:gen builder), (LIRBuilder''operand-2 builder, (:value this)))))
        nil
    )
)

(final-ns BlackholeNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<BlackholeNode>" BlackholeNode'TYPE (NodeClass'create-1 BlackholeNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)

    #_unused
    (§ defn #_"BlackholeNode" BlackholeNode'new-1 [#_"ValueNode" value]
        (let [
            #_"BlackholeNode" this (FixedWithNextNode'new-2 BlackholeNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" BlackholeNode''generate-2 [#_"BlackholeNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''emitBlackhole-2 (:gen builder), (LIRBuilder''operand-2 builder, (:value this)))
        nil
    )
)

;;;
 ; Marker interface for nodes that prevents control flow optimizations. The node should never be duplicated.
 ;;
(§ interface ControlFlowAnchored
)

(final-ns ControlFlowAnchorNode (§ extends FixedWithNextNode) (§ implements LIRLowerable, ControlFlowAnchored)
    (§ def #_"NodeClass<ControlFlowAnchorNode>" ControlFlowAnchorNode'TYPE (NodeClass'create-1 ControlFlowAnchorNode))

    (§ mutable #_"Unique" :unique nil)

    (§ defn #_"ControlFlowAnchorNode" ControlFlowAnchorNode'new-0 []
        (let [
            #_"ControlFlowAnchorNode" this (FixedWithNextNode'new-2 ControlFlowAnchorNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :unique (Unique'new-0))
        ]
            this
        )
    )

    ;;;
     ; Used by MacroSubstitution.
     ;;
    #_unused
    (§ defn #_"ControlFlowAnchorNode" ControlFlowAnchorNode'new-1 [#_"InvokeNode" invoke]
        (ControlFlowAnchorNode'new-0)
    )

    #_unused
    (§ override! #_"void" ControlFlowAnchorNode''generate-2 [#_"ControlFlowAnchorNode" this, #_"LIRBuilder" builder]
        ;; do nothing
        nil
    )

    #_unused
    (§ override! #_"void" ControlFlowAnchorNode''afterClone-2 [#_"ControlFlowAnchorNode" this, #_"Node" other]
        nil
    )
)

;;;
 ; @anno ControlFlowAnchorNode.Unique
 ;;
(final-ns Unique
    (§ defn #_"Unique" Unique'new-0 []
        (Object.)
    )
)

(final-ns OpaqueNode (§ extends FloatingNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<OpaqueNode>" OpaqueNode'TYPE (NodeClass'create-1 OpaqueNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)

    #_unused
    (§ defn #_"OpaqueNode" OpaqueNode'new-1 [#_"ValueNode" value]
        (let [
            #_"OpaqueNode" this (FloatingNode'new-2 OpaqueNode'TYPE, (Stamp''unrestricted-1 (:stamp value)))
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" OpaqueNode''generate-2 [#_"OpaqueNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRBuilder''operand-2 builder, (:value this)))
        nil
    )
)

(final-ns SpillRegistersNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<SpillRegistersNode>" SpillRegistersNode'TYPE (NodeClass'create-1 SpillRegistersNode))

    (§ mutable #_"Object" :unique nil)

    #_unused
    (§ defn #_"SpillRegistersNode" SpillRegistersNode'new-0 []
        (let [
            #_"SpillRegistersNode" this (FixedWithNextNode'new-2 SpillRegistersNode'TYPE, (StampFactory'forVoid-0))
            ;; prevent control-flow optimization
            this (assoc this :unique (Object.))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" SpillRegistersNode''generate-2 [#_"SpillRegistersNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''append-2 (:gen builder), (SpillRegistersOp'new-0))
        nil
    )
)

;;;
 ; The StringToBytesNode transforms a compilation-time String into a byte array in the
 ; compiled code.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns StringToBytesNode (§ extends FixedWithNextNode) (§ implements Lowerable, Single)
    (§ def #_"NodeClass<StringToBytesNode>" StringToBytesNode'TYPE (NodeClass'create-1 StringToBytesNode))

    (§ final #_"String" :value nil)

    #_unused
    (§ defn #_"StringToBytesNode" StringToBytesNode'new-2 [#_"String" value, #_"Stamp" stamp]
        (let [
            #_"StringToBytesNode" this (FixedWithNextNode'new-2 StringToBytesNode'TYPE, stamp)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" StringToBytesNode''lower-2 [#_"StringToBytesNode" this, #_"LoweringTool" lowerer]
        (when (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph this)))
            (StringToBytesTemplates''lower-3 Lowerer'stringToBytesSnippets, this, lowerer)
        )
        nil
    )

    #_unused
    (§ override! #_"LocationIdentity" StringToBytesNode''getLocationIdentity-1 [#_"StringToBytesNode" this]
        (NamedLocationIdentity'getArrayLocation-1 JavaKind/Byte)
    )
)

(final-ns DeoptimizeNode (§ extends AbstractDeoptimizeNode) (§ implements Lowerable, LIRLowerable, StaticDeoptimizingNode)
    (def #_"int" DeoptimizeNode'DEFAULT_DEBUG_ID 0)

    (§ def #_"NodeClass<DeoptimizeNode>" DeoptimizeNode'TYPE (NodeClass'create-1 DeoptimizeNode))

    (§ mutable #_"DeoptimizationAction" :action nil)
    (§ mutable #_"DeoptimizationReason" :reason nil)
    (§ mutable #_"int" :debugId 0)
    (§ final #_"JavaConstant" :speculation nil)

    (§ defn #_"DeoptimizeNode" DeoptimizeNode'new-2 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason]
        (DeoptimizeNode'new-5 action, reason, DeoptimizeNode'DEFAULT_DEBUG_ID, JavaConstant/NULL_POINTER, nil)
    )

    (§ defn #_"DeoptimizeNode" DeoptimizeNode'new-3 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason, #_"JavaConstant" speculation]
        (DeoptimizeNode'new-5 action, reason, DeoptimizeNode'DEFAULT_DEBUG_ID, speculation, nil)
    )

    (§ defn #_"DeoptimizeNode" DeoptimizeNode'new-5 [#_"DeoptimizationAction" action, #_"DeoptimizationReason" reason, #_"int" debugId, #_"JavaConstant" speculation, #_"FrameState" stateBefore]
        (let [
            #_"DeoptimizeNode" this (AbstractDeoptimizeNode'new-2 DeoptimizeNode'TYPE, stateBefore)
            this (assoc this :action action)
            this (assoc this :reason reason)
            this (assoc this :debugId debugId)
            this (assoc this :speculation speculation)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" DeoptimizeNode''setAction-2 [#_"DeoptimizeNode" this, #_"DeoptimizationAction" action]
        (§ ass! this (assoc this :action action))
        nil
    )

    #_unused
    (§ override! #_"void" DeoptimizeNode''setReason-2 [#_"DeoptimizeNode" this, #_"DeoptimizationReason" reason]
        (§ ass! this (assoc this :reason reason))
        nil
    )

    (§ override! #_"void" DeoptimizeNode''lower-2 [#_"DeoptimizeNode" this, #_"LoweringTool" lowerer]
        nil ;; No lowering, we generate LIR directly for this node.
    )

    #_unused
    (§ override! #_"void" DeoptimizeNode''generate-2 [#_"DeoptimizeNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value" actionAndReason (LIRGenerator''emitJavaConstant-2 (:gen builder), (#_"MetaAccessProvider" .encodeDeoptActionAndReason HotSpot'metaAccess, (:action this), (:reason this), (:debugId this)))
            #_"Value" speculationValue (LIRGenerator''emitJavaConstant-2 (:gen builder), (:speculation this))
        ]
            (LIRGenerator''emitDeoptimize-3 (:gen builder), actionAndReason, speculationValue)
        )
        nil
    )

    #_unused
    (§ override! #_"ValueNode" DeoptimizeNode''getActionAndReason-1 [#_"DeoptimizeNode" this]
        (ConstantNode'forConstant-2 (#_"MetaAccessProvider" .encodeDeoptActionAndReason HotSpot'metaAccess, (:action this), (:reason this), (:debugId this)), (:graph this))
    )

    #_unused
    (§ override! #_"ValueNode" DeoptimizeNode''getSpeculation-1 [#_"DeoptimizeNode" this]
        (ConstantNode'forConstant-2 (:speculation this), (:graph this))
    )

    ; @NodeIntrinsic
    (§ native #_"void" DeoptimizeNode'deopt-2 [#_@ConstantNodeParameter #_"DeoptimizationAction" action, #_@ConstantNodeParameter #_"DeoptimizationReason" reason])
)

(class-ns DeoptimizingFixedWithNextNode (§ extends FixedWithNextNode) (§ implements DeoptBefore)
    (§ def #_"NodeClass<DeoptimizingFixedWithNextNode>" DeoptimizingFixedWithNextNode'TYPE (NodeClass'create-1 DeoptimizingFixedWithNextNode))

    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateBefore nil)

    (§ defn #_"DeoptimizingFixedWithNextNode" DeoptimizingFixedWithNextNode'new-2 [#_"NodeClass<? extends DeoptimizingFixedWithNextNode>" c, #_"Stamp" stamp]
        (FixedWithNextNode'new-2 c, stamp)
    )

    (§ defn #_"DeoptimizingFixedWithNextNode" DeoptimizingFixedWithNextNode'new-3 [#_"NodeClass<? extends DeoptimizingFixedWithNextNode>" c, #_"Stamp" stamp, #_"FrameState" stateBefore]
        (let [
            #_"DeoptimizingFixedWithNextNode" this (FixedWithNextNode'new-2 c, stamp)
            this (assoc this :stateBefore stateBefore)
        ]
            this
        )
    )

    (§ override #_"FrameState" DeoptimizingFixedWithNextNode''stateBefore-1 [#_"DeoptimizingFixedWithNextNode" this]
        (:stateBefore this)
    )

    (§ override #_"void" DeoptimizingFixedWithNextNode''setStateBefore-2 [#_"DeoptimizingFixedWithNextNode" this, #_"FrameState" f]
        (Node''updateUsages-3 this, (:stateBefore this), f)
        (§ ass! this (assoc this :stateBefore f))
        nil
    )
)

;;;
 ; Shared interface to capture core methods of AbstractFixedGuardNode and GuardNode.
 ;;
(§ interface DeoptimizingGuard (§ extends GuardingNode, StaticDeoptimizingNode)
    (§ abstract #_"LogicNode" DeoptimizingGuard''getCondition-1 [#_"DeoptimizingGuard" this])

    (§ abstract #_"void" DeoptimizingGuard''setCondition-3 [#_"DeoptimizingGuard" this, #_"LogicNode" x, #_"boolean" negated?])
)

;;;
 ; Interface implemented by nodes which may need deoptimization information.
 ;;
(§ interface DeoptimizingNode (§ extends NodeWithState)
    ;;;
     ; Determines if this node needs deoptimization information.
     ;;
    (§ abstract #_"boolean" DeoptimizingNode''canDeoptimize-1 [#_"DeoptimizingNode" this])
)

;;;
 ; Interface for nodes that need a FrameState for deoptimizing to a point before their execution.
 ;
 ; @anno DeoptimizingNode.DeoptBefore
 ;;
(§ interface DeoptBefore (§ extends DeoptimizingNode)
    ;;;
     ; Sets the FrameState describing the program state before the execution of this node.
     ;;
    (§ abstract #_"void" DeoptBefore''setStateBefore-2 [#_"DeoptBefore" this, #_"FrameState" state])

    (§ abstract #_"FrameState" DeoptBefore''stateBefore-1 [#_"DeoptBefore" this])
)

;;;
 ; Interface for nodes that need a FrameState for deoptimizing to a point after their execution.
 ;
 ; @anno DeoptimizingNode.DeoptAfter
 ;;
(§ interface DeoptAfter (§ extends DeoptimizingNode, StateSplit)
)

;;;
 ; Interface for nodes that need a special FrameState for deoptimizing during their execution (e.g. InvokeNode).
 ;
 ; @anno DeoptimizingNode.DeoptDuring
 ;;
(§ interface DeoptDuring (§ extends DeoptimizingNode, StateSplit)
    (§ abstract #_"FrameState" DeoptDuring''stateDuring-1 [#_"DeoptDuring" this])

    ;;;
     ; Sets the FrameState describing the program state during the execution of this node.
     ;;
    (§ abstract #_"void" DeoptDuring''setStateDuring-2 [#_"DeoptDuring" this, #_"FrameState" state])

    ;;;
     ; Compute the FrameState describing the program state during the execution of this node from
     ; an input FrameState describing the program state after finishing the execution of this node.
     ;;
    (§ abstract #_"void" DeoptDuring''computeStateDuring-2 [#_"DeoptDuring" this, #_"FrameState" stateAfter])
)

(class-ns DirectCallTargetNode (§ extends LoweredCallTargetNode)
    (§ def #_"NodeClass<DirectCallTargetNode>" DirectCallTargetNode'TYPE (NodeClass'create-1 DirectCallTargetNode))

    #_unused
    (§ defn #_"DirectCallTargetNode" DirectCallTargetNode'new-6 [#_"ValueNode[]" arguments, #_"StampPair" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (DirectCallTargetNode'new-7 DirectCallTargetNode'TYPE, arguments, returnStamp, signature, target, callType, invokeKind)
    )

    (§ defn #_"DirectCallTargetNode" DirectCallTargetNode'new-7 [#_"NodeClass<? extends DirectCallTargetNode>" c, #_"ValueNode[]" arguments, #_"StampPair" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (LoweredCallTargetNode'new-7 c, arguments, returnStamp, signature, target, callType, invokeKind)
    )

    #_unused
    (§ override #_"String" DirectCallTargetNode''targetName-1 [#_"DirectCallTargetNode" this]
        (#_"ResolvedJavaMethod" .format (CallTargetNode''targetMethod-1 this), "Direct#%h.\n")
    )
)

(final-ns DynamicDeoptimizeNode (§ extends AbstractDeoptimizeNode) (§ implements LIRLowerable, Lowerable, Canonicalizable)
    (§ def #_"NodeClass<DynamicDeoptimizeNode>" DynamicDeoptimizeNode'TYPE (NodeClass'create-1 DynamicDeoptimizeNode))

    ; @Input
    (§ mutable #_"ValueNode" :actionAndReason nil)
    ; @Input
    (§ mutable #_"ValueNode" :speculation nil)

    (§ defn #_"DynamicDeoptimizeNode" DynamicDeoptimizeNode'new-2 [#_"ValueNode" actionAndReason, #_"ValueNode" speculation]
        (let [
            #_"DynamicDeoptimizeNode" this (AbstractDeoptimizeNode'new-2 DynamicDeoptimizeNode'TYPE, nil)
            this (assoc this :actionAndReason actionAndReason)
            this (assoc this :speculation speculation)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"ValueNode" DynamicDeoptimizeNode''getActionAndReason-1 [#_"DynamicDeoptimizeNode" this]
        (:actionAndReason this)
    )

    #_unused
    (§ override! #_"ValueNode" DynamicDeoptimizeNode''getSpeculation-1 [#_"DynamicDeoptimizeNode" this]
        (:speculation this)
    )

    #_unused
    (§ override! #_"void" DynamicDeoptimizeNode''lower-2 [#_"DynamicDeoptimizeNode" this, #_"LoweringTool" lowerer]
        nil ;; No lowering, we generate LIR directly for this node.
    )

    #_unused
    (§ override! #_"void" DynamicDeoptimizeNode''generate-2 [#_"DynamicDeoptimizeNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''emitDeoptimize-3 (:gen builder), (LIRBuilder''operand-2 builder, (:actionAndReason this)), (LIRBuilder''operand-2 builder, (:speculation this)))
        nil
    )

    #_unused
    (§ override! #_"Node" DynamicDeoptimizeNode''canonical-2 [#_"DynamicDeoptimizeNode" this, #_"CanonicalizerTool" tool]
        (when (and (instance? ConstantNode (:actionAndReason this)) (instance? ConstantNode (:speculation this))) => this
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 (:actionAndReason this))
            ]
                (DeoptimizeNode'new-5 (#_"MetaAccessProvider" .decodeDeoptAction HotSpot'metaAccess, constant), (#_"MetaAccessProvider" .decodeDeoptReason HotSpot'metaAccess, constant), (#_"MetaAccessProvider" .decodeDebugId HotSpot'metaAccess, constant), (ValueNode''asJavaConstant-1 (:speculation this)), (AbstractDeoptimizeNode''stateBefore-1 this))
            )
        )
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Association"
(final-ns EndNode (§ extends AbstractEndNode)
    (§ def #_"NodeClass<EndNode>" EndNode'TYPE (NodeClass'create-1 EndNode))

    (§ defn #_"EndNode" EndNode'new-0 []
        (AbstractEndNode'new-1 EndNode'TYPE)
    )
)

(§ interface AnchoringNode
)

(§ interface ArrayRangeWrite
    (§ abstract #_"AddressNode" ArrayRangeWrite''getAddress-1 [#_"ArrayRangeWrite" this])

    ;;;
     ; The length of the modified range.
     ;;
    (§ abstract #_"ValueNode" ArrayRangeWrite''getLength-1 [#_"ArrayRangeWrite" this])

    ;;;
     ; Return true if the written array is an object array, false if it is a primitive array.
     ;;
    (§ abstract #_"boolean" ArrayRangeWrite''writesObjectArray-1 [#_"ArrayRangeWrite" this])

    ;;;
     ; Returns whether this write is the initialization of the written location. If it is true, the
     ; old value of the memory location is either uninitialized or zero. If it is false, the memory
     ; location is guaranteed to contain a valid value or zero.
     ;;
    (§ abstract #_"boolean" ArrayRangeWrite''isInitialization-1 [#_"ArrayRangeWrite" this])

    (§ abstract #_"int" ArrayRangeWrite''getElementStride-1 [#_"ArrayRangeWrite" this])
)

;;;
 ; This node represents the boxing of a primitive value. This corresponds to a call to the valueOf
 ; methods in Integer, Long, etc.
 ;;
(final-ns BoxNode (§ extends FixedWithNextNode) (§ implements VirtualizableAllocation, Lowerable, Unary #_"<ValueNode>")
    (§ def #_"NodeClass<BoxNode>" BoxNode'TYPE (NodeClass'create-1 BoxNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)
    (§ final #_"JavaKind" :boxingKind nil)

    (§ defn #_"BoxNode" BoxNode'new-3 [#_"ValueNode" value, #_"ResolvedJavaType" resultType, #_"JavaKind" boxingKind]
        (BoxNode'new-4 BoxNode'TYPE, value, resultType, boxingKind)
    )

    (§ defn #_"BoxNode" BoxNode'new-4 [#_"NodeClass<? extends BoxNode>" c, #_"ValueNode" value, #_"ResolvedJavaType" resultType, #_"JavaKind" boxingKind]
        (let [
            #_"BoxNode" this (FixedWithNextNode'new-2 c, (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 resultType)))
            this (assoc this :value value)
            this (assoc this :boxingKind boxingKind)
        ]
            this
        )
    )

    (§ override! #_"ValueNode" BoxNode''getValue-1 [#_"BoxNode" this]
        (:value this)
    )

    #_unused
    (§ override! #_"void" BoxNode''lower-2 [#_"BoxNode" this, #_"LoweringTool" lowerer]
        (BoxingTemplates''lower-3 Lowerer'boxingSnippets, this, lowerer)
        nil
    )

    #_unused
    (§ override! #_"ValueNode" BoxNode''canonical-3 [#_"BoxNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (when-not (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
            this
        )
    )

    (§ method! #_"VirtualBoxingNode" BoxNode''createVirtualBoxingNode-1 [#_"BoxNode" this]
        (VirtualBoxingNode'new-2 (StampTool'typeOrNull-1 (:stamp this)), (:boxingKind this))
    )

    #_unused
    (§ override! #_"void" BoxNode''virtualize-2 [#_"BoxNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" alias (VirtualizerTool''getAlias-2 tool, (BoxNode''getValue-1 this))
            #_"VirtualBoxingNode" newVirtual (BoxNode''createVirtualBoxingNode-1 this)
        ]
            (VirtualizerTool''createVirtualObject-5 tool, newVirtual, (into-array ValueNode [ alias ]), #_"<MonitorIdNode>" (Collections/emptyList), false)
            (VirtualizerTool''replaceWithVirtual-2 tool, newVirtual)
        )
        nil
    )
)

;;;
 ; Instances of this node class will look for a preceding if node and put the given probability into
 ; the if node's taken probability. Then the branch probability node will be removed. This node is
 ; intended primarily for snippets, so that they can define their fast and slow paths.
 ;;
(final-ns BranchProbabilityNode (§ extends FloatingNode) (§ implements Simplifiable, Lowerable)
    (§ def #_"NodeClass<BranchProbabilityNode>" BranchProbabilityNode'TYPE (NodeClass'create-1 BranchProbabilityNode))

    (def #_"double" BranchProbabilityNode'LIKELY_PROBABILITY 0.6)
    (§ def #_"double" BranchProbabilityNode'NOT_LIKELY_PROBABILITY (- 1.0 BranchProbabilityNode'LIKELY_PROBABILITY))

    (def #_"double" BranchProbabilityNode'FREQUENT_PROBABILITY 0.9)
    (§ def #_"double" BranchProbabilityNode'NOT_FREQUENT_PROBABILITY (- 1.0 BranchProbabilityNode'FREQUENT_PROBABILITY))

    (def #_"double" BranchProbabilityNode'FAST_PATH_PROBABILITY 0.99)
    (§ def #_"double" BranchProbabilityNode'SLOW_PATH_PROBABILITY (- 1.0 BranchProbabilityNode'FAST_PATH_PROBABILITY))

    (def #_"double" BranchProbabilityNode'VERY_FAST_PATH_PROBABILITY 0.999)
    (§ def #_"double" BranchProbabilityNode'VERY_SLOW_PATH_PROBABILITY (- 1.0 BranchProbabilityNode'VERY_FAST_PATH_PROBABILITY))

    ; @Input
    (§ mutable #_"ValueNode" :probability nil)
    ; @Input
    (§ mutable #_"ValueNode" :condition nil)

    #_unused
    (§ defn #_"BranchProbabilityNode" BranchProbabilityNode'new-2 [#_"ValueNode" probability, #_"ValueNode" condition]
        (let [
            #_"BranchProbabilityNode" this (FloatingNode'new-2 BranchProbabilityNode'TYPE, (:stamp condition))
            this (assoc this :probability probability)
            this (assoc this :condition condition)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" BranchProbabilityNode''simplify-2 [#_"BranchProbabilityNode" this, #_"SimplifierTool" tool]
        (when (and (Node''hasUsages-1 this) (instance? ConstantNode (:probability this)))
            (let [
                #_"double" probabilityValue (#_"JavaConstant" .asDouble (ValueNode''asJavaConstant-1 (:probability this)))
            ]
                (cond
                    (< probabilityValue 0.0) (throw! (str "A negative probability of " probabilityValue " is not allowed!"))
                    (< 1.0 probabilityValue) (throw! (str "A probability of more than 1.0 (" probabilityValue ") is not allowed!"))
                    ;; We allow NaN if the node is in unreachable code that will eventually fall away,
                    ;; or else an error will be thrown during lowering since we keep the node around.
                    (Double/isNaN probabilityValue) nil
                    :else
                        (let [
                            #_"boolean" found?
                                (loop-when [found? false #_"ISeq" s (seq (NodeIterable''filter-2 (Node''usages-1 this), IntegerEqualsNode))] (some? s) => found?
                                    (let [
                                        #_"IntegerEqualsNode" node (first s)
                                        #_"ValueNode" other (if (= (:x node) this) (:y node) (:x node))
                                        found?
                                            (when (instance? ConstantNode other) => found?
                                                (let [
                                                    #_"double" probabilityToSet (if (zero? (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 other))) (- 1.0 probabilityValue) probabilityValue)
                                                    found?
                                                        (loop-when [found? found? #_"ISeq" s (seq (NodeIterable''filter-2 (Node''usages-1 node), IfNode))] (some? s) => found?
                                                            (§ ass! (first s) (IfNode''setTrueSuccessorProbability-2 (first s), probabilityToSet))
                                                            (recur true (next s))
                                                        )
                                                ]
                                                    (or found?
                                                        (NodeIterable''isNotEmpty-1 (NodeIterable''filter-2 (Node''usages-1 node), (PositiveTypePredicate''or-2 (PositiveTypePredicate'new-1 FixedGuardNode), ConditionalNode)))
                                                    )
                                                )
                                            )
                                    ]
                                        (recur found? (next s))
                                    )
                                )
                        ]
                            (if found?
                                (do
                                    (§ ass! this (Node''replaceAndDelete-2 this, (:condition this)))
                                    (when (some? tool)
                                        (SimplifierTool''addToWorkList-2 tool, (Node''usages-1 (:condition this)))
                                    )
                                )
                                (when-not (BranchProbabilityNode''isSubstitutionGraph-1 this)
                                    (throw! "Wrong usage of branch probability injection!")
                                )
                            )
                        )
                )
            )
        )
        nil
    )

    (§ method- #_"boolean" BranchProbabilityNode''isSubstitutionGraph-1 [#_"BranchProbabilityNode" this]
        (and (Node''hasExactlyOneUsage-1 this) (instance? ReturnNode (NodeIterable''first-1 (Node''usages-1 this))))
    )

    ;;;
     ; This intrinsic should only be used for the condition of an if statement. The parameter
     ; condition should also only denote a simple condition and not a combined condition involving
     ; && or || operators. It injects the probability of the condition into the if statement.
     ;
     ; @param probability the probability that the given condition is true as a double value between 0.0 and 1.0
     ; @param condition the simple condition without any && or || operators
     ; @return the condition
     ;;
    ; @NodeIntrinsic
    (§ native #_"boolean" BranchProbabilityNode'probability-2 [#_"double" probability, #_"boolean" condition])

    #_unused
    (§ override! #_"void" BranchProbabilityNode''lower-2 [#_"BranchProbabilityNode" this, #_"LoweringTool" lowerer]
        (throw! "Branch probability could not be injected, because the probability value did not reduce to a constant value.")
    )
)

(class-ns FixedValueAnchorNode (§ extends FixedWithNextNode) (§ implements LIRLowerable, ValueProxy, GuardingNode)
    (§ def #_"NodeClass<FixedValueAnchorNode>" FixedValueAnchorNode'TYPE (NodeClass'create-1 FixedValueAnchorNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)
    (§ mutable #_"Stamp" :predefinedStamp nil)

    (§ defn #_"FixedValueAnchorNode" FixedValueAnchorNode'new-2 [#_"NodeClass<? extends FixedValueAnchorNode>" c, #_"ValueNode" object]
        (let [
            #_"FixedValueAnchorNode" this (FixedWithNextNode'new-2 c, (:stamp object))
            this (assoc this :object object)
        ]
            this
        )
    )

    (§ defn #_"FixedValueAnchorNode" FixedValueAnchorNode'new-1 [#_"ValueNode" object]
        (FixedValueAnchorNode'new-2 FixedValueAnchorNode'TYPE, object)
    )

    (§ defn #_"FixedValueAnchorNode" FixedValueAnchorNode'new-2 [#_"ValueNode" object, #_"Stamp" predefinedStamp]
        (let [
            #_"FixedValueAnchorNode" this (FixedWithNextNode'new-2 FixedValueAnchorNode'TYPE, predefinedStamp)
            this (assoc this :object object)
            this (assoc this :predefinedStamp predefinedStamp)
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" FixedValueAnchorNode''inferStamp-1 [#_"FixedValueAnchorNode" this]
        (and (nil? (:predefinedStamp this)) (ValueNode''updateStamp-2 this, (:stamp (:object this))))
    )

    ; @NodeIntrinsic
    (§ native #_"Object" FixedValueAnchorNode'getObject-1 [#_"Object" object])

    #_unused
    (§ override #_"void" FixedValueAnchorNode''generate-2 [#_"FixedValueAnchorNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRBuilder''operand-2 builder, (:object this)))
        nil
    )

    #_unused
    (§ override #_"ValueNode" FixedValueAnchorNode''getOriginalNode-1 [#_"FixedValueAnchorNode" this]
        (:object this)
    )

    #_unused
    (§ override #_"GuardingNode" FixedValueAnchorNode''getGuard-1 [#_"FixedValueAnchorNode" this]
        this
    )
)

;;;
 ; Node for a foreign call.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns ForeignCallNode (§ extends AbstractMemoryCheckpoint) (§ implements LIRLowerable, DeoptDuring, Multi)
    (§ def #_"NodeClass<ForeignCallNode>" ForeignCallNode'TYPE (NodeClass'create-1 ForeignCallNode))

    ; @Input
    (§ mutable #_"NodeInputList<ValueNode>" :arguments nil)
    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateDuring nil)

    (§ final #_"ForeignCallDescriptor" :descriptor nil)
    (§ mutable #_"int" :bci BytecodeFrame/UNKNOWN_BCI)

    (§ defn #_"ForeignCallNode" ForeignCallNode'new-2* [#_"ForeignCallDescriptor" descriptor, #_"ValueNode..." arguments]
        (let [
            #_"ForeignCallNode" this (AbstractMemoryCheckpoint'new-2 ForeignCallNode'TYPE, (StampFactory'forKind-1 (JavaKind/fromJavaClass (:resultType descriptor))))
            this (assoc this :arguments (NodeInputList'new-2 this, arguments))
            this (assoc this :descriptor descriptor)
        ]
            this
        )
    )

    #_unused
    (§ defn #_"boolean" ForeignCallNode'intrinsify-5* [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" targetMethod, #_@InjectedNodeParameter #_"Stamp" returnStamp, #_"ForeignCallDescriptor" descriptor, #_"ValueNode..." arguments]
        (let [
            #_"ForeignCallNode" node (ForeignCallNode'new-2* descriptor, arguments)
        ]
            (§ ass! node (ValueNode''setStamp-2 node, returnStamp))

            ;; Need to update the BCI of a ForeignCallNode so that it gets the stateDuring in the case that the
            ;; foreign call can deoptimize. As with all deoptimization, we need a state in a non-intrinsic method.
            (let [
                #_"BytecodeParser" nonIntrinsicAncestor (BytecodeParser''getNonIntrinsicAncestor-1 parser)
            ]
                (when (some? nonIntrinsicAncestor)
                    (§ ass! node (ForeignCallNode''setBci-2 node, (BytecodeParser''bci-1 nonIntrinsicAncestor)))
                )

                (let [
                    #_"JavaKind" returnKind (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature targetMethod))
                ]
                    (if (= returnKind JavaKind/Void)
                        (BytecodeParser''add-2 parser, node)
                        (BytecodeParser''addPush-3 parser, returnKind, node)
                    )

                    true
                )
            )
        )
    )

    #_unused
    (§ override! #_"boolean" ForeignCallNode''hasSideEffect-1 [#_"ForeignCallNode" this]
        (not (ForeignCalls''isReexecutable-2 HotSpot'foreignCalls, (:descriptor this)))
    )

    #_unused
    (§ override! #_"LocationIdentity[]" ForeignCallNode''getLocationIdentities-1 [#_"ForeignCallNode" this]
        (ForeignCalls''getKilledLocations-2 HotSpot'foreignCalls, (:descriptor this))
    )

    (§ method! #_"Value[]" ForeignCallNode''operands-2 [#_"ForeignCallNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value[]" operands (make-array Value (count (:arguments this)))
        ]
            (dotimes [#_"int" i (count operands)]
                (aset operands i (LIRBuilder''operand-2 builder, (nth (:arguments this) i)))
            )
            operands
        )
    )

    #_unused
    (§ override! #_"void" ForeignCallNode''generate-2 [#_"ForeignCallNode" this, #_"LIRBuilder" builder]
        (let [
            #_"ForeignCallLinkage" linkage (ForeignCalls''lookupForeignCall-2 HotSpot'foreignCalls, (:descriptor this))
            #_"Value[]" operands (ForeignCallNode''operands-2 this, builder)
            #_"Value" result (LIRGenerator''emitForeignCall-3* (:gen builder), linkage, operands)
        ]
            (when (some? result)
                (LIRBuilder''setResult-3 builder, this, result)
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" ForeignCallNode''setStateAfter-2 [#_"ForeignCallNode" this, #_"FrameState" x]
        (AbstractStateSplit''setStateAfter-2 (§ super ), x)
        nil
    )

    #_unused
    (§ override! #_"FrameState" ForeignCallNode''stateDuring-1 [#_"ForeignCallNode" this]
        (:stateDuring this)
    )

    (§ override! #_"void" ForeignCallNode''setStateDuring-2 [#_"ForeignCallNode" this, #_"FrameState" stateDuring]
        (Node''updateUsages-3 this, (:stateDuring this), stateDuring)
        (§ ass! this (assoc this :stateDuring stateDuring))
        nil
    )

    ;;;
     ; Set the {@code bci} of the invoke bytecode for use when converting a stateAfter into a stateDuring.
     ;;
    (§ method! #_"ForeignCallNode" ForeignCallNode''setBci-2 [#_"ForeignCallNode" this, #_"int" bci]
        (assoc this :bci bci)
    )

    #_unused
    (§ override! #_"void" ForeignCallNode''computeStateDuring-2 [#_"ForeignCallNode" this, #_"FrameState" after]
        (let [
            #_"FrameState" during
                (if (or (and (< 0 (:stackSize after)) (= (FrameState''stackAt-2 after, (- (:stackSize after) 1)) this))
                        (and (< 1 (:stackSize after)) (= (FrameState''stackAt-2 after, (- (:stackSize after) 2)) this)))
                    ;; the result of this call is on the top of stack, so roll back to the previous bci
                    (FrameState''duplicateModifiedDuringCall-3 after, (:bci this), (ValueNode''getStackKind-1 this))
                    after
                )
        ]
            (ForeignCallNode''setStateDuring-2 this, during)
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" ForeignCallNode''canDeoptimize-1 [#_"ForeignCallNode" this]
        false
    )

    (§ method! #_"boolean" ForeignCallNode''isGuaranteedSafepoint-1 [#_"ForeignCallNode" this]
        (ForeignCalls''isGuaranteedSafepoint-2 HotSpot'foreignCalls, (:descriptor this))
    )
)

;;;
 ; Loads an object's class (i.e. this node can be created for {@code object.getClass()}).
 ;;
(final-ns GetClassNode (§ extends FloatingNode) (§ implements Lowerable, Canonicalizable, Virtualizable)
    (§ def #_"NodeClass<GetClassNode>" GetClassNode'TYPE (NodeClass'create-1 GetClassNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)

    #_unused
    (§ defn #_"GetClassNode" GetClassNode'new-2 [#_"Stamp" stamp, #_"ValueNode" object]
        (let [
            #_"GetClassNode" this (FloatingNode'new-2 GetClassNode'TYPE, stamp)
            this (assoc this :object object)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" GetClassNode''lower-2 [#_"GetClassNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerGetClassNode-3 this, lowerer, (:graph this))
        nil
    )

    (§ defn #_"ValueNode" GetClassNode'tryFold-1 [#_"ValueNode" object]
        (when (and (some? HotSpot'metaAccess) (some? object) (instance? ObjectStamp (:stamp object)) (AbstractObjectStamp''isExactType-1 (:stamp object)))
            (ConstantNode'forConstant-1 (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (AbstractObjectStamp''type-1 (:stamp object))))
        )
    )

    #_unused
    (§ override! #_"ValueNode" GetClassNode''canonical-2 [#_"GetClassNode" this, #_"CanonicalizerTool" tool]
        (or (GetClassNode'tryFold-1 (:object this))
            this
        )
    )

    #_unused
    (§ override! #_"void" GetClassNode''virtualize-2 [#_"GetClassNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" alias (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (instance? VirtualObjectNode alias)
                (VirtualizerTool''replaceWithValue-2 tool, (ConstantNode'forConstant-3 (:stamp this), (#_"ConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (VirtualObjectNode''type-1 alias)), (:graph this)))
            )
        )
        nil
    )
)

;;;
 ; A node that may be guarded by a guarding node.
 ;;
(§ interface GuardedNode
    (§ abstract #_"GuardingNode" GuardedNode''getGuard-1 [#_"GuardedNode" this])

    #_unused
    (§ abstract #_"void" GuardedNode''setGuard-2 [#_"GuardedNode" this, #_"GuardingNode" guard])
)

(final-ns GuardedUnsafeLoadNode (§ extends RawLoadNode) (§ implements GuardedNode)
    (§ def #_"NodeClass<GuardedUnsafeLoadNode>" GuardedUnsafeLoadNode'TYPE (NodeClass'create-1 GuardedUnsafeLoadNode))

    ; @OptionalInput(InputType'Guard)
    (§ mutable #_"GuardingNode" :guard nil)

    #_unused
    (§ defn #_"GuardedUnsafeLoadNode" GuardedUnsafeLoadNode'new-5 [#_"ValueNode" object, #_"ValueNode" offset, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity, #_"GuardingNode" guard]
        (let [
            #_"GuardedUnsafeLoadNode" this (RawLoadNode'new-5 GuardedUnsafeLoadNode'TYPE, object, offset, accessKind, locationIdentity)
            this (assoc this :guard guard)
        ]
            this
        )
    )

    (§ override! #_"GuardingNode" GuardedUnsafeLoadNode''getGuard-1 [#_"GuardedUnsafeLoadNode" this]
        (:guard this)
    )

    #_unused
    (§ override! #_"void" GuardedUnsafeLoadNode''setGuard-2 [#_"GuardedUnsafeLoadNode" this, #_"GuardingNode" guard]
        (Node''updateUsages-3 this, (:guard this), guard)
        (§ ass! this (assoc this :guard guard))
        nil
    )
)

(§ interface GuardingNode
)

;;;
 ; The IntegerSwitchNode represents a switch on integer keys, with a sorted array of key
 ; values. The actual implementation of the switch will be decided by the backend.
 ;;
(final-ns IntegerSwitchNode (§ extends SwitchNode) (§ implements LIRLowerable, Simplifiable)
    (§ def #_"NodeClass<IntegerSwitchNode>" IntegerSwitchNode'TYPE (NodeClass'create-1 IntegerSwitchNode))

    (§ final #_"int[]" :keys nil)

    (§ defn #_"IntegerSwitchNode" IntegerSwitchNode'new-5 [#_"ValueNode" value, #_"AbstractBeginNode[]" successors, #_"int[]" keys, #_"double[]" keyProbabilities, #_"int[]" keySuccessors]
        (let [
            #_"IntegerSwitchNode" this (SwitchNode'new-5 IntegerSwitchNode'TYPE, value, successors, keySuccessors, keyProbabilities)
            this (assoc this :keys keys)
        ]
            this
        )
    )

    (§ defn #_"IntegerSwitchNode" IntegerSwitchNode'new-5 [#_"ValueNode" value, #_"int" successorCount, #_"int[]" keys, #_"double[]" keyProbabilities, #_"int[]" keySuccessors]
        (IntegerSwitchNode'new-5 value, (make-array AbstractBeginNode successorCount), keys, keyProbabilities, keySuccessors)
    )

    #_unused
    (§ override! #_"boolean" IntegerSwitchNode''isSorted-1 [#_"IntegerSwitchNode" this]
        true
    )

    ;;;
     ; Gets the key at the specified index.
     ;;
    (§ override! #_"JavaConstant" IntegerSwitchNode''keyAt-2 [#_"IntegerSwitchNode" this, #_"int" i]
        (JavaConstant/forInt (nth (:keys this) i))
    )

    #_unused
    (§ override! #_"boolean" IntegerSwitchNode''equalKeys-2 [#_"IntegerSwitchNode" this, #_"SwitchNode" switchNode]
        (and (instance? IntegerSwitchNode switchNode) (Arrays/equals (:keys this), (:keys switchNode)))
    )

    #_unused
    (§ override! #_"void" IntegerSwitchNode''generate-2 [#_"IntegerSwitchNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''emitSwitch-2 builder, this)
        nil
    )

    #_unused
    (§ method! #_"AbstractBeginNode" IntegerSwitchNode''successorAtKey-2 [#_"IntegerSwitchNode" this, #_"int" key]
        (nth (:successors this) (IntegerSwitchNode''successorIndexAtKey-2 this, key))
    )

    (§ method! #_"int" IntegerSwitchNode''successorIndexAtKey-2 [#_"IntegerSwitchNode" this, #_"int" key]
        (let [
            #_"int" n (count (:keys this))
        ]
            (loop-when [#_"int" i 0] (< i n) => (SwitchNode''keySuccessorIndex-2 this, n)
                (if (= (nth (:keys this) i) key)
                    (SwitchNode''keySuccessorIndex-2 this, i)
                    (recur (inc i))
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" IntegerSwitchNode''simplify-2 [#_"IntegerSwitchNode" this, #_"SimplifierTool" tool]
        (cond
            (= (count (:successors this)) 1)
            (do
                (SimplifierTool''addToWorkList-2 tool, (SwitchNode''defaultSuccessor-1 this))
                (Graph''removeSplitPropagate-3 (:graph this), this, (SwitchNode''defaultSuccessor-1 this))
            )
            (instance? ConstantNode (SwitchNode''value-1 this))
                (SwitchNode''killOtherSuccessors-3 this, tool, (IntegerSwitchNode''successorIndexAtKey-2 this, (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (SwitchNode''value-1 this)))))
            (IntegerSwitchNode''tryOptimizeEnumSwitch-2 this, tool)
                nil
            (IntegerSwitchNode''tryRemoveUnreachableKeys-3 this, tool, (:stamp (SwitchNode''value-1 this)))
                nil
        )
        nil
    )

    ;;;
     ; Remove unreachable keys from the switch based on the stamp of the value,
     ; i.e. based on the known range of the switch value.
     ;;
    (§ method! #_"boolean" IntegerSwitchNode''tryRemoveUnreachableKeys-3 [#_"IntegerSwitchNode" this, #_"SimplifierTool" tool, #_"Stamp" stamp]
        (and (instance? IntegerStamp stamp) (not (IntegerStamp''isUnrestricted-1 stamp))
            (let [
                #_"List<KeyData>" newKeys (ArrayList.)
                #_"ArrayList<AbstractBeginNode>" newSuccessors (ArrayList.)
                _
                    (dotimes [#_"int" i (count (:keys this))]
                        (when (and (IntegerStamp''contains-2 stamp, (nth (:keys this) i)) (not= (SwitchNode''keySuccessor-2 this, i) (SwitchNode''defaultSuccessor-1 this)))
                            (#_"List" .add newKeys, (KeyData'new-3 (nth (:keys this) i), (nth (:keyProbabilities this) i), (IntegerSwitchNode'addNewSuccessor-2 (SwitchNode''keySuccessor-2 this, i), newSuccessors)))
                        )
                    )
            ]
                (cond
                    (= (count newKeys) (count (:keys this)))
                        false ;; all keys are reachable
                    (empty? newKeys)
                        (do
                            (when (some? tool)
                                (SimplifierTool''addToWorkList-2 tool, (SwitchNode''defaultSuccessor-1 this))
                            )
                            (Graph''removeSplitPropagate-3 (:graph this), this, (SwitchNode''defaultSuccessor-1 this))
                            true
                        )
                    :else
                        (do
                            (IntegerSwitchNode''doReplace-6 this, (SwitchNode''value-1 this), newKeys, newSuccessors, (IntegerSwitchNode'addNewSuccessor-2 (SwitchNode''defaultSuccessor-1 this), newSuccessors), (nth (:keyProbabilities this) (dec (count (:keyProbabilities this)))))
                            true
                        )
                )
            )
        )
    )

    ;;;
     ; For switch statements on enum values, the Java compiler has to generate complicated code:
     ; because Enum#ordinal() can change when recompiling an enum, it cannot be used
     ; directly as the value that is switched on. An intermediate int[] array, which is initialized
     ; once at run time based on the actual Enum#ordinal() values, is used.
     ;
     ; The ConstantFields of Graal already detects the int[] arrays and marks them as
     ; {@link ConstantNode#isDefaultStable() stable}, i.e. the array elements are constant. The
     ; code in this method detects array loads from such a stable array and re-wires the switch to
     ; use the keys from the array elements, so that the array load is unnecessary.
     ;;
    (§ method- #_"boolean" IntegerSwitchNode''tryOptimizeEnumSwitch-2 [#_"IntegerSwitchNode" this, #_"SimplifierTool" tool]
        (and (instance? LoadIndexedNode (SwitchNode''value-1 this))
            ;; Not the switch pattern we are looking for.
            (let [
                #_"LoadIndexedNode" loadIndexed (SwitchNode''value-1 this)
            ]
                ;; The array load is necessary for other reasons too, so there is no benefit optimizing the switch.
                (and (not (< 1 (NodeIterable''count-1 (Node''usages-1 loadIndexed))))
                    (let [
                        #_"ValueNode" newValue (AccessIndexedNode''index-1 loadIndexed)
                        #_"JavaConstant" arrayConstant (ValueNode''asJavaConstant-1 (AccessArrayNode''array-1 loadIndexed))
                    ]
                        ;; The array is a constant that we can optimize. We require the array elements to be
                        ;; constant too, since we put them as literal constants into the switch keys.
                        (and (some? arrayConstant)
                            (= (:stableDimension (AccessArrayNode''array-1 loadIndexed)) 1)
                            (:isDefaultStable (AccessArrayNode''array-1 loadIndexed))
                            (let [
                                #_"Integer" optionalArrayLength (#_"ConstantReflectionProvider" .readArrayLength HotSpot'constantReflection, arrayConstant)
                            ]
                                ;; => Loading a constant value can be denied by the VM.
                                (and (some? optionalArrayLength)
                                    (let [
                                        #_"int" arrayLength optionalArrayLength
                                        #_"Map<Integer, List<Integer>>" reverseArrayMapping (HashMap.)
                                    ]
                                        (and
                                            (loop-when [#_"int" i 0] (< i arrayLength) => true
                                                (let [
                                                    #_"JavaConstant" elementConstant (#_"ConstantReflectionProvider" .readArrayElement HotSpot'constantReflection, arrayConstant, i)
                                                ]
                                                    ;; => Loading a constant value can be denied by the VM.
                                                    (and (some? elementConstant) (= (#_"JavaConstant" .getJavaKind elementConstant) JavaKind/Int)
                                                        ;; The value loaded from the array is the old switch key, the index into the array is
                                                        ;; the new switch key. We build a mapping from the old switch key to new keys.
                                                        (#_"List" .add (#_"Map" .computeIfAbsent reverseArrayMapping, (#_"JavaConstant" .asInt elementConstant), (ß e -> (§ fun (ArrayList.)))), i)
                                                        (recur (inc i))
                                                    )
                                                )
                                            )
                                            ;; Build high-level representation of new switch keys.
                                            (let [
                                                #_"List<KeyData>" newKeyDatas (ArrayList.)
                                                #_"ArrayList<AbstractBeginNode>" newSuccessors (ArrayList.)
                                            ]
                                                (dotimes [#_"int" i (count (:keys this))]
                                                    (let [
                                                        #_"List<Integer>" newKeys (#_"Map" .get reverseArrayMapping, (nth (:keys this) i))
                                                    ]
                                                        ;; => The switch case is unreachable, we can ignore it.
                                                        (when (seq newKeys)
                                                            ;; We do not have detailed profiling information about the individual new keys, so we
                                                            ;; have to assume they split the probability of the old key.
                                                            (let [
                                                                #_"double" newKeyProbability (/ (nth (:keyProbabilities this) i) (count newKeys))
                                                                #_"int" newKeySuccessor (IntegerSwitchNode'addNewSuccessor-2 (SwitchNode''keySuccessor-2 this, i), newSuccessors)
                                                            ]
                                                                (doseq [#_"int" newKey newKeys]
                                                                    (#_"List" .add newKeyDatas, (KeyData'new-3 newKey, newKeyProbability, newKeySuccessor))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )

                                                (let [
                                                    #_"int" newDefaultSuccessor (IntegerSwitchNode'addNewSuccessor-2 (SwitchNode''defaultSuccessor-1 this), newSuccessors)
                                                    #_"double" newDefaultProbability (nth (:keyProbabilities this) (dec (count (:keyProbabilities this))))
                                                    ;; We remove the array load, but we still need to preserve exception semantics by keeping
                                                    ;; the bounds check. Fortunately the array length is a constant.
                                                    #_"LogicNode" boundsCheck (Graph''add-2 (:graph this), (IntegerBelowNode'new-2 newValue, (ConstantNode'forInt-2 arrayLength, (:graph this))))
                                                ]
                                                    (Graph''addBeforeFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (FixedGuardNode'new-3 boundsCheck, DeoptimizationReason/BoundsCheckException, DeoptimizationAction/InvalidateReprofile)))

                                                    ;; Build the low-level representation of the new switch keys and replace ourself with a new node.
                                                    (IntegerSwitchNode''doReplace-6 this, newValue, newKeyDatas, newSuccessors, newDefaultSuccessor, newDefaultProbability)

                                                    ;; The array load is now unnecessary.
                                                    (GraphUtil'removeFixedWithUnusedInputs-1 loadIndexed)

                                                    true
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"int" IntegerSwitchNode'addNewSuccessor-2 [#_"AbstractBeginNode" newSuccessor, #_"ArrayList<AbstractBeginNode>" newSuccessors]
        (let [
            #_"int" index (#_"ArrayList" .indexOf newSuccessors, newSuccessor)
        ]
            (when (= index -1) => index
                (let [
                    index (count newSuccessors)
                ]
                    (#_"ArrayList" .add newSuccessors, newSuccessor)
                    index
                )
            )
        )
    )

    (§ method- #_"void" IntegerSwitchNode''doReplace-6 [#_"IntegerSwitchNode" this, #_"ValueNode" newValue, #_"List<KeyData>" newKeyDatas, #_"ArrayList<AbstractBeginNode>" newSuccessors, #_"int" newDefaultSuccessor, #_"double" newDefaultProbability]
        ;; Sort the new keys (invariant of the IntegerSwitchNode).
        (#_"List" .sort newKeyDatas, (Comparator/comparingInt (ß k -> (§ fun (:key k)))))

        ;; Create the final data arrays.
        (let [
            #_"int" newKeyCount (count newKeyDatas)
            #_"int[]" newKeys (int-array newKeyCount)
            #_"double[]" newKeyProbabilities (double-array (inc newKeyCount))
            #_"int[]" newKeySuccessors (int-array (inc newKeyCount))
        ]
            (dotimes [#_"int" i newKeyCount]
                (let [
                    #_"KeyData" keyData (nth newKeyDatas i)
                ]
                    (aset newKeys i (:key keyData))
                    (aset newKeyProbabilities i (:keyProbability keyData))
                    (aset newKeySuccessors i (:keySuccessor keyData))
                )
            )

            (aset newKeySuccessors newKeyCount newDefaultSuccessor)
            (aset newKeyProbabilities newKeyCount newDefaultProbability)

            ;; Normalize new probabilities so that they sum up to 1.
            (let [
                #_"double" totalProbability
                    (loop-when-recur [totalProbability 0.0 #_"ISeq" s (seq newKeyProbabilities)]
                                     (some? s)
                                     [(+ totalProbability (first s)) (next s)]
                                  => totalProbability
                    )
            ]
                (if (pos? totalProbability)
                    (dotimes [#_"int" i (count newKeyProbabilities)]
                        (aswap newKeyProbabilities i / totalProbability)
                    )
                    (dotimes [#_"int" i (count newKeyProbabilities)]
                        (aset newKeyProbabilities i (/ 1.0 (count newKeyProbabilities)))
                    )
                )

                ;; Collect dead successors. Successors have to be cleaned before adding the new node to the graph.
                (let [
                    #_"List<AbstractBeginNode>" deadSuccessors (NodeIterable''snapshot-1 (NodeList''filter-2 (:successors this), (ß s -> (§ fun (not (#_"ArrayList" .contains newSuccessors, s))))))
                ]
                    (NodeList''clear-1 (:successors this))

                    ;; Create the new switch node. This is done before removing dead successors as 'killCFG' could edit
                    ;; some of the inputs (e.g. if 'newValue' is a loop-phi of the loop that dies while removing successors).
                    (let [
                        #_"AbstractBeginNode[]" successorsArray (#_"ArrayList" .toArray newSuccessors, (make-array AbstractBeginNode (count newSuccessors)))
                        #_"SwitchNode" newSwitch (Graph''add-2 (:graph this), (IntegerSwitchNode'new-5 newValue, successorsArray, newKeys, newKeyProbabilities, newKeySuccessors))
                    ]
                        ;; remove dead successors
                        (doseq [#_"AbstractBeginNode" successor deadSuccessors]
                            (GraphUtil'killCFG-1 successor)
                        )

                        ;; replace ourselves with the new switch
                        (§ ass! (:predecessor this) (FixedWithNextNode''setNext-2 (:predecessor this), newSwitch))
                        (GraphUtil'killWithUnusedFloatingInputs-1 this)
                    )
                )
            )
        )
        nil
    )

    (§ override! #_"Stamp" IntegerSwitchNode''getValueStampForSuccessor-2 [#_"IntegerSwitchNode" this, #_"AbstractBeginNode" beginNode]
        (when-not (= beginNode (SwitchNode''defaultSuccessor-1 this))
            (loop-when [#_"Stamp" stamp nil #_"int" i 0] (< i (count (:keys this))) => stamp
                (let [
                    stamp
                        (when (= (SwitchNode''keySuccessor-2 this, i) beginNode) => stamp
                            (if (nil? stamp)
                                (StampFactory'forPrimitiveConstant-1 (IntegerSwitchNode''keyAt-2 this, i))
                                (Stamp''meet-2 stamp, (StampFactory'forPrimitiveConstant-1 (IntegerSwitchNode''keyAt-2 this, i)))
                            )
                        )
                ]
                    (recur stamp (inc i))
                )
            )
        )
    )
)

;;;
 ; @anno IntegerSwitchNode.KeyData
 ;;
(final-ns KeyData
    (§ final #_"int" :key 0)
    (§ final #_"double" :keyProbability 0.0)
    (§ final #_"int" :keySuccessor 0)

    (§ defn #_"KeyData" KeyData'new-3 [#_"int" key, #_"double" keyProbability, #_"int" keySuccessor]
        (let [
            #_"KeyData" this (Object.)
            this (assoc this :key key)
            this (assoc this :keyProbability keyProbability)
            this (assoc this :keySuccessor keySuccessor)
        ]
            this
        )
    )
)

;;;
 ; Read a raw memory location according to Java field or array read semantics. It will perform read
 ; barriers, implicit conversions and optionally oop uncompression.
 ;;
(final-ns JavaReadNode (§ extends FixedAccessNode) (§ implements Lowerable, GuardingNode, Canonicalizable)
    (§ def #_"NodeClass<JavaReadNode>" JavaReadNode'TYPE (NodeClass'create-1 JavaReadNode))

    (§ final #_"JavaKind" :readKind nil)
    (§ final #_"boolean" :compressible? false)

    (§ defn #_"JavaReadNode" JavaReadNode'new-5 [#_"JavaKind" readKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"BarrierType" barrierType, #_"boolean" compressible?]
        (let [
            #_"JavaReadNode" this (FixedAccessNode'new-5 JavaReadNode'TYPE, address, location, (StampFactory'forKind-1 readKind), barrierType)
            this (assoc this :readKind readKind)
            this (assoc this :compressible? compressible?)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" JavaReadNode''lower-2 [#_"JavaReadNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerJavaReadNode-1 this)
        nil
    )

    #_unused
    (§ override! #_"boolean" JavaReadNode''canNullCheck-1 [#_"JavaReadNode" this]
        true
    )

    #_unused
    (§ override! #_"Node" JavaReadNode''canonical-2 [#_"JavaReadNode" this, #_"CanonicalizerTool" tool]
        (ReadNode'canonicalizeRead-4 this, (FixedAccessNode''getAddress-1 this), (FixedAccessNode''getLocationIdentity-1 this), tool)
    )
)

;;;
 ; Write a raw memory location according to Java field or array write semantics. It will perform
 ; write barriers, implicit conversions and optionally oop compression.
 ;;
(final-ns JavaWriteNode (§ extends AbstractWriteNode) (§ implements Lowerable, StateSplit, MemoryAccess, Single)
    (§ def #_"NodeClass<JavaWriteNode>" JavaWriteNode'TYPE (NodeClass'create-1 JavaWriteNode))

    (§ final #_"JavaKind" :writeKind nil)
    (§ final #_"boolean" :compressible? false)

    (§ defn #_"JavaWriteNode" JavaWriteNode'new-6 [#_"JavaKind" writeKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" value, #_"BarrierType" barrierType, #_"boolean" compressible?]
        (let [
            #_"JavaWriteNode" this (AbstractWriteNode'new-5 JavaWriteNode'TYPE, address, location, value, barrierType)
            this (assoc this :writeKind writeKind)
            this (assoc this :compressible? compressible?)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" JavaWriteNode''lower-2 [#_"JavaWriteNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerJavaWriteNode-1 this)
        nil
    )

    #_unused
    (§ override! #_"boolean" JavaWriteNode''canNullCheck-1 [#_"JavaWriteNode" this]
        true
    )
)

;;;
 ; Loads an object's hub. The object is not nil-checked by this operation.
 ;;
(final-ns LoadHubNode (§ extends FloatingNode) (§ implements Lowerable, Canonicalizable, Virtualizable)
    (§ def #_"NodeClass<LoadHubNode>" LoadHubNode'TYPE (NodeClass'create-1 LoadHubNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)

    (§ defn #_"ValueNode" LoadHubNode'create-1 [#_"ValueNode" value]
        (let [
            #_"Stamp" stamp KlassPointerStamp'KLASS_NON_NULL
        ]
            (or (LoadHubNode'findSynonym-2 value, stamp)
                (LoadHubNode'new-2 stamp, value)
            )
        )
    )

    (§ defn #_"LoadHubNode" LoadHubNode'new-1 [#_"ValueNode" value]
        (LoadHubNode'new-2 KlassPointerStamp'KLASS_NON_NULL, value)
    )

    (§ defn #_"LoadHubNode" LoadHubNode'new-2 [#_"Stamp" stamp, #_"ValueNode" value]
        (let [
            #_"LoadHubNode" this (FloatingNode'new-2 LoadHubNode'TYPE, stamp)
            this (assoc this :value value)
        ]
            this
        )
    )

    (§ override! #_"void" LoadHubNode''lower-2 [#_"LoadHubNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerLoadHubNode-2 this, lowerer)
        nil
    )

    #_unused
    (§ override! #_"ValueNode" LoadHubNode''canonical-2 [#_"LoadHubNode" this, #_"CanonicalizerTool" tool]
        (or (LoadHubNode'findSynonym-2 (:value this), (:stamp this))
            this
        )
    )

    (§ defn #_"ValueNode" LoadHubNode'findSynonym-2 [#_"ValueNode" curValue, #_"Stamp" stamp]
        (let [
            #_"TypeReference" type (StampTool'typeReferenceOrNull-1 (:stamp curValue))
        ]
            (when (and (some? type) (:exactReference type))
                (ConstantNode'forConstant-2 stamp, (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, (:type type)))
            )
        )
    )

    #_unused
    (§ override! #_"void" LoadHubNode''virtualize-2 [#_"LoadHubNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"TypeReference" type (StampTool'typeReferenceOrNull-1 (:stamp (VirtualizerTool''getAlias-2 tool, (:value this))))
        ]
            (when (and (some? type) (:exactReference type))
                (VirtualizerTool''replaceWithValue-2 tool, (ConstantNode'forConstant-3 (:stamp this), (#_"ConstantReflectionProvider" .asObjectHub HotSpot'constantReflection, (:type type)), (:graph this)))
            )
        )
        nil
    )
)

;;;
 ; Loads a method from the virtual method table of a given hub.
 ;;
(final-ns LoadMethodNode (§ extends FixedWithNextNode) (§ implements Lowerable, Canonicalizable)
    (§ def #_"NodeClass<LoadMethodNode>" LoadMethodNode'TYPE (NodeClass'create-1 LoadMethodNode))

    ; @Input
    (§ mutable #_"ValueNode" :hub nil)
    (§ final #_"ResolvedJavaMethod" :method nil)
    (§ final #_"ResolvedJavaType" :receiverType nil)

    ;;;
     ; The caller or context type used to perform access checks when resolving #method.
     ;;
    (§ final #_"ResolvedJavaType" :callerType nil)

    #_unused
    (§ defn #_"LoadMethodNode" LoadMethodNode'new-5 [#_@InjectedNodeParameter #_"Stamp" stamp, #_"ResolvedJavaMethod" method, #_"ResolvedJavaType" receiverType, #_"ResolvedJavaType" callerType, #_"ValueNode" hub]
        (let [
            #_"LoadMethodNode" this (FixedWithNextNode'new-2 LoadMethodNode'TYPE, stamp)
            this (assoc this :receiverType receiverType)
            this (assoc this :callerType callerType)
            this (assoc this :hub hub)
            this (assoc this :method method)
        ]
            (when-not (#_"ResolvedJavaMethod" .isInVirtualMethodTable method, receiverType)
                (throw! (str method " does not have a vtable entry in type " receiverType))
            )
            this
        )
    )

    #_unused
    (§ override! #_"void" LoadMethodNode''lower-2 [#_"LoadMethodNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerLoadMethodNode-1 this)
        nil
    )

    #_unused
    (§ override! #_"Node" LoadMethodNode''canonical-2 [#_"LoadMethodNode" this, #_"CanonicalizerTool" tool]
        (when (instance? LoadHubNode (:hub this))
            (let [
                #_"TypeReference" type (StampTool'typeReferenceOrNull-1 (:stamp (:value (:hub this))))
            ]
                (when (and (some? type) (:exactReference type))
                    (§ return (LoadMethodNode''resolveExactMethod-3 this, tool, (:type type)))
                )
            )
        )
        (when (instance? ConstantNode (:hub this)) => this
            (LoadMethodNode''resolveExactMethod-3 this, tool, (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (:value (:hub this))))
        )
    )

    ;;;
     ; Find the method which would be loaded.
     ;
     ; @param type the exact type of object being loaded from
     ; @return the method which would be invoked for {@code type} or nil if it doesn't implement the method
     ;;
    (§ method- #_"Node" LoadMethodNode''resolveExactMethod-3 [#_"LoadMethodNode" this, #_"CanonicalizerTool" tool, #_"ResolvedJavaType" type]
        (let [
            #_"ResolvedJavaMethod" newMethod (#_"ResolvedJavaType" .resolveConcreteMethod type, (:method this), (:callerType this))
        ]
            (if (some? newMethod)
                (ConstantNode'forConstant-2 (:stamp this), (#_"ResolvedJavaMethod" .getEncoding newMethod))
                ;; This really represent a misuse of LoadMethod since we're loading from a class which
                ;; isn't known to implement the original method but for now at least fold it away.
                (ConstantNode'forConstant-2 (:stamp this), JavaConstant/NULL_POINTER)
            )
        )
    )
)

;;;
 ; Creates a memory barrier.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns MembarNode (§ extends FixedWithNextNode) (§ implements LIRLowerable, Single)
    (§ def #_"NodeClass<MembarNode>" MembarNode'TYPE (NodeClass'create-1 MembarNode))

    (§ final #_"int" :barriers 0)
    (§ final #_"LocationIdentity" :location nil)

    (§ defn #_"MembarNode" MembarNode'new-1 [#_"int" barriers]
        (MembarNode'new-2 barriers, (LocationIdentity/any))
    )

    (§ defn #_"MembarNode" MembarNode'new-2 [#_"int" barriers, #_"LocationIdentity" location]
        (let [
            #_"MembarNode" this (FixedWithNextNode'new-2 MembarNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :barriers barriers)
            this (assoc this :location location)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"LocationIdentity" MembarNode''getLocationIdentity-1 [#_"MembarNode" this]
        (:location this)
    )

    #_unused
    (§ override! #_"void" MembarNode''generate-2 [#_"MembarNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''emitMembar-2 (:gen builder), (:barriers this))
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"void" MembarNode'memoryBarrier-1 [#_@ConstantNodeParameter #_"int" barriers])

    ; @NodeIntrinsic
    (§ native #_"void" MembarNode'memoryBarrier-2 [#_@ConstantNodeParameter #_"int" barriers, #_@ConstantNodeParameter #_"LocationIdentity" location])
)

;;;
 ; Denotes monitor locking transition.
 ;;
(§ interface MonitorEnter
)

;;;
 ; Denotes monitor unlocking transition.
 ;;
(§ interface MonitorExit (§ extends MemoryCheckpoint)
)

;; @NodeInfo.allowedUsageTypes "InputType.Guard"
(final-ns NullCheckNode (§ extends DeoptimizingFixedWithNextNode) (§ implements LIRLowerable, GuardingNode)
    (§ def #_"NodeClass<NullCheckNode>" NullCheckNode'TYPE (NodeClass'create-1 NullCheckNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)

    (§ defn #_"NullCheckNode" NullCheckNode'new-1 [#_"ValueNode" object]
        (let [
            #_"NullCheckNode" this (DeoptimizingFixedWithNextNode'new-2 NullCheckNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :object object)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" NullCheckNode''generate-2 [#_"NullCheckNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''emitNullCheck-2 (:gen builder), (LIRBuilder''operand-2 builder, (:object this)))
        nil
    )

    #_unused
    (§ override! #_"boolean" NullCheckNode''canDeoptimize-1 [#_"NullCheckNode" this]
        true
    )

    ; @NodeIntrinsic
    (§ native #_"void" NullCheckNode'nullCheck-1 [#_"Object" object])
)

;;;
 ; Load of a value from a location specified as an offset relative to an object. No nil-check is
 ; performed before the load.
 ;;
(class-ns RawLoadNode (§ extends UnsafeAccessNode) (§ implements Lowerable, Virtualizable, Canonicalizable)
    (§ def #_"NodeClass<RawLoadNode>" RawLoadNode'TYPE (NodeClass'create-1 RawLoadNode))

    ;;;
     ; This constructor exists for node intrinsics that need a stamp based on {@code accessKind}.
     ;;
    (§ defn #_"RawLoadNode" RawLoadNode'new-4 [#_"ValueNode" object, #_"ValueNode" offset, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity]
        (RawLoadNode'new-5 object, offset, accessKind, locationIdentity, false)
    )

    (§ defn #_"RawLoadNode" RawLoadNode'new-5 [#_"ValueNode" object, #_"ValueNode" offset, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity, #_"boolean" forceAnyLocation]
        (UnsafeAccessNode'new-7 RawLoadNode'TYPE, (StampFactory'forKind-1 (#_"JavaKind" .getStackKind accessKind)), object, offset, accessKind, locationIdentity, forceAnyLocation)
    )

    ;;;
     ; This constructor exists for node intrinsics that need a stamp based on the return type of
     ; the NodeIntrinsic annotated method.
     ;;
    (§ defn #_"RawLoadNode" RawLoadNode'new-5 [#_@InjectedNodeParameter #_"Stamp" stamp, #_"ValueNode" object, #_"ValueNode" offset, #_"LocationIdentity" locationIdentity, #_"JavaKind" accessKind]
        (UnsafeAccessNode'new-7 RawLoadNode'TYPE, stamp, object, offset, accessKind, locationIdentity, false)
    )

    (§ defn #_"RawLoadNode" RawLoadNode'new-5 [#_"NodeClass<? extends RawLoadNode>" c, #_"ValueNode" object, #_"ValueNode" offset, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity]
        (UnsafeAccessNode'new-7 c, (StampFactory'forKind-1 (#_"JavaKind" .getStackKind accessKind)), object, offset, accessKind, locationIdentity, false)
    )

    #_unused
    (§ override #_"void" RawLoadNode''lower-2 [#_"RawLoadNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerUnsafeLoadNode-2 this, lowerer)
        nil
    )

    #_unused
    (§ override #_"void" RawLoadNode''virtualize-2 [#_"RawLoadNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" object (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (instance? VirtualObjectNode object)
                (let [
                    #_"ValueNode" offset (VirtualizerTool''getAlias-2 tool, (:offset this))
                ]
                    (when (instance? ConstantNode offset)
                        (let [
                            #_"int" i (VirtualObjectNode''entryIndexForOffset-3 object, (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 offset)), (:accessKind this))
                        ]
                            (when-not (= i -1)
                                (let [
                                    #_"ValueNode" entry (VirtualizerTool''getEntry-3 tool, object, i)
                                ]
                                    (when (or (= (ValueNode''getStackKind-1 entry) (ValueNode''getStackKind-1 this)) (= (VirtualObjectNode''entryKind-2 object, i) (:accessKind this)))
                                        (cond
                                            (Stamp''isCompatible-2 (:stamp entry), (:stamp this))
                                                (VirtualizerTool''replaceWith-2 tool, entry)
                                            (and (instance? PrimitiveStamp (:stamp entry)) (instance? PrimitiveStamp (:stamp this)))
                                                (when (= (:bits (:stamp this)) (:bits (:stamp entry)))
                                                    (VirtualizerTool''replaceWith-2 tool, (ReinterpretNode'create-2 (:stamp entry), entry))
                                                )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override #_"Node" RawLoadNode''canonical-2 [#_"RawLoadNode" this, #_"CanonicalizerTool" tool]
        (or
            (when (and (not (:forceAnyLocation this)) (#_"LocationIdentity" .isAny (:locationIdentity this)))
                (let [
                    #_"ValueNode" object (:object this)
                ]
                    (when (and (instance? ConstantNode (:offset this)) (instance? ConstantNode object) (not (ValueNode''isNullConstant-1 object)))
                        (let [
                            #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp object))
                        ]
                            (when (and (some? type) (#_"ResolvedJavaType" .isArray type))
                                (let [
                                    #_"JavaConstant" array (ValueNode''asJavaConstant-1 object)
                                ]
                                    (when (some? array)
                                        (let [
                                            #_"int" stableDimension (:stableDimension object)
                                        ]
                                            (when (pos? stableDimension)
                                                (let [
                                                    #_"long" offset (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset this)))
                                                    #_"Constant" constant (Stamp''readConstant-4 (:stamp this), (#_"ConstantReflectionProvider" .getMemoryAccessProvider HotSpot'constantReflection), array, offset)
                                                    #_"boolean" isDefaultStable (:isDefaultStable object)
                                                ]
                                                    (when (and (some? constant) (or isDefaultStable (not (#_"Constant" .isDefaultForKind constant))))
                                                        (ConstantNode'forConstant-4 (:stamp this), constant, (dec stableDimension), isDefaultStable)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (UnsafeAccessNode''canonical-2 (§ super ), tool)
        )
    )

    #_unused
    (§ override #_"ValueNode" RawLoadNode''cloneAsFieldAccess-2 [#_"RawLoadNode" this, #_"ResolvedJavaField" field]
        (LoadFieldNode'create-2 (:object this), field)
    )

    #_unused
    (§ override #_"ValueNode" RawLoadNode''cloneAsArrayAccess-3 [#_"RawLoadNode" this, #_"ValueNode" location, #_"LocationIdentity" identity]
        (RawLoadNode'new-4 (:object this), location, (:accessKind this), identity)
    )

    ; @NodeIntrinsic
    #_unused
    (§ native #_"Object" RawLoadNode'load-4 [#_"Object" object, #_"long" offset, #_@ConstantNodeParameter #_"JavaKind" kind, #_@ConstantNodeParameter #_"LocationIdentity" locationIdentity])
)

;;;
 ; Store of a value at a location specified as an offset relative to an object. No nil-check is
 ; performed before the store.
 ;;
(final-ns RawStoreNode (§ extends UnsafeAccessNode) (§ implements StateSplit, Lowerable, Virtualizable, Single)
    (§ def #_"NodeClass<RawStoreNode>" RawStoreNode'TYPE (NodeClass'create-1 RawStoreNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)
    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)
    (§ final #_"boolean" :needsBarrier false)

    (§ defn #_"RawStoreNode" RawStoreNode'new-5 [#_"ValueNode" object, #_"ValueNode" offset, #_"ValueNode" value, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity]
        (RawStoreNode'new-6 object, offset, value, accessKind, locationIdentity, true)
    )

    (§ defn #_"RawStoreNode" RawStoreNode'new-6 [#_"ValueNode" object, #_"ValueNode" offset, #_"ValueNode" value, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity, #_"boolean" needsBarrier]
        (RawStoreNode'new-8 object, offset, value, accessKind, locationIdentity, needsBarrier, nil, false)
    )

    (§ defn #_"RawStoreNode" RawStoreNode'new-8 [#_"ValueNode" object, #_"ValueNode" offset, #_"ValueNode" value, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity, #_"boolean" needsBarrier, #_"FrameState" stateAfter, #_"boolean" forceAnyLocation]
        (let [
            #_"RawStoreNode" this (UnsafeAccessNode'new-7 RawStoreNode'TYPE, (StampFactory'forVoid-0), object, offset, accessKind, locationIdentity, forceAnyLocation)
            this (assoc this :value value)
            this (assoc this :needsBarrier needsBarrier)
            this (assoc this :stateAfter stateAfter)
        ]
            this
        )
    )

    ; @NodeIntrinsic
    #_unused
    (§ native #_"Object" RawStoreNode'storeObject-6 [#_"Object" object, #_"long" offset, #_"Object" value, #_@ConstantNodeParameter #_"JavaKind" kind, #_@ConstantNodeParameter #_"LocationIdentity" locationIdentity, #_@ConstantNodeParameter #_"boolean" needsBarrier])

    ; @NodeIntrinsic
    #_unused
    (§ native #_"Object" RawStoreNode'storeChar-5 [#_"Object" object, #_"long" offset, #_"char" value, #_@ConstantNodeParameter #_"JavaKind" kind, #_@ConstantNodeParameter #_"LocationIdentity" locationIdentity])

    (§ override! #_"FrameState" RawStoreNode''stateAfter-1 [#_"RawStoreNode" this]
        (:stateAfter this)
    )

    #_unused
    (§ override! #_"void" RawStoreNode''setStateAfter-2 [#_"RawStoreNode" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    #_unused
    (§ override! #_"boolean" RawStoreNode''hasSideEffect-1 [#_"RawStoreNode" this]
        true
    )

    #_unused
    (§ override! #_"void" RawStoreNode''lower-2 [#_"RawStoreNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerUnsafeStoreNode-1 this)
        nil
    )

    #_unused
    (§ override! #_"void" RawStoreNode''virtualize-2 [#_"RawStoreNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" object (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (instance? VirtualObjectNode object)
                (let [
                    #_"ValueNode" offset (VirtualizerTool''getAlias-2 tool, (:offset this))
                ]
                    (when (instance? ConstantNode offset)
                        (let [
                            #_"long" off (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 offset))
                            #_"int" i (VirtualObjectNode''entryIndexForOffset-3 object, off, (:accessKind this))
                        ]
                            (when (and (not= i -1) (VirtualizerTool''setVirtualEntry-6 tool, object, i, (:value this), (:accessKind this), off))
                                (VirtualizerTool''delete-1 tool)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"ValueNode" RawStoreNode''cloneAsFieldAccess-2 [#_"RawStoreNode" this, #_"ResolvedJavaField" field]
        (StoreFieldNode'new-4 (:object this), field, (:value this), (RawStoreNode''stateAfter-1 this))
    )

    #_unused
    (§ override! #_"ValueNode" RawStoreNode''cloneAsArrayAccess-3 [#_"RawStoreNode" this, #_"ValueNode" location, #_"LocationIdentity" identity]
        (RawStoreNode'new-8 (:object this), location, (:value this), (:accessKind this), identity, (:needsBarrier this), (RawStoreNode''stateAfter-1 this), (:forceAnyLocation this))
    )
)

;;;
 ; This node provides a state split along with the functionality of FixedValueAnchorNode.
 ; This is used to capture a state for deoptimization when a node has side effects which aren't
 ; easily represented. The anchored value is usually part of the FrameState since this forces uses
 ; of the value below this node so they will consume this frame state instead of an earlier one.
 ;;
(final-ns StateSplitProxyNode (§ extends FixedValueAnchorNode) (§ implements Canonicalizable, StateSplit)
    (§ def #_"NodeClass<StateSplitProxyNode>" StateSplitProxyNode'TYPE (NodeClass'create-1 StateSplitProxyNode))

    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)
    ;;;
     ; Disallows elimination of this node until after the FrameState has been consumed.
     ;;
    (§ final #_"boolean" :delayElimination false)

    (§ defn #_"StateSplitProxyNode" StateSplitProxyNode'new-1 [#_"ValueNode" object]
        (StateSplitProxyNode'new-2 object, false)
    )

    (§ defn #_"StateSplitProxyNode" StateSplitProxyNode'new-2 [#_"ValueNode" object, #_"boolean" delayElimination]
        (let [
            #_"StateSplitProxyNode" this (FixedValueAnchorNode'new-2 StateSplitProxyNode'TYPE, object)
            this (assoc this :delayElimination delayElimination)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"FrameState" StateSplitProxyNode''stateAfter-1 [#_"StateSplitProxyNode" this]
        (:stateAfter this)
    )

    (§ override! #_"void" StateSplitProxyNode''setStateAfter-2 [#_"StateSplitProxyNode" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    #_unused
    (§ override! #_"boolean" StateSplitProxyNode''hasSideEffect-1 [#_"StateSplitProxyNode" this]
        true
    )

    #_unused
    (§ override! #_"Node" StateSplitProxyNode''canonical-2 [#_"StateSplitProxyNode" this, #_"CanonicalizerTool" tool]
        (when (or (and (instance? ConstantNode (:object this)) (not (:delayElimination this))) (nil? (:stateAfter this))) => this
            (:object this)
        )
    )
)

(final-ns StoreHubNode (§ extends FixedWithNextNode) (§ implements Lowerable)
    (§ def #_"NodeClass<StoreHubNode>" StoreHubNode'TYPE (NodeClass'create-1 StoreHubNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)
    ; @Input
    (§ mutable #_"ValueNode" :object nil)

    #_unused
    (§ defn #_"StoreHubNode" StoreHubNode'new-2 [#_"ValueNode" object, #_"ValueNode" value]
        (let [
            #_"StoreHubNode" this (FixedWithNextNode'new-2 StoreHubNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :value value)
            this (assoc this :object object)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" StoreHubNode''lower-2 [#_"StoreHubNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerStoreHubNode-2 this, (:graph this))
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"void" StoreHubNode'write-2 [#_"Object" object, #_"Object" value])
)

;;;
 ; The SwitchNode class is the base of both lookup and table switches.
 ;;
(class-ns SwitchNode (§ extends ControlSplitNode)
    (§ def #_"NodeClass<SwitchNode>" SwitchNode'TYPE (NodeClass'create-1 SwitchNode))

    ; @Successor
    (§ mutable #_"NodeSuccessorList<AbstractBeginNode>" :successors nil)
    ; @Input
    (§ mutable #_"ValueNode" :value nil)

    ;; do not change the contents of these arrays:
    (§ final #_"double[]" :keyProbabilities nil)
    (§ final #_"int[]" :keySuccessors nil)

    ;;;
     ; Constructs a new Switch.
     ;
     ; @param value the instruction that provides the value to be switched over
     ; @param successors the list of successors of this switch
     ;;
    (§ defn #_"SwitchNode" SwitchNode'new-5 [#_"NodeClass<? extends SwitchNode>" c, #_"ValueNode" value, #_"AbstractBeginNode[]" successors, #_"int[]" keySuccessors, #_"double[]" keyProbabilities]
        (let [
            #_"SwitchNode" this (ControlSplitNode'new-2 c, (StampFactory'forVoid-0))
            this (assoc this :successors (NodeSuccessorList'new-2 this, successors))
            this (assoc this :value value)
            this (assoc this :keySuccessors keySuccessors)
            this (assoc this :keyProbabilities keyProbabilities)
        ]
            this
        )
    )

    #_unused
    (§ override #_"int" SwitchNode''getSuccessorCount-1 [#_"SwitchNode" this]
        (count (:successors this))
    )

    (§ override #_"double" SwitchNode''probability-2 [#_"SwitchNode" this, #_"AbstractBeginNode" successor]
        (loop-when [#_"double" sum 0.0 #_"int" i 0] (< i (count (:keySuccessors this))) => sum
            (let [
                sum
                    (when (= (nth (:successors this) (nth (:keySuccessors this) i)) successor) => sum
                        (+ sum (nth (:keyProbabilities this) i))
                    )
            ]
                (recur sum (inc i))
            )
        )
    )

    #_unused
    (§ override #_"boolean" SwitchNode''setProbability-3 [#_"SwitchNode" this, #_"AbstractBeginNode" successor, #_"double" value]
        (let [
            [#_"double" sum #_"double" otherSum]
                (loop-when [sum 0.0 otherSum 0.0 #_"int" i 0] (< i (count (:keySuccessors this))) => [sum otherSum]
                    (if (= (nth (:successors this) (nth (:keySuccessors this) i)) successor)
                        (recur (+ sum (nth (:keyProbabilities this) i)) otherSum (inc i))
                        (recur sum (+ otherSum (nth (:keyProbabilities this) i)) (inc i))
                    )
                )
        ]
            (if (or (zero? sum) (zero? otherSum))
                false ;; cannot correctly adjust probabilities
                (let [
                    #_"double" delta (- value sum)
                ]
                    (dotimes [#_"int" i (count (:keySuccessors this))]
                        (if (= (nth (:successors this) (nth (:keySuccessors this) i)) successor)
                            (aswap (:keyProbabilities this) i #(max 0.0 (+ % (/ (* delta %) sum))))
                            (aswap (:keyProbabilities this) i #(max 0.0 (- % (/ (* delta %) otherSum))))
                        )
                    )
                    true
                )
            )
        )
    )

    (§ method #_"ValueNode" SwitchNode''value-1 [#_"SwitchNode" this]
        (:value this)
    )

    (§ abstract #_"boolean" SwitchNode''isSorted-1 [#_"SwitchNode" this])

    ;;;
     ; The key at the specified position, encoded in a Constant.
     ;;
    (§ abstract #_"Constant" SwitchNode''keyAt-2 [#_"SwitchNode" this, #_"int" i])

    (§ method! #_"boolean" SwitchNode''structureEquals-2 [#_"SwitchNode" this, #_"SwitchNode" switchNode]
        (and (Arrays/equals (:keySuccessors this), (:keySuccessors switchNode)) (SwitchNode''equalKeys-2 this, switchNode))
    )

    ;;;
     ; Returns true if the switch has the same keys in the same order as this switch.
     ;;
    (§ abstract #_"boolean" SwitchNode''equalKeys-2 [#_"SwitchNode" this, #_"SwitchNode" switchNode])

    ;;;
     ; Returns the index of the successor belonging to the key at the specified index.
     ;;
    (§ method! #_"int" SwitchNode''keySuccessorIndex-2 [#_"SwitchNode" this, #_"int" i]
        (nth (:keySuccessors this) i)
    )

    ;;;
     ; Returns the successor for the key at the given index.
     ;;
    (§ method! #_"AbstractBeginNode" SwitchNode''keySuccessor-2 [#_"SwitchNode" this, #_"int" i]
        (nth (:successors this) (nth (:keySuccessors this) i))
    )

    ;;;
     ; Returns the probability of the key at the given index.
     ;;
    (§ method! #_"double" SwitchNode''keyProbability-2 [#_"SwitchNode" this, #_"int" i]
        (nth (:keyProbabilities this) i)
    )

    ;;;
     ; Returns the index of the default (fall through) successor of this switch.
     ;;
    (§ method! #_"int" SwitchNode''defaultSuccessorIndex-1 [#_"SwitchNode" this]
        (nth (:keySuccessors this) (dec (count (:keySuccessors this))))
    )

    (§ method! #_"void" SwitchNode''setBlockSuccessor-3 [#_"SwitchNode" this, #_"int" i, #_"AbstractBeginNode" s]
        (NodeList''set-3 (:successors this), i, s)
        nil
    )

    ;;;
     ; Gets the successor corresponding to the default (fall through) case.
     ;
     ; @return the default successor
     ;;
    (§ method! #_"AbstractBeginNode" SwitchNode''defaultSuccessor-1 [#_"SwitchNode" this]
        (when (= (SwitchNode''defaultSuccessorIndex-1 this) -1)
            (throw! "unexpected")
        )
        (nth (:successors this) (SwitchNode''defaultSuccessorIndex-1 this))
    )

    #_unused
    (§ override #_"AbstractBeginNode" SwitchNode''getPrimarySuccessor-1 [#_"SwitchNode" this]
        nil
    )

    ;;;
     ; Delete all other successors except for the one reached by {@code survivingEdge}.
     ;
     ; @param survivingEdge index of the edge in the SwitchNode#successors list
     ;;
    (§ method! #_"void" SwitchNode''killOtherSuccessors-3 [#_"SwitchNode" this, #_"SimplifierTool" tool, #_"int" survivingEdge]
        (doseq [#_"Node" successor (Node''successors-1 this)]
            ;; Deleting a branch change the successors, so reload the surviving successor each time.
            (when-not (= successor (nth (:successors this) survivingEdge))
                (SimplifierTool''deleteBranch-2 tool, successor)
            )
        )
        (SimplifierTool''addToWorkList-2 tool, (nth (:successors this) survivingEdge))
        (Graph''removeSplit-3 (:graph this), this, (nth (:successors this) survivingEdge))
        nil
    )

    #_unused
    (§ abstract #_"Stamp" SwitchNode''getValueStampForSuccessor-2 [#_"SwitchNode" this, #_"AbstractBeginNode" beginNode])
)

(final-ns UnboxNode (§ extends FixedWithNextNode) (§ implements Virtualizable, Lowerable, Unary #_"<ValueNode>")
    (§ def #_"NodeClass<UnboxNode>" UnboxNode'TYPE (NodeClass'create-1 UnboxNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)
    (§ final #_"JavaKind" :boxingKind nil)

    (§ override! #_"ValueNode" UnboxNode''getValue-1 [#_"UnboxNode" this]
        (:value this)
    )

    (§ defn #_"UnboxNode" UnboxNode'new-2 [#_"ValueNode" value, #_"JavaKind" boxingKind]
        (let [
            #_"UnboxNode" this (FixedWithNextNode'new-2 UnboxNode'TYPE, (StampFactory'forKind-1 (#_"JavaKind" .getStackKind boxingKind)))
            this (assoc this :value value)
            this (assoc this :boxingKind boxingKind)
        ]
            this
        )
    )

    #_unused
    (§ defn #_"ValueNode" UnboxNode'create-2 [#_"ValueNode" value, #_"JavaKind" boxingKind]
        (or (UnboxNode'findSynonym-2 value, boxingKind) (UnboxNode'new-2 value, boxingKind))
    )

    #_unused
    (§ override! #_"void" UnboxNode''lower-2 [#_"UnboxNode" this, #_"LoweringTool" lowerer]
        (BoxingTemplates''lower-3 Lowerer'boxingSnippets, this, lowerer)
        nil
    )

    #_unused
    (§ override! #_"void" UnboxNode''virtualize-2 [#_"UnboxNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" alias (VirtualizerTool''getAlias-2 tool, (UnboxNode''getValue-1 this))
        ]
            (when (instance? VirtualObjectNode alias)
                (let [
                    #_"ResolvedJavaType" objectType (VirtualObjectNode''type-1 alias)
                    #_"ResolvedJavaType" expectedType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (#_"JavaKind" .toBoxedJavaClass (:boxingKind this)))
                ]
                    (when (= objectType expectedType)
                        (VirtualizerTool''replaceWithValue-2 tool, (VirtualizerTool''getEntry-3 tool, alias, 0))
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"ValueNode" UnboxNode''canonical-3 [#_"UnboxNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (when-not (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this) (StampTool'isPointerNeverNull-1 (:stamp value)))
            (or (UnboxNode'findSynonym-2 value, (:boxingKind this))
                this
            )
        )
    )

    (§ defn- #_"ValueNode" UnboxNode'findSynonym-2 [#_"ValueNode" value, #_"JavaKind" boxingKind]
        (cond
            (instance? ConstantNode value)
                (let [
                    #_"JavaConstant" unboxed (#_"ConstantReflectionProvider" .unboxPrimitive HotSpot'constantReflection, (ValueNode''asJavaConstant-1 value))
                ]
                    (when (and (some? unboxed) (= (#_"JavaConstant" .getJavaKind unboxed) boxingKind))
                        (ConstantNode'forConstant-1 unboxed)
                    )
                )
            (instance? BoxNode value)
                (when (= boxingKind (:boxingKind value))
                    (BoxNode''getValue-1 value)
                )
        )
    )
)

(class-ns UnsafeAccessNode (§ extends FixedWithNextNode) (§ implements Canonicalizable)
    (§ def #_"NodeClass<UnsafeAccessNode>" UnsafeAccessNode'TYPE (NodeClass'create-1 UnsafeAccessNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)
    ; @Input
    (§ mutable #_"ValueNode" :offset nil)

    (§ final #_"JavaKind" :accessKind nil)
    (§ final #_"LocationIdentity" :locationIdentity nil)
    (§ final #_"boolean" :forceAnyLocation false)

    (§ defn #_"UnsafeAccessNode" UnsafeAccessNode'new-7 [#_"NodeClass<? extends UnsafeAccessNode>" c, #_"Stamp" stamp, #_"ValueNode" object, #_"ValueNode" offset, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity, #_"boolean" forceAnyLocation]
        (let [
            #_"UnsafeAccessNode" this (FixedWithNextNode'new-2 c, stamp)
            this (assoc this :object object)
            this (assoc this :offset offset)
            this (assoc this :accessKind accessKind)
            this (assoc this :locationIdentity locationIdentity)
            this (assoc this :forceAnyLocation forceAnyLocation)
        ]
            this
        )
    )

    (§ override #_"Node" UnsafeAccessNode''canonical-2 [#_"UnsafeAccessNode" this, #_"CanonicalizerTool" tool]
        (when (and (not (:forceAnyLocation this)) (#_"LocationIdentity" .isAny (:locationIdentity this))) => this
            (when (instance? ConstantNode (:offset this))
                (let [
                    #_"long" constantOffset (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset this)))
                    ;; Try to canonicalize to a field access.
                    #_"ResolvedJavaType" receiverType (StampTool'typeOrNull-1 (:stamp (:object this)))
                ]
                    (when (some? receiverType)
                        (let [
                            #_"ResolvedJavaField" field (#_"ResolvedJavaType" .findInstanceFieldWithOffset receiverType, constantOffset, (:accessKind this))
                        ]
                            ;; No need for checking that the receiver is non-nil. The field access includes
                            ;; the nil-check and if a field is found, the offset is so small that this is
                            ;; never a valid access of an arbitrary address.
                            (when (and (some? field) (= (#_"JavaType" .getJavaKind field) (:accessKind this)))
                                (§ return (UnsafeAccessNode''cloneAsFieldAccess-2 this, field))
                            )
                        )
                    )
                )
            )
            (let [
                #_"ResolvedJavaType" receiverType (StampTool'typeOrNull-1 (:stamp (:object this)))
            ]
                ;; Try to build a better location identity.
                (when (and (some? receiverType) (#_"ResolvedJavaType" .isArray receiverType)) => this
                    (UnsafeAccessNode''cloneAsArrayAccess-3 this, (:offset this), (NamedLocationIdentity'getArrayLocation-1 (#_"JavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType receiverType))))
                )
            )
        )
    )

    (§ abstract #_"ValueNode" UnsafeAccessNode''cloneAsFieldAccess-2 [#_"UnsafeAccessNode" this, #_"ResolvedJavaField" field])

    (§ abstract #_"ValueNode" UnsafeAccessNode''cloneAsArrayAccess-3 [#_"UnsafeAccessNode" this, #_"ValueNode" location, #_"LocationIdentity" identity])
)

;;;
 ; Copy a value at a location specified as an offset relative to a source object to another location
 ; specified as an offset relative to destination object. No nil-checks are performed.
 ;;
(final-ns UnsafeCopyNode
    #_unused
    (§ defn #_"UnsafeCopyNode" UnsafeCopyNode'new-0 []
        (Object.)
    )

    #_unused
    (§ defn #_"boolean" UnsafeCopyNode'intrinsify-8 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode" sourceObject, #_"ValueNode" sourceOffset, #_"ValueNode" destinationObject, #_"ValueNode" destinationOffset, #_"JavaKind" accessKind, #_"LocationIdentity" locationIdentity]
        (let [
            #_"RawLoadNode" value (BytecodeParser''add-2 parser, (RawLoadNode'new-4 sourceObject, sourceOffset, accessKind, locationIdentity))
        ]
            (BytecodeParser''add-2 parser, (RawStoreNode'new-5 destinationObject, destinationOffset, value, accessKind, locationIdentity))
            true
        )
    )

    ; @NodeIntrinsic
    #_unused
    (§ native #_"void" UnsafeCopyNode'copy-6 [#_"Object" srcObject, #_"long" srcOffset, #_"Object" destObject, #_"long" destOffset, #_@ConstantNodeParameter #_"JavaKind" kind, #_@ConstantNodeParameter #_"LocationIdentity" locationIdentity])
)

;;;
 ; Load of a value at a location specified as an absolute address.
 ;;
(final-ns UnsafeMemoryLoadNode (§ extends FixedWithNextNode) (§ implements Lowerable)
    (§ def #_"NodeClass<UnsafeMemoryLoadNode>" UnsafeMemoryLoadNode'TYPE (NodeClass'create-1 UnsafeMemoryLoadNode))

    ; @Input
    (§ mutable #_"ValueNode" :address nil)

    (§ final #_"JavaKind" :kind nil)
    (§ final #_"LocationIdentity" :locationIdentity nil)

    #_unused
    (§ defn #_"UnsafeMemoryLoadNode" UnsafeMemoryLoadNode'new-3 [#_"ValueNode" address, #_"JavaKind" kind, #_"LocationIdentity" locationIdentity]
        (let [
            #_"UnsafeMemoryLoadNode" this (FixedWithNextNode'new-2 UnsafeMemoryLoadNode'TYPE, (StampFactory'forKind-1 (#_"JavaKind" .getStackKind kind)))
            this (assoc this :address address)
            this (assoc this :kind kind)
            this (assoc this :locationIdentity locationIdentity)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" UnsafeMemoryLoadNode''lower-2 [#_"UnsafeMemoryLoadNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerUnsafeMemoryLoadNode-1 this)
        nil
    )
)

;;;
 ; Store of a value at a location specified as an absolute address.
 ;;
(final-ns UnsafeMemoryStoreNode (§ extends AbstractStateSplit) (§ implements Lowerable, Single)
    (§ def #_"NodeClass<UnsafeMemoryStoreNode>" UnsafeMemoryStoreNode'TYPE (NodeClass'create-1 UnsafeMemoryStoreNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)
    ; @Input
    (§ mutable #_"ValueNode" :address nil)

    (§ final #_"JavaKind" :kind nil)
    (§ final #_"LocationIdentity" :locationIdentity nil)

    #_unused
    (§ defn #_"UnsafeMemoryStoreNode" UnsafeMemoryStoreNode'new-4 [#_"ValueNode" address, #_"ValueNode" value, #_"JavaKind" kind, #_"LocationIdentity" locationIdentity]
        (let [
            #_"UnsafeMemoryStoreNode" this (AbstractStateSplit'new-2 UnsafeMemoryStoreNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :address address)
            this (assoc this :value value)
            this (assoc this :kind kind)
            this (assoc this :locationIdentity locationIdentity)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" UnsafeMemoryStoreNode''lower-2 [#_"UnsafeMemoryStoreNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerUnsafeMemoryStoreNode-1 this)
        nil
    )

    (§ override! #_"LocationIdentity" UnsafeMemoryStoreNode''getLocationIdentity-1 [#_"UnsafeMemoryStoreNode" this]
        (:locationIdentity this)
    )
)

;;;
 ; The ValueAnchor instruction keeps non-CFG (floating) nodes above a certain point in the graph.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Anchor, InputType.Guard"
(final-ns ValueAnchorNode (§ extends FixedWithNextNode) (§ implements LIRLowerable, Simplifiable, Virtualizable, AnchoringNode, GuardingNode)
    (§ def #_"NodeClass<ValueAnchorNode>" ValueAnchorNode'TYPE (NodeClass'create-1 ValueAnchorNode))

    ; @OptionalInput(InputType'Guard)
    (§ mutable #_"ValueNode" :anchored nil)

    (§ defn #_"ValueAnchorNode" ValueAnchorNode'new-1 [#_"ValueNode" value]
        (let [
            #_"ValueAnchorNode" this (FixedWithNextNode'new-2 ValueAnchorNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :anchored value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ValueAnchorNode''generate-2 [#_"ValueAnchorNode" this, #_"LIRBuilder" builder]
        ;; Nothing to emit, since this node is used for structural purposes only.
        nil
    )

    #_unused
    (§ override! #_"void" ValueAnchorNode''simplify-2 [#_"ValueAnchorNode" this, #_"SimplifierTool" tool]
        (loop-when [#_"ValueAnchorNode" nextAnchor (:next this)] (instance? ValueAnchorNode nextAnchor)
            (when (or (nil? (:anchored nextAnchor)) (= (:anchored nextAnchor) (:anchored this)))
                ;; two anchors for the same anchored -> coalesce
                ;; nothing anchored on the next anchor -> coalesce
                (§ ass! nextAnchor (Node''replaceAtUsages-2 nextAnchor, this))
                (GraphUtil'removeFixedWithUnusedInputs-1 nextAnchor)
                (recur (:next this))
            )
        )
        (if (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this) (instance? FixedAccessNode (:next this)) (= (FixedAccessNode''getGuard-1 (:next this)) (:anchored this)))
            (GraphUtil'removeFixedWithUnusedInputs-1 this)
            (do
                (when (and (some? (:anchored this)) (or (instance? ConstantNode (:anchored this)) (instance? FixedNode (:anchored this))))
                    ;; anchoring fixed nodes and constants is useless
                    (§ ass! this (ValueAnchorNode''removeAnchoredNode-1 this))
                )
                (when (and (nil? (:anchored this)) (Node''hasNoUsages-1 this))
                    ;; anchor is not necessary any more => remove.
                    (GraphUtil'removeFixedWithUnusedInputs-1 this)
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" ValueAnchorNode''virtualize-2 [#_"ValueAnchorNode" this, #_"VirtualizerTool" tool]
        (if (or (nil? (:anchored this)) (instance? AbstractBeginNode (:anchored this)))
            (VirtualizerTool''delete-1 tool)
            (when (instance? VirtualObjectNode (VirtualizerTool''getAlias-2 tool, (:anchored this)))
                (VirtualizerTool''delete-1 tool)
            )
        )
        nil
    )

    (§ method! #_"ValueAnchorNode" ValueAnchorNode''removeAnchoredNode-1 [#_"ValueAnchorNode" this]
        (Node''updateUsages-3 this, (:anchored this), nil)
        (assoc this :anchored nil)
    )
)

(final-ns FieldLocationIdentity (§ extends LocationIdentity)
    (§ final #_"ResolvedJavaField" :inner nil)

    (§ defn #_"FieldLocationIdentity" FieldLocationIdentity'new-1 [#_"ResolvedJavaField" inner]
        (let [
            #_"FieldLocationIdentity" this (LocationIdentity.)
            this (assoc this :inner inner)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" FieldLocationIdentity''isImmutable-1 [#_"FieldLocationIdentity" this]
        false
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Guard"
(final-ns FixedGuardNode (§ extends AbstractFixedGuardNode) (§ implements Lowerable, IterableNodeType)
    (§ def #_"NodeClass<FixedGuardNode>" FixedGuardNode'TYPE (NodeClass'create-1 FixedGuardNode))

    (§ defn #_"FixedGuardNode" FixedGuardNode'new-3 [#_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action]
        (FixedGuardNode'new-5 logic, reason, action, JavaConstant/NULL_POINTER, false)
    )

    (§ defn #_"FixedGuardNode" FixedGuardNode'new-4 [#_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"boolean" negated?]
        (FixedGuardNode'new-5 logic, reason, action, JavaConstant/NULL_POINTER, negated?)
    )

    (§ defn #_"FixedGuardNode" FixedGuardNode'new-5 [#_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"JavaConstant" speculation, #_"boolean" negated?]
        (AbstractFixedGuardNode'new-6 FixedGuardNode'TYPE, logic, reason, action, speculation, negated?)
    )

    #_unused
    (§ override! #_"void" FixedGuardNode''simplify-2 [#_"FixedGuardNode" this, #_"SimplifierTool" tool]
        (AbstractFixedGuardNode''simplify-2 (§ super ), tool)
        (let [
            #_"LogicNode" logic (AbstractFixedGuardNode''getCondition-1 this)
        ]
            (condp instance? logic
                LogicConstantNode
                    (do
                        (when (= (:value logic) (:negated? this))
                            (let [
                                #_"FixedNode" currentNext (:next this)
                            ]
                                (when (some? currentNext)
                                    (SimplifierTool''deleteBranch-2 tool, currentNext)
                                )

                                (let [
                                    #_"DeoptimizeNode" deopt (Graph''add-2 (:graph this), (DeoptimizeNode'new-3 (:action this), (:reason this), (:speculation this)))
                                ]
                                    (AbstractDeoptimizeNode''setStateBefore-2 deopt, (DeoptimizingFixedWithNextNode''stateBefore-1 this))
                                    (§ ass! this (FixedWithNextNode''setNext-2 this, deopt))
                                )
                            )
                        )
                        (§ ass! this (Node''replaceAtUsages-2 this, nil))
                        (Graph''removeFixed-2 (:graph this), this)
                    )
                ShortCircuitOrNode
                    (when (and (:negated? this) (Node''hasNoUsages-1 this))
                        (Graph''addAfterFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (FixedGuardNode'new-5 (:y logic), (:reason this), (:action this), (:speculation this), (not (:yNegated logic)))))
                        (§ ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (FixedGuardNode'new-5 (:x logic), (:reason this), (:action this), (:speculation this), (not (:xNegated logic))))))
                    )
                nil
            )
        )
        nil
    )

    (§ override! #_"void" FixedGuardNode''lower-2 [#_"FixedGuardNode" this, #_"LoweringTool" lowerer]
        (if (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph this)))
            (when-not (= (:action this) DeoptimizationAction/None)
                (let [
                    #_"ValueNode" guard (LoweringTool''createGuard-7 lowerer, this, (AbstractFixedGuardNode''getCondition-1 this), (:reason this), (:action this), (:speculation this), (:negated? this))
                ]
                    (§ ass! this (Node''replaceAtUsages-2 this, guard))
                    (Graph''removeFixed-2 (:graph this), this)
                )
            )
            (DeoptimizeNode''lower-2 (AbstractFixedGuardNode''lowerToIf-1 this), lowerer)
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" FixedGuardNode''canDeoptimize-1 [#_"FixedGuardNode" this]
        true
    )
)

(class-ns FixedNode (§ extends ValueNode)
    (§ def #_"NodeClass<FixedNode>" FixedNode'TYPE (NodeClass'create-1 FixedNode))

    (§ defn #_"FixedNode" FixedNode'new-2 [#_"NodeClass<? extends FixedNode>" c, #_"Stamp" stamp]
        (ValueNode'new-2 c, stamp)
    )
)

;;;
 ; Base class of all nodes that are fixed within the control flow graph and have an immediate successor.
 ;;
(class-ns FixedWithNextNode (§ extends FixedNode)
    (§ def #_"NodeClass<FixedWithNextNode>" FixedWithNextNode'TYPE (NodeClass'create-1 FixedWithNextNode))

    ; @Successor
    (§ mutable #_"FixedNode" :next nil)

    (§ method! #_"FixedWithNextNode" FixedWithNextNode''setNext-2 [#_"FixedWithNextNode" this, #_"FixedNode" node]
        (Node''updatePredecessor-3 this, (:next this), node)
        (assoc this :next node)
    )

    (§ defn #_"FixedWithNextNode" FixedWithNextNode'new-2 [#_"NodeClass<? extends FixedWithNextNode>" c, #_"Stamp" stamp]
        (FixedNode'new-2 c, stamp)
    )
)

(class-ns FloatingAnchoredNode (§ extends FloatingNode)
    (§ def #_"NodeClass<FloatingAnchoredNode>" FloatingAnchoredNode'TYPE (NodeClass'create-1 FloatingAnchoredNode))

    ; @Input(InputType'Anchor)
    (§ mutable #_"AnchoringNode" :anchor nil)

    #_unused
    (§ defn #_"FloatingAnchoredNode" FloatingAnchoredNode'new-2 [#_"NodeClass<? extends FloatingAnchoredNode>" c, #_"Stamp" stamp]
        (FloatingNode'new-2 c, stamp)
    )

    (§ defn #_"FloatingAnchoredNode" FloatingAnchoredNode'new-3 [#_"NodeClass<? extends FloatingAnchoredNode>" c, #_"Stamp" stamp, #_"AnchoringNode" anchor]
        (let [
            #_"FloatingAnchoredNode" this (FloatingNode'new-2 c, stamp)
            this (assoc this :anchor anchor)
        ]
            this
        )
    )

    (§ method #_"AnchoringNode" FloatingAnchoredNode''getAnchor-1 [#_"FloatingAnchoredNode" this]
        (:anchor this)
    )

    #_unused
    (§ method! #_"FloatingAnchoredNode" FloatingAnchoredNode''setAnchor-2 [#_"FloatingAnchoredNode" this, #_"AnchoringNode" anchor]
        (Node''updateUsages-3 this, (:anchor this), anchor)
        (assoc this :anchor anchor)
    )
)

(class-ns FloatingGuardedNode (§ extends FloatingNode) (§ implements GuardedNode)
    (§ def #_"NodeClass<FloatingGuardedNode>" FloatingGuardedNode'TYPE (NodeClass'create-1 FloatingGuardedNode))

    ; @OptionalInput(InputType'Guard)
    (§ mutable #_"GuardingNode" :guard nil)

    (§ defn #_"FloatingGuardedNode" FloatingGuardedNode'new-2 [#_"NodeClass<? extends FloatingGuardedNode>" c, #_"Stamp" stamp]
        (FloatingNode'new-2 c, stamp)
    )

    (§ defn #_"FloatingGuardedNode" FloatingGuardedNode'new-3 [#_"NodeClass<? extends FloatingGuardedNode>" c, #_"Stamp" stamp, #_"GuardingNode" guard]
        (let [
            #_"FloatingGuardedNode" this (FloatingNode'new-2 c, stamp)
            this (assoc this :guard guard)
        ]
            this
        )
    )

    (§ override #_"GuardingNode" FloatingGuardedNode''getGuard-1 [#_"FloatingGuardedNode" this]
        (:guard this)
    )

    #_unused
    (§ override #_"void" FloatingGuardedNode''setGuard-2 [#_"FloatingGuardedNode" this, #_"GuardingNode" guard]
        (Node''updateUsages-3 this, (:guard this), guard)
        (§ ass! this (assoc this :guard guard))
        nil
    )
)

;;;
 ; The FrameState class encapsulates the frame state (i.e. local variables and operand stack) at a particular
 ; point in the abstract interpretation.
 ;
 ; This can be used as debug or deoptimization information.
 ;;
(final-ns FrameState (§ extends VirtualState) (§ implements IterableNodeType)
    (§ def #_"NodeClass<FrameState>" FrameState'TYPE (NodeClass'create-1 FrameState))

    ;;;
     ; Marker value for the second slot of values that occupy two local variable or expression stack slots.
     ; The marker value is used by the bytecode parser, but replaced with nil in the #values of the FrameState.
     ;;
    (§ def #_"ValueNode" FrameState'TWO_SLOT_MARKER (TwoSlotMarker'new-0))

    ;;;
     ; Size of the local variables.
     ;;
    (§ final #_"int" :localsSize 0)

    ;;;
     ; Current size (height) of the stack.
     ;;
    (§ final #_"int" :stackSize 0)

    (§ final #_"boolean" :duringCall false)

    ; @OptionalInput(value = InputType'StateI)
    (§ mutable #_"FrameState" :outerFrameState nil)

    ;;;
     ; Contains the locals, the expressions and the locked objects, in this order.
     ;;
    ; @OptionalInput
    (§ mutable #_"NodeInputList<ValueNode>" :values nil)

    ; @Input(InputType'Association)
    (§ mutable #_"NodeInputList<MonitorIdNode>" :monitorIds nil)

    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"NodeInputList<EscapeObjectState>" :virtualObjectMappings nil)

    ;;;
     ; The bytecode index to which this frame state applies.
     ;;
    (§ final #_"int" :bci 0)

    ;;;
     ; The bytecode to which this frame state applies.
     ;;
    (§ final #_"Bytecode" :code nil)

    (§ defn #_"FrameState" FrameState'new-9 [#_"FrameState" outerFrameState, #_"Bytecode" code, #_"int" bci, #_"int" localsSize, #_"int" stackSize, #_"int" lockSize, #_"boolean" duringCall, #_"List<MonitorIdNode>" monitorIds, #_"List<EscapeObjectState>" virtualObjectMappings]
        (let [
            #_"FrameState" this (VirtualState'new-1 FrameState'TYPE)
        ]
            (when (some? code)
                ;; Make sure the bci is within range of the bytecodes. If the code size is 0 then allow
                ;; any value, otherwise the bci must be less than the code size. Any negative value is
                ;; also allowed to represent special bytecode states.
                (let [
                    #_"int" codeSize (Bytecode''getCodeSize-1 code)
                ]
                    (when (and (not= codeSize 0) (<= codeSize bci))
                        (throw! (str "bci " bci " is out of range for " (#_"ResolvedJavaMethod" .format (Bytecode''getMethod-1 code), "%H.\n(%p)") " " codeSize " bytes"))
                    )
                )
            )
            (let [
                this (assoc this :outerFrameState outerFrameState)
                this (assoc this :code code)
                this (assoc this :bci bci)
                this (assoc this :localsSize localsSize)
                this (assoc this :stackSize stackSize)
                this (assoc this :values (NodeInputList'new-2 this, (+ localsSize stackSize lockSize)))
                this
                    (when (seq monitorIds) => this
                        (assoc this :monitorIds (NodeInputList'new-2 this, monitorIds))
                    )
                this
                    (when (seq virtualObjectMappings) => this
                        (assoc this :virtualObjectMappings (NodeInputList'new-2 this, virtualObjectMappings))
                    )
                this (assoc this :duringCall duringCall)
            ]
                this
            )
        )
    )

    (§ defn #_"FrameState" FrameState'new-9 [#_"FrameState" outerFrameState, #_"Bytecode" code, #_"int" bci, #_"List<ValueNode>" values, #_"int" localsSize, #_"int" stackSize, #_"boolean" duringCall, #_"List<MonitorIdNode>" monitorIds, #_"List<EscapeObjectState>" virtualObjectMappings]
        (let [
            #_"FrameState" this (FrameState'new-9 outerFrameState, code, bci, localsSize, stackSize, (- (count values) localsSize stackSize), duringCall, monitorIds, virtualObjectMappings)
        ]
            (dotimes [#_"int" i (count values)]
                (NodeList''initialize-3 (:values this), i, (nth values i))
            )
            this
        )
    )

    (§ defn #_"FrameState" FrameState'new-1 [#_"int" bci]
        (FrameState'new-9 nil, nil, bci, 0, 0, 0, false, nil, #_"<EscapeObjectState>" (Collections/emptyList))
    )

    ;;;
     ; Creates a placeholder frame state with a single element on the stack representing a return
     ; value or thrown exception. This allows the parsing of an intrinsic to communicate the returned
     ; or thrown value in a {@link StateSplit#stateAfter() stateAfter} to the inlining call site.
     ;
     ; @param bci this must be BytecodeFrame#AFTER_BCI
     ;;
    (§ defn #_"FrameState" FrameState'new-2 [#_"int" bci, #_"ValueNode" returnValue]
        (let [
            #_"FrameState" this (FrameState'new-9 nil, nil, bci, 0, (#_"JavaKind" .getSlotCount (ValueNode''getStackKind-1 returnValue)), 0, false, nil, #_"<EscapeObjectState>" (Collections/emptyList))
        ]
            (NodeList''initialize-3 (:values this), 0, returnValue)
            this
        )
    )

    (§ defn #_"FrameState" FrameState'new-9 [#_"FrameState" outerFrameState, #_"Bytecode" code, #_"int" bci, #_"ValueNode[]" locals, #_"ValueNode[]" stack, #_"int" stackSize, #_"ValueNode[]" locks, #_"List<MonitorIdNode>" monitorIds, #_"boolean" duringCall]
        (let [
            #_"FrameState" this (FrameState'new-9 outerFrameState, code, bci, (count locals), stackSize, (count locks), duringCall, monitorIds, #_"<EscapeObjectState>" (Collections/emptyList))
            #_"int" index
                (loop-when-recur [index 0 #_"int" i 0] (< i (count locals)) [(inc index) (inc i)] => index
                    (let [
                        #_"ValueNode" value (nth locals i)
                    ]
                        (NodeList''initialize-3 (:values this), index, (when-not (= value FrameState'TWO_SLOT_MARKER) value))
                    )
                )
            index
                (loop-when-recur [index index #_"int" i 0] (< i (:stackSize this)) [(inc index) (inc i)] => index
                    (let [
                        #_"ValueNode" value (nth stack i)
                    ]
                        (NodeList''initialize-3 (:values this), index, (when-not (= value FrameState'TWO_SLOT_MARKER) value))
                    )
                )
        ]
            (loop-when-recur [index index #_"int" i 0] (< i (count locks)) [(inc index) (inc i)]
                (NodeList''initialize-3 (:values this), index, (nth locks i))
            )
            this
        )
    )

    (§ method! #_"FrameState" FrameState''setOuterFrameState-2 [#_"FrameState" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:outerFrameState this), x)
        (assoc this :outerFrameState x)
    )

    (§ method! #_"ResolvedJavaMethod" FrameState''getMethod-1 [#_"FrameState" this]
        (when (some? (:code this)) (Bytecode''getMethod-1 (:code this)))
    )

    ;;;
     ; Determines if this frame state can be converted to a BytecodeFrame.
     ;
     ; Since a BytecodeFrame encodes #getMethod() and #bci, it does not
     ; preserve #getCode(). #bci is only guaranteed to be valid in terms of
     ; {@code getCode().getCode()} which may be different from {@code getMethod().getCode()} if the
     ; latter has been subject to instrumentation.
     ;;
    #_unused
    (§ method! #_"boolean" FrameState''canProduceBytecodeFrame-1 [#_"FrameState" this]
        (and (some? (:code this)) (= (Bytecode''getCode-1 (:code this)) (#_"ResolvedJavaMethod" .getCode (Bytecode''getMethod-1 (:code this)))))
    )

    (§ method! #_"FrameState" FrameState''addVirtualObjectMapping-2 [#_"FrameState" this, #_"EscapeObjectState" virtualObject]
        (let [
            this
                (when (nil? (:virtualObjectMappings this)) => this
                    (assoc this :virtualObjectMappings (NodeInputList'new-1 this))
                )
        ]
            (NodeList''add-2 (:virtualObjectMappings this), virtualObject)
            this
        )
    )

    (§ method! #_"int" FrameState''virtualObjectMappingCount-1 [#_"FrameState" this]
        (if (some? (:virtualObjectMappings this)) (count (:virtualObjectMappings this)) 0)
    )

    (§ method! #_"EscapeObjectState" FrameState''virtualObjectMappingAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:virtualObjectMappings this) i)
    )

    ;;;
     ; Gets a copy of this frame state.
     ;;
    (§ method! #_"FrameState" FrameState''duplicate-2 [#_"FrameState" this, #_"int" newBci]
        (Graph''add-2 (:graph this), (FrameState'new-9 (:outerFrameState this), (:code this), newBci, (:values this), (:localsSize this), (:stackSize this), (:duringCall this), (:monitorIds this), (:virtualObjectMappings this)))
    )

    ;;;
     ; Gets a copy of this frame state.
     ;;
    (§ method! #_"FrameState" FrameState''duplicate-1 [#_"FrameState" this]
        (FrameState''duplicate-2 this, (:bci this))
    )

    ;;;
     ; Duplicates a FrameState, along with a deep copy of all connected VirtualState (outer
     ; FrameStates, VirtualObjectStates, ...).
     ;;
    (§ override! #_"FrameState" FrameState''duplicateWithVirtualState-1 [#_"FrameState" this]
        (let [
            #_"FrameState" newOuterFrameState (:outerFrameState this)
            newOuterFrameState (when (some? newOuterFrameState) (FrameState''duplicateWithVirtualState-1 newOuterFrameState))
            #_"ArrayList<EscapeObjectState>" newVirtualMappings
                (when (some? (:virtualObjectMappings this))
                    (let [
                        newVirtualMappings (ArrayList.)
                        _
                            (doseq [#_"EscapeObjectState" state (:virtualObjectMappings this)]
                                (#_"ArrayList" .add newVirtualMappings, (EscapeObjectState''duplicateWithVirtualState-1 state))
                            )
                    ]
                        newVirtualMappings
                    )
                )
        ]
            (Graph''add-2 (:graph this), (FrameState'new-9 newOuterFrameState, (:code this), (:bci this), (:values this), (:localsSize this), (:stackSize this), (:duringCall this), (:monitorIds this), newVirtualMappings))
        )
    )

    ;;;
     ; Creates a copy of this frame state with one stack element of type {@code popKind} popped from the stack.
     ;;
    (§ method! #_"FrameState" FrameState''duplicateModifiedDuringCall-3 [#_"FrameState" this, #_"int" newBci, #_"JavaKind" popKind]
        (FrameState''duplicateModified-7 this, (:graph this), newBci, true, popKind, nil, nil)
    )

    (§ method! #_"FrameState" FrameState''duplicateModifiedBeforeCall-5 [#_"FrameState" this, #_"int" newBci, #_"JavaKind" popKind, #_"JavaKind[]" pushedSlotKinds, #_"ValueNode[]" pushedValues]
        (FrameState''duplicateModified-7 this, (:graph this), newBci, false, popKind, pushedSlotKinds, pushedValues)
    )

    ;;;
     ; Creates a copy of this frame state with the top of stack replaced with with
     ; {@code pushedValue} which must be of type {@code popKind}.
     ;;
    (§ method! #_"FrameState" FrameState''duplicateModified-4 [#_"FrameState" this, #_"JavaKind" popKind, #_"JavaKind" pushedSlotKind, #_"ValueNode" pushedValue]
        (FrameState''duplicateModified-7 this, (:graph this), (:bci this), (:duringCall this), popKind, (into-array JavaKind [ pushedSlotKind ]), (into-array ValueNode [ pushedValue ]))
    )

    ;;;
     ; Creates a copy of this frame state with one stack element of type popKind popped from the
     ; stack and the values in pushedValues pushed on the stack. The pushedValues will be formatted
     ; correctly in slot encoding: a long or double will be followed by a nil slot. The bci will be
     ; changed to newBci.
     ;;
    (§ method! #_"FrameState" FrameState''duplicateModified-7 [#_"FrameState" this, #_"Graph" graph, #_"int" newBci, #_"boolean" newDuringCall, #_"JavaKind" popKind, #_"JavaKind[]" pushedSlotKinds, #_"ValueNode[]" pushedValues]
        (let [
            #_"ArrayList<ValueNode>" copy
                (let [
                    copy (ArrayList. (#_"List" .subList (:values this), 0, (+ (:localsSize this) (:stackSize this))))
                ]
                    (when-not (= popKind JavaKind/Void)
                        (when (nil? (FrameState''stackAt-2 this, (dec (:stackSize this))))
                            (#_"ArrayList" .remove copy, (dec (count copy)))
                        )
                        (#_"ArrayList" .remove copy, (dec (count copy)))
                    )
                    copy
                )
        ]
            (when (some? pushedValues)
                (dotimes [#_"int" i (count pushedValues)]
                    (#_"ArrayList" .add copy, (nth pushedValues i))
                    (when (#_"JavaKind" .needsTwoSlots (nth pushedSlotKinds i))
                        (#_"ArrayList" .add copy, nil)
                    )
                )
            )
            (let [
                #_"int" newStackSize (- (count copy) (:localsSize this))
            ]
                (#_"ArrayList" .addAll copy, (#_"List" .subList (:values this), (+ (:localsSize this) (:stackSize this)), (count (:values this))))

                (Graph''add-2 graph, (FrameState'new-9 (:outerFrameState this), (:code this), newBci, copy, (:localsSize this), newStackSize, newDuringCall, (:monitorIds this), (:virtualObjectMappings this)))
            )
        )
    )

    ;;;
     ; Gets the number of locked monitors in this frame state.
     ;;
    (§ method! #_"int" FrameState''locksSize-1 [#_"FrameState" this]
        (- (count (:values this)) (:localsSize this) (:stackSize this))
    )

    ;;;
     ; Gets the number of locked monitors in this frame state and all {@linkplain #outerFrameState() outer} frame states.
     ;;
    (§ method! #_"int" FrameState''nestedLockDepth-1 [#_"FrameState" this]
        (loop-when-recur [#_"int" depth (FrameState''locksSize-1 this) #_"FrameState" outer (:outerFrameState this)]
                         (some? outer)
                         [(+ depth (FrameState''locksSize-1 outer)) (:outerFrameState outer)]
                      => depth
        )
    )

    ;;;
     ; Gets the value in the local variables at the specified index.
     ;
     ; @param i the index into the locals
     ; @return the instruction that produced the value for the specified local
     ;;
    #_unused
    (§ method! #_"ValueNode" FrameState''localAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:values this) i)
    )

    ;;;
     ; Get the value on the stack at the specified stack index.
     ;
     ; @param i the index into the stack, with {@code 0} being the bottom of the stack
     ; @return the instruction at the specified position in the stack
     ;;
    (§ method! #_"ValueNode" FrameState''stackAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:values this) (+ (:localsSize this) i))
    )

    ;;;
     ; Get the monitor owner at the specified index.
     ;
     ; @param i the index into the list of locked monitors.
     ; @return the lock owner at the given index
     ;;
    #_unused
    (§ method! #_"ValueNode" FrameState''lockAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:values this) (+ (:localsSize this) (:stackSize this) i))
    )

    ;;;
     ; Get the MonitorIdNode that corresponds to the locked object at the specified index.
     ;;
    #_unused
    (§ method! #_"MonitorIdNode" FrameState''monitorIdAt-2 [#_"FrameState" this, #_"int" i]
        (nth (:monitorIds this) i)
    )

    (§ method! #_"int" FrameState''monitorIdCount-1 [#_"FrameState" this]
        (if (some? (:monitorIds this)) (count (:monitorIds this)) 0)
    )

    #_unused
    (§ method! #_"NodeIterable<FrameState>" FrameState''innerFrameStates-1 [#_"FrameState" this]
        (NodeIterable''filter-2 (Node''usages-1 this), FrameState)
    )

    #_unused
    (§ method- #_"int" FrameState''outerLockDepth-1 [#_"FrameState" this]
        (loop-when-recur [#_"int" depth 0 #_"FrameState" outer (:outerFrameState this)]
                         (some? outer)
                         [(+ depth (FrameState''monitorIdCount-1 outer)) (:outerFrameState outer)]
                      => depth
        )
    )

    (§ override! #_"void" FrameState''applyToNonVirtual-2 [#_"FrameState" this, #_"NodeClosure<? super ValueNode>" closure]
        (doseq [#_"ValueNode" value (:values this)]
            (when (some? value)
                (NodeClosure''apply-3 closure, this, value)
            )
        )
        (when (some? (:monitorIds this))
            (doseq [#_"MonitorIdNode" monitorId (:monitorIds this)]
                (when (some? monitorId)
                    (NodeClosure''apply-3 closure, this, monitorId)
                )
            )
        )
        (when (some? (:virtualObjectMappings this))
            (doseq [#_"EscapeObjectState" state (:virtualObjectMappings this)]
                (VirtualState''applyToNonVirtual-2 state, closure)
            )
        )
        (when (some? (:outerFrameState this))
            (FrameState''applyToNonVirtual-2 (:outerFrameState this), closure)
        )
        nil
    )

    (§ override! #_"void" FrameState''applyToVirtual-2 [#_"FrameState" this, #_"VirtualClosure" closure]
        (VirtualClosure''apply-2 closure, this)
        (when (some? (:virtualObjectMappings this))
            (doseq [#_"EscapeObjectState" state (:virtualObjectMappings this)]
                (EscapeObjectState''applyToVirtual-2 state, closure)
            )
        )
        (when (some? (:outerFrameState this))
            (FrameState''applyToVirtual-2 (:outerFrameState this), closure)
        )
        nil
    )

    (§ override! #_"boolean" FrameState''isPartOfThisState-2 [#_"FrameState" this, #_"VirtualState" state]
        (or (= state this)
            (and (some? (:outerFrameState this)) (FrameState''isPartOfThisState-2 (:outerFrameState this), state))
            (loop [#_"ISeq" s (seq (:virtualObjectMappings this))]
                (and (some? s)
                    (or (EscapeObjectState''isPartOfThisState-2 (first s), state)
                        (recur (next s))
                    )
                )
            )
        )
    )
)

;;;
 ; @anno FrameState.TwoSlotMarker
 ;;
(final-ns TwoSlotMarker (§ extends ValueNode)
    (§ def #_"NodeClass<TwoSlotMarker>" TwoSlotMarker'TYPE (NodeClass'create-1 TwoSlotMarker))

    (§ defn #_"TwoSlotMarker" TwoSlotMarker'new-0 []
        (ValueNode'new-2 TwoSlotMarker'TYPE, (StampFactory'forKind-1 JavaKind/Illegal))
    )
)

(final-ns GraphBuilderConfiguration
    (§ final #_"boolean" :eagerResolving false)
    (§ final #_"boolean" :unresolvedIsError false)
    (§ final #_"Plugins" :plugins nil)

    (§ defn- #_"GraphBuilderConfiguration" GraphBuilderConfiguration'new-3 [#_"boolean" eagerResolving, #_"boolean" unresolvedIsError, #_"Plugins" plugins]
        (let [
            #_"GraphBuilderConfiguration" this (Object.)
            this (assoc this :eagerResolving eagerResolving)
            this (assoc this :unresolvedIsError unresolvedIsError)
            this (assoc this :plugins plugins)
        ]
            this
        )
    )

    (§ defn #_"GraphBuilderConfiguration" GraphBuilderConfiguration'getDefault-0 []
        (GraphBuilderConfiguration'new-3 false, false, HotSpot'plugins)
    )

    (§ defn #_"GraphBuilderConfiguration" GraphBuilderConfiguration'getSnippetDefault-1 [#_"Plugins" plugins]
        (GraphBuilderConfiguration'new-3 true, true, plugins)
    )
)

;;;
 ; @anno GraphBuilderConfiguration.Plugins
 ;;
(final-ns Plugins
    (§ mutable #_"NodePlugin[]" :nodePlugins nil)
    (§ mutable #_"ParameterPlugin[]" :parameterPlugins nil)
    (§ mutable #_"TypePlugin[]" :typePlugins nil)
    (§ mutable #_"InlineInvokePlugin[]" :inlineInvokePlugins nil)
    (§ mutable #_"InvokeDynamicPlugin" :invokeDynamicPlugin nil)

    ;;;
     ; Creates a copy of a given set of plugins.
     ;;
    (§ defn #_"Plugins" Plugins'copy-1 [#_"Plugins" copyFrom]
        (let [
            #_"Plugins" this (Object.)
            this (assoc this :nodePlugins (:nodePlugins copyFrom))
            this (assoc this :parameterPlugins (:parameterPlugins copyFrom))
            this (assoc this :typePlugins (:typePlugins copyFrom))
            this (assoc this :inlineInvokePlugins (:inlineInvokePlugins copyFrom))
            this (assoc this :invokeDynamicPlugin (:invokeDynamicPlugin copyFrom))
        ]
            this
        )
    )

    ;;;
     ; Creates a new set of plugins.
     ;;
    (§ defn #_"Plugins" Plugins'new-0 []
        (let [
            #_"Plugins" this (Object.)
            this (assoc this :nodePlugins (make-array NodePlugin 0))
            this (assoc this :parameterPlugins (make-array ParameterPlugin 0))
            this (assoc this :typePlugins (make-array TypePlugin 0))
            this (assoc this :inlineInvokePlugins (make-array InlineInvokePlugin 0))
        ]
            this
        )
    )

    (§ defn #_"Plugins" Plugins'create-0 []
        (let [
            #_"Plugins" plugins (Plugins'new-0)
            #_"HotSpotNodePlugin" nodePlugin (HotSpotNodePlugin'new-1 (HotSpotWordOperationPlugin'new-0))
            plugins (Plugins''appendTypePlugin-2 plugins, nodePlugin)
            plugins (Plugins''appendNodePlugin-2 plugins, nodePlugin)
            plugins (Plugins''appendNodePlugin-2 plugins, (MethodHandlePlugin'new-2 (#_"ConstantReflectionProvider" .getMethodHandleAccess HotSpot'constantReflection), true))
            plugins (Plugins''appendInlineInvokePlugin-2 plugins, HotSpot'replacements)
            plugins
                (when GraalOptions'inlineDuringParsing => plugins
                    (Plugins''appendInlineInvokePlugin-2 plugins, (InlineDuringParsingPlugin'new-0))
                )
        ]
            plugins
        )
    )

    (§ method! #_"Plugins" Plugins''appendNodePlugin-2 [#_"Plugins" this, #_"NodePlugin" plugin]
        (let [
            this (assoc this :nodePlugins (Arrays/copyOf (:nodePlugins this), (inc (count (:nodePlugins this)))))
        ]
            (aset (:nodePlugins this) (dec (count (:nodePlugins this))) plugin)
            this
        )
    )

    (§ method! #_"Plugins" Plugins''prependParameterPlugin-2 [#_"Plugins" this, #_"ParameterPlugin" plugin]
        (let [
            #_"ParameterPlugin[]" a (make-array ParameterPlugin (inc (count (:parameterPlugins this))))
        ]
            (System/arraycopy (:parameterPlugins this), 0, a, 1, (count (:parameterPlugins this)))
            (aset a 0 plugin)
            (assoc this :parameterPlugins a)
        )
    )

    (§ method! #_"Plugins" Plugins''appendTypePlugin-2 [#_"Plugins" this, #_"TypePlugin" plugin]
        (let [
            this (assoc this :typePlugins (Arrays/copyOf (:typePlugins this), (inc (count (:typePlugins this)))))
        ]
            (aset (:typePlugins this) (dec (count (:typePlugins this))) plugin)
            this
        )
    )

    (§ method! #_"Plugins" Plugins''appendInlineInvokePlugin-2 [#_"Plugins" this, #_"InlineInvokePlugin" plugin]
        (let [
            this (assoc this :inlineInvokePlugins (Arrays/copyOf (:inlineInvokePlugins this), (inc (count (:inlineInvokePlugins this)))))
        ]
            (aset (:inlineInvokePlugins this) (dec (count (:inlineInvokePlugins this))) plugin)
            this
        )
    )

    (§ method! #_"StampPair" Plugins''getOverridingStamp-4 [#_"Plugins" this, #_"GraphBuilderTool" b, #_"JavaType" type, #_"boolean" never-nil?]
        (loop-when [#_"ISeq" s (seq (:typePlugins this))] (some? s)
            (or (TypePlugin''interceptType-4 (first s), b, type, never-nil?)
                (recur (next s))
            )
        )
        nil
    )
)

;;;
 ; Used by a GraphBuilderPlugin to interface with an object that builds a graph.
 ;;
(§ interface GraphBuilderTool
    ;;;
     ; Adds the given node to the graph and also adds recursively all referenced inputs.
     ;
     ; @param value the node to be added to the graph
     ; @return either the node added or an equivalent node
     ;;
    #_unused
    (§ abstract #_"ValueNode" GraphBuilderTool''append-2 [#_"GraphBuilderTool" this, #_"ValueNode" value])

    ;;;
     ; Determines if this parsing context is within the bytecode of an intrinsic or a method inlined
     ; by an intrinsic.
     ;;
    (§ abstract #_"boolean" GraphBuilderTool''parsingIntrinsic-1 [#_"GraphBuilderTool" this])
)

;;;
 ; Plugin for specifying what is inlined during graph parsing. This plugin is also notified
 ; {@link #notifyBeforeInline before} and #notifyAfterInline the inlining, as well as of
 ; {@link #notifyNotInlined non-inlined} invocations (i.e. those for which an InvokeNode
 ; is created).
 ;;
(§ interface InlineInvokePlugin
    ;;;
     ; Determines whether a call to a given method is to be inlined. The return value is a tri-state:
     ;
     ; Non-null return value with a non-nil {@link InlineInvokeInfo#getMethodToInline method}:
     ; That {@link InlineInvokeInfo#getMethodToInline method} is inlined. Note that it can be
     ; a different method than the one specified here as the parameter, which allows method substitutions.
     ;
     ; Non-null return value with a nil {@link InlineInvokeInfo#getMethodToInline method},
     ; e.g. InlineInvokeInfo#DO_NOT_INLINE_WITH_EXCEPTION: The method is not inlined,
     ; and other plugins with a lower priority cannot overwrite this decision.
     ;
     ; Null return value: This plugin made no decision, other plugins with a lower priority are asked.
     ;
     ; @param method the target method of an invoke
     ; @param args the arguments to the invoke
     ;;
    (§ default #_"InlineInvokeInfo" InlineInvokePlugin''shouldInlineInvoke-4 [#_"InlineInvokePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
        nil
    )

    ;;;
     ; Notification that a method is about to be inlined.
     ;
     ; @param methodToInline the inlined method
     ;;
    (§ default #_"void" InlineInvokePlugin''notifyBeforeInline-2 [#_"InlineInvokePlugin" this, #_"ResolvedJavaMethod" methodToInline]
        nil
    )

    ;;;
     ; Notification that a method was inlined.
     ;
     ; @param methodToInline the inlined method
     ;;
    (§ default #_"void" InlineInvokePlugin''notifyAfterInline-2 [#_"InlineInvokePlugin" this, #_"ResolvedJavaMethod" methodToInline]
        nil
    )

    ;;;
     ; Notifies this plugin of the InvokeNode created for a method that was not inlined per #shouldInlineInvoke.
     ;
     ; @param method the method that was not inlined
     ; @param invoke the invoke node created for the call to {@code method}
     ;;
    (§ default #_"void" InlineInvokePlugin''notifyNotInlined-4 [#_"InlineInvokePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"InvokeNode" invoke]
        nil
    )
)

;;;
 ; Result of a {@link #shouldInlineInvoke inlining decision}.
 ;
 ; @anno InlineInvokePlugin.InlineInvokeInfo
 ;;
(final-ns InlineInvokeInfo
    ;;;
     ; The method to be inlined, or nil if the call site must not be inlined.
     ;;
    (§ final #_"ResolvedJavaMethod" :methodToInline nil)
    ;;;
     ; The provider of bytecode to be parsed for #getMethodToInline() if it is
     ; an intrinsic for the original method (i.e. the {@code method} passed to
     ; InlineInvokePlugin#shouldInlineInvoke).
     ; A nil value indicates that this is not an intrinsic inlining.
     ;;
    (§ final #_"BytecodeProvider" :intrinsicBytecodeProvider nil)

    (§ defn- #_"InlineInvokeInfo" InlineInvokeInfo'new-2 [#_"ResolvedJavaMethod" methodToInline, #_"BytecodeProvider" intrinsicBytecodeProvider]
        (let [
            #_"InlineInvokeInfo" this (Object.)
            this (assoc this :methodToInline methodToInline)
            this (assoc this :intrinsicBytecodeProvider intrinsicBytecodeProvider)
        ]
            this
        )
    )

    (§ defn #_"InlineInvokeInfo" InlineInvokeInfo'createStandardInlineInfo-1 [#_"ResolvedJavaMethod" methodToInline]
        (InlineInvokeInfo'new-2 methodToInline, nil)
    )

    (§ defn #_"InlineInvokeInfo" InlineInvokeInfo'createIntrinsicInlineInfo-1 [#_"ResolvedJavaMethod" methodToInline]
        (InlineInvokeInfo'new-2 methodToInline, HotSpot'defaultBytecodeProvider)
    )

    #_unused
    (§ method! #_"boolean" InlineInvokeInfo''allowsInlining-1 [#_"InlineInvokeInfo" this]
        (some? (:methodToInline this))
    )
)

;;;
 ; An intrinsic is a substitute implementation of a Java method (or a bytecode in the case of
 ; snippets) that is itself implemented in Java. This interface provides information about the
 ; intrinsic currently being processed by the graph builder.
 ;
 ; When in the scope of an intrinsic, the graph builder does not check the value kinds flowing
 ; through the JVM state since intrinsics can employ non-Java kinds to represent values such as
 ; raw machine words and pointers.
 ;;
(final-ns IntrinsicContext
    ;;;
     ; Method being intrinsified.
     ;;
    (§ final #_"ResolvedJavaMethod" :originalMethod nil)

    ;;;
     ; Method providing the intrinsic implementation.
     ;;
    (§ final #_"ResolvedJavaMethod" :intrinsicMethod nil)

    ;;;
     ; Provider of bytecode to be parsed for a method that is part of an intrinsic.
     ;;
    (§ final #_"BytecodeProvider" :bytecodeProvider nil)

    (§ final #_"CompilationContext" :compilationContext nil)

    (§ defn #_"IntrinsicContext" IntrinsicContext'new-4 [#_"ResolvedJavaMethod" method, #_"ResolvedJavaMethod" intrinsic, #_"BytecodeProvider" bytecodeProvider, #_"CompilationContext" compilationContext]
        (let [
            #_"IntrinsicContext" this (Object.)
            this (assoc this :originalMethod method)
            this (assoc this :intrinsicMethod intrinsic)
            this (assoc this :bytecodeProvider bytecodeProvider)
            this (assoc this :compilationContext compilationContext)
        ]
            this
        )
    )

    ;;;
     ; Determines if a call within the compilation scope of this intrinsic represents a call to the
     ; {@linkplain #getOriginalMethod() original} method. This denotes the path where a partial
     ; intrinsification falls back to the original method.
     ;;
    (§ method! #_"boolean" IntrinsicContext''isCallToOriginal-2 [#_"IntrinsicContext" this, #_"ResolvedJavaMethod" targetMethod]
        (or (= (:originalMethod this) targetMethod) (= (:intrinsicMethod this) targetMethod))
    )

    (§ method! #_"boolean" IntrinsicContext''isPostParseInlined-1 [#_"IntrinsicContext" this]
        (= (:compilationContext this) CompilationContext'INLINE_AFTER_PARSING)
    )

    (§ method! #_"boolean" IntrinsicContext''isCompilationRoot-1 [#_"IntrinsicContext" this]
        (= (:compilationContext this) CompilationContext'ROOT_COMPILATION)
    )

    (§ method! #_"FrameState" IntrinsicContext''createFrameState-4 [#_"IntrinsicContext" this, #_"Graph" graph, #_"SideEffectsState" sideEffects, #_"StateSplit" forStateSplit]
        (if (StateSplit''hasSideEffect-1 forStateSplit)
            (do
                (when (SideEffectsState''isAfterSideEffect-1 sideEffects)
                    ;; only the last side effect on any execution path in a replacement can inherit the stateAfter of the replaced node
                    (let [
                        #_"FrameState" invalid (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/INVALID_FRAMESTATE_BCI))
                    ]
                        (doseq [#_"StateSplit" lastSideEffect (SideEffectsState''sideEffects-1 sideEffects)]
                            (StateSplit''setStateAfter-2 lastSideEffect, invalid)
                        )
                    )
                )
                (SideEffectsState''addSideEffect-2 sideEffects, forStateSplit)
                (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/AFTER_BCI))
            )
            (if (instance? AbstractMergeNode forStateSplit)
                ;; merge nodes always need a frame state
                (if (SideEffectsState''isAfterSideEffect-1 sideEffects)
                    (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/AFTER_BCI))  ;; a merge after one or more side effects
                    (Graph''add-2 graph, (FrameState'new-1 BytecodeFrame/BEFORE_BCI)) ;; a merge before any side effects
                )
                ;; other non-side-effects do not need a state
                nil
            )
        )
    )
)

;;;
 ; Denotes the compilation context in which an intrinsic is being parsed.
 ;
 ; @anno IntrinsicContext.CompilationContext
 ;;
(value-ns CompilationContext
    ;;;
     ; An intrinsic is being processed when parsing an invoke bytecode that calls the
     ; intrinsified method.
     ;;
    (§ enum CompilationContext'INLINE_DURING_PARSING)
    ;;;
     ; An intrinsic is being processed when inlining an InvokeNode in an existing graph.
     ;;
    (§ enum CompilationContext'INLINE_AFTER_PARSING)
    ;;;
     ; An intrinsic is the root of compilation.
     ;;
    (§ enum CompilationContext'ROOT_COMPILATION)
)

;;;
 ; Models the state of a graph in terms of {@link StateSplit#hasSideEffect() side effects}
 ; that are control flow predecessors of the current point in a graph.
 ;
 ; @anno IntrinsicContext.SideEffectsState
 ;;
(§ interface SideEffectsState
    ;;;
     ; Determines if the current program point is preceded by one or more side effects.
     ;;
    (§ abstract #_"boolean" SideEffectsState''isAfterSideEffect-1 [#_"SideEffectsState" this])

    ;;;
     ; Gets the side effects preceding the current program point.
     ;;
    (§ abstract #_"Iterable<StateSplit>" SideEffectsState''sideEffects-1 [#_"SideEffectsState" this])

    ;;;
     ; Records a side effect for the current program point.
     ;;
    (§ abstract #_"void" SideEffectsState''addSideEffect-2 [#_"SideEffectsState" this, #_"StateSplit" sideEffect])
)

;;;
 ; The receiver in a non-static method.
 ;
 ; @anno InvocationPlugin.Receiver
 ;;
(§ interface Receiver
    ;;;
     ; Gets the receiver value, nil-checking it first if necessary.
     ;
     ; @return the receiver value with a {@linkplain StampTool#isPointerNonNull(ValueNode) non-nil} stamp
     ;;
    (§ default #_"ValueNode" Receiver''get-1 [#_"Receiver" this]
        (Receiver''get-2 this, true)
    )

    ;;;
     ; Gets the receiver value, optionally nil-checking it first if necessary.
     ;;
    (§ abstract #_"ValueNode" Receiver''get-2 [#_"Receiver" this, #_"boolean" performNullCheck])

    ;;;
     ; Determines if the receiver is constant.
     ;;
    #_unused
    (§ default #_"boolean" Receiver''isConstant-1 [#_"Receiver" this]
        false
    )
)

;;;
 ; @anno InvocationPlugins.InvocationPluginReceiver
 ;;
(final-ns InvocationPluginReceiver (§ implements Receiver)
    (§ final #_"BytecodeParser" :parser nil)
    (§ mutable #_"ValueNode[]" :args nil)
    (§ mutable #_"ValueNode" :value nil)

    (§ defn #_"InvocationPluginReceiver" InvocationPluginReceiver'new-1 [#_"BytecodeParser" parser]
        (let [
            #_"InvocationPluginReceiver" this (Object.)
            this (assoc this :parser parser)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"ValueNode" InvocationPluginReceiver''get-2 [#_"InvocationPluginReceiver" this, #_"boolean" performNullCheck]
        (when performNullCheck => (nth (:args this) 0)
            (when (nil? (:value this))
                (§ ass! this (assoc this :value (BytecodeParser''nullCheckedValue-2 (:parser this), (nth (:args this) 0))))
                (when-not (= (:value this) (nth (:args this) 0))
                    (aset (:args this) 0 (:value this))
                )
            )
            (:value this)
        )
    )

    #_unused
    (§ override! #_"boolean" InvocationPluginReceiver''isConstant-1 [#_"InvocationPluginReceiver" this]
        (instance? ConstantNode (nth (:args this) 0))
    )

    (§ method! #_"InvocationPluginReceiver" InvocationPluginReceiver''init-3 [#_"InvocationPluginReceiver" this, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode[]" newArgs]
        (when-not (#_"ResolvedJavaMethod" .isStatic targetMethod)
            (§ ass this (assoc this :args newArgs))
            (§ ass this (assoc this :value nil))
            this
        )
    )
)

;;;
 ; GraphBuilderPlugin interface for static compilation mode, allowing references to dynamic types.
 ;;
(§ interface InvokeDynamicPlugin
    ;;;
     ; Checks for a resolved dynamic adapter method at the specified index, resulting from either
     ; a resolved invokedynamic or invokevirtual on a signature polymorphic MethodHandle method
     ; (HotSpot invokehandle).
     ;
     ; @param cpi the constant pool index
     ; @param opcode the opcode of the instruction for which the lookup is being performed
     ; @return true if a signature polymorphic method reference was found, otherwise false
     ;;
    (§ abstract #_"boolean" InvokeDynamicPlugin''isResolvedDynamicInvoke-4 [#_"InvokeDynamicPlugin" this, #_"BytecodeParser" parser, #_"int" cpi, #_"int" opcode])

    ;;;
     ; Checks if this plugin instance supports the specified dynamic invoke.
     ;
     ; @param cpi the constant pool index
     ; @param opcode the opcode of the invoke instruction
     ; @return true if this dynamic invoke is supported
     ;;
    #_unused
    (§ abstract #_"boolean" InvokeDynamicPlugin''supportsDynamicInvoke-4 [#_"InvokeDynamicPlugin" this, #_"BytecodeParser" parser, #_"int" cpi, #_"int" opcode])

    ;;;
     ; Notifies this object of the value and context of the dynamic method target (e.g. a HotSpot
     ; adapter method) for a resolved dynamic invoke.
     ;
     ; @param cpi the constant pool index
     ; @param opcode the opcode of the instruction for which the lookup is being performed
     ; @param target dynamic target method to record
     ;;
    (§ abstract #_"void" InvokeDynamicPlugin''recordDynamicMethod-5 [#_"InvokeDynamicPlugin" this, #_"BytecodeParser" parser, #_"int" cpi, #_"int" opcode, #_"ResolvedJavaMethod" target])

    ;;;
     ; Notifies this object of the value and context of the dynamic appendix object for a resolved
     ; dynamic invoke.
     ;
     ; @param cpi the constant pool index
     ; @param opcode the opcode of the instruction for which the lookup is being performed
     ; @return ValueNode for appendix constant
     ;;
    (§ abstract #_"ValueNode" InvokeDynamicPlugin''genAppendixNode-6 [#_"InvokeDynamicPlugin" this, #_"BytecodeParser" parser, #_"int" cpi, #_"int" opcode, #_"JavaConstant" appendix, #_"FrameState" frameState])
)

(§ interface NodePlugin
    ;;;
     ; Handle the parsing of a method invocation bytecode to a method that can be bound statically.
     ; If the method returns true, it must push a value as the result of the method invocation
     ; using the {@link Signature#getReturnKind return kind} of the method.
     ;
     ; @param method the statically bound, invoked method
     ; @param args the arguments of the method invocation
     ; @return true if the plugin handles the invocation, false otherwise
     ;;
    (§ default #_"boolean" NodePlugin''handleInvoke-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
        false
    )

    ;;;
     ; Handle the parsing of a GETFIELD bytecode. If the method returns true, it must
     ; push a value using the {@link ResolvedJavaField#getJavaKind() kind} of the field.
     ;
     ; @param object the receiver object for the field access
     ; @param field the accessed field
     ; @return true if the plugin handles the field access, false otherwise
     ;;
    (§ default #_"boolean" NodePlugin''handleLoadField-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field]
        false
    )

    ;;;
     ; Handle the parsing of a GETSTATIC bytecode. If the method returns true, it must
     ; push a value using the {@link ResolvedJavaField#getJavaKind() kind} of the field.
     ;
     ; @param field the accessed field
     ; @return true if the plugin handles the field access, false otherwise
     ;;
    (§ default #_"boolean" NodePlugin''handleLoadStaticField-3 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field]
        false
    )

    ;;;
     ; Handle the parsing of a PUTFIELD bytecode.
     ;
     ; @param object the receiver object for the field access
     ; @param field the accessed field
     ; @param value the value to be stored into the field
     ; @return true if the plugin handles the field access, false otherwise
     ;;
    (§ default #_"boolean" NodePlugin''handleStoreField-5 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value]
        false
    )

    ;;;
     ; Handle the parsing of a PUTSTATIC bytecode.
     ;
     ; @param field the accessed field
     ; @param value the value to be stored into the field
     ; @return true if the plugin handles the field access, false otherwise
     ;;
    (§ default #_"boolean" NodePlugin''handleStoreStaticField-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"ValueNode" value]
        false
    )

    ;;;
     ; Handle the parsing of an array load bytecode. If the method returns true,
     ; it must push a value using the provided elementKind.
     ;
     ; @param array the accessed array
     ; @param index the index for the array access
     ; @param elementKind the element kind of the accessed array
     ; @return true if the plugin handles the array access, false otherwise
     ;;
    (§ default #_"boolean" NodePlugin''handleLoadIndexed-5 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        false
    )

    ;;;
     ; Handle the parsing of an array store bytecode.
     ;
     ; @param array the accessed array
     ; @param index the index for the array access
     ; @param elementKind the element kind of the accessed array
     ; @param value the value to be stored into the array
     ; @return true if the plugin handles the array access, false otherwise
     ;;
    (§ default #_"boolean" NodePlugin''handleStoreIndexed-6 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind, #_"ValueNode" value]
        false
    )

    ;;;
     ; Handle the parsing of a CHECKCAST bytecode. If the method returns true,
     ; it must push a value with the result of the cast using JavaKind#Object.
     ;
     ; @param object the object to be type checked
     ; @param type the type that the object is checked against
     ; @return true if the plugin handles the cast, false otherwise
     ;;
    (§ default #_"boolean" NodePlugin''handleCheckCast-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
        false
    )

    ;;;
     ; Handle the parsing of an INSTANCEOF bytecode. If the method returns true,
     ; it must push a value with the result of the instanceof using JavaKind#Int.
     ;
     ; @param object the object to be type checked
     ; @param type the type that the object is checked against
     ; @return true if the plugin handles the instanceof, false otherwise
     ;;
    (§ default #_"boolean" NodePlugin''handleInstanceOf-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
        false
    )

    ;;;
     ; Handle the parsing of a NEW bytecode. If the method returns true, it must push
     ; a value with the result of the allocation using JavaKind#Object.
     ;
     ; @param type the type to be instantiated
     ; @return true if the plugin handles the bytecode, false otherwise
     ;;
    (§ default! #_"boolean" NodePlugin''handleNewInstance-3 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaType" type]
        false
    )

    ;;;
     ; Handle the parsing of a NEWARRAY or ANEWARRAY bytecode. If the method returns true,
     ; it must push a value with the result of the allocation using JavaKind#Object.
     ;
     ; @param elementType the element type of the array to be instantiated
     ; @param length the length of the new array
     ; @return true if the plugin handles the bytecode, false otherwise
     ;;
    (§ default! #_"boolean" NodePlugin''handleNewArray-4 [#_"NodePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaType" elementType, #_"ValueNode" length]
        false
    )
)

(§ interface ParameterPlugin
    (§ abstract #_"FloatingNode" ParameterPlugin''interceptParameter-4 [#_"ParameterPlugin" this, #_"GraphBuilderTool" b, #_"int" index, #_"StampPair" stamp])
)

;;;
 ; Plugin for overriding types in the bytecode parser. This can be used to modify the standard
 ; behavior of Java type resolution, e.g. to introduce trusted interface types with special semantics.
 ;;
(§ interface TypePlugin
    ;;;
     ; Intercept the type of arguments or return values.
     ;;
    (§ abstract #_"StampPair" TypePlugin''interceptType-4 [#_"TypePlugin" this, #_"GraphBuilderTool" b, #_"JavaType" declaredType, #_"boolean" never-nil?])
)

;;;
 ; A node that changes the type of its input, usually narrowing it. For example, a GuardedValueNode
 ; is used to keep the nodes depending on guards inside a loop during speculative guard movement.
 ;
 ; A GuardedValueNode will only go away if its guard is nil or Graph#start().
 ;;
(final-ns GuardedValueNode (§ extends FloatingGuardedNode) (§ implements LIRLowerable, Virtualizable, Canonicalizable, ValueProxy)
    (§ def #_"NodeClass<GuardedValueNode>" GuardedValueNode'TYPE (NodeClass'create-1 GuardedValueNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)

    #_unused
    (§ defn #_"GuardedValueNode" GuardedValueNode'new-2 [#_"ValueNode" object, #_"GuardingNode" guard]
        (let [
            #_"GuardedValueNode" this (FloatingGuardedNode'new-3 GuardedValueNode'TYPE, (:stamp object), guard)
            this (assoc this :object object)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" GuardedValueNode''generate-2 [#_"GuardedValueNode" this, #_"LIRBuilder" builder]
        (when (and (not= (ValueNode''getStackKind-1 (:object this)) JavaKind/Void) (not= (ValueNode''getStackKind-1 (:object this)) JavaKind/Illegal))
            (LIRBuilder''setResult-3 builder, this, (LIRBuilder''operand-2 builder, (:object this)))
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" GuardedValueNode''inferStamp-1 [#_"GuardedValueNode" this]
        (ValueNode''updateStamp-2 this, (:stamp (:object this)))
    )

    #_unused
    (§ override! #_"void" GuardedValueNode''virtualize-2 [#_"GuardedValueNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" alias (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (instance? VirtualObjectNode alias)
                (VirtualizerTool''replaceWithVirtual-2 tool, alias)
            )
        )
        nil
    )

    #_unused
    (§ override! #_"Node" GuardedValueNode''canonical-2 [#_"GuardedValueNode" this, #_"CanonicalizerTool" tool]
        (when (nil? (FloatingGuardedNode''getGuard-1 this)) => this
            (if (= (:stamp this) (:stamp (:object this)))
                (:object this)
                (PiNode'create-2 (:object this), (:stamp this))
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" GuardedValueNode''getOriginalNode-1 [#_"GuardedValueNode" this]
        (:object this)
    )
)

;;;
 ; A guard is a node that deoptimizes based on a conditional expression. Guards are not attached to
 ; a certain frame state, they can move around freely and will always use the correct frame state
 ; when the nodes are scheduled (i.e. the last emitted frame state). The node that is guarded has a
 ; data dependency on the guard and the guard in turn has a data dependency on the condition. A
 ; guard may only be executed if it is guaranteed that the guarded node is executed too (if no
 ; exceptions are thrown). Therefore, an anchor is placed after a control flow split and the guard
 ; has a data dependency to the anchor. The anchor is the most distant node that is post-dominated
 ; by the guarded node and the guard can be scheduled anywhere between those two nodes. This ensures
 ; maximum flexibility for the guard node and guarantees that deoptimization occurs only if the
 ; control flow would have reached the guarded node (without taking exceptions into account).
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Guard"
(final-ns GuardNode (§ extends FloatingAnchoredNode) (§ implements Canonicalizable, GuardingNode, DeoptimizingGuard, IterableNodeType)
    (§ def #_"NodeClass<GuardNode>" GuardNode'TYPE (NodeClass'create-1 GuardNode))

    ; @Input(InputType'ConditionI)
    (§ mutable #_"LogicNode" :condition nil)
    (§ mutable #_"DeoptimizationReason" :reason nil)
    (§ mutable #_"DeoptimizationAction" :action nil)
    (§ mutable #_"JavaConstant" :speculation nil)
    (§ mutable #_"boolean" :negated? false)

    (§ defn #_"GuardNode" GuardNode'new-6 [#_"LogicNode" condition, #_"AnchoringNode" anchor, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"boolean" negated?, #_"JavaConstant" speculation]
        (GuardNode'new-7 GuardNode'TYPE, condition, anchor, reason, action, negated?, speculation)
    )

    (§ defn #_"GuardNode" GuardNode'new-7 [#_"NodeClass<? extends GuardNode>" c, #_"LogicNode" condition, #_"AnchoringNode" anchor, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"boolean" negated?, #_"JavaConstant" speculation]
        (let [
            #_"GuardNode" this (FloatingAnchoredNode'new-3 c, (StampFactory'forVoid-0), anchor)
            this (assoc this :condition condition)
            this (assoc this :reason reason)
            this (assoc this :action action)
            this (assoc this :negated? negated?)
            this (assoc this :speculation speculation)
        ]
            this
        )
    )

    ;;;
     ; The instruction that produces the tested boolean value.
     ;;
    (§ override! #_"LogicNode" GuardNode''getCondition-1 [#_"GuardNode" this]
        (:condition this)
    )

    #_unused
    (§ override! #_"void" GuardNode''setCondition-3 [#_"GuardNode" this, #_"LogicNode" x, #_"boolean" negated?]
        (Node''updateUsages-3 this, (:condition this), x)
        (§ ass! this (assoc this :condition x))
        (§ ass! this (assoc this :negated? negated?))
        nil
    )

    #_unused
    (§ method! #_"GuardNode" GuardNode''setSpeculation-2 [#_"GuardNode" this, #_"JavaConstant" speculation]
        (assoc this :speculation speculation)
    )

    #_unused
    (§ override! #_"Node" GuardNode''canonical-2 [#_"GuardNode" this, #_"CanonicalizerTool" tool]
        (let [
            #_"LogicNode" logic (GuardNode''getCondition-1 this)
        ]
            (cond
                (instance? LogicNegationNode logic)
                    (GuardNode'new-6 (LogicNegationNode''getValue-1 logic), (FloatingAnchoredNode''getAnchor-1 this), (:reason this), (:action this), (not (:negated? this)), (:speculation this))
                (or (not (instance? LogicConstantNode logic)) (= (:value logic) (:negated? this)))
                    this
            )
        )
    )

    (§ method! #_"FixedWithNextNode" GuardNode''lowerGuard-1 [#_"GuardNode" this]
        nil
    )

    #_unused
    (§ method! #_"GuardNode" GuardNode''negate-1 [#_"GuardNode" this]
        (update this :negated? not)
    )

    #_unused
    (§ override! #_"void" GuardNode''setAction-2 [#_"GuardNode" this, #_"DeoptimizationAction" invalidaterecompile]
        (§ ass! this (assoc this :action invalidaterecompile))
        nil
    )

    #_unused
    (§ override! #_"void" GuardNode''setReason-2 [#_"GuardNode" this, #_"DeoptimizationReason" reason]
        (§ ass! this (assoc this :reason reason))
        nil
    )
)

;;;
 ; Guard PhiNodes merge guard dependencies at control flow merges.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Guard"
(final-ns GuardPhiNode (§ extends PhiNode) (§ implements GuardingNode)
    (§ def #_"NodeClass<GuardPhiNode>" GuardPhiNode'TYPE (NodeClass'create-1 GuardPhiNode))

    ; @OptionalInput(InputType'Guard)
    (§ mutable #_"NodeInputList<ValueNode>" :values nil)

    (§ defn #_"GuardPhiNode" GuardPhiNode'new-1 [#_"AbstractMergeNode" merge]
        (let [
            #_"GuardPhiNode" this (PhiNode'new-3 GuardPhiNode'TYPE, (StampFactory'forVoid-0), merge)
            this (assoc this :values (NodeInputList'new-1 this))
        ]
            this
        )
    )

    #_unused
    (§ defn #_"GuardPhiNode" GuardPhiNode'new-2 [#_"AbstractMergeNode" merge, #_"ValueNode[]" values]
        (let [
            #_"GuardPhiNode" this (PhiNode'new-3 GuardPhiNode'TYPE, (StampFactory'forVoid-0), merge)
            this (assoc this :values (NodeInputList'new-2 this, values))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"NodeInputList<ValueNode>" GuardPhiNode''values-1 [#_"GuardPhiNode" this]
        (:values this)
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Guard"
(final-ns GuardProxyNode (§ extends ProxyNode) (§ implements GuardingNode, Proxy, LIRLowerable, Canonicalizable)
    (§ def #_"NodeClass<GuardProxyNode>" GuardProxyNode'TYPE (NodeClass'create-1 GuardProxyNode))

    ; @OptionalInput(InputType'Guard)
    (§ mutable #_"GuardingNode" :value nil)

    (§ defn #_"GuardProxyNode" GuardProxyNode'new-2 [#_"GuardingNode" value, #_"LoopExitNode" proxyPoint]
        (let [
            #_"GuardProxyNode" this (ProxyNode'new-3 GuardProxyNode'TYPE, (StampFactory'forVoid-0), proxyPoint)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" GuardProxyNode''generate-2 [#_"GuardProxyNode" this, #_"LIRBuilder" builder]
        nil
    )

    #_unused
    (§ method! #_"GuardProxyNode" GuardProxyNode''setValue-2 [#_"GuardProxyNode" this, #_"GuardingNode" newValue]
        (Node''updateUsages-3 this, (:value this), newValue)
        (assoc this :value newValue)
    )

    #_unused
    (§ override! #_"ValueNode" GuardProxyNode''value-1 [#_"GuardProxyNode" this]
        (when (some? (:value this))
            (:value this)
        )
    )

    #_unused
    (§ override! #_"Node" GuardProxyNode''getOriginalNode-1 [#_"GuardProxyNode" this]
        (when (some? (:value this))
            (:value this)
        )
    )

    #_unused
    (§ override! #_"Node" GuardProxyNode''canonical-2 [#_"GuardProxyNode" this, #_"CanonicalizerTool" tool]
        (when (some? (:value this))
            this
        )
    )
)

;;;
 ; The IfNode represents a branch that can go one of two directions depending on the outcome
 ; of a comparison.
 ;;
(final-ns IfNode (§ extends ControlSplitNode) (§ implements Simplifiable, LIRLowerable)
    (§ def #_"NodeClass<IfNode>" IfNode'TYPE (NodeClass'create-1 IfNode))

    ; @Successor
    (§ mutable #_"AbstractBeginNode" :trueSuccessor nil)
    ; @Successor
    (§ mutable #_"AbstractBeginNode" :falseSuccessor nil)
    ; @Input(InputType'ConditionI)
    (§ mutable #_"LogicNode" :condition nil)
    (§ mutable #_"double" :trueSuccessorProbability 0.0)

    (§ method! #_"IfNode" IfNode''setCondition-2 [#_"IfNode" this, #_"LogicNode" x]
        (Node''updateUsages-3 this, (:condition this), x)
        (assoc this :condition x)
    )

    (§ defn #_"IfNode" IfNode'new-4 [#_"LogicNode" condition, #_"FixedNode" trueSuccessor, #_"FixedNode" falseSuccessor, #_"double" trueSuccessorProbability]
        (IfNode'new-4 condition, (BeginNode'begin-1 trueSuccessor), (BeginNode'begin-1 falseSuccessor), trueSuccessorProbability)
    )

    (§ defn #_"IfNode" IfNode'new-4 [#_"LogicNode" condition, #_"AbstractBeginNode" trueSuccessor, #_"AbstractBeginNode" falseSuccessor, #_"double" trueSuccessorProbability]
        (let [
            #_"IfNode" this (ControlSplitNode'new-2 IfNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :condition condition)
            this (assoc this :falseSuccessor falseSuccessor)
            this (assoc this :trueSuccessor trueSuccessor)
        ]
            (§ ass! this (IfNode''setTrueSuccessorProbability-2 this, trueSuccessorProbability))
            this
        )
    )

    (§ method! #_"IfNode" IfNode''setTrueSuccessor-2 [#_"IfNode" this, #_"AbstractBeginNode" node]
        (Node''updatePredecessor-3 this, (:trueSuccessor this), node)
        (assoc this :trueSuccessor node)
    )

    (§ method! #_"IfNode" IfNode''setFalseSuccessor-2 [#_"IfNode" this, #_"AbstractBeginNode" node]
        (Node''updatePredecessor-3 this, (:falseSuccessor this), node)
        (assoc this :falseSuccessor node)
    )

    ;;;
     ; Gets the node corresponding to the specified outcome of the branch.
     ;
     ; @param istrue true if the true successor is requested, false otherwise
     ; @return the corresponding successor
     ;;
    #_unused
    (§ method! #_"AbstractBeginNode" IfNode''successor-2 [#_"IfNode" this, #_"boolean" istrue]
        (if istrue (:trueSuccessor this) (:falseSuccessor this))
    )

    (§ method! #_"IfNode" IfNode''setTrueSuccessorProbability-2 [#_"IfNode" this, #_"double" prob]
        (assoc this :trueSuccessorProbability (min 1.0 (max 0.0 prob)))
    )

    (§ override! #_"double" IfNode''probability-2 [#_"IfNode" this, #_"AbstractBeginNode" successor]
        (if (= successor (:trueSuccessor this)) (:trueSuccessorProbability this) (- 1.0 (:trueSuccessorProbability this)))
    )

    #_unused
    (§ override! #_"void" IfNode''generate-2 [#_"IfNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''emitIf-2 builder, this)
        nil
    )

    (§ method! #_"IfNode" IfNode''eliminateNegation-1 [#_"IfNode" this]
        (let [
            this (assoc this :trueSuccessor (:falseSuccessor this) :falseSuccessor (:trueSuccessor this))
            this (assoc this :trueSuccessorProbability (- 1.0 (:trueSuccessorProbability this)))
            this (IfNode''setCondition-2 this, (LogicNegationNode''getValue-1 (§ cast #_"LogicNegationNode" (:condition this))))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" IfNode''simplify-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (cond
            (instance? DeoptimizeNode (:next (:trueSuccessor this)))
                (when-not (= (:trueSuccessorProbability this) 0)
                    (§ ass! this (assoc this :trueSuccessorProbability 0))
                )
            (instance? DeoptimizeNode (:next (:falseSuccessor this)))
                (when-not (= (:trueSuccessorProbability this) 1)
                    (§ ass! this (assoc this :trueSuccessorProbability 1))
                )
        )
        (when (instance? LogicNegationNode (:condition this))
            (§ ass! this (IfNode''eliminateNegation-1 this))
        )
        (or
            (when (instance? LogicConstantNode (:condition this))
                (let [
                    #_"LogicConstantNode" c (:condition this)
                ]
                    (if (:value c)
                        (do
                            (SimplifierTool''deleteBranch-2 tool, (:falseSuccessor this))
                            (SimplifierTool''addToWorkList-2 tool, (:trueSuccessor this))
                            (Graph''removeSplit-3 (:graph this), this, (:trueSuccessor this))
                        )
                        (do
                            (SimplifierTool''deleteBranch-2 tool, (:trueSuccessor this))
                            (SimplifierTool''addToWorkList-2 tool, (:falseSuccessor this))
                            (Graph''removeSplit-3 (:graph this), this, (:falseSuccessor this))
                        )
                    )
                    :done
                )
            )
            (when (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 (:trueSuccessor this)) (Node''hasNoUsages-1 (:falseSuccessor this)))
                (IfNode''pushNodesThroughIf-2 this, tool)
                (when (or (IfNode''checkForUnsignedCompare-2 this, tool) (IfNode''removeOrMaterializeIf-2 this, tool))
                    :done
                )
            )
            (when (IfNode''removeIntermediateMaterialization-2 this, tool)
                :done
            )
            (when (IfNode''splitIfAtPhi-2 this, tool)
                :done
            )
            (when (IfNode''conditionalNodeOptimization-2 this, tool)
                :done
            )
            (when (and (Node''hasNoUsages-1 (:falseSuccessor this)) (not (instance? LoopExitNode (:falseSuccessor this))) (instance? IfNode (:next (:falseSuccessor this))))
                (let [
                    #_"AbstractBeginNode" intermediateBegin (:falseSuccessor this)
                    #_"IfNode" nextIf (:next intermediateBegin)
                    #_"double" probabilityB (* (- 1.0 (:trueSuccessorProbability this)) (:trueSuccessorProbability nextIf))
                ]
                    ;; Reordering of those two if statements is beneficial from the point of view of their probabilities.
                    ;; Reordering is allowed from (if1 => begin => if2) to (if2 => begin => if1).
                    (when (and (< (:trueSuccessorProbability this) probabilityB) (IfNode'prepareForSwap-3 tool, (:condition this), (:condition nextIf)))
                        (let [
                            #_"AbstractBeginNode" bothFalseBegin (:falseSuccessor nextIf)
                        ]
                            (§ ass! nextIf (IfNode''setFalseSuccessor-2 nextIf, nil))
                            (§ ass! intermediateBegin (FixedWithNextNode''setNext-2 intermediateBegin, nil))
                            (§ ass! this (IfNode''setFalseSuccessor-2 this, nil))

                            (Node''replaceAtPredecessor-2 this, nextIf)
                            (§ ass! nextIf (IfNode''setFalseSuccessor-2 nextIf, intermediateBegin))
                            (§ ass! intermediateBegin (FixedWithNextNode''setNext-2 intermediateBegin, this))
                            (§ ass! this (IfNode''setFalseSuccessor-2 this, bothFalseBegin))

                            (§ ass! nextIf (IfNode''setTrueSuccessorProbability-2 nextIf, probabilityB))
                            (§ ass! this (IfNode''setTrueSuccessorProbability-2 this, (if (= probabilityB 1.0) 0.0 (min 1.0 (/ (:trueSuccessorProbability this) (- 1.0 probabilityB))))))
                            :done
                        )
                    )
                )
            )
            (when (IfNode''tryEliminateBoxedReferenceEquals-2 this, tool)
                :done
            )
        )
        nil
    )

    (§ method- #_"boolean" IfNode''isUnboxedFrom-3 [#_"IfNode" this, #_"ValueNode" x, #_"ValueNode" src]
        (or (= x src)
            (condp instance? x
                UnboxNode (IfNode''isUnboxedFrom-3 this, (UnboxNode''getValue-1 x), src)
                PiNode    (IfNode''isUnboxedFrom-3 this, (PiNode''getOriginalNode-1 x), src)
                LoadFieldNode
                    (let [
                        #_"ValueNode" value (LoadFieldNode''getValue-1 x)
                    ]
                        (and (= (Stamp''javaType-1 (:stamp value)) (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Integer))
                            (IfNode''isUnboxedFrom-3 this, value, src)
                        )
                    )
                false
            )
        )
    )

    ;;;
     ; Attempts to replace the following pattern:
     ;
     ; Integer x = ...;
     ; Integer y = ...;
     ; if ((x == y) || x.equals(y)) { ... }
     ;
     ; with:
     ;
     ; Integer x = ...;
     ; Integer y = ...;
     ; if (x.equals(y)) { ... }
     ;
     ; whenever the probability that the reference check will pass is relatively small.
     ;
     ; See GR-1315 for more information.
     ;;
    (§ method- #_"boolean" IfNode''tryEliminateBoxedReferenceEquals-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (and (instance? ObjectEqualsNode (:condition this))
            (let [
                #_"ValueNode" x (:x (:condition this))
                #_"ValueNode" y (:y (:condition this))
                #_"ResolvedJavaType" integerType (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Integer)
            ]
                (and
                    ;; At least one argument for reference equal must be a boxed primitive.
                    (or (= (Stamp''javaType-1 (:stamp x)) integerType) (= (Stamp''javaType-1 (:stamp y)) integerType))
                    ;; The reference equality check is usually more efficient compared to a boxing check.
                    ;; The success of the reference equals must therefore be relatively rare, otherwise
                    ;; it makes no sense to eliminate it.
                    (<= (:trueSuccessorProbability this) 0.4)
                    ;; True branch must be empty.
                    (and (or (instance? BeginNode (:trueSuccessor this)) (instance? LoopExitNode (:trueSuccessor this)))
                        (instance? EndNode (:next (:trueSuccessor this))) ;; Empty true branch.
                    )
                    ;; False branch must only check the unboxed values.
                    (let [
                        [#_"UnboxNode" unbox #_"FixedGuardNode" unboxCheck]
                            (loop-when [unbox nil unboxCheck nil #_"ISeq" s (seq (AbstractBeginNode''getBlockNodes-1 (:falseSuccessor this)))] (some? s) => [unbox unboxCheck]
                                (let [
                                    #_"FixedNode" node (first s)
                                ]
                                    (when (or (instance? BeginNode node) (instance? UnboxNode node) (instance? FixedGuardNode node) (instance? EndNode node) (instance? LoadFieldNode node) (instance? LoopExitNode node))
                                        (let [
                                            unbox
                                                (when (instance? UnboxNode node) => unbox
                                                    (when (nil? unbox) => (§ return nil)
                                                        node
                                                    )
                                                )
                                        ]
                                            (let [
                                                unboxCheck
                                                    (when (and (instance? FixedGuardNode node) (instance? IntegerEqualsNode (AbstractFixedGuardNode''condition-1 node))) => unboxCheck
                                                        (let [
                                                            #_"IntegerEqualsNode" equals (AbstractFixedGuardNode''condition-1 node)
                                                        ]
                                                            (when (or (and (IfNode''isUnboxedFrom-3 this, (:x equals), x) (IfNode''isUnboxedFrom-3 this, (:y equals), y)) (and (IfNode''isUnboxedFrom-3 this, (:x equals), y) (IfNode''isUnboxedFrom-3 this, (:y equals), x))) => unboxCheck
                                                                node
                                                            )
                                                        )
                                                    )
                                            ]
                                                (recur unbox unboxCheck (next s))
                                            )
                                        )
                                    )
                                )
                            )
                    ]
                        (and (some? unbox) (some? unboxCheck)
                            (do
                                ;; Falsify the reference check.
                                (§ ass! this (IfNode''setCondition-2 this, (Graph''addOrUniqueWithInputs-2 (:graph this), (LogicConstantNode'contradiction-0))))
                                true
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Try to optimize this as if it were a ConditionalNode.
     ;;
    (§ method- #_"boolean" IfNode''conditionalNodeOptimization-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (and (instance? AbstractEndNode (:next (:trueSuccessor this)))
             (instance? AbstractEndNode (:next (:falseSuccessor this)))
            (let [
                #_"AbstractEndNode" trueEnd (:next (:trueSuccessor this))
                #_"AbstractEndNode" falseEnd (:next (:falseSuccessor this))
            ]
                (and (= (AbstractEndNode''merge-1 trueEnd) (AbstractEndNode''merge-1 falseEnd)) (instance? MergeNode (AbstractEndNode''merge-1 trueEnd))
                    (let [
                        #_"MergeNode" merge (AbstractEndNode''merge-1 trueEnd)
                    ]
                        (and (= (NodeIterable''count-1 (Node''usages-1 merge)) 1) (= (NodeIterable''count-1 (AbstractMergeNode''phis-1 merge)) 1)
                            (if (or (NodeIterable''isNotEmpty-1 (AbstractBeginNode''anchored-1 (:trueSuccessor this)))
                                    (NodeIterable''isNotEmpty-1 (AbstractBeginNode''anchored-1 (:falseSuccessor this)))
                                )
                                false
                                (let [
                                    #_"PhiNode" phi (NodeIterable''first-1 (AbstractMergeNode''phis-1 merge))
                                    #_"ValueNode" result (ConditionalNode'canonicalizeConditional-4 (:condition this), (PhiNode''valueAt-2 phi, trueEnd), (PhiNode''valueAt-2 phi, falseEnd), (:stamp phi))
                                ]
                                    (and (some? result)
                                        ;; canonicalizeConditional returns possibly new nodes so add them to the graph
                                        (let [
                                            result
                                                (when (nil? (:graph result)) => result
                                                    (Graph''addOrUniqueWithInputs-2 (:graph this), result)
                                                )
                                            result (IfNode''proxyReplacement-2 this, result)
                                        ]
                                            ;; This optimization can be performed even if multiple values merge at this phi
                                            ;; since the two inputs get simplified into one.
                                            (PhiNode''setValueAt-3 phi, trueEnd, result)
                                            (IfNode''removeThroughFalseBranch-3 this, tool, merge)
                                            true
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method- #_"void" IfNode''pushNodesThroughIf-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        ;; push similar nodes upwards through the if, thereby deduplicating them
        (loop []
            (let [
                #_"AbstractBeginNode" trueSucc (:trueSuccessor this)
                #_"AbstractBeginNode" falseSucc (:falseSuccessor this)
            ]
                (when (and (instance? BeginNode trueSucc) (instance? BeginNode falseSucc) (instance? FixedWithNextNode (:next trueSucc)) (instance? FixedWithNextNode (:next falseSucc)))
                    (let [
                        #_"FixedWithNextNode" trueNext (:next trueSucc)
                        #_"FixedWithNextNode" falseNext (:next falseSucc)
                        #_"NodeClass" nodeClass (:nodeClass trueNext)
                    ]
                        (when (= (#_"Object" .getClass trueNext) (#_"Object" .getClass falseNext))
                            (cond
                                (instance? AbstractBeginNode trueNext)
                                (do
                                    ;; Cannot do this optimization for begin nodes, because it could
                                    ;; move guards above the if that need to stay below a branch.
                                )
                                (and (NodeClass''equalInputs-3 nodeClass, trueNext, falseNext) (Node''valueEquals-2 trueNext, falseNext))
                                (do
                                    (§ ass! falseNext (Node''replaceAtUsages-2 falseNext, trueNext))
                                    (Graph''removeFixed-2 (:graph this), falseNext)
                                    (GraphUtil'unlinkFixedNode-1 trueNext)
                                    (Graph''addBeforeFixed-3 (:graph this), this, trueNext)
                                    (doseq [#_"Node" usage (NodeIterable''snapshot-1 (Node''usages-1 trueNext))]
                                        (when (Node''isAlive-1 usage)
                                            (SimplifierTool''addToWorkList-2 tool, usage)
                                        )
                                    )
                                    (recur)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Recognize a couple patterns that can be merged into an unsigned compare.
     ;
     ; @return true if a replacement was done
     ;;
    (§ method- #_"boolean" IfNode''checkForUnsignedCompare-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (and (instance? IntegerLessThanNode (:condition this))
            (let [
                #_"IntegerLessThanNode" lessThan (:condition this)
                #_"Constant" y (Stamp''asConstant-1 (:stamp (:y lessThan)))
            ]
                (and (instance? PrimitiveConstant y) (zero? (UnsignedLong''asLong-1 y)) (instance? IfNode (:next (:falseSuccessor this)))
                    (let [
                        #_"IfNode" ifNode2 (:next (:falseSuccessor this))
                    ]
                        (and (instance? IntegerLessThanNode (:condition ifNode2))
                            (let [
                                #_"IntegerLessThanNode" lessThan2 (:condition ifNode2)
                                #_"AbstractBeginNode" trueSucc (:trueSuccessor ifNode2)
                                #_"AbstractBeginNode" falseSucc (:falseSuccessor ifNode2)
                                [trueSucc falseSucc #_"IntegerBelowNode" below]
                                    ;; Convert x >= 0 && x < positive, which is represented as !(x < 0) && x < <positive>, into an unsigned compare.
                                    (cond
                                        (and (= (:x lessThan2) (:x lessThan)) (instance? IntegerStamp (:stamp (:y lessThan2))) (IntegerStamp''isPositive-1 (:stamp (:y lessThan2))) (IfNode'sameDestination-2 (:trueSuccessor this), (:falseSuccessor ifNode2)))
                                            ;; swap direction
                                            [falseSucc trueSucc (Graph''add-2 (:graph this), (IntegerBelowNode'new-2 (:x lessThan2), (:y lessThan2)))]
                                        (and (= (:y lessThan2) (:x lessThan)) (IfNode'sameDestination-2 (:trueSuccessor this), (:trueSuccessor ifNode2)))
                                            ;; Convert x >= 0 && x <= positive, which is represented as !(x < 0) && !(<positive> > x), into x <| positive + 1.
                                            ;; Only for constants, since there isn't an IntegerBelowEqualThanNode, but that doesn't appear to be interesting.
                                            (let [
                                                #_"JavaConstant" positive (ValueNode''asJavaConstant-1 (:x lessThan2))
                                                below
                                                    (when (and (some? positive) (pos? (UnsignedLong''asLong-1 positive)) (< (UnsignedLong''asLong-1 positive) (#_"JavaKind" .getMaxValue (#_"JavaConstant" .getJavaKind positive))))
                                                        (Graph''add-2 (:graph this), (IntegerBelowNode'new-2 (:x lessThan), (ConstantNode'forIntegerStamp-3 (:stamp (:x lessThan2)), (inc (UnsignedLong''asLong-1 positive)), (:graph this))))
                                                    )
                                            ]
                                                [trueSucc falseSucc below]
                                            )
                                        :else
                                            [trueSucc falseSucc nil]
                                    )
                            ]
                                (and (some? below)
                                    (do
                                        (§ ass! ifNode2 (IfNode''setTrueSuccessor-2 ifNode2, nil))
                                        (§ ass! ifNode2 (IfNode''setFalseSuccessor-2 ifNode2, nil))

                                        (let [
                                            #_"IfNode" newIfNode (Graph''add-2 (:graph this), (IfNode'new-4 below, falseSucc, trueSucc, (- 1.0 (:trueSuccessorProbability this))))
                                        ]
                                            ;; Remove the < 0 test.
                                            (SimplifierTool''deleteBranch-2 tool, (:trueSuccessor this))
                                            (Graph''removeSplit-3 (:graph this), this, (:falseSuccessor this))

                                            ;; Replace the second test with the new one.
                                            (Node''replaceFirstSuccessor-3 (:predecessor ifNode2), ifNode2, newIfNode)
                                            (Node''safeDelete-1 ifNode2)
                                            true
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Check it these two blocks end up at the same place. Meeting at the same merge, or deoptimizing in the same way.
     ;;
    (§ defn- #_"boolean" IfNode'sameDestination-2 [#_"AbstractBeginNode" succ1, #_"AbstractBeginNode" succ2]
        (let [
            #_"Node" next1 (:next succ1)
            #_"Node" next2 (:next succ2)
        ]
            (cond
                ;; go to the same MergeNode and merge the same values
                (and (instance? EndNode next1) (instance? EndNode next2))
                    (and (= (AbstractEndNode''merge-1 next1) (AbstractEndNode''merge-1 next2))
                        (loop-when [#_"ISeq" s (seq (AbstractMergeNode''phis-1 (AbstractEndNode''merge-1 next1)))] (some? s) => true
                            (let [
                                #_"PhiNode" phi (first s)
                            ]
                                (and (= (PhiNode''valueAt-2 phi, next1) (PhiNode''valueAt-2 phi, next2))
                                    (recur (next s))
                                )
                            )
                        )
                    )
                ;; same deoptimization reason and action
                (and (instance? DeoptimizeNode next1) (instance? DeoptimizeNode next2))
                    (and (= (:reason next1) (:reason next2)) (= (:action next1) (:action next2)))
                ;; exit the same loop and end up at the same place
                (and (instance? LoopExitNode next1) (instance? LoopExitNode next2))
                    (and (= (:loopBegin next1) (:loopBegin next2))
                         (= (BeginStateSplitNode''stateAfter-1 next1) (BeginStateSplitNode''stateAfter-1 next2))
                         (nil? (BeginStateSplitNode''stateAfter-1 next1))
                         (IfNode'sameDestination-2 next1, next2)
                    )
                ;; exit the same loop and end up at the same place
                (and (instance? ReturnNode next1) (instance? ReturnNode next2))
                    (= (:result next1) (:result next2))
                :else
                    false
            )
        )
    )

    (§ defn- #_"boolean" IfNode'prepareForSwap-3 [#_"SimplifierTool" tool, #_"LogicNode" a, #_"LogicNode" b]
        (condp instance? a
            InstanceOfNode
                (condp instance? b
                    IsNullNode
                        (= (UnaryOpLogicNode''getValue-1 b) (UnaryOpLogicNode''getValue-1 a))
                    InstanceOfNode
                        ;; Two instanceof on the same value with mutually exclusive types.
                        (and (= (UnaryOpLogicNode''getValue-1 a) (UnaryOpLogicNode''getValue-1 b))
                             (not (#_"ResolvedJavaType" .isInterface (:type (InstanceOfNode''type-1 a))))
                             (not (#_"ResolvedJavaType" .isInterface (:type (InstanceOfNode''type-1 b))))
                             (not (#_"ResolvedJavaType" .isAssignableFrom (:type (InstanceOfNode''type-1 a)), (:type (InstanceOfNode''type-1 b))))
                             (not (#_"ResolvedJavaType" .isAssignableFrom (:type (InstanceOfNode''type-1 b)), (:type (InstanceOfNode''type-1 a))))
                        )
                    false
                )
            CompareNode
                (let [
                    #_"Condition" conditionA (:condition (CompareNode''condition-1 a))
                ]
                    (and (instance? CompareNode b) (not= a b)
                        (let [
                            #_"Condition" conditionB (:condition (CompareNode''condition-1 b))
                            #_"Condition" comparableCondition
                                (cond
                                    (and (= (:x b) (:x a)) (= (:y b) (:y a)))                      conditionB
                                    (and (= (:x b) (:y a)) (= (:y b) (:x a))) (Condition''mirror-1 conditionB)
                                )
                        ]
                            (if (nil? comparableCondition)
                                (and (= conditionA conditionB Condition'EQ)
                                    (or (and (= (:x a) (:x b)) (IfNode'valuesDistinct-3 tool, (:y a), (:y b)))
                                        (and (= (:x a) (:y b)) (IfNode'valuesDistinct-3 tool, (:y a), (:x b)))
                                        (and (= (:y a) (:x b)) (IfNode'valuesDistinct-3 tool, (:x a), (:y b)))
                                        (and (= (:y a) (:y b)) (IfNode'valuesDistinct-3 tool, (:x a), (:x b)))
                                    )
                                )
                                ;; The two conditions are disjoint => can reorder.
                                (nil? (Condition''join-2 conditionA, comparableCondition))
                            )
                        )
                    )
                )
            false
        )
    )

    (§ defn- #_"boolean" IfNode'valuesDistinct-3 [#_"SimplifierTool" tool, #_"ValueNode" a, #_"ValueNode" b]
        (when (and (instance? ConstantNode a) (instance? ConstantNode b))
            (let [
                #_"Boolean" equal (#_"ConstantReflectionProvider" .constantEquals HotSpot'constantReflection, (:value a), (:value b))
            ]
                (when (some? equal)
                    (§ return (not (#_"Boolean" .booleanValue equal)))
                )
            )
        )

        (Stamp''alwaysDistinct-2 (:stamp a), (:stamp b))
    )

    ;;;
     ; Tries to remove an empty if construct or replace an if construct with a materialization.
     ;
     ; @return true if a transformation was made, false otherwise
     ;;
    (§ method- #_"boolean" IfNode''removeOrMaterializeIf-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (let [
            #_"FixedNode" trueEnd (:next (:trueSuccessor this))
            #_"FixedNode" falseEnd (:next (:falseSuccessor this))
        ]
            (when (and (instance? AbstractEndNode trueEnd) (instance? AbstractEndNode falseEnd))
                (let [
                    #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 trueEnd)
                ]
                    (when (and (= merge (AbstractEndNode''merge-1 falseEnd)) (NodeIterable''isEmpty-1 (AbstractBeginNode''anchored-1 (:trueSuccessor this))) (NodeIterable''isEmpty-1 (AbstractBeginNode''anchored-1 (:falseSuccessor this))))
                        (let [
                            [#_"PhiNode" singlePhi #_"int" distinct]
                                (loop-when [singlePhi nil distinct 0 #_"ISeq" s (seq (AbstractMergeNode''phis-1 merge))] (some? s) => [singlePhi distinct]
                                    (let [
                                        #_"PhiNode" phi (first s)
                                    ]
                                        (if (= (PhiNode''valueAt-2 phi, trueEnd) (PhiNode''valueAt-2 phi, falseEnd))
                                            (recur singlePhi distinct (next s))
                                            (recur phi (inc distinct) (next s))
                                        )
                                    )
                                )
                        ]
                            (case distinct
                                0
                                    (do
                                        ;; multiple phis, but merging same values for true and false, so simply delete the path
                                        (IfNode''removeThroughFalseBranch-3 this, tool, merge)
                                        (§ return true)
                                    )
                                1
                                    (let [
                                        #_"ValueNode" trueValue (PhiNode''valueAt-2 singlePhi, trueEnd)
                                        #_"ValueNode" falseValue (PhiNode''valueAt-2 singlePhi, falseEnd)
                                        #_"ValueNode" conditional (IfNode''canonicalizeConditionalCascade-4 this, tool, trueValue, falseValue)
                                    ]
                                        (when (some? conditional)
                                            (PhiNode''setValueAt-3 singlePhi, trueEnd, (IfNode''proxyReplacement-2 this, conditional))
                                            (IfNode''removeThroughFalseBranch-3 this, tool, merge)
                                            (§ return true)
                                        )
                                    )
                                nil
                            )
                        )
                    )
                )
            )
            (and (instance? ReturnNode trueEnd) (instance? ReturnNode falseEnd)
                (let [
                    #_"ValueNode" trueValue (:result trueEnd)
                    #_"ValueNode" falseValue (:result falseEnd)
                    #_"ValueNode" value nil
                ]
                    (when (some? trueValue)
                        (if (= trueValue falseValue)
                            (§ ass value trueValue)
                            (do
                                (§ ass value (IfNode''canonicalizeConditionalCascade-4 this, tool, trueValue, falseValue))
                                (when (nil? value)
                                    (§ return false)
                                )
                            )
                        )
                    )
                    (Node''replaceAtPredecessor-2 this, (Graph''add-2 (:graph this), (ReturnNode'new-1 value)))
                    (GraphUtil'killCFG-1 this)
                    true
                )
            )
        )
    )

    (§ method- #_"ValueNode" IfNode''proxyReplacement-2 [#_"IfNode" this, #_"ValueNode" replacement]
        ;; Special case: Every empty diamond we collapse to a conditional node can potentially
        ;; contain loop exit nodes on both branches. See the graph below: The two loop exits
        ;; (instanceof begin node) exit the same loop. The resulting phi is defined outside the
        ;; loop, but the resulting conditional node will be inside the loop, so we need to proxy the
        ;; resulting conditional node. Callers of this method ensure that true and false successor
        ;; have no usages, therefore a and b in the graph below can never be proxies themselves.
        ;;
        ;;              +--+
        ;;              |If|
        ;;              +--+      +-----+ +-----+
        ;;         +----+  +----+ |  a  | |  b  |
        ;;         |Lex |  |Lex | +----^+ +^----+
        ;;         +----+  +----+      |   |
        ;;           +-------+         +---+
        ;;           | Merge +---------+Phi|
        ;;           +-------+         +---+
        (if (and (:hasValueProxies (:graph this)) (instance? LoopExitNode (:trueSuccessor this)) (instance? LoopExitNode (:falseSuccessor this)))
            (Graph''add-2 (:graph this), (ValueProxyNode'new-2 replacement, (:trueSuccessor this)))
            replacement
        )
    )

    (§ method! #_"void" IfNode''removeThroughFalseBranch-3 [#_"IfNode" this, #_"SimplifierTool" tool, #_"AbstractMergeNode" merge]
        (let [
            #_"AbstractBeginNode" trueBegin (:trueSuccessor this)
            #_"LogicNode" logic (:condition this)
        ]
            (Graph''removeSplitPropagate-3 (:graph this), this, trueBegin)
            (SimplifierTool''addToWorkList-2 tool, trueBegin)
            (when (some? logic)
                (GraphUtil'tryKillUnused-1 logic)
            )
            (when (and (Node''isAlive-1 merge) (< 1 (AbstractMergeNode''forwardEndCount-1 merge)))
                (doseq [#_"FixedNode" end (AbstractMergeNode''forwardEnds-1 merge)]
                    (let [
                        #_"Node" n (loop-when-recur [n end] (and (some? n) (instance? BeginNode (:predecessor n))) [(:predecessor n)] => n)
                    ]
                        (when (and (some? n) (instance? IfNode (:predecessor n)))
                            (SimplifierTool''addToWorkList-2 tool, (:predecessor n))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"ValueNode" IfNode''canonicalizeConditionalCascade-4 [#_"IfNode" this, #_"SimplifierTool" tool, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (cond
            (not (= (ValueNode''getStackKind-1 trueValue) (ValueNode''getStackKind-1 falseValue)))
                nil
            (not (any = (ValueNode''getStackKind-1 trueValue) JavaKind/Int JavaKind/Long))
                nil
            (and (instance? ConstantNode trueValue) (instance? ConstantNode falseValue))
                (Graph''add-2 (:graph this), (ConditionalNode'new-3 (:condition this), trueValue, falseValue))
            (not (:isAfterExpandLogic (:graph this)))
                (let [
                    [#_"ConditionalNode" conditional #_"ValueNode" constant #_"boolean" negateCondition]
                        (cond
                            (and (instance? ConditionalNode trueValue)  (instance? ConstantNode falseValue)) [trueValue falseValue true ]
                            (and (instance? ConditionalNode falseValue) (instance? ConstantNode trueValue) ) [falseValue trueValue false]
                            :else
                                (§ return nil)
                        )
                ]
                    (let [
                        [#_"ValueNode" otherValue #_"boolean" negateConditionalCondition]
                            (condp = constant
                                (:trueValue conditional)  [(:falseValue conditional) false]
                                (:falseValue conditional) [(:trueValue conditional)  true ]
                                                          [nil                       false]
                            )
                    ]
                        (cond
                            (and (some? otherValue) (instance? ConstantNode otherValue))
                                (let [
                                    #_"double" shortCutProbability (IfNode''probability-2 this, (:trueSuccessor this))
                                    #_"LogicNode" newCondition (LogicNode'or-5 (:condition this), negateCondition, (:condition conditional), negateConditionalCondition, shortCutProbability)
                                ]
                                    (Graph''add-2 (:graph this), (ConditionalNode'new-3 newCondition, constant, otherValue))
                                )
                            (and (not negateCondition) (ValueNode''isJavaConstant-1 constant) (ValueNode''isJavaConstant-1 (:trueValue conditional)) (ValueNode''isJavaConstant-1 (:falseValue conditional)))
                                (let [
                                    [#_"IntegerLessThanNode" lessThan #_"IntegerEqualsNode" equals]
                                        (cond
                                            (and (instance? IntegerLessThanNode (:condition this)) (instance? IntegerEqualsNode (:condition conditional)) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 constant)) -1) (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:trueValue conditional)))) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:falseValue conditional))) 1))
                                                [
                                                    (:condition this)
                                                    (:condition conditional)
                                                ]
                                            (and (instance? IntegerEqualsNode (:condition this)) (instance? IntegerLessThanNode (:condition conditional)) (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 constant))) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:trueValue conditional))) -1) (= (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:falseValue conditional))) 1))
                                                [
                                                    (:condition conditional)
                                                    (:condition this)
                                                ]
                                        )
                                ]
                                    (when (some? lessThan)
                                        (when (or (and (= (:x lessThan) (:x equals)) (= (:y lessThan) (:y equals))) (and (= (:x lessThan) (:y equals)) (= (:y lessThan) (:x equals))))
                                            (Graph''add-2 (:graph this), (NormalizeCompareNode'new-3 (:x lessThan), (:y lessThan), (Stamp''getStackKind-1 (:stamp (:trueValue conditional)))))
                                        )
                                    )
                                )
                        )
                    )
                )
        )
    )

    ;;;
     ; Take an if that is immediately dominated by a merge with a single phi and split off any paths
     ; where the test would be statically decidable creating a new merge below the approriate side
     ; of the IfNode. Any undecidable tests will continue to use the original IfNode.
     ;;
    (§ method- #_"boolean" IfNode''splitIfAtPhi-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        ;; disabled until we make sure we have no FrameState-less merges at this stage
        (and (not (GuardsStage'areFrameStatesAtSideEffects-1 (:guardsStage (:graph this))))
            (instance? MergeNode (:predecessor this))
            (let [
                #_"MergeNode" merge (:predecessor this)
            ]
                (and (not (= (AbstractMergeNode''forwardEndCount-1 merge) 1)) ;; don't bother
                    (= (NodeIterable''count-1 (Node''usages-1 merge)) 1) (= (NodeIterable''count-1 (AbstractMergeNode''phis-1 merge)) 1)
                    (nil? (BeginStateSplitNode''stateAfter-1 merge)) ;; we'll get the chance to simplify this after frame state assignment
                    (let [
                        #_"PhiNode" phi (NodeIterable''first-1 (AbstractMergeNode''phis-1 merge))
                    ]
                        (and
                            ;; for simplicity, the code below assumes that phi goes dead at the end, so skip this case
                            (= (NodeIterable''count-1 (Node''usages-1 phi)) 1)
                            ;; check that the condition uses the phi and that there is only one user of the condition expression
                            (IfNode'conditionUses-2 (:condition this), phi)
                            ;; We could additionally filter for the case that at least some of the Phi inputs or one of
                            ;; the condition inputs are constants but there are cases where a non-constant is simplifiable,
                            ;; usually where the stamp allows the question to be answered.

                            ;; each successor of the if gets a new merge if needed
                            (let [
                                [#_"MergeNode" trueMerge #_"MergeNode" falseMerge]
                                    (loop-when [trueMerge nil falseMerge nil #_"ISeq" s (seq (NodeList''snapshot-1 (AbstractMergeNode''forwardEnds-1 merge)))] (some? s) => [trueMerge falseMerge]
                                        (let [
                                            #_"EndNode" end (first s)
                                            #_"Node" value (PhiNode''valueAt-2 phi, end)
                                            #_"LogicNode" result (IfNode'computeCondition-4 tool, (:condition this), phi, value)
                                            [trueMerge falseMerge]
                                                (cond
                                                    (instance? LogicConstantNode result)
                                                        (do
                                                            (AbstractMergeNode''removeEnd-2 merge, end)
                                                            (if (:value result)
                                                                (let [
                                                                    trueMerge (or trueMerge (IfNode''insertMerge-2 this, (:trueSuccessor this)))
                                                                ]
                                                                    (AbstractMergeNode''addForwardEnd-2 trueMerge, end)
                                                                    [trueMerge falseMerge]
                                                                )
                                                                (let [
                                                                    falseMerge (or falseMerge (IfNode''insertMerge-2 this, (:falseSuccessor this)))
                                                                ]
                                                                    (AbstractMergeNode''addForwardEnd-2 falseMerge, end)
                                                                    [trueMerge falseMerge]
                                                                )
                                                            )
                                                        )
                                                    (= result (:condition this))
                                                        [trueMerge falseMerge]
                                                    :else
                                                        ;; build a new IfNode using the new condition
                                                        (let [
                                                            #_"BeginNode" trueBegin (Graph''add-2 (:graph this), (BeginNode'new-0))
                                                            #_"BeginNode" falseBegin (Graph''add-2 (:graph this), (BeginNode'new-0))
                                                            result (if (some? (:graph result)) result (Graph''addOrUniqueWithInputs-2 (:graph this), result))
                                                            #_"IfNode" newIfNode (Graph''add-2 (:graph this), (IfNode'new-4 result, trueBegin, falseBegin, (:trueSuccessorProbability this)))
                                                            _ (AbstractMergeNode''removeEnd-2 merge, end)
                                                            _ (§ ass! (:predecessor end) (FixedWithNextNode''setNext-2 (:predecessor end), newIfNode))
                                                            trueMerge (or trueMerge (IfNode''insertMerge-2 this, (:trueSuccessor this)))
                                                            _ (§ ass! trueBegin (FixedWithNextNode''setNext-2 trueBegin, (Graph''add-2 (:graph this), (EndNode'new-0))))
                                                            _ (AbstractMergeNode''addForwardEnd-2 trueMerge, (:next trueBegin))
                                                            falseMerge (or falseMerge (IfNode''insertMerge-2 this, (:falseSuccessor this)))
                                                            _ (§ ass! falseBegin (FixedWithNextNode''setNext-2 falseBegin, (Graph''add-2 (:graph this), (EndNode'new-0))))
                                                            _ (AbstractMergeNode''addForwardEnd-2 falseMerge, (:next falseBegin))
                                                            _ (Node''safeDelete-1 end)
                                                        ]
                                                            [trueMerge falseMerge]
                                                        )
                                                )
                                        ]
                                            (recur trueMerge falseMerge (next s))
                                        )
                                    )
                            ]
                                (IfNode'transferProxies-2 (:trueSuccessor this), trueMerge)
                                (IfNode'transferProxies-2 (:falseSuccessor this), falseMerge)

                                (IfNode''cleanupMerge-2 this, merge)
                                (IfNode''cleanupMerge-2 this, trueMerge)
                                (IfNode''cleanupMerge-2 this, falseMerge)

                                true
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Return true if the passed in {@code logic} uses {@code phi} and the condition is only used once.
     ; Since the phi will go dead, the logic using it will also have to be dead after the optimization.
     ;;
    (§ defn- #_"boolean" IfNode'conditionUses-2 [#_"LogicNode" logic, #_"PhiNode" phi]
        (and (= (NodeIterable''count-1 (Node''usages-1 logic)) 1)
            (condp instance? logic
                ShortCircuitOrNode
                    (and (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph logic)))
                        ;; It can be unsafe to simplify a ShortCircuitOr before deopts are fixed because
                        ;; conversion to guards assumes that all the required conditions are being tested.
                        ;; Simplfying the condition based on context before this happens may lose a condition.
                        (or (IfNode'conditionUses-2 (:x logic), phi) (IfNode'conditionUses-2 (:y logic), phi))
                    )
                Unary  (= (Unary''getValue-1 logic) phi)
                Binary (or (= (:x logic) phi) (= (:y logic) phi))
                       false
            )
        )
    )

    ;;;
     ; Canonicalize {@code logic} using {@code value} in place of {@code phi}.
     ;;
    (§ defn- #_"LogicNode" IfNode'computeCondition-4 [#_"SimplifierTool" tool, #_"LogicNode" logic, #_"PhiNode" phi, #_"Node" value]
        (condp instance? logic
            ShortCircuitOrNode
                (when (and (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph logic))) (not (:isAfterExpandLogic (:graph logic))))
                    (let [
                        #_"LogicNode" resultX (IfNode'computeCondition-4 tool, (:x logic), phi, value)
                        #_"LogicNode" resultY (IfNode'computeCondition-4 tool, (:y logic), phi, value)
                    ]
                        (when-not (and (= resultX (:x logic)) (= resultY (:y logic)))
                            (let [
                                #_"LogicNode" canon (ShortCircuitOrNode''canonical-4 logic, tool, resultX, resultY)
                            ]
                                (if-not (= canon logic)
                                    (§ return canon)
                                    ;; Create a new node to carry the optimized inputs.
                                    (§ return (LogicNode''canonical-2 (ShortCircuitOrNode'new-5 resultX, (:xNegated logic), resultY, (:yNegated logic), (:shortCircuitProbability logic)), tool))
                                )
                            )
                        )
                        (§ return logic)
                    )
                )
            Binary
                (cond
                    (= (:x logic) phi)
                        (§ return (Binary''canonical-4 logic, tool, value, (:y logic)))
                    (= (:y logic) phi)
                        (§ return (Binary''canonical-4 logic, tool, (:x logic), value))
                )
            Unary
                (when (= (Unary''getValue-1 logic) phi)
                    (§ return (Unary''canonical-3 logic, tool, value))
                )
            nil
        )
        (if (instance? Canonicalizable logic) (Canonicalizable''canonical-2 logic, tool) logic)
    )

    (§ defn- #_"void" IfNode'transferProxies-2 [#_"AbstractBeginNode" successor, #_"MergeNode" falseMerge]
        (when (and (instance? LoopExitNode successor) (some? falseMerge))
            (doseq [#_"ProxyNode" proxy (NodeIterable''snapshot-1 (LoopExitNode''proxies-1 successor))]
                (Node''replaceFirstInput-3 proxy, successor, falseMerge)
            )
        )
        nil
    )

    (§ method- #_"void" IfNode''cleanupMerge-2 [#_"IfNode" this, #_"MergeNode" merge]
        (when (and (some? merge) (Node''isAlive-1 merge))
            (case (AbstractMergeNode''forwardEndCount-1 merge)
                0 (GraphUtil'killCFG-1 merge)
                1 (Graph''reduceTrivialMerge-2 (:graph this), merge)
                nil
            )
        )
        nil
    )

    (§ method- #_"MergeNode" IfNode''insertMerge-2 [#_"IfNode" this, #_"AbstractBeginNode" begin]
        (let [
            #_"MergeNode" merge (Graph''add-2 (:graph this), (MergeNode'new-0))
        ]
            (when-not (NodeIterable''isEmpty-1 (AbstractBeginNode''anchored-1 begin))
                (Node''replaceAtUsages-3 begin, InputType'Guard, merge)
                (Node''replaceAtUsages-3 begin, InputType'Anchor, merge)
            )

            (let [
                #_"AbstractBeginNode" theBegin
                    (when (instance? LoopExitNode begin) => begin
                        ;; Insert an extra begin to make it easier.
                        (let [
                            theBegin (Graph''add-2 (:graph this), (BeginNode'new-0))
                        ]
                            (Node''replaceAtPredecessor-2 begin, theBegin)
                            (§ ass! theBegin (FixedWithNextNode''setNext-2 theBegin, begin))
                            theBegin
                        )
                    )
                #_"FixedNode" next (:next theBegin)
            ]
                (Node''replaceAtPredecessor-2 next, merge)
                (§ ass! theBegin (FixedWithNextNode''setNext-2 theBegin, (Graph''add-2 (:graph this), (EndNode'new-0))))
                (AbstractMergeNode''addForwardEnd-2 merge, (:next theBegin))
                (§ ass! merge (FixedWithNextNode''setNext-2 merge, next))
                merge
            )
        )
    )

    ;;;
     ; Tries to connect code that initializes a variable directly with the successors of an if
     ; construct that switches on the variable. For example, the pseudo code below:
     ;
     ; contains(list, e, yes, no) {
     ;     if (list == null || e == null) {
     ;         condition = false;
     ;     } else {
     ;         condition = false;
     ;         for (i in list) {
     ;             if (i.equals(e)) {
     ;                 condition = true;
     ;                 break;
     ;             }
     ;         }
     ;     }
     ;     if (condition) {
     ;         return yes;
     ;     } else {
     ;         return no;
     ;     }
     ; }
     ;
     ; will be transformed into:
     ;
     ; contains(list, e, yes, no) {
     ;     if (list == null || e == null) {
     ;         return no;
     ;     } else {
     ;         condition = false;
     ;         for (i in list) {
     ;             if (i.equals(e)) {
     ;                 return yes;
     ;             }
     ;         }
     ;         return no;
     ;     }
     ; }
     ;
     ; @return true if a transformation was made, false otherwise
     ;;
    (§ method- #_"boolean" IfNode''removeIntermediateMaterialization-2 [#_"IfNode" this, #_"SimplifierTool" tool]
        (and (instance? AbstractMergeNode (:predecessor this)) (not (instance? LoopBeginNode (:predecessor this))) (instance? CompareNode (:condition this))
            (let [
                #_"CompareNode" compare (:condition this)
            ]
                (and (= (Node''getUsageCount-1 compare) 1)
                    ;; only consider merges with a single usage that is both a phi and an operand of the comparison
                    (let [
                        #_"AbstractMergeNode" merge (:predecessor this)
                        #_"NodeIterable<Node>" mergeUsages (Node''usages-1 merge)
                    ]
                        (and (= (NodeIterable''count-1 mergeUsages) 1)
                            (let [
                                #_"Node" singleUsage (NodeIterable''first-1 mergeUsages)
                            ]
                                (and (instance? ValuePhiNode singleUsage) (or (= singleUsage (:x compare)) (= singleUsage (:y compare)))
                                    ;; ensure phi is used by at most the comparison and the merge's frame state (if any)
                                    (let [
                                        #_"ValuePhiNode" phi singleUsage
                                        #_"NodeIterable<Node>" phiUsages (Node''usages-1 phi)
                                    ]
                                        (and
                                            (<= (NodeIterable''count-1 phiUsages) 2)
                                            (loop-when [#_"ISeq" s (seq phiUsages)] (some? s) => true
                                                (and (any = (first s) compare (BeginStateSplitNode''stateAfter-1 merge))
                                                    (recur (next s))
                                                )
                                            )
                                            (let [
                                                #_"List<EndNode>" mergePredecessors (NodeIterable''snapshot-1 (AbstractMergeNode''cfgPredecessors-1 merge))
                                                #_"Constant[]" xs (IfNode'constantValues-3 (:x compare), merge, false)
                                                #_"Constant[]" ys (IfNode'constantValues-3 (:y compare), merge, false)
                                            ]
                                                (and (some? xs) (some? ys)
                                                    ;; Sanity check that both ends are not followed by a merge without frame state.
                                                    (or (IfNode'checkFrameState-1 (:trueSuccessor this)) (IfNode'checkFrameState-1 (:falseSuccessor this)))
                                                    (let [
                                                        #_"List<EndNode>" falseEnds (ArrayList.)
                                                        #_"List<EndNode>" trueEnds (ArrayList.)
                                                        #_"EconomicMap<AbstractEndNode, ValueNode>" phiValues (EconomicMap/create Equivalence/IDENTITY, (count mergePredecessors))
                                                        #_"AbstractBeginNode" oldFalseSuccessor (:falseSuccessor this)
                                                        #_"AbstractBeginNode" oldTrueSuccessor (:trueSuccessor this)
                                                        _ (§ ass! this (IfNode''setFalseSuccessor-2 this, nil))
                                                        _ (§ ass! this (IfNode''setTrueSuccessor-2 this, nil))
                                                        #_"Iterator<EndNode>" ends (#_"List" .iterator mergePredecessors)
                                                    ]
                                                        (dotimes [#_"int" i (count xs)]
                                                            (let [
                                                                #_"EndNode" end (#_"Iterator" .next ends)
                                                            ]
                                                                (#_"EconomicMap" .put phiValues, end, (PhiNode''valueAt-2 phi, end))
                                                                (if (Condition''foldCondition-3 (CompareNode''condition-1 compare), (:condition (nth xs i)), (nth ys i))
                                                                    (#_"List" .add trueEnds, end)
                                                                    (#_"List" .add falseEnds, end)
                                                                )
                                                            )
                                                        )

                                                        (IfNode''connectEnds-6 this, falseEnds, phiValues, oldFalseSuccessor, merge, tool)
                                                        (IfNode''connectEnds-6 this, trueEnds, phiValues, oldTrueSuccessor, merge, tool)

                                                        (when (= (:trueSuccessorProbability this) 0.0)
                                                            (doseq [#_"AbstractEndNode" endNode trueEnds]
                                                                (IfNode''propagateZeroProbability-2 this, endNode)
                                                            )
                                                        )

                                                        (when (= (:trueSuccessorProbability this) 1.0)
                                                            (doseq [#_"AbstractEndNode" endNode falseEnds]
                                                                (IfNode''propagateZeroProbability-2 this, endNode)
                                                            )
                                                        )

                                                        ;; Remove obsolete ends only after processing all ends, otherwise oldTrueSuccessor or
                                                        ;; oldFalseSuccessor might have been removed if it is a LoopExitNode.
                                                        (when (empty? falseEnds)
                                                            (GraphUtil'killCFG-1 oldFalseSuccessor)
                                                        )
                                                        (when (empty? trueEnds)
                                                            (GraphUtil'killCFG-1 oldTrueSuccessor)
                                                        )
                                                        (GraphUtil'killCFG-1 merge)

                                                        true
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method- #_"void" IfNode''propagateZeroProbability-2 [#_"IfNode" this, #_"FixedNode" startNode]
        (loop-when [#_"Node" prev nil #_"ISeq" s (seq (GraphUtil'predecessorIterable-1 startNode))] (some? s)
            (let [
                #_"FixedNode" node (first s)
            ]
                (and
                    (cond
                        (instance? IfNode node)
                            (condp = prev
                                (:trueSuccessor node)
                                    (case (:trueSuccessorProbability node)
                                        0.0 nil
                                        1.0 :continue
                                        (do
                                            (§ ass! node (IfNode''setTrueSuccessorProbability-2 node, 0.0))
                                            nil
                                        )
                                    )
                                (:falseSuccessor node)
                                    (case (:trueSuccessorProbability node)
                                        1.0 nil
                                        0.0 :continue
                                        (do
                                            (§ ass! node (IfNode''setTrueSuccessorProbability-2 node, 1.0))
                                            nil
                                        )
                                    )
                            )
                        (and (instance? AbstractMergeNode node) (not (instance? LoopBeginNode node)))
                            (do
                                (doseq [#_"AbstractEndNode" endNode (AbstractMergeNode''cfgPredecessors-1 node)]
                                    (IfNode''propagateZeroProbability-2 this, endNode)
                                )
                                nil
                            )
                        :else
                            :continue
                    )
                    (recur node (next s))
                )
            )
        )
        nil
    )

    (§ defn- #_"boolean" IfNode'checkFrameState-1 [#_"FixedNode" node]
        (loop [node node]
            (condp instance? node
                AbstractMergeNode
                    (§ return (some? (BeginStateSplitNode''stateAfter-1 node)))
                StateSplit
                    (when (some? (StateSplit''stateAfter-1 node))
                        (§ return true)
                    )
                nil
            )

            (condp instance? node
                ControlSplitNode
                    (loop-when [#_"ISeq" s (seq (Node''cfgSuccessors-1 node))] (some? s) => false
                        (or (IfNode'checkFrameState-1 (first s))
                            (recur (next s))
                        )
                    )
                FixedWithNextNode (recur (:next node))
                AbstractEndNode   (recur (AbstractEndNode''merge-1 node))
                ControlSinkNode   true
                                  false
            )
        )
    )

    ;;;
     ; Connects a set of ends to a given successor, inserting a merge node if there is more than
     ; one end. If {@code ends} is not empty, then {@code successor} is added to {@code tool}'s
     ; {@linkplain SimplifierTool#addToWorkList(Node) work list}.
     ;
     ; @param oldMerge the merge being removed
     ; @param phiValues the values of the phi at the merge, keyed by the merge ends
     ;;
    (§ method- #_"void" IfNode''connectEnds-6 [#_"IfNode" this, #_"List<EndNode>" ends, #_"EconomicMap<AbstractEndNode, ValueNode>" phiValues, #_"AbstractBeginNode" successor, #_"AbstractMergeNode" oldMerge, #_"SimplifierTool" tool]
        (when (seq ends)
            (if (= (count ends) 1)
                (let [
                    #_"AbstractEndNode" end (nth ends 0)
                ]
                    (§ ass! (:predecessor end) (FixedWithNextNode''setNext-2 (:predecessor end), successor))
                    (AbstractMergeNode''removeEnd-2 oldMerge, end)
                    (GraphUtil'killCFG-1 end)
                )
                ;; need a new phi in case the frame state is used by more than the merge being removed
                (let [
                    #_"AbstractMergeNode" newMerge (Graph''add-2 (:graph this), (MergeNode'new-0))
                    #_"PhiNode" oldPhi (NodeIterable''first-1 (Node''usages-1 oldMerge))
                    #_"PhiNode" newPhi (Graph''add-2 (:graph this), (ValuePhiNode'new-2 (:stamp oldPhi), newMerge))
                ]
                    (doseq [#_"EndNode" end ends]
                        (PhiNode''addInput-2 newPhi, (get phiValues end))
                        (AbstractMergeNode''addForwardEnd-2 newMerge, end)
                    )

                    (let [
                        #_"FrameState" stateAfter (BeginStateSplitNode''stateAfter-1 oldMerge)
                    ]
                        (when (some? stateAfter)
                            (§ ass stateAfter (FrameState''duplicate-1 stateAfter))
                            (Node''replaceFirstInput-3 stateAfter, oldPhi, newPhi)
                            (BeginStateSplitNode''setStateAfter-2 newMerge, stateAfter)
                        )

                        (§ ass! newMerge (FixedWithNextNode''setNext-2 newMerge, successor))
                    )
                )
            )
            (SimplifierTool''addToWorkList-2 tool, successor)
        )
        nil
    )

    ;;;
     ; Gets an array of constants derived from a node that is either a ConstantNode or a
     ; PhiNode whose input values are all constants. The length of the returned array is
     ; equal to the number of ends terminating in a given merge node.
     ;
     ; @return nil if {@code node} is neither a ConstantNode nor a PhiNode whose
     ;         input values are all constants
     ;;
    (§ defn #_"Constant[]" IfNode'constantValues-3 [#_"ValueNode" node, #_"AbstractMergeNode" merge, #_"boolean" allow-nil?]
        (cond
            (instance? ConstantNode node)
                (let [
                    #_"Constant[]" constants (make-array Constant (AbstractMergeNode''forwardEndCount-1 merge))
                ]
                    (Arrays/fill constants, (:value node))
                    constants
                )
            (and (instance? PhiNode node) (= (PhiNode''merge-1 node) merge) (instance? ValuePhiNode node) (= (PhiNode''valueCount-1 node) (AbstractMergeNode''forwardEndCount-1 merge)))
                (let [
                    #_"Constant[]" constants (make-array Constant (AbstractMergeNode''forwardEndCount-1 merge))
                ]
                    (loop-when [#_"int" i 0 #_"ISeq" s (seq (PhiNode''values-1 node))] (some? s) => constants
                        (let [
                            #_"ValueNode" n (first s)
                        ]
                            (when (or allow-nil? (instance? ConstantNode n))
                                (aset constants i (ValueNode''asConstant-1 n))
                                (recur (inc i) (next s))
                            )
                        )
                    )
                )
        )
    )

    #_unused
    (§ override! #_"AbstractBeginNode" IfNode''getPrimarySuccessor-1 [#_"IfNode" this]
        nil
    )

    (§ method! #_"AbstractBeginNode" IfNode''getSuccessor-2 [#_"IfNode" this, #_"boolean" result]
        (if result (:trueSuccessor this) (:falseSuccessor this))
    )

    #_unused
    (§ override! #_"boolean" IfNode''setProbability-3 [#_"IfNode" this, #_"AbstractBeginNode" successor, #_"double" value]
        (condp = successor
            (:trueSuccessor this)
            (do
                (§ ass! this (IfNode''setTrueSuccessorProbability-2 this, value))
                true
            )
            (:falseSuccessor this)
            (do
                (§ ass! this (IfNode''setTrueSuccessorProbability-2 this, (- 1.0 value)))
                true
            )
            false
        )
    )

    #_unused
    (§ override! #_"int" IfNode''getSuccessorCount-1 [#_"IfNode" this]
        2
    )
)

(class-ns IndirectCallTargetNode (§ extends LoweredCallTargetNode)
    (§ def #_"NodeClass<IndirectCallTargetNode>" IndirectCallTargetNode'TYPE (NodeClass'create-1 IndirectCallTargetNode))

    ; @Input
    (§ mutable #_"ValueNode" :computedAddress nil)

    #_unused
    (§ defn #_"IndirectCallTargetNode" IndirectCallTargetNode'new-7 [#_"ValueNode" computedAddress, #_"ValueNode[]" arguments, #_"StampPair" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (IndirectCallTargetNode'new-8 IndirectCallTargetNode'TYPE, computedAddress, arguments, returnStamp, signature, target, callType, invokeKind)
    )

    (§ defn #_"IndirectCallTargetNode" IndirectCallTargetNode'new-8 [#_"NodeClass<? extends IndirectCallTargetNode>" c, #_"ValueNode" computedAddress, #_"ValueNode[]" arguments, #_"StampPair" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (let [
            #_"IndirectCallTargetNode" this (LoweredCallTargetNode'new-7 c, arguments, returnStamp, signature, target, callType, invokeKind)
            this (assoc this :computedAddress computedAddress)
        ]
            this
        )
    )

    #_unused
    (§ override #_"String" IndirectCallTargetNode''targetName-1 [#_"IndirectCallTargetNode" this]
        (if (some? (CallTargetNode''targetMethod-1 this))
            (#_"ResolvedJavaMethod" .format (CallTargetNode''targetMethod-1 this), "Indirect#%h.\n")
            "[unknown]"
        )
    )
)

;;;
 ; The InvokeNode represents all kinds of method calls.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns InvokeNode (§ extends AbstractMemoryCheckpoint) (§ implements StateSplit, Lowerable, DeoptDuring, LIRLowerable, Single, UncheckedInterfaceProvider)
    (§ def #_"NodeClass<InvokeNode>" InvokeNode'TYPE (NodeClass'create-1 InvokeNode))

    ; @Input(InputType'Extension)
    (§ mutable #_"CallTargetNode" :callTarget nil)
    (§ final #_"int" :bci 0)

    ; @OptionalInput
    (§ mutable #_"ValueNode" :classInit nil)
    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateDuring nil)

    (§ mutable #_"boolean" :useForInlining true)

    (§ defn #_"InvokeNode" InvokeNode'new-2 [#_"CallTargetNode" callTarget, #_"int" bci]
        (InvokeNode'new-3 callTarget, bci, (:trustedStamp (CallTargetNode''returnStamp-1 callTarget)))
    )

    (§ defn #_"InvokeNode" InvokeNode'new-3 [#_"CallTargetNode" callTarget, #_"int" bci, #_"Stamp" stamp]
        (let [
            #_"InvokeNode" this (AbstractMemoryCheckpoint'new-2 InvokeNode'TYPE, stamp)
            this (assoc this :callTarget callTarget)
            this (assoc this :bci bci)
        ]
            this
        )
    )

    #_unused
    (§ method! #_"ResolvedJavaMethod" InvokeNode''getTargetMethod-1 [#_"InvokeNode" this]
        (when (some? (:callTarget this)) (CallTargetNode''targetMethod-1 (:callTarget this)))
    )

    ;;;
     ; Returns the method from which this invoke is executed.
     ; This is the caller method and in the case of inlining may be different from the method
     ; of the graph this node is in.
     ;
     ; @return the method from which this invoke is executed
     ;;
    (§ method! #_"ResolvedJavaMethod" InvokeNode''getContextMethod-1 [#_"InvokeNode" this]
        (FrameState''getMethod-1 (or (AbstractStateSplit''stateAfter-1 this) (InvokeNode''stateDuring-1 this)))
    )

    ;;;
     ; Returns the type from which this invoke is executed.
     ; This is the declaring type of the caller method.
     ;
     ; @return the type from which this invoke is executed
     ;;
    (§ method! #_"ResolvedJavaType" InvokeNode''getContextType-1 [#_"InvokeNode" this]
        (let [
            #_"ResolvedJavaMethod" contextMethod (InvokeNode''getContextMethod-1 this)
        ]
            (when (some? contextMethod)
                (#_"ResolvedJavaMethod" .getDeclaringClass contextMethod)
            )
        )
    )

    #_unused
    (§ override! #_"void" InvokeNode''computeStateDuring-2 [#_"InvokeNode" this, #_"FrameState" stateAfter]
        (InvokeNode''setStateDuring-2 this, (FrameState''duplicateModifiedDuringCall-3 stateAfter, (:bci this), (ValueNode''getStackKind-1 this)))
        nil
    )

    (§ method! #_"ValueNode" InvokeNode''getReceiver-1 [#_"InvokeNode" this]
        (nth (CallTargetNode''arguments-1 (:callTarget this)) 0)
    )

    (§ method! #_"ResolvedJavaType" InvokeNode''getReceiverType-1 [#_"InvokeNode" this]
        (or (StampTool'typeOrNull-1 (:stamp (InvokeNode''getReceiver-1 this)))
            (#_"ResolvedJavaMethod" .getDeclaringClass (CallTargetNode''targetMethod-1 (:callTarget this)))
        )
    )

    (§ method! #_"InvokeKind" InvokeNode''getInvokeKind-1 [#_"InvokeNode" this]
        (CallTargetNode''invokeKind-1 (:callTarget this))
    )


    #_unused
    (§ override! #_"void" InvokeNode''afterClone-2 [#_"InvokeNode" this, #_"Node" other]
        nil
    )

    #_unused
    (§ method! #_"InvokeNode" InvokeNode''setCallTarget-2 [#_"InvokeNode" this, #_"CallTargetNode" callTarget]
        (Node''updateUsages-3 this, (:callTarget this), callTarget)
        (assoc this :callTarget callTarget)
    )

    (§ method! #_"InvokeNode" InvokeNode''setUseForInlining-2 [#_"InvokeNode" this, #_"boolean" value]
        (assoc this :useForInlining value)
    )

    #_unused
    (§ override! #_"boolean" InvokeNode''isAllowedUsageType-2 [#_"InvokeNode" this, #_"InputType" type]
        (or (Node''isAllowedUsageType-2 (§ super ), type)
            (and (not (= (ValueNode''getStackKind-1 this) JavaKind/Void))
                (instance? MethodCallTargetNode (:callTarget this))
                (some? (#_"ResolvedJavaMethod" .getAnnotation (CallTargetNode''targetMethod-1 (:callTarget this)), NodeIntrinsic))
            )
        )
    )

    #_unused
    (§ override! #_"LocationIdentity" InvokeNode''getLocationIdentity-1 [#_"InvokeNode" this]
        (LocationIdentity/any)
    )

    (§ override! #_"void" InvokeNode''lower-2 [#_"InvokeNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerInvoke-3 this, lowerer, (:graph this))
        nil
    )

    #_unused
    (§ override! #_"void" InvokeNode''generate-2 [#_"InvokeNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''emitInvoke-2 builder, this)
        nil
    )

    (§ method! #_"void" InvokeNode''intrinsify-2 [#_"InvokeNode" this, #_"Node" node]
        (let [
            #_"CallTargetNode" call (:callTarget this)
            #_"FrameState" currentStateAfter (AbstractStateSplit''stateAfter-1 this)
        ]
            (when (instance? StateSplit node)
                (StateSplit''setStateAfter-2 node, currentStateAfter)
            )
            (when (instance? ForeignCallNode node)
                (§ ass! node (ForeignCallNode''setBci-2 node, (:bci this)))
            )
            (condp instance? node
                FixedWithNextNode
                    (§ ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, node))
                ControlSinkNode
                    (do
                        (Node''replaceAtPredecessor-2 this, node)
                        (§ ass! this (Node''replaceAtUsages-2 this, nil))
                        (GraphUtil'killCFG-1 this)
                        (§ return )
                    )
                #_else
                    (§ ass! (:graph this) (Graph''replaceFixed-3 (:graph this), this, node))
            )
            (GraphUtil'killWithUnusedFloatingInputs-1 call)
            (when (Node''hasNoUsages-1 currentStateAfter)
                (GraphUtil'killWithUnusedFloatingInputs-1 currentStateAfter)
            )
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" InvokeNode''canDeoptimize-1 [#_"InvokeNode" this]
        true
    )

    (§ override! #_"FrameState" InvokeNode''stateDuring-1 [#_"InvokeNode" this]
        (:stateDuring this)
    )

    (§ override! #_"void" InvokeNode''setStateDuring-2 [#_"InvokeNode" this, #_"FrameState" stateDuring]
        (Node''updateUsages-3 this, (:stateDuring this), stateDuring)
        (§ ass! this (assoc this :stateDuring stateDuring))
        nil
    )

    #_unused
    (§ override! #_"Stamp" InvokeNode''uncheckedStamp-1 [#_"InvokeNode" this]
        (:uncheckedStamp (CallTargetNode''returnStamp-1 (:callTarget this)))
    )

    (§ method! #_"InvokeNode" InvokeNode''setClassInit-2 [#_"InvokeNode" this, #_"ValueNode" classInit]
        (let [
            this (assoc this :classInit classInit)
        ]
            (Node''updateUsages-3 this, nil, classInit)
            this
        )
    )
)

;;;
 ; Low-level atomic compare-and-swap operation.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Value, InputType.Memory"
(class-ns AbstractCompareAndSwapNode (§ extends FixedAccessNode) (§ implements StateSplit, LIRLowerableAccess, Single)
    (§ def #_"NodeClass<AbstractCompareAndSwapNode>" AbstractCompareAndSwapNode'TYPE (NodeClass'create-1 AbstractCompareAndSwapNode))

    ; @Input
    (§ mutable #_"ValueNode" :expectedValue nil)
    ; @Input
    (§ mutable #_"ValueNode" :newValue nil)
    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)

    #_unused
    (§ override #_"FrameState" AbstractCompareAndSwapNode''stateAfter-1 [#_"AbstractCompareAndSwapNode" this]
        (:stateAfter this)
    )

    (§ override #_"void" AbstractCompareAndSwapNode''setStateAfter-2 [#_"AbstractCompareAndSwapNode" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    #_unused
    (§ override #_"boolean" AbstractCompareAndSwapNode''hasSideEffect-1 [#_"AbstractCompareAndSwapNode" this]
        true
    )

    (§ method #_"ValueNode" AbstractCompareAndSwapNode''getNewValue-1 [#_"AbstractCompareAndSwapNode" this]
        (:newValue this)
    )

    (§ defn #_"AbstractCompareAndSwapNode" AbstractCompareAndSwapNode'new-7 [#_"NodeClass<? extends AbstractCompareAndSwapNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"BarrierType" barrierType, #_"Stamp" stamp]
        (let [
            #_"AbstractCompareAndSwapNode" this (FixedAccessNode'new-5 c, address, location, stamp, barrierType)
            this (assoc this :expectedValue expectedValue)
            this (assoc this :newValue newValue)
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" AbstractCompareAndSwapNode''canNullCheck-1 [#_"AbstractCompareAndSwapNode" this]
        false
    )

    #_unused
    (§ override #_"Stamp" AbstractCompareAndSwapNode''getAccessStamp-1 [#_"AbstractCompareAndSwapNode" this]
        (Stamp''unrestricted-1 (Stamp''meet-2 (:stamp (:expectedValue this)), (:stamp (:newValue this))))
    )
)

;;;
 ; The AbstractNewArrayNode is used for all 1-dimensional array allocations.
 ;;
(class-ns AbstractNewArrayNode (§ extends AbstractNewObjectNode) (§ implements ArrayLengthProvider)
    (§ def #_"NodeClass<AbstractNewArrayNode>" AbstractNewArrayNode'TYPE (NodeClass'create-1 AbstractNewArrayNode))

    ; @Input
    (§ mutable #_"ValueNode" :length nil)

    (§ override #_"ValueNode" ArrayLengthProvider''length-1 [#_"AbstractNewArrayNode" this]
        (:length this)
    )

    (§ defn #_"AbstractNewArrayNode" AbstractNewArrayNode'new-5 [#_"NodeClass<? extends AbstractNewArrayNode>" c, #_"Stamp" stamp, #_"ValueNode" length, #_"boolean" fillContents, #_"FrameState" stateBefore]
        (let [
            #_"AbstractNewArrayNode" this (AbstractNewObjectNode'new-4 c, stamp, fillContents, stateBefore)
            this (assoc this :length length)
        ]
            this
        )
    )

    ;;;
     ; The list of node which produce input for this instruction.
     ;;
    #_unused
    (§ method #_"ValueNode" AbstractNewArrayNode''dimension-2 [#_"AbstractNewArrayNode" this, #_"int" index]
        (AbstractNewObjectNode''length-1 this)
    )

    ;;;
     ; The rank of the array allocated by this node, i.e. how many array dimensions.
     ;;
    #_unused
    (§ method #_"int" AbstractNewArrayNode''dimensionCount-1 [#_"AbstractNewArrayNode" this]
        1
    )
)

;;;
 ; The AbstractNewObjectNode is the base class for the new instance and new array nodes.
 ;;
(class-ns AbstractNewObjectNode (§ extends DeoptimizingFixedWithNextNode) (§ implements Lowerable)
    (§ def #_"NodeClass<AbstractNewObjectNode>" AbstractNewObjectNode'TYPE (NodeClass'create-1 AbstractNewObjectNode))

    ;;;
     ; {@code true} if the object's contents should be initialized to zero/nil
     ;;
    (§ final #_"boolean" :fillContents false)

    (§ defn #_"AbstractNewObjectNode" AbstractNewObjectNode'new-4 [#_"NodeClass<? extends AbstractNewObjectNode>" c, #_"Stamp" stamp, #_"boolean" fillContents, #_"FrameState" stateBefore]
        (let [
            #_"AbstractNewObjectNode" this (DeoptimizingFixedWithNextNode'new-3 c, stamp, stateBefore)
            this (assoc this :fillContents fillContents)
        ]
            this
        )
    )

    (§ override #_"void" AbstractNewObjectNode''lower-2 [#_"AbstractNewObjectNode" this, #_"LoweringTool" lowerer]
        (condp instance? this
            NewInstanceNode
                (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
                    (NewObjectTemplates''lower-3 Lowerer'newObjectSnippets, this, lowerer)
                )
            DynamicNewInstanceNode
                (do
                    (when (nil? (:classClass this))
                        (let [
                            #_"JavaConstant" classClassMirror (#_"HotSpotConstantReflectionProvider" .forObject HotSpot'constantReflection, Class)
                            #_"ConstantNode" classClass (ConstantNode'forConstant-2 classClassMirror, (:graph this))
                        ]
                            (§ ass! this (DynamicNewInstanceNode''setClassClass-2 this, classClass))
                        )
                    )
                    (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
                        (NewObjectTemplates''lower-3 Lowerer'newObjectSnippets, this, lowerer)
                    )
                )
            NewArrayNode
                (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
                    (NewObjectTemplates''lower-3 Lowerer'newObjectSnippets, this, lowerer)
                )
            DynamicNewArrayNode
                (do
                    (when (nil? (:voidClass this))
                        (let [
                            #_"JavaConstant" voidClassMirror (#_"HotSpotConstantReflectionProvider" .forObject HotSpot'constantReflection, void'class)
                            #_"ConstantNode" voidClass (ConstantNode'forConstant-2 voidClassMirror, (:graph this))
                        ]
                            (§ ass! this (DynamicNewArrayNode''setVoidClass-2 this, voidClass))
                        )
                    )
                    (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
                        (NewObjectTemplates''lower-3 Lowerer'newObjectSnippets, this, lowerer)
                    )
                )
        )
        nil
    )

    #_unused
    (§ override #_"boolean" AbstractNewObjectNode''canDeoptimize-1 [#_"AbstractNewObjectNode" this]
        true
    )
)

;;;
 ; This the base class of all array operations.
 ;;
(class-ns AccessArrayNode (§ extends FixedWithNextNode)
    (§ def #_"NodeClass<AccessArrayNode>" AccessArrayNode'TYPE (NodeClass'create-1 AccessArrayNode))

    ; @Input
    (§ mutable #_"ValueNode" :array nil)

    (§ method #_"ValueNode" AccessArrayNode''array-1 [#_"AccessArrayNode" this]
        (:array this)
    )

    ;;;
     ; Creates a new AccessArrayNode.
     ;
     ; @param array the instruction that produces the array object value
     ;;
    (§ defn #_"AccessArrayNode" AccessArrayNode'new-3 [#_"NodeClass<? extends AccessArrayNode>" c, #_"Stamp" stamp, #_"ValueNode" array]
        (let [
            #_"AccessArrayNode" this (FixedWithNextNode'new-2 c, stamp)
            this (assoc this :array array)
        ]
            this
        )
    )

    #_unused
    (§ method! #_"AccessArrayNode" AccessArrayNode''setArray-2 [#_"AccessArrayNode" this, #_"ValueNode" array]
        (Node''updateUsages-3 this, (:array this), array)
        (assoc this :array array)
    )
)

;;;
 ; The base class of all instructions that access fields.
 ;;
(class-ns AccessFieldNode (§ extends FixedWithNextNode) (§ implements Lowerable)
    (§ def #_"NodeClass<AccessFieldNode>" AccessFieldNode'TYPE (NodeClass'create-1 AccessFieldNode))

    ; @OptionalInput
    (§ mutable #_"ValueNode" :object nil)

    (§ final #_"ResolvedJavaField" :field nil)

    ;;;
     ; Constructs a new access field object.
     ;
     ; @param object the instruction producing the receiver object
     ; @param field the compiler interface representation of the field
     ;;
    (§ defn #_"AccessFieldNode" AccessFieldNode'new-4 [#_"NodeClass<? extends AccessFieldNode>" c, #_"Stamp" stamp, #_"ValueNode" object, #_"ResolvedJavaField" field]
        (let [
            #_"AccessFieldNode" this (FixedWithNextNode'new-2 c, stamp)
            this (assoc this :object object)
            this (assoc this :field field)
        ]
            this
        )
    )

    ;;;
     ; Gets the compiler interface field for this field access.
     ;
     ; @return the compiler interface field for this field access
     ;;
    (§ method #_"ResolvedJavaField" AccessFieldNode''field-1 [#_"AccessFieldNode" this]
        (:field this)
    )

    ;;;
     ; Checks whether this field access is an access to a static field.
     ;
     ; @return true if this field access is to a static field
     ;;
    (§ method #_"boolean" AccessFieldNode''isStatic-1 [#_"AccessFieldNode" this]
        (#_"ResolvedJavaField" .isStatic (:field this))
    )

    ;;;
     ; Checks whether this field is declared volatile.
     ;
     ; @return true if the field is resolved and declared volatile
     ;;
    (§ method! #_"boolean" AccessFieldNode''isVolatile-1 [#_"AccessFieldNode" this]
        (#_"ResolvedJavaField" .isVolatile (:field this))
    )

    #_unused
    (§ override #_"void" AccessFieldNode''lower-2 [#_"AccessFieldNode" this, #_"LoweringTool" lowerer]
        (condp instance? this
            LoadFieldNode  (Lowerer'lowerLoadFieldNode-2 this, lowerer)
            StoreFieldNode (Lowerer'lowerStoreFieldNode-2 this, lowerer)
        )
        nil
    )
)

;;;
 ; The AccessIndexedNode class is the base class of instructions that read or write elements
 ; of an array.
 ;;
(class-ns AccessIndexedNode (§ extends AccessArrayNode) (§ implements Lowerable)
    (§ def #_"NodeClass<AccessIndexedNode>" AccessIndexedNode'TYPE (NodeClass'create-1 AccessIndexedNode))

    ; @Input
    (§ mutable #_"ValueNode" :index nil)
    ;;;
     ; The element type of the array.
     ;;
    (§ final #_"JavaKind" :elementKind nil)

    (§ method #_"ValueNode" AccessIndexedNode''index-1 [#_"AccessIndexedNode" this]
        (:index this)
    )

    ;;;
     ; Create an new AccessIndexedNode.
     ;
     ; @param stamp the result kind of the access
     ; @param array the instruction producing the array
     ; @param index the instruction producing the index
     ; @param elementKind the kind of the elements of the array
     ;;
    (§ defn #_"AccessIndexedNode" AccessIndexedNode'new-5 [#_"NodeClass<? extends AccessIndexedNode>" c, #_"Stamp" stamp, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (let [
            #_"AccessIndexedNode" this (AccessArrayNode'new-3 c, stamp, array)
            this (assoc this :index index)
            this (assoc this :elementKind elementKind)
        ]
            this
        )
    )

    #_unused
    (§ override #_"void" AccessIndexedNode''lower-2 [#_"AccessIndexedNode" this, #_"LoweringTool" lowerer]
        (condp instance? this
            LoadIndexedNode  (Lowerer'lowerLoadIndexedNode-2 this, lowerer)
            StoreIndexedNode (Lowerer'lowerStoreIndexedNode-2 this, lowerer)
        )
        nil
    )
)

;;;
 ; The AccessMonitorNode is the base class of both monitor acquisition and release.
 ;
 ; The Java bytecode specification allows non-balanced locking. Graal does not handle such cases.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(class-ns AccessMonitorNode (§ extends AbstractMemoryCheckpoint) (§ implements MemoryCheckpoint, DeoptBefore, DeoptAfter)
    (§ def #_"NodeClass<AccessMonitorNode>" AccessMonitorNode'TYPE (NodeClass'create-1 AccessMonitorNode))

    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateBefore nil)
    ; @Input
    (§ mutable #_"ValueNode" :object nil)
    ; @Input(InputType'Association)
    (§ mutable #_"MonitorIdNode" :monitorId nil)

    #_unused
    (§ override #_"boolean" AccessMonitorNode''canDeoptimize-1 [#_"AccessMonitorNode" this]
        true
    )

    (§ override #_"FrameState" AccessMonitorNode''stateBefore-1 [#_"AccessMonitorNode" this]
        (:stateBefore this)
    )

    (§ override #_"void" AccessMonitorNode''setStateBefore-2 [#_"AccessMonitorNode" this, #_"FrameState" f]
        (Node''updateUsages-3 this, (:stateBefore this), f)
        (§ ass! this (assoc this :stateBefore f))
        nil
    )

    #_unused
    (§ method #_"void" AccessMonitorNode''setObject-2 [#_"AccessMonitorNode" this, #_"ValueNode" lockedObject]
        (Node''updateUsages-3 this, (:object this), lockedObject)
        (§ ass! this (assoc this :object lockedObject))
        nil
    )

    ;;;
     ; Creates a new AccessMonitor instruction.
     ;
     ; @param object the instruction producing the object
     ;;
    (§ defn #_"AccessMonitorNode" AccessMonitorNode'new-3 [#_"NodeClass<? extends AccessMonitorNode>" c, #_"ValueNode" object, #_"MonitorIdNode" monitorId]
        (let [
            #_"AccessMonitorNode" this (AbstractMemoryCheckpoint'new-2 c, (StampFactory'forVoid-0))
            this (assoc this :object object)
            this (assoc this :monitorId monitorId)
        ]
            this
        )
    )
)

;;;
 ; The ArrayLength instruction gets the length of an array.
 ;;
(final-ns ArrayLengthNode (§ extends FixedWithNextNode) (§ implements Unary #_"<ValueNode>", Lowerable, Virtualizable)
    (§ def #_"NodeClass<ArrayLengthNode>" ArrayLengthNode'TYPE (NodeClass'create-1 ArrayLengthNode))

    ; @Input
    (§ mutable #_"ValueNode" :array nil)

    #_unused
    (§ override! #_"ValueNode" ArrayLengthNode''getValue-1 [#_"ArrayLengthNode" this]
        (:array this)
    )

    (§ defn #_"ArrayLengthNode" ArrayLengthNode'new-1 [#_"ValueNode" array]
        (let [
            #_"ArrayLengthNode" this (FixedWithNextNode'new-2 ArrayLengthNode'TYPE, StampFactory'nonNegativeInt)
            this (assoc this :array array)
        ]
            this
        )
    )

    (§ defn #_"ValueNode" ArrayLengthNode'create-1 [#_"ValueNode" value]
        (when-not (instance? NewArrayNode value) => (AbstractNewArrayNode''length-1 value)
            (or (ArrayLengthNode'readArrayLengthConstant-1 value)
                (ArrayLengthNode'new-1 value)
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" ArrayLengthNode''canonical-3 [#_"ArrayLengthNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (or (ArrayLengthNode'readArrayLength-1 value)
            this
        )
    )

    ;;;
     ; Replicate the ValueProxyNodes from {@code originalValue} onto {@code value}.
     ;
     ; @param originalValue a possibly proxied value
     ; @param value a value needing proxies
     ; @return proxies wrapping {@code value}
     ;;
    (§ defn- #_"ValueNode" ArrayLengthNode'reproxyValue-2 [#_"ValueNode" originalValue, #_"ValueNode" value]
        (if (instance? ConstantNode value)
            value ;; no proxy needed
            (condp instance? originalValue
                ValueProxyNode
                    (ValueProxyNode'new-2 (ArrayLengthNode'reproxyValue-2 (ValueProxyNode''getOriginalNode-1 originalValue), value), (:loopExit originalValue))
                ValueProxy
                    (ArrayLengthNode'reproxyValue-2 (Proxy''getOriginalNode-1 originalValue), value)
                value
            )
        )
    )

    ;;;
     ; Gets the length of an array if possible.
     ;
     ; @return a node representing the length of {@code array} or nil if it is not available
     ;;
    (§ defn #_"ValueNode" ArrayLengthNode'readArrayLength-1 [#_"ValueNode" originalArray]
        (let [
            #_"ValueNode" length (GraphUtil'arrayLength-1 originalArray)
        ]
            (if (some? length)
                ;; ensure that any proxies on the original value end up on the length value
                (ArrayLengthNode'reproxyValue-2 originalArray, length)
                (ArrayLengthNode'readArrayLengthConstant-1 originalArray)
            )
        )
    )

    (§ defn- #_"ValueNode" ArrayLengthNode'readArrayLengthConstant-1 [#_"ValueNode" originalArray]
        (let [
            #_"ValueNode" array (GraphUtil'unproxify-1 originalArray)
        ]
            (when (and (some? HotSpot'constantReflection) (instance? ConstantNode array) (not (ValueNode''isNullConstant-1 array)))
                (let [
                    #_"JavaConstant" constantValue (ValueNode''asJavaConstant-1 array)
                ]
                    (when (and (some? constantValue) (#_"JavaConstant" .isNonNull constantValue))
                        (let [
                            #_"Integer" constantLength (#_"ConstantReflectionProvider" .readArrayLength HotSpot'constantReflection, constantValue)
                        ]
                            (when (some? constantLength)
                                (ConstantNode'forInt-1 constantLength)
                            )
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" ArrayLengthNode''lower-2 [#_"ArrayLengthNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerArrayLengthNode-2 this, lowerer)
        nil
    )

    ; @NodeIntrinsic
    #_unused
    (§ native #_"int" ArrayLengthNode'arrayLength-1 [#_"Object" array])

    #_unused
    (§ override! #_"void" ArrayLengthNode''virtualize-2 [#_"ArrayLengthNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" array (VirtualizerTool''getAlias-2 tool, (:array this))
        ]
            (when (instance? VirtualArrayNode array)
                (VirtualizerTool''replaceWithValue-2 tool, (ConstantNode'forInt-2 (VirtualArrayNode''entryCount-1 array), (:graph this)))
            )
        )
        nil
    )
)

;;;
 ; Represents an atomic read-and-add operation like
 ; {@link sun.misc.Unsafe#getAndAddInt(Object, long, int)}.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns AtomicReadAndAddNode (§ extends AbstractMemoryCheckpoint) (§ implements LIRLowerable, Single)
    (§ def #_"NodeClass<AtomicReadAndAddNode>" AtomicReadAndAddNode'TYPE (NodeClass'create-1 AtomicReadAndAddNode))

    ; @Input(InputType'Association)
    (§ mutable #_"AddressNode" :address nil)
    ; @Input
    (§ mutable #_"ValueNode" :delta nil)

    (§ final #_"LocationIdentity" :locationIdentity nil)

    #_unused
    (§ defn #_"AtomicReadAndAddNode" AtomicReadAndAddNode'new-3 [#_"AddressNode" address, #_"ValueNode" delta, #_"LocationIdentity" locationIdentity]
        (let [
            #_"AtomicReadAndAddNode" this (AbstractMemoryCheckpoint'new-2 AtomicReadAndAddNode'TYPE, (StampFactory'forKind-1 (ValueNode''getStackKind-1 delta)))
            this (assoc this :address address)
            this (assoc this :delta delta)
            this (assoc this :locationIdentity locationIdentity)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"LocationIdentity" AtomicReadAndAddNode''getLocationIdentity-1 [#_"AtomicReadAndAddNode" this]
        (:locationIdentity this)
    )

    #_unused
    (§ override! #_"void" AtomicReadAndAddNode''generate-2 [#_"AtomicReadAndAddNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitAtomicReadAndAdd-3 (:gen builder), (LIRBuilder''operand-2 builder, (:address this)), (LIRBuilder''operand-2 builder, (:delta this))))
        nil
    )
)

;;;
 ; Represents an atomic read-and-write operation like
 ; {@link sun.misc.Unsafe#getAndSetInt(Object, long, int)}.
 ;;
(final-ns AtomicReadAndWriteNode (§ extends AbstractMemoryCheckpoint) (§ implements Lowerable, Single)
    (§ def #_"NodeClass<AtomicReadAndWriteNode>" AtomicReadAndWriteNode'TYPE (NodeClass'create-1 AtomicReadAndWriteNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)
    ; @Input
    (§ mutable #_"ValueNode" :offset nil)
    ; @Input
    (§ mutable #_"ValueNode" :newValue nil)

    (§ final #_"JavaKind" :valueKind nil)
    (§ final #_"LocationIdentity" :locationIdentity nil)

    #_unused
    (§ defn #_"AtomicReadAndWriteNode" AtomicReadAndWriteNode'new-5 [#_"ValueNode" object, #_"ValueNode" offset, #_"ValueNode" newValue, #_"JavaKind" valueKind, #_"LocationIdentity" locationIdentity]
        (let [
            #_"AtomicReadAndWriteNode" this (AbstractMemoryCheckpoint'new-2 AtomicReadAndWriteNode'TYPE, (StampFactory'forKind-1 (ValueNode''getStackKind-1 newValue)))
            this (assoc this :object object)
            this (assoc this :offset offset)
            this (assoc this :newValue newValue)
            this (assoc this :valueKind valueKind)
            this (assoc this :locationIdentity locationIdentity)
        ]
            this
        )
    )

    (§ override! #_"LocationIdentity" AtomicReadAndWriteNode''getLocationIdentity-1 [#_"AtomicReadAndWriteNode" this]
        (:locationIdentity this)
    )

    #_unused
    (§ override! #_"void" AtomicReadAndWriteNode''lower-2 [#_"AtomicReadAndWriteNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerAtomicReadAndWriteNode-1 this)
        nil
    )
)

;;;
 ; The ClassIsAssignableFromNode represents a type check against Class instead of
 ; against instances. This is used, for instance, to intrinsify Class#isAssignableFrom(Class).
 ;;
(final-ns ClassIsAssignableFromNode (§ extends BinaryOpLogicNode) (§ implements Binary #_"<ValueNode>", Lowerable)
    (§ def #_"NodeClass<ClassIsAssignableFromNode>" ClassIsAssignableFromNode'TYPE (NodeClass'create-1 ClassIsAssignableFromNode))

    #_unused
    (§ defn #_"ClassIsAssignableFromNode" ClassIsAssignableFromNode'new-2 [#_"ValueNode" thisClass, #_"ValueNode" otherClass]
        (BinaryOpLogicNode'new-3 ClassIsAssignableFromNode'TYPE, thisClass, otherClass)
    )

    #_unused
    (§ override! #_"Node" ClassIsAssignableFromNode''canonical-4 [#_"ClassIsAssignableFromNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (when (and (instance? ConstantNode forX) (instance? ConstantNode forY)) => this
            (let [
                #_"ResolvedJavaType" thisType (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (ValueNode''asJavaConstant-1 forX))
                #_"ResolvedJavaType" otherType (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (ValueNode''asJavaConstant-1 forY))
            ]
                (when (and (some? thisType) (some? otherType)) => this
                    (LogicConstantNode'forBoolean-1 (#_"ResolvedJavaType" .isAssignableFrom thisType, otherType))
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" ClassIsAssignableFromNode''lower-2 [#_"ClassIsAssignableFromNode" this, #_"LoweringTool" lowerer]
        (when (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph this)))
            (InstanceOfSnippetsTemplates''lower-3 Lowerer'instanceofSnippets, this, lowerer)
        )
        nil
    )

    #_unused
    (§ override! #_"Stamp" ClassIsAssignableFromNode''getSucceedingStampForX-4 [#_"ClassIsAssignableFromNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        nil
    )

    #_unused
    (§ override! #_"Stamp" ClassIsAssignableFromNode''getSucceedingStampForY-4 [#_"ClassIsAssignableFromNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        nil
    )

    #_unused
    (§ override! #_"TriState" ClassIsAssignableFromNode''tryFold-3 [#_"ClassIsAssignableFromNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
        TriState/UNKNOWN
    )
)

;;;
 ; The DynamicNewArrayNode is used for allocation of arrays when the type is not a
 ; compile-time constant.
 ;;
(final-ns DynamicNewArrayNode (§ extends AbstractNewArrayNode) (§ implements Canonicalizable)
    (§ def #_"NodeClass<DynamicNewArrayNode>" DynamicNewArrayNode'TYPE (NodeClass'create-1 DynamicNewArrayNode))

    ; @Input
    (§ mutable #_"ValueNode" :elementType nil)

    ;;;
     ; Class pointer to void.class needs to be exposed earlier than this node is lowered so that it
     ; can be replaced by the AOT machinery. If it's not needed for lowering this input can be ignored.
     ;;
    ; @OptionalInput
    (§ mutable #_"ValueNode" :voidClass nil)

    ;;;
     ; A non-nil value indicating the worst case element type. Mainly useful for distinguishing
     ; Object arrays from primitive arrays.
     ;;
    (§ final #_"JavaKind" :knownElementKind nil)

    #_unused
    (§ defn #_"DynamicNewArrayNode" DynamicNewArrayNode'new-3 [#_"ValueNode" elementType, #_"ValueNode" length, #_"boolean" fillContents]
        (DynamicNewArrayNode'new-6 DynamicNewArrayNode'TYPE, elementType, length, fillContents, nil, nil)
    )

    #_unused
    (§ defn #_"DynamicNewArrayNode" DynamicNewArrayNode'new-4 [#_"ValueNode" elementType, #_"ValueNode" length, #_"boolean" fillContents, #_"JavaKind" knownElementKind]
        (DynamicNewArrayNode'new-6 DynamicNewArrayNode'TYPE, elementType, length, fillContents, knownElementKind, nil)
    )

    (§ defn- #_"Stamp" DynamicNewArrayNode'computeStamp-1 [#_"JavaKind" knownElementKind]
        (when (and (some? knownElementKind) (some? HotSpot'metaAccess)) => StampFactory'objectNonNullStamp
            (let [
                #_"ResolvedJavaType" arrayType (#_"ResolvedJavaType" .getArrayClass (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (if (= knownElementKind JavaKind/Object) Object (#_"JavaKind" .toJavaClass knownElementKind))))
            ]
                (StampFactory'objectNonNull-1 (TypeReference'create-1 arrayType))
            )
        )
    )

    (§ defn #_"DynamicNewArrayNode" DynamicNewArrayNode'new-6 [#_"NodeClass<? extends DynamicNewArrayNode>" c, #_"ValueNode" elementType, #_"ValueNode" length, #_"boolean" fillContents, #_"JavaKind" knownElementKind, #_"FrameState" stateBefore]
        (let [
            #_"DynamicNewArrayNode" this (AbstractNewArrayNode'new-5 c, (DynamicNewArrayNode'computeStamp-1 knownElementKind), length, fillContents, stateBefore)
            this (assoc this :elementType elementType)
            this (assoc this :knownElementKind knownElementKind)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Node" DynamicNewArrayNode''canonical-2 [#_"DynamicNewArrayNode" this, #_"CanonicalizerTool" tool]
        (when (instance? ConstantNode (:elementType this)) => this
            (let [
                #_"ResolvedJavaType" type (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (:value (:elementType this)))
            ]
                (when (and (some? type) (not (DynamicNewArrayNode'throwsIllegalArgumentException-1 type))) => this
                    (DynamicNewArrayNode''createNewArrayNode-2 this, type)
                )
            )
        )
    )

    ;;;
     ; Hook for subclasses to instantiate a subclass of NewArrayNode.
     ;;
    (§ method! #_"NewArrayNode" DynamicNewArrayNode''createNewArrayNode-2 [#_"DynamicNewArrayNode" this, #_"ResolvedJavaType" type]
        (NewArrayNode'new-4 type, (AbstractNewArrayNode''length-1 this), (:fillContents this), (DeoptimizingFixedWithNextNode''stateBefore-1 this))
    )

    (§ defn #_"boolean" DynamicNewArrayNode'throwsIllegalArgumentException-2 [#_"Class" elementType, #_"Class" voidClass]
        (= elementType voidClass)
    )

    (§ defn #_"boolean" DynamicNewArrayNode'throwsIllegalArgumentException-1 [#_"ResolvedJavaType" elementType]
        (= (#_"ResolvedJavaType" .getJavaKind elementType) JavaKind/Void)
    )

    ; @NodeIntrinsic
    (§ native- #_"Object" DynamicNewArrayNode'newArray-3 [#_"Class" componentType, #_"int" length, #_@ConstantNodeParameter #_"boolean" fillContents])

    #_unused
    (§ defn #_"Object" DynamicNewArrayNode'newArray-2 [#_"Class" componentType, #_"int" length]
        (DynamicNewArrayNode'newArray-3 componentType, length, true)
    )

    ; @NodeIntrinsic
    (§ native- #_"Object" DynamicNewArrayNode'newArray-4 [#_"Class" componentType, #_"int" length, #_@ConstantNodeParameter #_"boolean" fillContents, #_@ConstantNodeParameter #_"JavaKind" knownElementKind])

    (§ defn #_"Object" DynamicNewArrayNode'newArray-3 [#_"Class" componentType, #_"int" length, #_"JavaKind" knownElementKind]
        (DynamicNewArrayNode'newArray-4 componentType, length, true, knownElementKind)
    )

    #_unused
    (§ defn #_"Object" DynamicNewArrayNode'newUninitializedArray-3 [#_"Class" componentType, #_"int" length, #_"JavaKind" knownElementKind]
        (DynamicNewArrayNode'newArray-4 componentType, length, false, knownElementKind)
    )

    (§ method! #_"DynamicNewArrayNode" DynamicNewArrayNode''setVoidClass-2 [#_"DynamicNewArrayNode" this, #_"ValueNode" newVoidClass]
        (Node''updateUsages-3 this, (:voidClass this), newVoidClass)
        (assoc this :voidClass newVoidClass)
    )
)

(final-ns DynamicNewInstanceNode (§ extends AbstractNewObjectNode) (§ implements Canonicalizable)
    (§ def #_"NodeClass<DynamicNewInstanceNode>" DynamicNewInstanceNode'TYPE (NodeClass'create-1 DynamicNewInstanceNode))

    ; @Input
    (§ mutable #_"ValueNode" :class nil)

    ;;;
     ; Class pointer to class.class needs to be exposed earlier than this node is lowered so that it
     ; can be replaced by the AOT machinery. If it's not needed for lowering this input can be ignored.
     ;;
    ; @OptionalInput
    (§ mutable #_"ValueNode" :classClass nil)

    #_unused
    (§ defn #_"DynamicNewInstanceNode" DynamicNewInstanceNode'new-2 [#_"ValueNode" clazz, #_"boolean" fillContents]
        (DynamicNewInstanceNode'new-4 DynamicNewInstanceNode'TYPE, clazz, fillContents, nil)
    )

    (§ defn #_"DynamicNewInstanceNode" DynamicNewInstanceNode'new-4 [#_"NodeClass<? extends DynamicNewInstanceNode>" c, #_"ValueNode" clazz, #_"boolean" fillContents, #_"FrameState" stateBefore]
        (let [
            #_"DynamicNewInstanceNode" this (AbstractNewObjectNode'new-4 c, StampFactory'objectNonNullStamp, fillContents, stateBefore)
            this (assoc this :class clazz)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Node" DynamicNewInstanceNode''canonical-2 [#_"DynamicNewInstanceNode" this, #_"CanonicalizerTool" tool]
        (when (instance? ConstantNode (:class this)) => this
            (let [
                #_"ResolvedJavaType" type (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (:value (:class this)))
            ]
                (when (and (some? type) (#_"ResolvedJavaType" .isInitialized type) (not (DynamicNewInstanceNode'throwsInstantiationException-1 type))) => this
                    (DynamicNewInstanceNode''createNewInstanceNode-2 this, type)
                )
            )
        )
    )

    ;;;
     ; Hook for subclasses to instantiate a subclass of NewInstanceNode.
     ;;
    (§ method! #_"NewInstanceNode" DynamicNewInstanceNode''createNewInstanceNode-2 [#_"DynamicNewInstanceNode" this, #_"ResolvedJavaType" type]
        (NewInstanceNode'new-3 type, (:fillContents this), (DeoptimizingFixedWithNextNode''stateBefore-1 this))
    )

    (§ defn #_"boolean" DynamicNewInstanceNode'throwsInstantiationException-2 [#_"Class" type, #_"Class" classClass]
        (or (#_"Class" .isPrimitive type) (#_"Class" .isArray type) (#_"Class" .isInterface type) (Modifier/isAbstract (#_"Class" .getModifiers type)) (= type classClass))
    )

    (§ defn #_"boolean" DynamicNewInstanceNode'throwsInstantiationException-1 [#_"ResolvedJavaType" type]
        (or (#_"ResolvedJavaType" .isPrimitive type) (#_"ResolvedJavaType" .isArray type) (#_"ResolvedJavaType" .isInterface type) (Modifier/isAbstract (#_"ResolvedJavaType" .getModifiers type)) (= type (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Class)))
    )

    (§ method! #_"DynamicNewInstanceNode" DynamicNewInstanceNode''setClassClass-2 [#_"DynamicNewInstanceNode" this, #_"ValueNode" newClassClass]
        (Node''updateUsages-3 this, (:classClass this), newClassClass)
        (assoc this :classClass newClassClass)
    )
)

(final-ns FinalFieldBarrierNode (§ extends FixedWithNextNode) (§ implements Virtualizable, Lowerable)
    (§ def #_"NodeClass<FinalFieldBarrierNode>" FinalFieldBarrierNode'TYPE (NodeClass'create-1 FinalFieldBarrierNode))

    ; @OptionalInput
    (§ mutable #_"ValueNode" :value nil)

    (§ defn #_"FinalFieldBarrierNode" FinalFieldBarrierNode'new-1 [#_"ValueNode" value]
        (let [
            #_"FinalFieldBarrierNode" this (FixedWithNextNode'new-2 FinalFieldBarrierNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" FinalFieldBarrierNode''virtualize-2 [#_"FinalFieldBarrierNode" this, #_"VirtualizerTool" tool]
        (when (and (some? (:value this)) (instance? VirtualObjectNode (VirtualizerTool''getAlias-2 tool, (:value this))))
            (VirtualizerTool''delete-1 tool)
        )
        nil
    )

    #_unused
    (§ override! #_"void" FinalFieldBarrierNode''lower-2 [#_"FinalFieldBarrierNode" this, #_"LoweringTool" lowerer]
        (§ ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, (Graph''add-2 (:graph this), (MembarNode'new-1 (| MemoryBarriers/LOAD_STORE MemoryBarriers/STORE_STORE)))))
        nil
    )
)

;;;
 ; The InstanceOfDynamicNode represents a type check where the type being checked is not
 ; known at compile time. This is used, for instance, to intrinsify Class#isInstance(Object).
 ;;
(final-ns InstanceOfDynamicNode (§ extends BinaryOpLogicNode) (§ implements Binary #_"<ValueNode>", Lowerable)
    (§ def #_"NodeClass<InstanceOfDynamicNode>" InstanceOfDynamicNode'TYPE (NodeClass'create-1 InstanceOfDynamicNode))

    (§ final #_"boolean" :allow-nil? false)
    (§ final #_"boolean" :exact? false)

    (§ defn #_"LogicNode" InstanceOfDynamicNode'create-4 [#_"ValueNode" mirror, #_"ValueNode" object, #_"boolean" allow-nil?, #_"boolean" exact?]
        (or (InstanceOfDynamicNode'findSynonym-4 mirror, object, allow-nil?, exact?)
            (InstanceOfDynamicNode'new-4 mirror, object, allow-nil?, exact?)
        )
    )

    (§ defn #_"LogicNode" InstanceOfDynamicNode'create-3 [#_"ValueNode" mirror, #_"ValueNode" object, #_"boolean" allow-nil?]
        (InstanceOfDynamicNode'create-4 mirror, object, allow-nil?, false)
    )

    (§ defn #_"InstanceOfDynamicNode" InstanceOfDynamicNode'new-4 [#_"ValueNode" mirror, #_"ValueNode" object, #_"boolean" allow-nil?, #_"boolean" exact?]
        (let [
            #_"InstanceOfDynamicNode" this (BinaryOpLogicNode'new-3 InstanceOfDynamicNode'TYPE, mirror, object)
            this (assoc this :allow-nil? allow-nil?)
            this (assoc this :exact? exact?)
        ]
            this
        )
    )

    (§ method! #_"boolean" InstanceOfDynamicNode''isMirror-1 [#_"InstanceOfDynamicNode" this]
        (= (ValueNode''getStackKind-1 (:x this)) JavaKind/Object)
    )

    #_unused
    (§ method! #_"boolean" InstanceOfDynamicNode''isHub-1 [#_"InstanceOfDynamicNode" this]
        (not (InstanceOfDynamicNode''isMirror-1 this))
    )

    #_unused
    (§ override! #_"void" InstanceOfDynamicNode''lower-2 [#_"InstanceOfDynamicNode" this, #_"LoweringTool" lowerer]
        (if (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph this)))
            (InstanceOfSnippetsTemplates''lower-3 Lowerer'instanceofSnippets, this, lowerer)
            (do
                (when (= (Stamp''getStackKind-1 (:stamp (:x this))) JavaKind/Object)
                    (§ ass! this (InstanceOfDynamicNode''setMirror-2 this, (Graph''add-2 (:graph this), (ClassGetHubNode'new-1 (:x this)))))
                )
                (when (:allow-nil? this)
                    (let [
                        #_"LogicNode" newTypeCheck (Graph''addOrUniqueWithInputs-2 (:graph this), (InstanceOfDynamicNode'create-3 (:x this), (:y this), false))
                        #_"LogicNode" newNode (LogicNode'or-3 (Graph''add-2 (:graph this), (IsNullNode'create-1 (:y this))), newTypeCheck, GraalDirectives'UNLIKELY_PROBABILITY)
                    ]
                        (§ ass! this (Node''replaceAndDelete-2 this, newNode))
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"LogicNode" InstanceOfDynamicNode'findSynonym-4 [#_"ValueNode" forMirror, #_"ValueNode" forObject, #_"boolean" allow-nil?, #_"boolean" exact?]
        (when (instance? ConstantNode forMirror)
            (let [
                #_"ResolvedJavaType" t (#_"ConstantReflectionProvider" .asJavaType HotSpot'constantReflection, (:value forMirror))
            ]
                (when (some? t)
                    (if (#_"ResolvedJavaType" .isPrimitive t)
                        (if allow-nil?
                            (IsNullNode'create-1 forObject)
                            (LogicConstantNode'contradiction-0)
                        )
                        (let [
                            #_"TypeReference" type (if exact? (TypeReference'createExactTrusted-1 t) (TypeReference'createTrusted-1 t))
                        ]
                            (if allow-nil?
                                (InstanceOfNode'createAllowNull-2 type, forObject)
                                (InstanceOfNode'create-2 type, forObject)
                            )
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"LogicNode" InstanceOfDynamicNode''canonical-4 [#_"InstanceOfDynamicNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forMirror, #_"ValueNode" forObject]
        (or (InstanceOfDynamicNode'findSynonym-4 forMirror, forObject, (:allow-nil? this), (:exact? this))
            this
        )
    )

    (§ method! #_"InstanceOfDynamicNode" InstanceOfDynamicNode''setMirror-2 [#_"InstanceOfDynamicNode" this, #_"ValueNode" newObject]
        (Node''updateUsages-3 this, (:x this), newObject)
        (assoc this :x newObject)
    )

    #_unused
    (§ override! #_"Stamp" InstanceOfDynamicNode''getSucceedingStampForX-4 [#_"InstanceOfDynamicNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        nil
    )

    #_unused
    (§ override! #_"Stamp" InstanceOfDynamicNode''getSucceedingStampForY-4 [#_"InstanceOfDynamicNode" this, #_"boolean" negated?, #_"Stamp" xStamp, #_"Stamp" yStamp]
        nil
    )

    #_unused
    (§ override! #_"TriState" InstanceOfDynamicNode''tryFold-3 [#_"InstanceOfDynamicNode" this, #_"Stamp" xStamp, #_"Stamp" yStamp]
        TriState/UNKNOWN
    )
)

;;;
 ; The InstanceOfNode represents an instanceof test.
 ;;
(final-ns InstanceOfNode (§ extends UnaryOpLogicNode) (§ implements Lowerable, Virtualizable)
    (§ def #_"NodeClass<InstanceOfNode>" InstanceOfNode'TYPE (NodeClass'create-1 InstanceOfNode))

    (§ mutable #_"ObjectStamp" :checkedStamp nil)

    ; @OptionalInput(InputType'Anchor)
    (§ mutable #_"AnchoringNode" :anchor nil)

    (§ defn- #_"InstanceOfNode" InstanceOfNode'new-3 [#_"ObjectStamp" checkedStamp, #_"ValueNode" object, #_"AnchoringNode" anchor]
        (InstanceOfNode'new-4 InstanceOfNode'TYPE, checkedStamp, object, anchor)
    )

    (§ defn #_"InstanceOfNode" InstanceOfNode'new-4 [#_"NodeClass<? extends InstanceOfNode>" c, #_"ObjectStamp" checkedStamp, #_"ValueNode" object, #_"AnchoringNode" anchor]
        (let [
            #_"InstanceOfNode" this (UnaryOpLogicNode'new-2 c, object)
            this (assoc this :checkedStamp checkedStamp)
            this (assoc this :anchor anchor)
        ]
            this
        )
    )

    (§ defn #_"LogicNode" InstanceOfNode'createAllowNull-2 [#_"TypeReference" type, #_"ValueNode" object]
        (if (StampTool'isPointerNeverNull-1 (:stamp object))
            (InstanceOfNode'create-2 type, object)
            (InstanceOfNode'createHelper-3 (StampFactory'object-1 type), object, nil)
        )
    )

    (§ defn #_"LogicNode" InstanceOfNode'create-2 [#_"TypeReference" type, #_"ValueNode" object]
        (InstanceOfNode'create-3 type, object, nil)
    )

    (§ defn #_"LogicNode" InstanceOfNode'create-3 [#_"TypeReference" type, #_"ValueNode" object, #_"AnchoringNode" anchor]
        (InstanceOfNode'createHelper-3 (StampFactory'objectNonNull-1 type), object, anchor)
    )

    (§ defn #_"LogicNode" InstanceOfNode'createHelper-3 [#_"ObjectStamp" checkedStamp, #_"ValueNode" object, #_"AnchoringNode" anchor]
        (or (InstanceOfNode'findSynonym-2 checkedStamp, object) (InstanceOfNode'new-3 checkedStamp, object, anchor))
    )

    #_unused
    (§ override! #_"void" InstanceOfNode''lower-2 [#_"InstanceOfNode" this, #_"LoweringTool" lowerer]
        (if (GuardsStage'areDeoptsFixed-1 (:guardsStage (:graph this)))
            (InstanceOfSnippetsTemplates''lower-3 Lowerer'instanceofSnippets, this, lowerer)
            (when (InstanceOfNode''allowsNull-1 this)
                (let [
                    #_"ValueNode" object (UnaryOpLogicNode''getValue-1 this)
                    #_"LogicNode" newTypeCheck (Graph''addOrUniqueWithInputs-2 (:graph this), (InstanceOfNode'create-3 (InstanceOfNode''type-1 this), object, (:anchor this)))
                    #_"LogicNode" newNode (LogicNode'or-3 (Graph''add-2 (:graph this), (IsNullNode'create-1 object)), newTypeCheck, GraalDirectives'UNLIKELY_PROBABILITY)
                ]
                    (§ ass! this (Node''replaceAndDelete-2 this, newNode))
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"ValueNode" InstanceOfNode''canonical-3 [#_"InstanceOfNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (or (InstanceOfNode'findSynonym-2 (:checkedStamp this), value)
            this
        )
    )

    (§ defn #_"LogicNode" InstanceOfNode'findSynonym-2 [#_"ObjectStamp" checkedStamp, #_"ValueNode" object]
        (let [
            #_"ObjectStamp" inputStamp (:stamp object)
        ]
            (if (Stamp''isEmpty-1 (Stamp''join-2 checkedStamp, inputStamp))
                ;; The check can never succeed, the intersection of the two stamps is empty.
                (LogicConstantNode'contradiction-0)
                (let [
                    #_"ObjectStamp" meetStamp (Stamp''meet-2 checkedStamp, inputStamp)
                ]
                    (cond
                        ;; The check will always succeed, the union of the two stamps is equal to the checked stamp.
                        (= checkedStamp meetStamp)  (LogicConstantNode'tautology-0)
                        (:always-nil? checkedStamp) (IsNullNode'create-1 object)
                        (and (= (AbstractObjectStamp''type-1 checkedStamp) (AbstractObjectStamp''type-1 meetStamp))
                             (= (AbstractObjectStamp''isExactType-1 checkedStamp) (AbstractObjectStamp''isExactType-1 meetStamp))
                             (= (:always-nil? checkedStamp) (:always-nil? meetStamp))
                        )
                            ;; The only difference makes the nil-ness of the value => simplify the check.
                            (if (:never-nil? checkedStamp)
                                (LogicNegationNode'create-1 (IsNullNode'create-1 object))
                                (IsNullNode'create-1 object)
                            )
                    )
                )
            )
        )
    )

    ;;;
     ; Gets the type being tested.
     ;;
    (§ method! #_"TypeReference" InstanceOfNode''type-1 [#_"InstanceOfNode" this]
        (StampTool'typeReferenceOrNull-1 (:checkedStamp this))
    )

    #_unused
    (§ override! #_"void" InstanceOfNode''virtualize-2 [#_"InstanceOfNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"TriState" fold (InstanceOfNode''tryFold-2 this, (:stamp (VirtualizerTool''getAlias-2 tool, (UnaryOpLogicNode''getValue-1 this))))
        ]
            (when-not (= fold TriState/UNKNOWN)
                (VirtualizerTool''replaceWithValue-2 tool, (LogicConstantNode'forBoolean-2 (#_"TriState" .isTrue fold), (:graph this)))
            )
        )
        nil
    )

    #_unused
    (§ override! #_"Stamp" InstanceOfNode''getSucceedingStampForValue-2 [#_"InstanceOfNode" this, #_"boolean" negated?]
        (when-not negated? (:checkedStamp this))
    )

    (§ override! #_"TriState" InstanceOfNode''tryFold-2 [#_"InstanceOfNode" this, #_"Stamp" stamp]
        (when (instance? ObjectStamp stamp) => TriState/UNKNOWN
            (cond
                ;; The check can never succeed, the intersection of the two stamps is empty.
                (Stamp''isEmpty-1 (Stamp''join-2 (:checkedStamp this), stamp))       TriState/FALSE
                ;; The check will always succeed, the union of the two stamps is equal to the checked stamp.
                (= (:checkedStamp this) (Stamp''meet-2 (:checkedStamp this), stamp)) TriState/TRUE
                :else                                                                      TriState/UNKNOWN
            )
        )
    )

    (§ method! #_"boolean" InstanceOfNode''allowsNull-1 [#_"InstanceOfNode" this]
        (not (:never-nil? (:checkedStamp this)))
    )

    #_unused
    (§ method! #_"InstanceOfNode" InstanceOfNode''strengthenCheckedStamp-2 [#_"InstanceOfNode" this, #_"ObjectStamp" newCheckedStamp]
        (assoc this :checkedStamp newCheckedStamp)
    )
)

;;;
 ; The LoadFieldNode represents a read of a static or instance field.
 ;;
(final-ns LoadFieldNode (§ extends AccessFieldNode) (§ implements Unary #_"<ValueNode>", Virtualizable, UncheckedInterfaceProvider)
    (§ def #_"NodeClass<LoadFieldNode>" LoadFieldNode'TYPE (NodeClass'create-1 LoadFieldNode))

    (§ final #_"Stamp" :uncheckedStamp nil)

    (§ defn #_"LoadFieldNode" LoadFieldNode'new-3 [#_"StampPair" stamp, #_"ValueNode" object, #_"ResolvedJavaField" field]
        (let [
            #_"LoadFieldNode" this (AccessFieldNode'new-4 LoadFieldNode'TYPE, (:trustedStamp stamp), object, field)
            this (assoc this :uncheckedStamp (:uncheckedStamp stamp))
        ]
            this
        )
    )

    (§ defn #_"LoadFieldNode" LoadFieldNode'create-2 [#_"ValueNode" object, #_"ResolvedJavaField" field]
        (LoadFieldNode'new-3 (StampFactory'forDeclaredType-2 (#_"ResolvedJavaField" .getType field), false), object, field)
    )

    (§ defn #_"ValueNode" LoadFieldNode'create-4 [#_"ValueNode" object, #_"ResolvedJavaField" field, #_"boolean" canonicalizeReads, #_"boolean" allUsagesAvailable]
        (LoadFieldNode'canonical-6 nil, (StampFactory'forDeclaredType-2 (#_"ResolvedJavaField" .getType field), false), object, field, canonicalizeReads, allUsagesAvailable)
    )

    (§ defn #_"LoadFieldNode" LoadFieldNode'createOverrideStamp-3 [#_"StampPair" stamp, #_"ValueNode" object, #_"ResolvedJavaField" field]
        (LoadFieldNode'new-3 stamp, object, field)
    )

    (§ defn #_"ValueNode" LoadFieldNode'createOverrideStamp-5 [#_"StampPair" stamp, #_"ValueNode" object, #_"ResolvedJavaField" field, #_"boolean" canonicalizeReads, #_"boolean" allUsagesAvailable]
        (LoadFieldNode'canonical-6 nil, stamp, object, field, canonicalizeReads, allUsagesAvailable)
    )

    (§ override! #_"ValueNode" LoadFieldNode''getValue-1 [#_"LoadFieldNode" this]
        (:object this)
    )

    #_unused
    (§ override! #_"ValueNode" LoadFieldNode''canonical-3 [#_"LoadFieldNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forObject]
        (when-not (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this) (not (AccessFieldNode''isVolatile-1 this)) (or (AccessFieldNode''isStatic-1 this) (StampTool'isPointerNeverNull-1 (:stamp forObject))))
            (LoadFieldNode'canonical-6 this, (StampPair'new-2 (:stamp this), (:uncheckedStamp this)), forObject, (:field this), (CanonicalizerTool''canonicalizeReads-1 tool), (CanonicalizerTool''allUsagesAvailable-1 tool))
        )
    )

    (§ defn- #_"ValueNode" LoadFieldNode'canonical-6 [#_"LoadFieldNode" self, #_"StampPair" stamp, #_"ValueNode" forObject, #_"ResolvedJavaField" field, #_"boolean" canonicalizeReads, #_"boolean" allUsagesAvailable]
        (or
            (when (and canonicalizeReads (some? HotSpot'metaAccess))
                (or
                    (LoadFieldNode'asConstant-2 forObject, field)
                    (when allUsagesAvailable
                        (LoadFieldNode'asPhi-3 forObject, field, (:trustedStamp stamp))
                    )
                )
            )
            (if (and (some? self) (not (#_"ResolvedJavaField" .isStatic field)) (ValueNode''isNullConstant-1 forObject))
                (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateReprofile, DeoptimizationReason/NullCheckException)
                (or self (LoadFieldNode'new-3 stamp, forObject, field))
            )
        )
    )

    ;;;
     ; Gets a constant value for this load if possible.
     ;;
    #_unused
    (§ method! #_"ConstantNode" LoadFieldNode''asConstant-3 [#_"LoadFieldNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forObject]
        (LoadFieldNode'asConstant-2 forObject, (:field this))
    )

    (§ defn- #_"ConstantNode" LoadFieldNode'asConstant-2 [#_"ValueNode" forObject, #_"ResolvedJavaField" field]
        (cond
            (#_"ResolvedJavaField" .isStatic field)
                (ConstantFields'tryConstantFold-2 field, nil)
            (and (instance? ConstantNode forObject) (not (ValueNode''isNullConstant-1 forObject)))
                (ConstantFields'tryConstantFold-2 field, (ValueNode''asJavaConstant-1 forObject))
        )
    )

    #_unused
    (§ method! #_"ConstantNode" LoadFieldNode''asConstant-3 [#_"LoadFieldNode" this, #_"CanonicalizerTool" tool, #_"JavaConstant" constant]
        (ConstantFields'tryConstantFold-2 (AccessFieldNode''field-1 this), constant)
    )

    (§ defn- #_"PhiNode" LoadFieldNode'asPhi-3 [#_"ValueNode" object, #_"ResolvedJavaField" field, #_"Stamp" stamp]
        (when (and (not (#_"ResolvedJavaField" .isStatic field)) (#_"ResolvedJavaField" .isFinal field) (instance? ValuePhiNode object) (NodeIterable''isEmpty-1 (NodeList''filter-2 (ValuePhiNode''values-1 object), (NegativeTypePredicate'new-1 ConstantNode))))
            (let [
                #_"ConstantNode[]" constantNodes (make-array ConstantNode (PhiNode''valueCount-1 object))
            ]
                (loop-when [#_"int" i 0] (< i (PhiNode''valueCount-1 object)) => (ValuePhiNode'new-3 stamp, (PhiNode''merge-1 object), constantNodes)
                    (let [
                        #_"ConstantNode" constant (ConstantFields'tryConstantFold-2 field, (ValueNode''asJavaConstant-1 (PhiNode''valueAt-2 object, i)))
                    ]
                        (when (some? constant)
                            (aset constantNodes i constant)
                            (recur (inc i))
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" LoadFieldNode''virtualize-2 [#_"LoadFieldNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" object (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (instance? VirtualObjectNode object)
                (let [
                    #_"int" i (VirtualInstanceNode''fieldIndex-2 object, (AccessFieldNode''field-1 this))
                ]
                    (when-not (= i -1)
                        (let [
                            #_"ValueNode" entry (VirtualizerTool''getEntry-3 tool, object, i)
                        ]
                            (when (Stamp''isCompatible-2 (:stamp this), (:stamp entry))
                                (VirtualizerTool''replaceWith-2 tool, entry)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"Stamp" LoadFieldNode''uncheckedStamp-1 [#_"LoadFieldNode" this]
        (:uncheckedStamp this)
    )

    #_unused
    (§ method! #_"LoadFieldNode" LoadFieldNode''setObject-2 [#_"LoadFieldNode" this, #_"ValueNode" newObject]
        (Node''updateUsages-3 this, (:object this), newObject)
        (assoc this :object newObject)
    )
)

;;;
 ; The LoadIndexedNode represents a read from an element of an array.
 ;;
(class-ns LoadIndexedNode (§ extends AccessIndexedNode) (§ implements Virtualizable, Canonicalizable)
    (§ def #_"NodeClass<LoadIndexedNode>" LoadIndexedNode'TYPE (NodeClass'create-1 LoadIndexedNode))

    ;;;
     ; Creates a new LoadIndexedNode.
     ;
     ; @param array the instruction producing the array
     ; @param index the instruction producing the index
     ; @param elementKind the element type
     ;;
    (§ defn #_"LoadIndexedNode" LoadIndexedNode'new-3 [#_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (LoadIndexedNode'new-5 LoadIndexedNode'TYPE, (LoadIndexedNode'createStamp-2 array, elementKind), array, index, elementKind)
    )

    (§ defn #_"ValueNode" LoadIndexedNode'create-3 [#_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (or (LoadIndexedNode'tryConstantFold-2 array, index)
            (LoadIndexedNode'new-3 array, index, elementKind)
        )
    )

    (§ defn #_"LoadIndexedNode" LoadIndexedNode'new-5 [#_"NodeClass<? extends LoadIndexedNode>" c, #_"Stamp" stamp, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (AccessIndexedNode'new-5 c, stamp, array, index, elementKind)
    )

    (§ defn- #_"Stamp" LoadIndexedNode'createStamp-2 [#_"ValueNode" array, #_"JavaKind" kind]
        (let [
            #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp array))
        ]
            (if (and (= kind JavaKind/Object) (some? type) (#_"ResolvedJavaType" .isArray type))
                (StampFactory'object-1 (TypeReference'createTrusted-1 (#_"ResolvedJavaType" .getComponentType type)))
                (StampFactory'forKind-1 (LoadIndexedNode'determinePreciseArrayElementType-2 array, kind))
            )
        )
    )

    (§ defn- #_"JavaKind" LoadIndexedNode'determinePreciseArrayElementType-2 [#_"ValueNode" array, #_"JavaKind" kind]
        (when (= kind JavaKind/Byte) => kind
            (let [
                #_"ResolvedJavaType" type (AbstractObjectStamp''type-1 (:stamp array))
            ]
                (when (and (some? type) (#_"ResolvedJavaType" .isArray type) (some? (#_"ResolvedJavaType" .getComponentType type)) (= (#_"ResolvedJavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType type)) JavaKind/Boolean)) => kind
                    JavaKind/Boolean
                )
            )
        )
    )

    #_unused
    (§ override #_"boolean" LoadIndexedNode''inferStamp-1 [#_"LoadIndexedNode" this]
        (ValueNode''updateStamp-2 this, (Stamp''improveWith-2 (:stamp this), (LoadIndexedNode'createStamp-2 (AccessArrayNode''array-1 this), (:elementKind this))))
    )

    #_unused
    (§ override #_"void" LoadIndexedNode''virtualize-2 [#_"LoadIndexedNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" array (VirtualizerTool''getAlias-2 tool, (AccessArrayNode''array-1 this))
        ]
            (when (instance? VirtualObjectNode array)
                (let [
                    #_"ValueNode" index (VirtualizerTool''getAlias-2 tool, (AccessIndexedNode''index-1 this))
                    #_"int" i (if (instance? ConstantNode index) (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 index)) -1)
                ]
                    (when (< -1 i (VirtualArrayNode''entryCount-1 array))
                        (let [
                            #_"ValueNode" entry (VirtualizerTool''getEntry-3 tool, array, i)
                        ]
                            (when (Stamp''isCompatible-2 (:stamp this), (:stamp entry))
                                (VirtualizerTool''replaceWith-2 tool, entry)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override #_"Node" LoadIndexedNode''canonical-2 [#_"LoadIndexedNode" this, #_"CanonicalizerTool" tool]
        (or (LoadIndexedNode'tryConstantFold-2 (AccessArrayNode''array-1 this), (AccessIndexedNode''index-1 this))
            this
        )
    )

    (§ defn- #_"ValueNode" LoadIndexedNode'tryConstantFold-2 [#_"ValueNode" array, #_"ValueNode" index]
        (when (and (instance? ConstantNode array) (not (ValueNode''isNullConstant-1 array)) (instance? ConstantNode index))
            (let [
                #_"JavaConstant" arrayConstant (ValueNode''asJavaConstant-1 array)
            ]
                (when (and (some? arrayConstant) (pos? (:stableDimension array)))
                    (let [
                        #_"JavaConstant" constant (#_"ConstantReflectionProvider" .readArrayElement HotSpot'constantReflection, arrayConstant, (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 index)))
                    ]
                        (when (and (some? constant) (or (:isDefaultStable array) (not (#_"JavaConstant" .isDefaultForKind constant))))
                            (ConstantNode'forConstant-3 constant, (dec (:stableDimension array)), (:isDefaultStable array))
                        )
                    )
                )
            )
        )
    )
)

;;;
 ; Represents the low-level version of an atomic compare-and-swap operation.
 ;
 ; This version returns a boolean indicating is the CAS was successful or not.
 ;;
(final-ns LogicCompareAndSwapNode (§ extends AbstractCompareAndSwapNode)
    (§ def #_"NodeClass<LogicCompareAndSwapNode>" LogicCompareAndSwapNode'TYPE (NodeClass'create-1 LogicCompareAndSwapNode))

    (§ defn #_"LogicCompareAndSwapNode" LogicCompareAndSwapNode'new-4 [#_"ValueNode" address, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"LocationIdentity" location]
        (LogicCompareAndSwapNode'new-5 address, location, expectedValue, newValue, BarrierType'NONE)
    )

    (§ defn #_"LogicCompareAndSwapNode" LogicCompareAndSwapNode'new-5 [#_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"BarrierType" barrierType]
        (AbstractCompareAndSwapNode'new-7 LogicCompareAndSwapNode'TYPE, address, location, expectedValue, newValue, barrierType, (StampFactory'forKind-1 (#_"JavaKind" .getStackKind JavaKind/Boolean)))
    )

    #_unused
    (§ override! #_"void" LogicCompareAndSwapNode''generate-2 [#_"LogicCompareAndSwapNode" this, #_"LIRBuilder" builder]
        (let [
            #_"LIRKind" resultKind (Stamp''getLIRKind-1 (:stamp this))
            #_"Value" trueResult (LIRGenerator''emitConstant-3 (:gen builder), resultKind, JavaConstant/TRUE)
            #_"Value" falseResult (LIRGenerator''emitConstant-3 (:gen builder), resultKind, JavaConstant/FALSE)
            #_"Value" result (LIRGenerator''emitLogicCompareAndSwap-6 (:gen builder), (LIRBuilder''operand-2 builder, (FixedAccessNode''getAddress-1 this)), (LIRBuilder''operand-2 builder, (:expectedValue this)), (LIRBuilder''operand-2 builder, (AbstractCompareAndSwapNode''getNewValue-1 this)), trueResult, falseResult)
        ]
            (LIRBuilder''setResult-3 builder, this, result)
        )
        nil
    )
)

;;;
 ; Represents the lowered version of an atomic read-and-write operation like
 ; {@link sun.misc.Unsafe#getAndSetInt(Object, long, int)}.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns LoweredAtomicReadAndWriteNode (§ extends FixedAccessNode) (§ implements StateSplit, LIRLowerableAccess, Single)
    (§ def #_"NodeClass<LoweredAtomicReadAndWriteNode>" LoweredAtomicReadAndWriteNode'TYPE (NodeClass'create-1 LoweredAtomicReadAndWriteNode))

    ; @Input
    (§ mutable #_"ValueNode" :newValue nil)
    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)

    (§ defn #_"LoweredAtomicReadAndWriteNode" LoweredAtomicReadAndWriteNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" newValue, #_"BarrierType" barrierType]
        (let [
            #_"LoweredAtomicReadAndWriteNode" this (FixedAccessNode'new-5 LoweredAtomicReadAndWriteNode'TYPE, address, location, (Stamp''unrestricted-1 (:stamp newValue)), barrierType)
            this (assoc this :newValue newValue)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"FrameState" LoweredAtomicReadAndWriteNode''stateAfter-1 [#_"LoweredAtomicReadAndWriteNode" this]
        (:stateAfter this)
    )

    (§ override! #_"void" LoweredAtomicReadAndWriteNode''setStateAfter-2 [#_"LoweredAtomicReadAndWriteNode" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    #_unused
    (§ override! #_"boolean" LoweredAtomicReadAndWriteNode''hasSideEffect-1 [#_"LoweredAtomicReadAndWriteNode" this]
        true
    )

    #_unused
    (§ override! #_"void" LoweredAtomicReadAndWriteNode''generate-2 [#_"LoweredAtomicReadAndWriteNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value" result (LIRGenerator''emitAtomicReadAndWrite-3 (:gen builder), (LIRBuilder''operand-2 builder, (FixedAccessNode''getAddress-1 this)), (LIRBuilder''operand-2 builder, (:newValue this)))
        ]
            (LIRBuilder''setResult-3 builder, this, result)
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" LoweredAtomicReadAndWriteNode''canNullCheck-1 [#_"LoweredAtomicReadAndWriteNode" this]
        false
    )

    #_unused
    (§ override! #_"Stamp" LoweredAtomicReadAndWriteNode''getAccessStamp-1 [#_"LoweredAtomicReadAndWriteNode" this]
        (:stamp this)
    )
)

(class-ns MethodCallTargetNode (§ extends CallTargetNode) (§ implements IterableNodeType, Simplifiable)
    (§ def #_"NodeClass<MethodCallTargetNode>" MethodCallTargetNode'TYPE (NodeClass'create-1 MethodCallTargetNode))

    (§ defn #_"MethodCallTargetNode" MethodCallTargetNode'new-4 [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode[]" arguments, #_"StampPair" returnStamp]
        (MethodCallTargetNode'new-5 MethodCallTargetNode'TYPE, invokeKind, targetMethod, arguments, returnStamp)
    )

    (§ defn #_"MethodCallTargetNode" MethodCallTargetNode'new-5 [#_"NodeClass<? extends MethodCallTargetNode>" c, #_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode[]" arguments, #_"StampPair" returnStamp]
        (CallTargetNode'new-5 c, arguments, targetMethod, invokeKind, returnStamp)
    )

    ;;;
     ; Gets the instruction that produces the receiver object for this invocation, if any.
     ;
     ; @return the instruction that produces the receiver object for this invocation if any,
     ;         nil if this invocation does not take a receiver object
     ;;
    (§ method! #_"ValueNode" MethodCallTargetNode''receiver-1 [#_"MethodCallTargetNode" this]
        (when-not (MethodCallTargetNode''isStatic-1 this)
            (nth (CallTargetNode''arguments-1 this) 0)
        )
    )

    ;;;
     ; Checks whether this is an invocation of a static method.
     ;
     ; @return true if the invocation is a static invocation
     ;;
    (§ method #_"boolean" MethodCallTargetNode''isStatic-1 [#_"MethodCallTargetNode" this]
        (= (CallTargetNode''invokeKind-1 this) InvokeKind'Static)
    )

    #_unused
    (§ method! #_"JavaKind" MethodCallTargetNode''returnKind-1 [#_"MethodCallTargetNode" this]
        (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature (CallTargetNode''targetMethod-1 this)))
    )

    (§ method #_"InvokeNode" MethodCallTargetNode''invoke-1 [#_"MethodCallTargetNode" this]
        (NodeIterable''first-1 (Node''usages-1 this))
    )

    (§ defn #_"ResolvedJavaMethod" MethodCallTargetNode'findSpecialCallTarget-4 [#_"InvokeKind" invokeKind, #_"ValueNode" receiver, #_"ResolvedJavaMethod" targetMethod, #_"ResolvedJavaType" contextType]
        (cond
            (:direct invokeKind) nil
            ;; check for trivial cases (e.g. final methods, nonvirtual methods)
            (#_"ResolvedJavaMethod" .canBeStaticallyBound targetMethod) targetMethod
            :else (MethodCallTargetNode'devirtualizeCall-4 invokeKind, targetMethod, contextType, (:stamp receiver))
        )
    )

    (§ defn #_"ResolvedJavaMethod" MethodCallTargetNode'devirtualizeCall-4 [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"ResolvedJavaType" contextType, #_"Stamp" receiverStamp]
        (let [
            #_"TypeReference" type
                (or (StampTool'typeReferenceOrNull-1 receiverStamp)
                    (when (= invokeKind InvokeKind'Virtual)
                        ;; For virtual calls, we are guaranteed to receive a correct receiver type.
                        (TypeReference'createTrusted-1 (#_"ResolvedJavaMethod" .getDeclaringClass targetMethod))
                    )
                )
        ]
            (when (some? type)
                ;; either the holder class is exact, or the receiver object has an exact type, or it's an array type
                (let [
                    #_"ResolvedJavaMethod" resolvedMethod (#_"ResolvedJavaType" .resolveConcreteMethod (:type type), targetMethod, contextType)
                ]
                    (when (and (some? resolvedMethod) (or (#_"ResolvedJavaMethod" .canBeStaticallyBound resolvedMethod) (:exactReference type) (#_"ResolvedJavaType" .isArray (:type type))))
                        resolvedMethod
                    )
                )
            )
        )
    )

    #_unused
    (§ override #_"void" MethodCallTargetNode''simplify-2 [#_"MethodCallTargetNode" this, #_"SimplifierTool" tool]
        ;; attempt to devirtualize the call
        (when (some? (InvokeNode''getContextMethod-1 (MethodCallTargetNode''invoke-1 this))) ;; => avoid invokes that have placeholder bcis: they do not have a valid contextType
            (let [
                #_"ResolvedJavaType" contextType (when-not (and (nil? (AbstractStateSplit''stateAfter-1 (MethodCallTargetNode''invoke-1 this))) (nil? (InvokeNode''stateDuring-1 (MethodCallTargetNode''invoke-1 this)))) (InvokeNode''getContextType-1 (MethodCallTargetNode''invoke-1 this)))
                #_"ResolvedJavaMethod" specialCallTarget (MethodCallTargetNode'findSpecialCallTarget-4 (:invokeKind this), (MethodCallTargetNode''receiver-1 this), (:targetMethod this), contextType)
            ]
                (when (some? specialCallTarget)
                    (§ ass! this (CallTargetNode''setTargetMethod-2 this, specialCallTarget))
                    (§ ass! this (CallTargetNode''setInvokeKind-2 this, InvokeKind'Special))
                )
            )
        )
        nil
    )

    #_unused
    (§ override #_"String" MethodCallTargetNode''targetName-1 [#_"MethodCallTargetNode" this]
        (if (some? (CallTargetNode''targetMethod-1 this))
            (#_"ResolvedJavaMethod" .format (CallTargetNode''targetMethod-1 this), "%h.\n")
            "??Invalid!"
        )
    )

    #_unused
    (§ defn #_"MethodCallTargetNode" MethodCallTargetNode'find-2 [#_"Graph" graph, #_"ResolvedJavaMethod" method]
        (loop-when [#_"ISeq" s (seq (Graph''getNodes-2 graph, MethodCallTargetNode'TYPE))] (some? s)
            (let [
                #_"MethodCallTargetNode" target (first s)
            ]
                (when (= (CallTargetNode''targetMethod-1 target) method) => (recur (next s))
                    target
                )
            )
        )
    )
)

;;;
 ; The MonitorEnterNode represents the acquisition of a monitor.
 ;;
(final-ns MonitorEnterNode (§ extends AccessMonitorNode) (§ implements Virtualizable, Lowerable, IterableNodeType, MonitorEnter, Single)
    (§ def #_"NodeClass<MonitorEnterNode>" MonitorEnterNode'TYPE (NodeClass'create-1 MonitorEnterNode))

    (§ defn #_"MonitorEnterNode" MonitorEnterNode'new-2 [#_"ValueNode" object, #_"MonitorIdNode" monitorId]
        (MonitorEnterNode'new-3 MonitorEnterNode'TYPE, object, monitorId)
    )

    (§ defn #_"MonitorEnterNode" MonitorEnterNode'new-3 [#_"NodeClass<? extends MonitorEnterNode>" c, #_"ValueNode" object, #_"MonitorIdNode" monitorId]
        (AccessMonitorNode'new-3 c, object, monitorId)
    )

    #_unused
    (§ override! #_"LocationIdentity" MonitorEnterNode''getLocationIdentity-1 [#_"MonitorEnterNode" this]
        (LocationIdentity/any)
    )

    (§ override! #_"void" MonitorEnterNode''lower-2 [#_"MonitorEnterNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerMonitorEnterNode-3 this, lowerer, (:graph this))
        nil
    )

    #_unused
    (§ override! #_"void" MonitorEnterNode''virtualize-2 [#_"MonitorEnterNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" object (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (and (instance? VirtualObjectNode object) (VirtualObjectNode''hasIdentity-1 object))
                (VirtualizerTool''addLock-3 tool, object, (:monitorId this))
                (VirtualizerTool''delete-1 tool)
            )
        )
        nil
    )
)

;;;
 ; The MonitorExitNode represents a monitor release. If it is the release of the monitor
 ; of a synchronized method, then the return value of the method will be referenced via the edge
 ; #escapedReturnValue, so that it will be materialized before releasing the monitor.
 ;;
(final-ns MonitorExitNode (§ extends AccessMonitorNode) (§ implements Virtualizable, Lowerable, IterableNodeType, MonitorExit, Single)
    (§ def #_"NodeClass<MonitorExitNode>" MonitorExitNode'TYPE (NodeClass'create-1 MonitorExitNode))

    ;;;
     ; Non-null for the monitor exit introduced due to a synchronized root method and nil in all other cases.
     ;;
    ; @OptionalInput
    (§ mutable #_"ValueNode" :escapedReturnValue nil)

    (§ defn #_"MonitorExitNode" MonitorExitNode'new-3 [#_"ValueNode" object, #_"MonitorIdNode" monitorId, #_"ValueNode" escapedReturnValue]
        (let [
            #_"MonitorExitNode" this (AccessMonitorNode'new-3 MonitorExitNode'TYPE, object, monitorId)
            this (assoc this :escapedReturnValue escapedReturnValue)
        ]
            this
        )
    )

    ;;;
     ; Return value is cleared when a synchronized method graph is inlined.
     ;;
    (§ method! #_"MonitorExitNode" MonitorExitNode''clearEscapedReturnValue-1 [#_"MonitorExitNode" this]
        (Node''updateUsages-3 this, (:escapedReturnValue this), nil)
        (assoc this :escapedReturnValue nil)
    )

    #_unused
    (§ override! #_"LocationIdentity" MonitorExitNode''getLocationIdentity-1 [#_"MonitorExitNode" this]
        (LocationIdentity/any)
    )

    #_unused
    (§ override! #_"void" MonitorExitNode''lower-2 [#_"MonitorExitNode" this, #_"LoweringTool" lowerer]
        (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
            (MonitorTemplates''lower-3 Lowerer'monitorSnippets, this, lowerer)
        )
        nil
    )

    #_unused
    (§ override! #_"void" MonitorExitNode''virtualize-2 [#_"MonitorExitNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" object (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (and (instance? VirtualObjectNode object) (VirtualObjectNode''hasIdentity-1 object))
                (VirtualizerTool''removeLock-2 tool, object)
                (VirtualizerTool''delete-1 tool)
            )
        )
        nil
    )
)

;;;
 ; This node describes one locking scope; it ties the monitor enter, monitor exit and
 ; the frame states together. It is thus referenced from the MonitorEnterNode,
 ; from the MonitorExitNode and from the FrameState.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Association"
(final-ns MonitorIdNode (§ extends ValueNode) (§ implements IterableNodeType, LIRLowerable)
    (§ def #_"NodeClass<MonitorIdNode>" MonitorIdNode'TYPE (NodeClass'create-1 MonitorIdNode))

    (§ mutable #_"int" :lockDepth 0)
    (§ mutable #_"boolean" :eliminated false)

    (§ defn #_"MonitorIdNode" MonitorIdNode'new-1 [#_"int" lockDepth]
        (MonitorIdNode'new-2 MonitorIdNode'TYPE, lockDepth)
    )

    (§ defn #_"MonitorIdNode" MonitorIdNode'new-2 [#_"NodeClass<? extends MonitorIdNode>" c, #_"int" lockDepth]
        (let [
            #_"MonitorIdNode" this (ValueNode'new-2 c, (StampFactory'forVoid-0))
            this (assoc this :lockDepth lockDepth)
        ]
            this
        )
    )

    (§ method! #_"MonitorIdNode" MonitorIdNode''setLockDepth-2 [#_"MonitorIdNode" this, #_"int" lockDepth]
        (assoc this :lockDepth lockDepth)
    )

    #_unused
    (§ method! #_"MonitorIdNode" MonitorIdNode''setEliminated-1 [#_"MonitorIdNode" this]
        (assoc this :eliminated true)
    )

    #_unused
    (§ override! #_"void" MonitorIdNode''generate-2 [#_"MonitorIdNode" this, #_"LIRBuilder" builder]
        ;; nothing to do
        nil
    )
)

;;;
 ; The NewArrayNode is used for all array allocations where the element type is know at
 ; compile time.
 ;;
(final-ns NewArrayNode (§ extends AbstractNewArrayNode) (§ implements VirtualizableAllocation, Simplifiable)
    (§ def #_"NodeClass<NewArrayNode>" NewArrayNode'TYPE (NodeClass'create-1 NewArrayNode))

    (§ final #_"ResolvedJavaType" :elementType nil)

    (§ defn #_"NewArrayNode" NewArrayNode'new-3 [#_"ResolvedJavaType" elementType, #_"ValueNode" length, #_"boolean" fillContents]
        (NewArrayNode'new-4 elementType, length, fillContents, nil)
    )

    (§ defn #_"NewArrayNode" NewArrayNode'new-4 [#_"ResolvedJavaType" elementType, #_"ValueNode" length, #_"boolean" fillContents, #_"FrameState" stateBefore]
        (NewArrayNode'new-5 NewArrayNode'TYPE, elementType, length, fillContents, stateBefore)
    )

    (§ defn #_"NewArrayNode" NewArrayNode'new-5 [#_"NodeClass<? extends NewArrayNode>" c, #_"ResolvedJavaType" elementType, #_"ValueNode" length, #_"boolean" fillContents, #_"FrameState" stateBefore]
        (let [
            #_"NewArrayNode" this (AbstractNewArrayNode'new-5 c, (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 (#_"ResolvedJavaType" .getArrayClass elementType))), length, fillContents, stateBefore)
            this (assoc this :elementType elementType)
        ]
            this
        )
    )

    ; @NodeIntrinsic
    (§ native- #_"Object" NewArrayNode'newArray-3 [#_@ConstantNodeParameter #_"Class" elementType, #_"int" length, #_@ConstantNodeParameter #_"boolean" fillContents])

    (§ defn #_"Object" NewArrayNode'newUninitializedArray-2 [#_"Class" elementType, #_"int" length]
        (NewArrayNode'newArray-3 elementType, length, false)
    )

    #_unused
    (§ override! #_"void" NewArrayNode''virtualize-2 [#_"NewArrayNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" lengthAlias (VirtualizerTool''getAlias-2 tool, (AbstractNewArrayNode''length-1 this))
        ]
            (when (some? (ValueNode''asConstant-1 lengthAlias))
                (let [
                    #_"int" constantLength (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 lengthAlias))
                ]
                    (when (< -1 constantLength (VirtualizerTool''getMaximumEntryCount-1 tool))
                        (let [
                            #_"VirtualObjectNode" virtualObject (NewArrayNode''createVirtualArrayNode-2 this, constantLength)
                            #_"ConstantNode" defaultForKind (when-not (zero? constantLength) (NewArrayNode''defaultElementValue-1 this))
                            #_"ValueNode[]" state (into-array ValueNode (repeat constantLength defaultForKind))
                        ]
                            (VirtualizerTool''createVirtualObject-5 tool, virtualObject, state, #_"<MonitorIdNode>" (Collections/emptyList), false)
                            (VirtualizerTool''replaceWithVirtual-2 tool, virtualObject)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"VirtualArrayNode" NewArrayNode''createVirtualArrayNode-2 [#_"NewArrayNode" this, #_"int" constantLength]
        (VirtualArrayNode'new-2 (:elementType this), constantLength)
    )

    ;; Factored out in a separate method so that subclasses can override it.
    (§ method! #_"ConstantNode" NewArrayNode''defaultElementValue-1 [#_"NewArrayNode" this]
        (ConstantNode'defaultForKind-2 (#_"ResolvedJavaType" .getJavaKind (:elementType this)), (:graph this))
    )

    #_unused
    (§ override! #_"void" NewArrayNode''simplify-2 [#_"NewArrayNode" this, #_"SimplifierTool" tool]
        (when (Node''hasNoUsages-1 this)
            (let [
                #_"Stamp" stamp (:stamp (AbstractNewArrayNode''length-1 this))
            ]
                (if (and (instance? IntegerStamp stamp) (IntegerStamp''isPositive-1 stamp))
                    (GraphUtil'removeFixedWithUnusedInputs-1 this)
                    ;; should be areFrameStatesAtSideEffects, but currently SVM will complain about RuntimeConstraint
                    (when (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph this)))
                        (let [
                            #_"LogicNode" lengthNegativeCondition (CompareNode'createCompareNode-4 (:graph this), CanonicalCondition'LT, (AbstractNewArrayNode''length-1 this), (ConstantNode'forInt-2 0, (:graph this)))
                            ;; we do not have a non-deopting path for that at the moment so action is None.
                            #_"FixedGuardNode" guard (Graph''add-2 (:graph this), (FixedGuardNode'new-4 lengthNegativeCondition, DeoptimizationReason/RuntimeConstraint, DeoptimizationAction/None, true))
                        ]
                            (§ ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, guard))
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; The NewInstanceNode represents the allocation of an instance class object.
 ;;
(final-ns NewInstanceNode (§ extends AbstractNewObjectNode) (§ implements VirtualizableAllocation)
    (§ def #_"NodeClass<NewInstanceNode>" NewInstanceNode'TYPE (NodeClass'create-1 NewInstanceNode))

    ;;;
     ; The instance class being allocated by this node.
     ;;
    (§ final #_"ResolvedJavaType" :instanceClass nil)

    (§ defn #_"NewInstanceNode" NewInstanceNode'new-2 [#_"ResolvedJavaType" type, #_"boolean" fillContents]
        (NewInstanceNode'new-4 NewInstanceNode'TYPE, type, fillContents, nil)
    )

    (§ defn #_"NewInstanceNode" NewInstanceNode'new-3 [#_"ResolvedJavaType" type, #_"boolean" fillContents, #_"FrameState" stateBefore]
        (NewInstanceNode'new-4 NewInstanceNode'TYPE, type, fillContents, stateBefore)
    )

    (§ defn #_"NewInstanceNode" NewInstanceNode'new-4 [#_"NodeClass<? extends NewInstanceNode>" c, #_"ResolvedJavaType" type, #_"boolean" fillContents, #_"FrameState" stateBefore]
        (let [
            #_"NewInstanceNode" this (AbstractNewObjectNode'new-4 c, (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 type)), fillContents, stateBefore)
            this (assoc this :instanceClass type)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" NewInstanceNode''virtualize-2 [#_"NewInstanceNode" this, #_"VirtualizerTool" tool]
        ;; Reference objects can escape into their ReferenceQueue at any safepoint, therefore they're excluded from escape analysis.
        (when-not (#_"ResolvedJavaType" .isAssignableFrom (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, java.lang.ref.Reference), (:instanceClass this))
            (let [
                #_"VirtualInstanceNode" virtualObject (NewInstanceNode''createVirtualInstanceNode-2 this, true)
                #_"ResolvedJavaField[]" fields (VirtualInstanceNode''getFields-1 virtualObject)
                #_"ValueNode[]" state (make-array ValueNode (count fields))
            ]
                (dotimes [#_"int" i (count state)]
                    (aset state i (NewInstanceNode''defaultFieldValue-2 this, (nth fields i)))
                )
                (VirtualizerTool''createVirtualObject-5 tool, virtualObject, state, #_"<MonitorIdNode>" (Collections/emptyList), false)
                (VirtualizerTool''replaceWithVirtual-2 tool, virtualObject)
            )
        )
        nil
    )

    (§ method! #_"VirtualInstanceNode" NewInstanceNode''createVirtualInstanceNode-2 [#_"NewInstanceNode" this, #_"boolean" hasIdentity]
        (VirtualInstanceNode'new-2 (:instanceClass this), hasIdentity)
    )

    ;; Factored out in a separate method so that subclasses can override it.
    (§ method! #_"ConstantNode" NewInstanceNode''defaultFieldValue-2 [#_"NewInstanceNode" this, #_"ResolvedJavaField" field]
        (ConstantNode'defaultForKind-2 (#_"JavaType" .getJavaKind (#_"ResolvedJavaField" .getType field)), (:graph this))
    )
)

;;;
 ; The RawMonitorEnterNode represents the acquisition of a monitor. The object needs to
 ; already be non-nil and the hub is an additional parameter to the node.
 ;;
(final-ns RawMonitorEnterNode (§ extends AccessMonitorNode) (§ implements Virtualizable, Lowerable, IterableNodeType, MonitorEnter, Single)
    (§ def #_"NodeClass<RawMonitorEnterNode>" RawMonitorEnterNode'TYPE (NodeClass'create-1 RawMonitorEnterNode))

    ; @Input
    (§ mutable #_"ValueNode" :hub nil)

    (§ defn #_"RawMonitorEnterNode" RawMonitorEnterNode'new-3 [#_"ValueNode" object, #_"ValueNode" hub, #_"MonitorIdNode" monitorId]
        (let [
            #_"RawMonitorEnterNode" this (AccessMonitorNode'new-3 RawMonitorEnterNode'TYPE, object, monitorId)
            this (assoc this :hub hub)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"LocationIdentity" RawMonitorEnterNode''getLocationIdentity-1 [#_"RawMonitorEnterNode" this]
        (LocationIdentity/any)
    )

    #_unused
    (§ override! #_"void" RawMonitorEnterNode''lower-2 [#_"RawMonitorEnterNode" this, #_"LoweringTool" lowerer]
        (when (GuardsStage'areFrameStatesAtDeopts-1 (:guardsStage (:graph this)))
            (MonitorTemplates''lower-3 Lowerer'monitorSnippets, this, lowerer)
        )
        nil
    )

    #_unused
    (§ override! #_"void" RawMonitorEnterNode''virtualize-2 [#_"RawMonitorEnterNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" object (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (and (instance? VirtualObjectNode object) (VirtualObjectNode''hasIdentity-1 object))
                (VirtualizerTool''addLock-3 tool, object, (:monitorId this))
                (VirtualizerTool''delete-1 tool)
            )
        )
        nil
    )
)

;;;
 ; The StoreFieldNode represents a write to a static or instance field.
 ;;
(final-ns StoreFieldNode (§ extends AccessFieldNode) (§ implements StateSplit, Virtualizable)
    (§ def #_"NodeClass<StoreFieldNode>" StoreFieldNode'TYPE (NodeClass'create-1 StoreFieldNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)
    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)

    (§ override! #_"FrameState" StoreFieldNode''stateAfter-1 [#_"StoreFieldNode" this]
        (:stateAfter this)
    )

    (§ override! #_"void" StoreFieldNode''setStateAfter-2 [#_"StoreFieldNode" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    #_unused
    (§ override! #_"boolean" StoreFieldNode''hasSideEffect-1 [#_"StoreFieldNode" this]
        true
    )

    (§ defn #_"StoreFieldNode" StoreFieldNode'new-3 [#_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value]
        (let [
            #_"StoreFieldNode" this (AccessFieldNode'new-4 StoreFieldNode'TYPE, (StampFactory'forVoid-0), object, field)
            this (assoc this :value value)
        ]
            this
        )
    )

    (§ defn #_"StoreFieldNode" StoreFieldNode'new-4 [#_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value, #_"FrameState" stateAfter]
        (let [
            #_"StoreFieldNode" this (AccessFieldNode'new-4 StoreFieldNode'TYPE, (StampFactory'forVoid-0), object, field)
            this (assoc this :value value)
            this (assoc this :stateAfter stateAfter)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" StoreFieldNode''virtualize-2 [#_"StoreFieldNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" object (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (instance? VirtualObjectNode object)
                (let [
                    #_"int" i (VirtualInstanceNode''fieldIndex-2 object, (AccessFieldNode''field-1 this))
                ]
                    (when-not (= i -1)
                        (VirtualizerTool''setVirtualEntry-4 tool, object, i, (:value this))
                        (VirtualizerTool''delete-1 tool)
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; The StoreIndexedNode represents a write to an array element.
 ;;
(final-ns StoreIndexedNode (§ extends AccessIndexedNode) (§ implements StateSplit, Lowerable, Virtualizable)
    (§ def #_"NodeClass<StoreIndexedNode>" StoreIndexedNode'TYPE (NodeClass'create-1 StoreIndexedNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)
    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)

    (§ override! #_"FrameState" StoreIndexedNode''stateAfter-1 [#_"StoreIndexedNode" this]
        (:stateAfter this)
    )

    #_unused
    (§ override! #_"void" StoreIndexedNode''setStateAfter-2 [#_"StoreIndexedNode" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    #_unused
    (§ override! #_"boolean" StoreIndexedNode''hasSideEffect-1 [#_"StoreIndexedNode" this]
        true
    )

    (§ defn #_"StoreIndexedNode" StoreIndexedNode'new-4 [#_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind, #_"ValueNode" value]
        (let [
            #_"StoreIndexedNode" this (AccessIndexedNode'new-5 StoreIndexedNode'TYPE, (StampFactory'forVoid-0), array, index, elementKind)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" StoreIndexedNode''virtualize-2 [#_"StoreIndexedNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" array (VirtualizerTool''getAlias-2 tool, (AccessArrayNode''array-1 this))
        ]
            (when (instance? VirtualObjectNode array)
                (let [
                    #_"ValueNode" index (VirtualizerTool''getAlias-2 tool, (AccessIndexedNode''index-1 this))
                    #_"int" i (if (instance? ConstantNode index) (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 index)) -1)
                ]
                    (when (< -1 i (VirtualArrayNode''entryCount-1 array))
                        (let [
                            #_"ResolvedJavaType" componentType (#_"ResolvedJavaType" .getComponentType (VirtualArrayNode''type-1 array))
                        ]
                            (when (or (#_"ResolvedJavaType" .isPrimitive componentType) (StampTool'isPointerAlwaysNull-1 (:stamp (:value this))) (nil? (#_"ResolvedJavaType" .getSuperclass componentType)) (and (some? (StampTool'typeReferenceOrNull-1 (:stamp (:value this)))) (#_"ResolvedJavaType" .isAssignableFrom componentType, (StampTool'typeOrNull-1 (:stamp (:value this))))))
                                (VirtualizerTool''setVirtualEntry-4 tool, array, i, (:value this))
                                (VirtualizerTool''delete-1 tool)
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; Represents an atomic compare-and-swap operation The result is a boolean that contains whether the
 ; value matched the expected value.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Value, InputType.Memory"
(final-ns UnsafeCompareAndSwapNode (§ extends AbstractMemoryCheckpoint) (§ implements Lowerable, Single)
    (§ def #_"NodeClass<UnsafeCompareAndSwapNode>" UnsafeCompareAndSwapNode'TYPE (NodeClass'create-1 UnsafeCompareAndSwapNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)
    ; @Input
    (§ mutable #_"ValueNode" :offset nil)
    ; @Input
    (§ mutable #_"ValueNode" :expected nil)
    ; @Input
    (§ mutable #_"ValueNode" :newValue nil)

    (§ final #_"JavaKind" :valueKind nil)
    (§ final #_"LocationIdentity" :locationIdentity nil)

    #_unused
    (§ defn #_"UnsafeCompareAndSwapNode" UnsafeCompareAndSwapNode'new-6 [#_"ValueNode" object, #_"ValueNode" offset, #_"ValueNode" expected, #_"ValueNode" newValue, #_"JavaKind" valueKind, #_"LocationIdentity" locationIdentity]
        (let [
            #_"UnsafeCompareAndSwapNode" this (AbstractMemoryCheckpoint'new-2 UnsafeCompareAndSwapNode'TYPE, (StampFactory'forKind-1 (#_"JavaKind" .getStackKind JavaKind/Boolean)))
            this (assoc this :object object)
            this (assoc this :offset offset)
            this (assoc this :expected expected)
            this (assoc this :newValue newValue)
            this (assoc this :valueKind valueKind)
            this (assoc this :locationIdentity locationIdentity)
        ]
            this
        )
    )

    (§ override! #_"LocationIdentity" UnsafeCompareAndSwapNode''getLocationIdentity-1 [#_"UnsafeCompareAndSwapNode" this]
        (:locationIdentity this)
    )

    #_unused
    (§ override! #_"void" UnsafeCompareAndSwapNode''lower-2 [#_"UnsafeCompareAndSwapNode" this, #_"LoweringTool" lowerer]
        (Lowerer'lowerCompareAndSwapNode-1 this)
        nil
    )
)

;;;
 ; A special purpose store node that differs from LogicCompareAndSwapNode in that it returns
 ; either the expected value or the compared against value instead of a boolean.
 ;;
(final-ns ValueCompareAndSwapNode (§ extends AbstractCompareAndSwapNode)
    (§ def #_"NodeClass<ValueCompareAndSwapNode>" ValueCompareAndSwapNode'TYPE (NodeClass'create-1 ValueCompareAndSwapNode))

    (§ defn #_"ValueCompareAndSwapNode" ValueCompareAndSwapNode'new-4 [#_"ValueNode" address, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"LocationIdentity" location]
        (ValueCompareAndSwapNode'new-5 address, expectedValue, newValue, location, BarrierType'NONE)
    )

    (§ defn #_"ValueCompareAndSwapNode" ValueCompareAndSwapNode'new-5 [#_"AddressNode" address, #_"ValueNode" expectedValue, #_"ValueNode" newValue, #_"LocationIdentity" location, #_"BarrierType" barrierType]
        (AbstractCompareAndSwapNode'new-7 ValueCompareAndSwapNode'TYPE, address, location, expectedValue, newValue, barrierType, (Stamp''unrestricted-1 (Stamp''meet-2 (:stamp expectedValue), (:stamp newValue))))
    )

    #_unused
    (§ override! #_"void" ValueCompareAndSwapNode''generate-2 [#_"ValueCompareAndSwapNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitValueCompareAndSwap-4 (:gen builder), (LIRBuilder''operand-2 builder, (FixedAccessNode''getAddress-1 this)), (LIRBuilder''operand-2 builder, (:expectedValue this)), (LIRBuilder''operand-2 builder, (AbstractCompareAndSwapNode''getNewValue-1 this))))
        nil
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns KillingBeginNode (§ extends AbstractBeginNode) (§ implements Single)
    (§ def #_"NodeClass<KillingBeginNode>" KillingBeginNode'TYPE (NodeClass'create-1 KillingBeginNode))

    (§ mutable #_"LocationIdentity" :locationIdentity nil)

    (§ defn #_"KillingBeginNode" KillingBeginNode'new-1 [#_"LocationIdentity" locationIdentity]
        (let [
            #_"KillingBeginNode" this (AbstractBeginNode'new-1 KillingBeginNode'TYPE)
            this (assoc this :locationIdentity locationIdentity)
        ]
            this
        )
    )

    #_unused
    (§ defn #_"AbstractBeginNode" KillingBeginNode'begin-2 [#_"FixedNode" with, #_"LocationIdentity" locationIdentity]
        (when-not (instance? KillingBeginNode with) => with
            (let [
                #_"AbstractBeginNode" begin (Graph''add-2 (:graph with), (KillingBeginNode'create-1 locationIdentity))
            ]
                (§ ass! begin (FixedWithNextNode''setNext-2 begin, with))
                begin
            )
        )
    )

    (§ defn #_"AbstractBeginNode" KillingBeginNode'create-1 [#_"LocationIdentity" locationIdentity]
        (KillingBeginNode'new-1 locationIdentity)
    )

    (§ override! #_"LocationIdentity" KillingBeginNode''getLocationIdentity-1 [#_"KillingBeginNode" this]
        (:locationIdentity this)
    )
)

;;;
 ; The LogicConstantNode represents a boolean constant.
 ;;
(final-ns LogicConstantNode (§ extends LogicNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<LogicConstantNode>" LogicConstantNode'TYPE (NodeClass'create-1 LogicConstantNode))

    (§ final #_"boolean" :value false)

    (§ defn #_"LogicConstantNode" LogicConstantNode'new-1 [#_"boolean" value]
        (let [
            #_"LogicConstantNode" this (LogicNode'new-1 LogicConstantNode'TYPE)
            this (assoc this :value value)
        ]
            this
        )
    )

    ;;;
     ; Returns a node for a boolean constant.
     ;
     ; @param v the boolean value for which to create the instruction
     ; @return a node representing the boolean
     ;;
    (§ defn #_"LogicConstantNode" LogicConstantNode'forBoolean-2 [#_"boolean" v, #_"Graph" graph]
        (Graph''add-2 graph, (LogicConstantNode'new-1 v))
    )

    ;;;
     ; Returns a node for a boolean constant.
     ;
     ; @param v the boolean value for which to create the instruction
     ; @return a node representing the boolean
     ;;
    (§ defn #_"LogicConstantNode" LogicConstantNode'forBoolean-1 [#_"boolean" v]
        (LogicConstantNode'new-1 v)
    )

    ;;;
     ; Gets a constant for true.
     ;;
    #_unused
    (§ defn #_"LogicConstantNode" LogicConstantNode'tautology-1 [#_"Graph" graph]
        (LogicConstantNode'forBoolean-2 true, graph)
    )

    ;;;
     ; Gets a constant for false.
     ;;
    (§ defn #_"LogicConstantNode" LogicConstantNode'contradiction-1 [#_"Graph" graph]
        (LogicConstantNode'forBoolean-2 false, graph)
    )

    ;;;
     ; Gets a constant for true.
     ;;
    (§ defn #_"LogicConstantNode" LogicConstantNode'tautology-0 []
        (LogicConstantNode'forBoolean-1 true)
    )

    ;;;
     ; Gets a constant for false.
     ;;
    (§ defn #_"LogicConstantNode" LogicConstantNode'contradiction-0 []
        (LogicConstantNode'forBoolean-1 false)
    )

    #_unused
    (§ override! #_"void" LogicConstantNode''generate-2 [#_"LogicConstantNode" this, #_"LIRBuilder" builder]
        ;; nothing to do
        nil
    )
)

;;;
 ; Logic node that negates its argument.
 ;;
(final-ns LogicNegationNode (§ extends LogicNode) (§ implements Unary #_"<LogicNode>")
    (§ def #_"NodeClass<LogicNegationNode>" LogicNegationNode'TYPE (NodeClass'create-1 LogicNegationNode))

    ; @Input(InputType'ConditionI)
    (§ mutable #_"LogicNode" :value nil)

    (§ defn #_"LogicNegationNode" LogicNegationNode'new-1 [#_"LogicNode" value]
        (let [
            #_"LogicNegationNode" this (LogicNode'new-1 LogicNegationNode'TYPE)
            this (assoc this :value value)
        ]
            this
        )
    )

    (§ defn #_"LogicNode" LogicNegationNode'create-1 [#_"LogicNode" value]
        (or (LogicNegationNode'findSynonym-1 value)
            (LogicNegationNode'new-1 value)
        )
    )

    (§ defn- #_"LogicNode" LogicNegationNode'findSynonym-1 [#_"LogicNode" value]
        (condp instance? value
            LogicConstantNode (LogicConstantNode'forBoolean-1 (not (:value value)))
            LogicNegationNode (LogicNegationNode''getValue-1 value)
            nil
        )
    )

    (§ override! #_"LogicNode" LogicNegationNode''getValue-1 [#_"LogicNegationNode" this]
        (:value this)
    )

    #_unused
    (§ override! #_"LogicNode" LogicNegationNode''canonical-3 [#_"LogicNegationNode" this, #_"CanonicalizerTool" tool, #_"LogicNode" value]
        (or (LogicNegationNode'findSynonym-1 value)
            this
        )
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.ConditionI"
(class-ns LogicNode (§ extends FloatingNode) (§ implements IndirectCanonicalization)
    (§ def #_"NodeClass<LogicNode>" LogicNode'TYPE (NodeClass'create-1 LogicNode))

    (§ defn #_"LogicNode" LogicNode'new-1 [#_"NodeClass<? extends LogicNode>" c]
        (FloatingNode'new-2 c, (StampFactory'forVoid-0))
    )

    #_unused
    (§ defn #_"LogicNode" LogicNode'and-3 [#_"LogicNode" a, #_"LogicNode" b, #_"double" shortCircuitProbability]
        (LogicNode'and-5 a, false, b, false, shortCircuitProbability)
    )

    (§ defn #_"LogicNode" LogicNode'and-5 [#_"LogicNode" a, #_"boolean" negateA, #_"LogicNode" b, #_"boolean" negateB, #_"double" shortCircuitProbability]
        (let [
            #_"Graph" graph (:graph a)
            #_"ShortCircuitOrNode" notAorNotB (Graph''add-2 graph, (ShortCircuitOrNode'new-5 a, (not negateA), b, (not negateB), shortCircuitProbability))
        ]
            (Graph''add-2 graph, (LogicNegationNode'new-1 notAorNotB))
        )
    )

    (§ defn #_"LogicNode" LogicNode'or-3 [#_"LogicNode" a, #_"LogicNode" b, #_"double" shortCircuitProbability]
        (LogicNode'or-5 a, false, b, false, shortCircuitProbability)
    )

    (§ defn #_"LogicNode" LogicNode'or-5 [#_"LogicNode" a, #_"boolean" negateA, #_"LogicNode" b, #_"boolean" negateB, #_"double" shortCircuitProbability]
        (Graph''add-2 (:graph a), (ShortCircuitOrNode'new-5 a, negateA, b, negateB, shortCircuitProbability))
    )

    (§ method! #_"boolean" LogicNode''isTautology-1 [#_"LogicNode" this]
        (and (instance? LogicConstantNode this)
            (:value this)
        )
    )

    #_unused
    (§ method! #_"boolean" LogicNode''isContradiction-1 [#_"LogicNode" this]
        (and (instance? LogicConstantNode this)
            (not (:value this))
        )
    )
)

(final-ns LoopBeginNode (§ extends AbstractMergeNode) (§ implements IterableNodeType, LIRLowerable)
    (§ def #_"NodeClass<LoopBeginNode>" LoopBeginNode'TYPE (NodeClass'create-1 LoopBeginNode))

    (§ mutable #_"double" :loopFrequency 0.0)
    (§ mutable #_"double" :loopOrigFrequency 0.0)
    (§ mutable #_"int" :nextEndIndex 0)
    (§ mutable #_"int" :unswitches 0)
    (§ mutable #_"int" :splits 0)
    (§ mutable #_"int" :inversionCount 0)
    (§ mutable #_"LoopType" :loopType nil)
    (§ mutable #_"int" :unrollFactor 0)

    ;;;
     ; See LoopEndNode#canSafepoint for more information.
     ;;
    (§ mutable #_"boolean" :canEndsSafepoint false)

    ; @OptionalInput(InputType'Guard)
    (§ mutable #_"GuardingNode" :overflowGuard nil)

    (§ defn #_"LoopBeginNode" LoopBeginNode'new-0 []
        (let [
            #_"LoopBeginNode" this (AbstractMergeNode'new-1 LoopBeginNode'TYPE)
            this (assoc this :loopFrequency 1)
            this (assoc this :loopOrigFrequency 1)
            this (assoc this :unswitches 0)
            this (assoc this :splits 0)
            this (assoc this :canEndsSafepoint true)
            this (assoc this :loopType LoopType'SIMPLE_LOOP)
            this (assoc this :unrollFactor 1)
        ]
            this
        )
    )

    (§ method! #_"boolean" LoopBeginNode''isSimpleLoop-1 [#_"LoopBeginNode" this]
        (= (:loopType this) LoopType'SIMPLE_LOOP)
    )

    (§ method! #_"LoopBeginNode" LoopBeginNode''setPreLoop-1 [#_"LoopBeginNode" this]
        (assoc this :loopType LoopType'PRE_LOOP)
    )

    #_unused
    (§ method! #_"boolean" LoopBeginNode''isPreLoop-1 [#_"LoopBeginNode" this]
        (= (:loopType this) LoopType'PRE_LOOP)
    )

    (§ method! #_"LoopBeginNode" LoopBeginNode''setMainLoop-1 [#_"LoopBeginNode" this]
        (assoc this :loopType LoopType'MAIN_LOOP)
    )

    (§ method! #_"boolean" LoopBeginNode''isMainLoop-1 [#_"LoopBeginNode" this]
        (= (:loopType this) LoopType'MAIN_LOOP)
    )

    (§ method! #_"LoopBeginNode" LoopBeginNode''setPostLoop-1 [#_"LoopBeginNode" this]
        (assoc this :loopType LoopType'POST_LOOP)
    )

    #_unused
    (§ method! #_"boolean" LoopBeginNode''isPostLoop-1 [#_"LoopBeginNode" this]
        (= (:loopType this) LoopType'POST_LOOP)
    )

    (§ method! #_"LoopBeginNode" LoopBeginNode''setUnrollFactor-2 [#_"LoopBeginNode" this, #_"int" currentUnrollFactor]
        (assoc this :unrollFactor currentUnrollFactor)
    )

    ;;;
     ; Disables safepoint for the whole loop, i.e. for all {@link LoopEndNode loop ends}.
     ;;
    (§ method! #_"LoopBeginNode" LoopBeginNode''disableSafepoint-1 [#_"LoopBeginNode" this]
        ;; Store flag locally in case new loop ends are created later on.
        (let [
            this (assoc this :canEndsSafepoint false)
        ]
            ;; Propagate flag to all existing loop ends.
            (doseq [#_"LoopEndNode" loopEnd (LoopBeginNode''loopEnds-1 this)]
                (§ ass! loopEnd (LoopEndNode''disableSafepoint-1 loopEnd))
            )
            this
        )
    )

    (§ method! #_"LoopBeginNode" LoopBeginNode''setLoopOrigFrequency-2 [#_"LoopBeginNode" this, #_"double" loopOrigFrequency]
        (assoc this :loopOrigFrequency loopOrigFrequency)
    )

    (§ method! #_"LoopBeginNode" LoopBeginNode''setLoopFrequency-2 [#_"LoopBeginNode" this, #_"double" loopFrequency]
        (assoc this :loopFrequency loopFrequency)
    )

    ;;;
     ; Returns the <b>unordered</b> set of LoopEndNode that correspond to back-edges for
     ; this loop. The order of the back-edges is unspecified, if you need to get an ordering
     ; compatible for PhiNode creation, use #orderedLoopEnds().
     ;
     ; @return the set of LoopEndNode that correspond to back-edges for this loop
     ;;
    (§ method! #_"NodeIterable<LoopEndNode>" LoopBeginNode''loopEnds-1 [#_"LoopBeginNode" this]
        (NodeIterable''filter-2 (Node''usages-1 this), LoopEndNode)
    )

    (§ method! #_"NodeIterable<LoopExitNode>" LoopBeginNode''loopExits-1 [#_"LoopBeginNode" this]
        (NodeIterable''filter-2 (Node''usages-1 this), LoopExitNode)
    )

    #_unused
    (§ override! #_"NodeIterable<Node>" LoopBeginNode''anchored-1 [#_"LoopBeginNode" this]
        (NodeIterable''filter-2 (AbstractMergeNode''anchored-1 (§ super )), (NegativeTypePredicate''nor-2 (NegativeTypePredicate'new-1 LoopEndNode), LoopExitNode))
    )

    ;;;
     ; Returns the set of LoopEndNode that correspond to back-edges for this loop, in increasing
     ; #phiPredecessorIndex order. This method is suited to create new loop PhiNode.
     ;
     ; For example a new PhiNode may be added as follow:
     ;
     ; PhiNode phi = ValuePhiNode'new(stamp, loop);
     ; phi.addInput(forwardEdgeValue);
     ; for (LoopEndNode loopEnd : loop.orderedLoopEnds()) {
     ;     phi.addInput(backEdgeValue(loopEnd));
     ; }
     ;
     ; @return the set of LoopEndNode that correspond to back-edges for this loop
     ;;
    (§ method! #_"LoopEndNode[]" LoopBeginNode''orderedLoopEnds-1 [#_"LoopBeginNode" this]
        (let [
            #_"LoopEndNode[]" result (make-array LoopEndNode (:nextEndIndex this))
        ]
            (doseq [#_"LoopEndNode" end (LoopBeginNode''loopEnds-1 this)]
                (aset result (:endIndex end) end)
            )
            result
        )
    )

    #_unused
    (§ method! #_"boolean" LoopBeginNode''isSingleEntryLoop-1 [#_"LoopBeginNode" this]
        (= (AbstractMergeNode''forwardEndCount-1 this) 1)
    )

    (§ method! #_"AbstractEndNode" LoopBeginNode''forwardEnd-1 [#_"LoopBeginNode" this]
        (AbstractMergeNode''forwardEndAt-2 this, 0)
    )

    (§ method! #_"LoopBeginNode" LoopBeginNode''incrementSplits-1 [#_"LoopBeginNode" this]
        (update this :splits inc)
    )

    #_unused
    (§ override! #_"void" LoopBeginNode''generate-2 [#_"LoopBeginNode" this, #_"LIRBuilder" builder]
        ;; Nothing to emit, since this is node is used for structural purposes only.
        nil
    )

    #_unused
    (§ override! #_"void" LoopBeginNode''deleteEnd-2 [#_"LoopBeginNode" this, #_"AbstractEndNode" end]
        (when (instance? LoopEndNode end) => (AbstractMergeNode''deleteEnd-2 (§ super ), end)
            (§ ass! end (LoopEndNode''setLoopBegin-2 end, nil))
            (let [
                #_"int" i (:endIndex end)
            ]
                (doseq [#_"LoopEndNode" e (LoopBeginNode''loopEnds-1 this)]
                    (let [
                        #_"int" j (:endIndex e)
                    ]
                        (when (< i j)
                            (§ ass! e (LoopEndNode''setEndIndex-2 e, (dec j)))
                        )
                    )
                )
                (§ ass! this (update this :nextEndIndex dec))
            )
        )
        nil
    )

    (§ override! #_"int" LoopBeginNode''phiPredecessorCount-1 [#_"LoopBeginNode" this]
        (+ (AbstractMergeNode''forwardEndCount-1 this) (NodeIterable''count-1 (LoopBeginNode''loopEnds-1 this)))
    )

    (§ override! #_"int" LoopBeginNode''phiPredecessorIndex-2 [#_"LoopBeginNode" this, #_"AbstractEndNode" pred]
        (when (instance? LoopEndNode pred) => (AbstractMergeNode''forwardEndIndex-2 (§ super ), pred)
            (when (= (:loopBegin pred) this) => (throw! "should not reach here")
                (+ (:endIndex pred) (AbstractMergeNode''forwardEndCount-1 this))
            )
        )
    )

    #_unused
    (§ override! #_"AbstractEndNode" LoopBeginNode''phiPredecessorAt-2 [#_"LoopBeginNode" this, #_"int" index]
        (if (< index (AbstractMergeNode''forwardEndCount-1 this))
            (AbstractMergeNode''forwardEndAt-2 this, index)
            (loop-when [#_"ISeq" s (seq (LoopBeginNode''loopEnds-1 this))] (some? s) => (throw! "should not reach here")
                (let [
                    #_"LoopEndNode" end (first s)
                ]
                    (if (= (:endIndex end) (- index (AbstractMergeNode''forwardEndCount-1 this)))
                        end
                        (recur (next s))
                    )
                )
            )
        )
    )

    (§ method! #_"int" LoopBeginNode''nextEndIndex-1 [#_"LoopBeginNode" this]
        (let [
            _ (:nextEndIndex this)
        ]
            (§ ass! this (update this :nextEndIndex inc))
            _
        )
    )

    (§ method! #_"LoopBeginNode" LoopBeginNode''incrementUnswitches-1 [#_"LoopBeginNode" this]
        (update this :unswitches inc)
    )

    #_unused
    (§ method! #_"LoopBeginNode" LoopBeginNode''setInversionCount-2 [#_"LoopBeginNode" this, #_"int" count]
        (assoc this :inversionCount count)
    )

    #_unused
    (§ override! #_"void" LoopBeginNode''simplify-2 [#_"LoopBeginNode" this, #_"SimplifierTool" tool]
        (LoopBeginNode''canonicalizePhis-2 this, tool)
        nil
    )

    (§ method! #_"boolean" LoopBeginNode''isLoopExit-2 [#_"LoopBeginNode" this, #_"AbstractBeginNode" begin]
        (and (instance? LoopExitNode begin) (= (:loopBegin begin) this))
    )

    (§ method! #_"LoopExitNode" LoopBeginNode''getSingleLoopExit-1 [#_"LoopBeginNode" this]
        (NodeIterable''first-1 (LoopBeginNode''loopExits-1 this))
    )

    (§ method! #_"LoopEndNode" LoopBeginNode''getSingleLoopEnd-1 [#_"LoopBeginNode" this]
        (NodeIterable''first-1 (LoopBeginNode''loopEnds-1 this))
    )

    (§ method! #_"void" LoopBeginNode''removeExits-1 [#_"LoopBeginNode" this]
        (doseq [#_"LoopExitNode" loopexit (NodeIterable''snapshot-1 (LoopBeginNode''loopExits-1 this))]
            (LoopExitNode''removeProxies-1 loopexit)
            (let [
                #_"FrameState" loopStateAfter (BeginStateSplitNode''stateAfter-1 loopexit)
            ]
                (§ ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), loopexit, (Graph''add-2 (:graph this), (BeginNode'new-0))))
                (when (some? loopStateAfter)
                    (GraphUtil'tryKillUnused-1 loopStateAfter)
                )
            )
        )
        nil
    )

    (§ method! #_"LoopBeginNode" LoopBeginNode''setOverflowGuard-2 [#_"LoopBeginNode" this, #_"GuardingNode" overflowGuard]
        (Node''updateUsages-3 this, (:overflowGuard this), overflowGuard)
        (assoc this :overflowGuard overflowGuard)
    )

    (§ def- #_"int" LoopBeginNode'NO_INCREMENT Integer/MIN_VALUE)

    ;;;
     ; Returns an array with one entry for each input of the phi, which is either #NO_INCREMENT
     ; or the increment, i.e. the value by which the phi is incremented in the corresponding branch.
     ;;
    (§ defn- #_"int[]" LoopBeginNode'getSelfIncrements-1 [#_"PhiNode" phi]
        (let [
            #_"int[]" selfIncrement (int-array (PhiNode''valueCount-1 phi))
        ]
            (loop-when-recur [#_"int" i 0] (< i (PhiNode''valueCount-1 phi)) [(inc i)]
                (let [
                    #_"ValueNode" input (PhiNode''valueAt-2 phi, i)
                    #_"long" increment
                        (cond
                            (and (some? input) (instance? AddNode input) (instance? IntegerStamp (:stamp input)))
                                (cond
                                    (and (= (:x input) phi) (instance? ConstantNode (:y input)))
                                        (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:y input)))
                                    (and (= (:y input) phi) (instance? ConstantNode (:x input)))
                                        (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:x input)))
                                    :else
                                        LoopBeginNode'NO_INCREMENT
                                )
                            (= input phi)
                                0
                            :else
                                LoopBeginNode'NO_INCREMENT
                        )
                    increment
                        (when-not (<= Integer/MIN_VALUE increment Integer/MAX_VALUE) => increment
                            LoopBeginNode'NO_INCREMENT
                        )
                ]
                    (aset selfIncrement i (int increment))
                )
            )
            selfIncrement
        )
    )

    ;;;
     ; Coalesces loop phis that represent the same value (which is not handled by normal Global Value Numbering).
     ;;
    (§ method! #_"void" LoopBeginNode''canonicalizePhis-2 [#_"LoopBeginNode" this, #_"SimplifierTool" tool]
        (let [
            #_"int" phiCount (NodeIterable''count-1 (AbstractMergeNode''phis-1 this))
        ]
            (when (< 1 phiCount)
                (let [
                    #_"int" phiInputCount (LoopBeginNode''phiPredecessorCount-1 this)
                    #_"int[][]" selfIncrement (ß new int[phiCount][])
                    #_"PhiNode[]" phis (#_"List" .toArray (NodeIterable''snapshot-1 (AbstractMergeNode''phis-1 this)), (make-array PhiNode phiCount))
                ]
                    (loop-when-recur [#_"int" phiIndex 0] (< phiIndex phiCount) [(inc phiIndex)]
                        (let [
                            #_"PhiNode" phi (nth phis phiIndex)
                        ]
                            (when (some? phi)
                                (§ label nextPhi)
                                (loop-when-recur [#_"int" otherPhiIndex (inc phiIndex)] (< otherPhiIndex phiCount) [(inc otherPhiIndex)]
                                    (let [
                                        #_"PhiNode" otherPhi (nth phis otherPhiIndex)
                                    ]
                                        (when (and (some? otherPhi) (= (:nodeClass phi) (:nodeClass otherPhi)) (Node''valueEquals-2 phi, otherPhi))
                                            (when (nil? (nth selfIncrement phiIndex))
                                                (aset selfIncrement phiIndex (LoopBeginNode'getSelfIncrements-1 phi))
                                            )
                                            (when (nil? (nth selfIncrement otherPhiIndex))
                                                (aset selfIncrement otherPhiIndex (LoopBeginNode'getSelfIncrements-1 otherPhi))
                                            )
                                            (let [
                                                #_"int[]" phiIncrement (nth selfIncrement phiIndex)
                                                #_"int[]" otherPhiIncrement (nth selfIncrement otherPhiIndex)
                                            ]
                                                (loop-when-recur [#_"int" inputIndex 0] (< inputIndex phiInputCount) [(inc inputIndex)]
                                                    (when (= (nth phiIncrement inputIndex) LoopBeginNode'NO_INCREMENT)
                                                        (when-not (= (PhiNode''valueAt-2 phi, inputIndex) (PhiNode''valueAt-2 otherPhi, inputIndex))
                                                            (§ continue nextPhi)
                                                        )
                                                    )
                                                    (when-not (= (nth phiIncrement inputIndex) (nth otherPhiIncrement inputIndex))
                                                        (§ continue nextPhi)
                                                    )
                                                )
                                                (when (some? tool)
                                                    (SimplifierTool''addToWorkList-2 tool, (Node''usages-1 otherPhi))
                                                )
                                                (§ ass! otherPhi (Node''replaceAtUsages-2 otherPhi, phi))
                                                (GraphUtil'killWithUnusedFloatingInputs-1 otherPhi)
                                                (aset phis otherPhiIndex nil)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; @anno LoopBeginNode.LoopType
 ;;
(value-ns LoopType
    (§ enum LoopType'SIMPLE_LOOP)
    (§ enum LoopType'PRE_LOOP)
    (§ enum LoopType'MAIN_LOOP)
    (§ enum LoopType'POST_LOOP)
)

;;;
 ; LoopEnd nodes represent a loop back-edge. When a LoopEnd is reached, execution continues at the
 ; {@linkplain #loopBegin() loop header}.
 ;;
(final-ns LoopEndNode (§ extends AbstractEndNode)
    (§ def #_"NodeClass<LoopEndNode>" LoopEndNode'TYPE (NodeClass'create-1 LoopEndNode))

    ;; The declared type of the field cannot be LoopBeginNode, because loop explosion during partial
    ;; evaluation can temporarily assign a non-loop begin. This node will then be deleted shortly
    ;; after - but we still must not have type system violations for that short amount of time.
    ; @Input(InputType'Association)
    (§ mutable #_"AbstractBeginNode" :loopBegin nil)
    ;;;
     ; The index of this loop end amongst its LoopBeginNode's loop ends.
     ;
     ; Since a LoopBeginNode also has {@linkplain LoopBeginNode#forwardEnds() forward ends},
     ; this is *not* the index into PhiNode values at the loop begin.
     ; Use LoopBeginNode#phiPredecessorIndex(AbstractEndNode) for this purpose.
     ;;
    (§ mutable #_"int" :endIndex 0)

    ;;;
     ; Most loop ends need a safepoint (flag set to true) so that garbage collection can interrupt
     ; a long-running (possibly endless) loop. Safepoints may be disabled for two reasons: (1) Some
     ; code must be safepoint free, i.e. uninterruptible by garbage collection. (2) An optimization
     ; phase determined that the loop already has another safepoint or cannot be endless, so there
     ; is no need for a loop-end safepoint.
     ;
     ; Note that (1) is a hard correctness issue: emitting a safepoint in uninterruptible code is a bug,
     ; i.e. it is not allowed to set the flag back to true once it is false. To ensure that loop ends
     ; that are created late, e.g. during control flow simplifications, have no safepoints in such cases,
     ; the safepoints are actually disabled for the {@link LoopBeginNode#canEndsSafepoint loop begin}.
     ; New loop ends inherit the flag value from the loop begin.
     ;;
    (§ mutable #_"boolean" :canSafepoint false)

    (§ defn #_"LoopEndNode" LoopEndNode'new-1 [#_"LoopBeginNode" begin]
        (let [
            #_"LoopEndNode" this (AbstractEndNode'new-1 LoopEndNode'TYPE)
            this (assoc this :endIndex (LoopBeginNode''nextEndIndex-1 begin))
            this (assoc this :loopBegin begin)
            this (assoc this :canSafepoint (:canEndsSafepoint begin))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"AbstractMergeNode" LoopEndNode''merge-1 [#_"LoopEndNode" this]
        (:loopBegin this)
    )

    (§ method! #_"LoopEndNode" LoopEndNode''setLoopBegin-2 [#_"LoopEndNode" this, #_"LoopBeginNode" loopBegin]
        (Node''updateUsages-3 this, (:loopBegin this), loopBegin)
        (assoc this :loopBegin loopBegin)
    )

    ;;;
     ; Disables safepoints for only this loop end (in contrast to disabling it for
     ; {@link LoopBeginNode#disableSafepoint() the whole loop}).
     ;;
    (§ method! #_"LoopEndNode" LoopEndNode''disableSafepoint-1 [#_"LoopEndNode" this]
        (assoc this :canSafepoint false)
    )

    #_unused
    (§ override! #_"void" LoopEndNode''generate-2 [#_"LoopEndNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''visitLoopEnd-2 builder, this)
        (AbstractEndNode''generate-2 (§ super ), builder)
        nil
    )

    (§ method! #_"LoopEndNode" LoopEndNode''setEndIndex-2 [#_"LoopEndNode" this, #_"int" idx]
        (assoc this :endIndex idx)
    )

    #_unused
    (§ override! #_"Iterable<? extends Node>" LoopEndNode''cfgSuccessors-1 [#_"LoopEndNode" this]
        (Collections/emptyList)
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Association"
(final-ns LoopExitNode (§ extends BeginStateSplitNode) (§ implements IterableNodeType, Simplifiable)
    (§ def #_"NodeClass<LoopExitNode>" LoopExitNode'TYPE (NodeClass'create-1 LoopExitNode))

    ;; The declared type of the field cannot be LoopBeginNode, because loop explosion during partial
    ;; evaluation can temporarily assign a non-loop begin. This node will then be deleted shortly
    ;; after - but we still must not have type system violations for that short amount of time.
    ; @Input(InputType'Association)
    (§ mutable #_"AbstractBeginNode" :loopBegin nil)

    (§ defn #_"LoopExitNode" LoopExitNode'new-1 [#_"LoopBeginNode" loop]
        (let [
            #_"LoopExitNode" this (BeginStateSplitNode'new-1 LoopExitNode'TYPE)
            this (assoc this :loopBegin loop)
        ]
            this
        )
    )

    (§ override! #_"NodeIterable<Node>" LoopExitNode''anchored-1 [#_"LoopExitNode" this]
        (-> (AbstractBeginNode''anchored-1 (§ super )) (NodeIterable''filter-2 (ß node ->
            (§ fun
                (not (and (instance? ProxyNode node) (= (:loopExit node) this)))
            )
        )))
    )

    #_unused
    (§ override! #_"void" LoopExitNode''prepareDelete-2 [#_"LoopExitNode" this, #_"FixedNode" evacuateFrom]
        (LoopExitNode''removeProxies-1 this)
        (AbstractBeginNode''prepareDelete-2 (§ super ), evacuateFrom)
        nil
    )

    (§ method! #_"void" LoopExitNode''removeProxies-1 [#_"LoopExitNode" this]
        (when (Node''hasUsages-1 this)
            (while
                (loop-when [#_"ISeq" s (seq (NodeIterable''snapshot-1 (LoopExitNode''proxies-1 this)))] (some? s)
                    (let [
                        #_"ProxyNode" vpn (first s)
                        #_"ValueNode" value (ProxyNode''value-1 vpn)
                    ]
                        (Node''replaceAtUsagesAndDelete-2 vpn, value)
                        ;; Guard proxy could have this input as value.
                        (or (= value this) (recur (next s)))
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"NodeIterable<ProxyNode>" LoopExitNode''proxies-1 [#_"LoopExitNode" this]
        (-> (Node''usages-1 this) (NodeIterable''filter-2 (ß node ->
            (§ fun
                (and (instance? ProxyNode node) (= (:loopExit node) this))
            )
        )))
    )

    #_unused
    (§ override! #_"void" LoopExitNode''simplify-2 [#_"LoopExitNode" this, #_"SimplifierTool" tool]
        (loop-when [#_"Node" pred (:predecessor this)] (and (CanonicalizerTool''allUsagesAvailable-1 tool) (instance? BeginNode pred) (Node''hasNoUsages-1 pred))
            (let [
                #_"AbstractBeginNode" begin pred
                pred (:predecessor pred)
            ]
                (Graph''removeFixed-2 (:graph this), begin)
                (recur pred)
            )
        )
        nil
    )
)

(class-ns LoweredCallTargetNode (§ extends CallTargetNode)
    (§ def #_"NodeClass<LoweredCallTargetNode>" LoweredCallTargetNode'TYPE (NodeClass'create-1 LoweredCallTargetNode))

    (§ final #_"JavaType[]" :signature nil)
    (§ final #_"CallingConvention$Type" :callType nil)

    (§ defn #_"LoweredCallTargetNode" LoweredCallTargetNode'new-7 [#_"NodeClass<? extends LoweredCallTargetNode>" c, #_"ValueNode[]" arguments, #_"StampPair" returnStamp, #_"JavaType[]" signature, #_"ResolvedJavaMethod" target, #_"CallingConvention$Type" callType, #_"InvokeKind" invokeKind]
        (let [
            #_"LoweredCallTargetNode" this (CallTargetNode'new-5 c, arguments, target, invokeKind, returnStamp)
            this (assoc this :signature signature)
            this (assoc this :callType callType)
        ]
            this
        )
    )

    (§ method! #_"JavaType[]" LoweredCallTargetNode''signature-1 [#_"LoweredCallTargetNode" this]
        (:signature this)
    )

    (§ method! #_"CallingConvention$Type" LoweredCallTargetNode''callType-1 [#_"LoweredCallTargetNode" this]
        (:callType this)
    )
)

;;;
 ; Provides an implementation of StateSplit.
 ;;
(class-ns AbstractMemoryCheckpoint (§ extends AbstractStateSplit) (§ implements MemoryCheckpoint)
    (§ def #_"NodeClass<AbstractMemoryCheckpoint>" AbstractMemoryCheckpoint'TYPE (NodeClass'create-1 AbstractMemoryCheckpoint))

    (§ defn #_"AbstractMemoryCheckpoint" AbstractMemoryCheckpoint'new-2 [#_"NodeClass<? extends AbstractMemoryCheckpoint>" c, #_"Stamp" stamp]
        (AbstractMemoryCheckpoint'new-3 c, stamp, nil)
    )

    (§ defn #_"AbstractMemoryCheckpoint" AbstractMemoryCheckpoint'new-3 [#_"NodeClass<? extends AbstractMemoryCheckpoint>" c, #_"Stamp" stamp, #_"FrameState" stateAfter]
        (AbstractStateSplit'new-3 c, stamp, stateAfter)
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Memory, InputType.Guard"
(class-ns AbstractWriteNode (§ extends FixedAccessNode) (§ implements StateSplit, Single, MemoryAccess, GuardingNode)
    (§ def #_"NodeClass<AbstractWriteNode>" AbstractWriteNode'TYPE (NodeClass'create-1 AbstractWriteNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)
    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)
    ; @OptionalInput(InputType'Memory)
    (§ mutable #_"Node" :lastLocationAccess nil)

    (§ override #_"FrameState" AbstractWriteNode''stateAfter-1 [#_"AbstractWriteNode" this]
        (:stateAfter this)
    )

    (§ override #_"void" AbstractWriteNode''setStateAfter-2 [#_"AbstractWriteNode" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    #_unused
    (§ override #_"boolean" AbstractWriteNode''hasSideEffect-1 [#_"AbstractWriteNode" this]
        true
    )

    (§ method #_"ValueNode" AbstractWriteNode''value-1 [#_"AbstractWriteNode" this]
        (:value this)
    )

    (§ defn #_"AbstractWriteNode" AbstractWriteNode'new-5 [#_"NodeClass<? extends AbstractWriteNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" value, #_"BarrierType" barrierType]
        (let [
            #_"AbstractWriteNode" this (FixedAccessNode'new-5 c, address, location, (StampFactory'forVoid-0), barrierType)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" AbstractWriteNode''isAllowedUsageType-2 [#_"AbstractWriteNode" this, #_"InputType" type]
        (or (and (= type InputType'Guard) (:nullCheck this)) (Node''isAllowedUsageType-2 (§ super ), type))
    )

    (§ override #_"void" AbstractWriteNode''setLastLocationAccess-2 [#_"AbstractWriteNode" this, #_"MemoryNode" lla]
        (Node''updateUsages-3 this, (:lastLocationAccess this), lla)
        (§ ass! this (assoc this :lastLocationAccess lla))
        nil
    )
)

(§ interface Access (§ extends GuardedNode, HeapAccess)
    (§ abstract #_"AddressNode" Access''getAddress-1 [#_"Access" this])

    #_unused
    (§ abstract #_"void" Access''setAddress-2 [#_"Access" this, #_"AddressNode" address])

    (§ abstract #_"LocationIdentity" Access''getLocationIdentity-1 [#_"Access" this])

    #_unused
    (§ abstract #_"boolean" Access''canNullCheck-1 [#_"Access" this])
)

;;;
 ; Base class for nodes that deal with addressing calculation.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Association"
(class-ns AddressNode (§ extends FloatingNode) (§ implements IndirectCanonicalization)
    (§ def #_"NodeClass<AddressNode>" AddressNode'TYPE (NodeClass'create-1 AddressNode))

    (§ defn #_"AddressNode" AddressNode'new-1 [#_"NodeClass<? extends AddressNode>" c]
        (FloatingNode'new-2 c, StampFactory'rawPointer)
    )

    (§ abstract #_"ValueNode" AddressNode''getBase-1 [#_"AddressNode" this])

    (§ abstract #_"ValueNode" AddressNode''getIndex-1 [#_"AddressNode" this])

    ;;;
     ; Constant that is the maximum displacement from the base and index for this address. This value
     ; is used to determine whether using the access as an implicit nil-check on the base is valid.
     ;
     ; @return the maximum distance in bytes from the base that this address can be
     ;;
    (§ abstract #_"long" AddressNode''getMaxConstantDisplacement-1 [#_"AddressNode" this])
)

;;;
 ; @anno AddressNode.Address
 ;;
(final-ns Address (§ extends Association)
    #_unused
    (§ defn #_"Address" Address'new-0 []
        (Association'new-0)
    )
)

;;;
 ; Represents an address that is composed of a base and an offset. The base can be either a
 ; JavaKind#Object, a word-sized integer or another pointer. The offset must be a word-sized integer.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Association"
(final-ns OffsetAddressNode (§ extends AddressNode) (§ implements Canonicalizable)
    (§ def #_"NodeClass<OffsetAddressNode>" OffsetAddressNode'TYPE (NodeClass'create-1 OffsetAddressNode))

    ; @Input
    (§ mutable #_"ValueNode" :base nil)
    ; @Input
    (§ mutable #_"ValueNode" :offset nil)

    (§ defn #_"OffsetAddressNode" OffsetAddressNode'new-2 [#_"ValueNode" base, #_"ValueNode" offset]
        (let [
            #_"OffsetAddressNode" this (AddressNode'new-1 OffsetAddressNode'TYPE)
            this (assoc this :base base)
            this (assoc this :offset offset)
        ]
            this
        )
    )

    (§ defn #_"OffsetAddressNode" OffsetAddressNode'create-1 [#_"ValueNode" base]
        (OffsetAddressNode'new-2 base, (ConstantNode'forIntegerBits-2 (PrimitiveStamp'getBits-1 (:stamp base)), 0))
    )

    (§ override! #_"ValueNode" OffsetAddressNode''getBase-1 [#_"OffsetAddressNode" this]
        (:base this)
    )

    #_unused
    (§ method! #_"OffsetAddressNode" OffsetAddressNode''setBase-2 [#_"OffsetAddressNode" this, #_"ValueNode" base]
        (Node''updateUsages-3 this, (:base this), base)
        (assoc this :base base)
    )

    #_unused
    (§ method! #_"OffsetAddressNode" OffsetAddressNode''setOffset-2 [#_"OffsetAddressNode" this, #_"ValueNode" offset]
        (Node''updateUsages-3 this, (:offset this), offset)
        (assoc this :offset offset)
    )

    #_unused
    (§ override! #_"Node" OffsetAddressNode''canonical-2 [#_"OffsetAddressNode" this, #_"CanonicalizerTool" tool]
        (condp instance? (:base this)
            OffsetAddressNode
                ;; Rewrite (&base[offset1])[offset2] to base[offset1 + offset2].
                (OffsetAddressNode'new-2 (OffsetAddressNode''getBase-1 (:base this)), (BinaryArithmeticNode'add-2 (:offset (:base this)), (:offset this)))
            AddNode
                (if (instance? ConstantNode (:y (:base this)))
                    (OffsetAddressNode'new-2 (:x (:base this)), (AddNode'new-2 (:y (:base this)), (:offset this)))
                    this
                )
            this
        )
    )

    ; @NodeIntrinsic
    (§ native #_"Address" OffsetAddressNode'address-2 [#_"Object" base, #_"long" offset])

    #_unused
    (§ override! #_"long" OffsetAddressNode''getMaxConstantDisplacement-1 [#_"OffsetAddressNode" this]
        (let [
            #_"Stamp" stamp (:stamp (:offset this))
        ]
            (if (and (instance? IntegerStamp stamp) (<= 0 (:lowerBound stamp))) (:upperBound stamp) Long/MAX_VALUE)
        )
    )

    #_unused
    (§ override! #_"ValueNode" OffsetAddressNode''getIndex-1 [#_"OffsetAddressNode" this]
        nil
    )
)

;;;
 ; Accesses a value at an memory address specified by an {@linkplain #address address}. The access
 ; does not include a nil-check on the object.
 ;;
(class-ns FixedAccessNode (§ extends DeoptimizingFixedWithNextNode) (§ implements Access, IterableNodeType)
    (§ def #_"NodeClass<FixedAccessNode>" FixedAccessNode'TYPE (NodeClass'create-1 FixedAccessNode))

    ; @OptionalInput(InputType'Guard)
    (§ mutable #_"GuardingNode" :guard nil)

    ; @Input(InputType'Association)
    (§ mutable #_"AddressNode" :address nil)
    (§ final #_"LocationIdentity" :location nil)

    (§ mutable #_"boolean" :nullCheck false)
    (§ mutable #_"BarrierType" :barrierType nil)

    (§ override #_"AddressNode" FixedAccessNode''getAddress-1 [#_"FixedAccessNode" this]
        (:address this)
    )

    #_unused
    (§ override #_"void" FixedAccessNode''setAddress-2 [#_"FixedAccessNode" this, #_"AddressNode" address]
        (Node''updateUsages-3 this, (:address this), address)
        (§ ass! this (assoc this :address address))
        nil
    )

    (§ override #_"LocationIdentity" FixedAccessNode''getLocationIdentity-1 [#_"FixedAccessNode" this]
        (:location this)
    )

    (§ method! #_"FixedAccessNode" FixedAccessNode''setNullCheck-2 [#_"FixedAccessNode" this, #_"boolean" check]
        (assoc this :nullCheck check)
    )

    (§ defn #_"FixedAccessNode" FixedAccessNode'new-4 [#_"NodeClass<? extends FixedAccessNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp]
        (FixedAccessNode'new-5 c, address, location, stamp, BarrierType'NONE)
    )

    (§ defn #_"FixedAccessNode" FixedAccessNode'new-5 [#_"NodeClass<? extends FixedAccessNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"BarrierType" barrierType]
        (FixedAccessNode'new-8 c, address, location, stamp, nil, barrierType, false, nil)
    )

    (§ defn #_"FixedAccessNode" FixedAccessNode'new-8 [#_"NodeClass<? extends FixedAccessNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"GuardingNode" guard, #_"BarrierType" barrierType, #_"boolean" nullCheck, #_"FrameState" stateBefore]
        (let [
            #_"FixedAccessNode" this (DeoptimizingFixedWithNextNode'new-3 c, stamp, stateBefore)
            this (assoc this :address address)
            this (assoc this :location location)
            this (assoc this :guard guard)
            this (assoc this :barrierType barrierType)
            this (assoc this :nullCheck nullCheck)
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" FixedAccessNode''canDeoptimize-1 [#_"FixedAccessNode" this]
        (:nullCheck this)
    )

    (§ override #_"GuardingNode" FixedAccessNode''getGuard-1 [#_"FixedAccessNode" this]
        (:guard this)
    )

    (§ override #_"void" FixedAccessNode''setGuard-2 [#_"FixedAccessNode" this, #_"GuardingNode" guard]
        (Node''updateUsages-3 this, (:guard this), guard)
        (§ ass! this (assoc this :guard guard))
        nil
    )

    (§ override #_"BarrierType" FixedAccessNode''getBarrierType-1 [#_"FixedAccessNode" this]
        (:barrierType this)
    )
)

;;;
 ; An FixedAccessNode that can be converted to a FloatingAccessNode.
 ;;
(class-ns FloatableAccessNode (§ extends FixedAccessNode)
    (§ def #_"NodeClass<FloatableAccessNode>" FloatableAccessNode'TYPE (NodeClass'create-1 FloatableAccessNode))

    #_unused
    (§ defn #_"FloatableAccessNode" FloatableAccessNode'new-4 [#_"NodeClass<? extends FloatableAccessNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp]
        (FixedAccessNode'new-4 c, address, location, stamp)
    )

    #_unused
    (§ defn #_"FloatableAccessNode" FloatableAccessNode'new-6 [#_"NodeClass<? extends FloatableAccessNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"GuardingNode" guard, #_"BarrierType" barrierType]
        (FixedAccessNode'new-8 c, address, location, stamp, guard, barrierType, false, nil)
    )

    (§ defn #_"FloatableAccessNode" FloatableAccessNode'new-8 [#_"NodeClass<? extends FloatableAccessNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"GuardingNode" guard, #_"BarrierType" barrierType, #_"boolean" nullCheck, #_"FrameState" stateBefore]
        (FixedAccessNode'new-8 c, address, location, stamp, guard, barrierType, nullCheck, stateBefore)
    )

    (§ abstract #_"FloatingAccessNode" FloatableAccessNode''asFloatingNode-2 [#_"FloatableAccessNode" this, #_"MemoryNode" lastLocationAccess])

    (§ mutable #_"boolean" :forceFixed false)

    (§ method! #_"FloatableAccessNode" FloatableAccessNode''setForceFixed-2 [#_"FloatableAccessNode" this, #_"boolean" flag]
        (assoc this :forceFixed flag)
    )

    ;;;
     ; AccessNodes can float only if their location identities are not ANY_LOCATION. Furthermore, in
     ; case G1 is enabled any access (read) to the java.lang.ref.Reference.referent field which has
     ; an attached write barrier with pre-semantics can not also float.
     ;;
    (§ method! #_"boolean" FloatableAccessNode''canFloat-1 [#_"FloatableAccessNode" this]
        (and (not (:forceFixed this)) (#_"LocationIdentity" .isSingle (FixedAccessNode''getLocationIdentity-1 this)) (= (FixedAccessNode''getBarrierType-1 this) BarrierType'NONE))
    )
)

(class-ns FloatingAccessNode (§ extends FloatingGuardedNode) (§ implements Access, MemoryAccess)
    (§ def #_"NodeClass<FloatingAccessNode>" FloatingAccessNode'TYPE (NodeClass'create-1 FloatingAccessNode))

    ; @Input(InputType'Association)
    (§ mutable #_"AddressNode" :address nil)
    (§ final #_"LocationIdentity" :location nil)

    (§ mutable #_"BarrierType" :barrierType nil)

    #_unused
    (§ defn #_"FloatingAccessNode" FloatingAccessNode'new-4 [#_"NodeClass<? extends FloatingAccessNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp]
        (let [
            #_"FloatingAccessNode" this (FloatingGuardedNode'new-2 c, stamp)
            this (assoc this :address address)
            this (assoc this :location location)
        ]
            this
        )
    )

    (§ defn #_"FloatingAccessNode" FloatingAccessNode'new-6 [#_"NodeClass<? extends FloatingAccessNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"GuardingNode" guard, #_"BarrierType" barrierType]
        (let [
            #_"FloatingAccessNode" this (FloatingGuardedNode'new-3 c, stamp, guard)
            this (assoc this :address address)
            this (assoc this :location location)
            this (assoc this :barrierType barrierType)
        ]
            this
        )
    )

    (§ override #_"AddressNode" FloatingAccessNode''getAddress-1 [#_"FloatingAccessNode" this]
        (:address this)
    )

    #_unused
    (§ override #_"void" FloatingAccessNode''setAddress-2 [#_"FloatingAccessNode" this, #_"AddressNode" address]
        (Node''updateUsages-3 this, (:address this), address)
        (§ ass! this (assoc this :address address))
        nil
    )

    (§ override #_"LocationIdentity" FloatingAccessNode''getLocationIdentity-1 [#_"FloatingAccessNode" this]
        (:location this)
    )

    (§ override #_"BarrierType" FloatingAccessNode''getBarrierType-1 [#_"FloatingAccessNode" this]
        (:barrierType this)
    )

    #_unused
    (§ override #_"boolean" FloatingAccessNode''canNullCheck-1 [#_"FloatingAccessNode" this]
        true
    )

    (§ abstract #_"FixedAccessNode" FloatingAccessNode''asFixedNode-1 [#_"FloatingAccessNode" this])
)

;;;
 ; A floating read of a value from memory specified in terms of an object base and an object
 ; relative location. This node does not nil-check the object.
 ;;
(final-ns FloatingReadNode (§ extends FloatingAccessNode) (§ implements LIRLowerableAccess, Canonicalizable)
    (§ def #_"NodeClass<FloatingReadNode>" FloatingReadNode'TYPE (NodeClass'create-1 FloatingReadNode))

    ; @OptionalInput(InputType'Memory)
    (§ mutable #_"MemoryNode" :lastLocationAccess nil)

    #_unused
    (§ defn #_"FloatingReadNode" FloatingReadNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"MemoryNode" lastLocationAccess, #_"Stamp" stamp]
        (FloatingReadNode'new-6 address, location, lastLocationAccess, stamp, nil, BarrierType'NONE)
    )

    (§ defn #_"FloatingReadNode" FloatingReadNode'new-5 [#_"AddressNode" address, #_"LocationIdentity" location, #_"MemoryNode" lastLocationAccess, #_"Stamp" stamp, #_"GuardingNode" guard]
        (FloatingReadNode'new-6 address, location, lastLocationAccess, stamp, guard, BarrierType'NONE)
    )

    (§ defn #_"FloatingReadNode" FloatingReadNode'new-6 [#_"AddressNode" address, #_"LocationIdentity" location, #_"MemoryNode" lastLocationAccess, #_"Stamp" stamp, #_"GuardingNode" guard, #_"BarrierType" barrierType]
        (let [
            #_"FloatingReadNode" this (FloatingAccessNode'new-6 FloatingReadNode'TYPE, address, location, stamp, guard, barrierType)
            this (assoc this :lastLocationAccess lastLocationAccess)
        ]
            ;; The input to floating reads must be always non-nil or have at least a guard.
            this
        )
    )

    #_unused
    (§ override! #_"void" FloatingReadNode''setLastLocationAccess-2 [#_"FloatingReadNode" this, #_"MemoryNode" newlla]
        (Node''updateUsages-3 this, (:lastLocationAccess this), newlla)
        (§ ass! this (assoc this :lastLocationAccess newlla))
        nil
    )

    #_unused
    (§ override! #_"void" FloatingReadNode''generate-2 [#_"FloatingReadNode" this, #_"LIRBuilder" builder]
        (let [
            #_"LIRKind" readKind (Stamp''getLIRKind-1 (:stamp this))
        ]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitLoad-3 (:gen builder), readKind, (LIRBuilder''operand-2 builder, (:address this))))
        )
        nil
    )

    #_unused
    (§ override! #_"Node" FloatingReadNode''canonical-2 [#_"FloatingReadNode" this, #_"CanonicalizerTool" tool]
        (let [
            #_"Node" result (ReadNode'canonicalizeRead-4 this, (FloatingAccessNode''getAddress-1 this), (FloatingAccessNode''getLocationIdentity-1 this), tool)
        ]
            (when (= result this) => result
                (when (and (CanonicalizerTool''canonicalizeReads-1 tool) (Node''hasMoreThanOneUsage-1 (FloatingAccessNode''getAddress-1 this)) (instance? WriteNode (:lastLocationAccess this))) => this
                    (let [
                        #_"WriteNode" write (:lastLocationAccess this)
                    ]
                        (when (and (= (FixedAccessNode''getAddress-1 write) (FloatingAccessNode''getAddress-1 this)) (Stamp''isCompatible-2 (WriteNode''getAccessStamp-1 write), (FloatingReadNode''getAccessStamp-1 this))) => this
                            ;; same memory location with no intervening write
                            (AbstractWriteNode''value-1 write)
                        )
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"FixedAccessNode" FloatingReadNode''asFixedNode-1 [#_"FloatingReadNode" this]
        (let [
            #_"ReadNode" result (Graph''add-2 (:graph this), (ReadNode'new-4 (FloatingAccessNode''getAddress-1 this), (FloatingAccessNode''getLocationIdentity-1 this), (:stamp this), (FloatingAccessNode''getBarrierType-1 this)))
        ]
            (FixedAccessNode''setGuard-2 result, (FloatingGuardedNode''getGuard-1 this))
            result
        )
    )

    (§ override! #_"Stamp" FloatingReadNode''getAccessStamp-1 [#_"FloatingReadNode" this]
        (:stamp this)
    )
)

;;;
 ; Encapsulates properties of a node describing how it accesses the heap.
 ;;
(§ interface HeapAccess
    ;;;
     ; Gets the write barrier type for that particular access.
     ;;
    #_unused
    (§ abstract #_"BarrierType" HeapAccess''getBarrierType-1 [#_"HeapAccess" this])
)

;;;
 ; The types of (write/read) barriers attached to stores.
 ;
 ; @anno HeapAccess.BarrierType
 ;;
(value-ns BarrierType
    ;;;
     ; Primitive stores which do not necessitate barriers.
     ;;
    (§ enum BarrierType'NONE)
    ;;;
     ; Array object stores which necessitate precise barriers.
     ;;
    (§ enum BarrierType'PRECISE)
    ;;;
     ; Field object stores which necessitate imprecise barriers.
     ;;
    (§ enum BarrierType'IMPRECISE)
)

(§ interface LIRLowerableAccess (§ extends LIRLowerable, Access)
    #_unused
    (§ abstract #_"Stamp" LIRLowerableAccess''getAccessStamp-1 [#_"LIRLowerableAccess" this])
)

;;;
 ; This interface marks nodes that access some memory location, and that have an edge to the last
 ; node that kills this location.
 ;;
(§ interface MemoryAccess
    (§ abstract #_"LocationIdentity" MemoryAccess''getLocationIdentity-1 [#_"MemoryAccess" this])

    ;;;
     ; @param lla the MemoryNode that represents the last kill of the location
     ;;
    (§ abstract #_"void" MemoryAccess''setLastLocationAccess-2 [#_"MemoryAccess" this, #_"MemoryNode" lla])
)

;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns MemoryAnchorNode (§ extends FixedWithNextNode) (§ implements LIRLowerable, MemoryNode, Canonicalizable)
    (§ def #_"NodeClass<MemoryAnchorNode>" MemoryAnchorNode'TYPE (NodeClass'create-1 MemoryAnchorNode))

    (§ defn #_"MemoryAnchorNode" MemoryAnchorNode'new-0 []
        (FixedWithNextNode'new-2 MemoryAnchorNode'TYPE, (StampFactory'forVoid-0))
    )

    #_unused
    (§ override! #_"void" MemoryAnchorNode''generate-2 [#_"MemoryAnchorNode" this, #_"LIRBuilder" builder]
        ;; Nothing to emit, since this node is used for structural purposes only.
        nil
    )

    #_unused
    (§ override! #_"Node" MemoryAnchorNode''canonical-2 [#_"MemoryAnchorNode" this, #_"CanonicalizerTool" tool]
        (when-not (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
            this
        )
    )

    ; @NodeIntrinsic
    #_unused
    (§ native #_"Memory" MemoryAnchorNode'anchor-0 [])
)

;;;
 ; This interface marks subclasses of FixedNode that kill a set of memory locations
 ; represented by location identities (i.e. change a value at one or more locations that belong
 ; to these location identities).
 ;;
(§ interface MemoryCheckpoint (§ extends MemoryNode)
)

;;;
 ; @anno MemoryCheckpoint.Single
 ;;
(§ interface Single (§ extends MemoryCheckpoint)
    ;;;
     ; This method is used to determine which memory location is killed by this node. Returning
     ; the special value LocationIdentity#any() will kill all memory locations.
     ;
     ; @return the identity of the location killed by this node
     ;;
    (§ abstract #_"LocationIdentity" Single''getLocationIdentity-1 [#_"Single" this])
)

;;;
 ; @anno MemoryCheckpoint.Multi
 ;;
(§ interface Multi (§ extends MemoryCheckpoint)
    ;;;
     ; This method is used to determine which set of memory locations is killed by this node.
     ; Returning the special value LocationIdentity#any() will kill all memory locations.
     ;
     ; @return the identities of all locations killed by this node
     ;;
    (§ abstract #_"LocationIdentity[]" Multi''getLocationIdentities-1 [#_"Multi" this])
)

;;;
 ; Maps a location to the last node that (potentially) wrote to the location.
 ;;
(§ interface MemoryMap
    ;;;
     ; Gets the last node that that (potentially) wrote to {@code locationIdentity}.
     ;;
    (§ abstract #_"MemoryNode" MemoryMap''getLastLocationAccess-2 [#_"MemoryMap" this, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Gets the location identities in the domain of this map.
     ;;
    (§ abstract #_"Iterable<LocationIdentity>" MemoryMap''getLocations-1 [#_"MemoryMap" this])
)

;; @NodeInfo.allowedUsageTypes "InputType.Extension, InputType.Memory"
(final-ns MemoryMapNode (§ extends FloatingNode) (§ implements MemoryMap, MemoryNode, LIRLowerable)
    (§ def #_"NodeClass<MemoryMapNode>" MemoryMapNode'TYPE (NodeClass'create-1 MemoryMapNode))

    (§ final #_"List<LocationIdentity>" :locationIdentities nil)
    ; @Input(InputType'Memory)
    (§ mutable #_"NodeInputList<ValueNode>" :nodes nil)

    (§ defn #_"MemoryMapNode" MemoryMapNode'new-1 [#_"EconomicMap<LocationIdentity, MemoryNode>" mmap]
        (let [
            #_"MemoryMapNode" this (FloatingNode'new-2 MemoryMapNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :locationIdentities (ArrayList.))
            this (assoc this :nodes (NodeInputList'new-2 this, (count mmap)))
            #_"MapCursor<LocationIdentity, MemoryNode>" cursor (#_"EconomicMap" .getEntries mmap)
            _
                (loop-when-recur [#_"int" i 0] (#_"MapCursor" .advance cursor) [(inc i)]
                    (#_"List" .add (:locationIdentities this), (#_"MapCursor" .getKey cursor))
                    (NodeList''initialize-3 (:nodes this), i, (#_"MapCursor" .getValue cursor))
                )
        ]
            this
        )
    )

    #_unused
    (§ method! #_"boolean" MemoryMapNode''isEmpty-1 [#_"MemoryMapNode" this]
        (or (empty? (:locationIdentities this))
            (and (= (count (:locationIdentities this)) 1)
                (instance? StartNode (nth (:nodes this) 0))
            )
        )
    )

    (§ override! #_"MemoryNode" MemoryMapNode''getLastLocationAccess-2 [#_"MemoryMapNode" this, #_"LocationIdentity" locationIdentity]
        (when-not (#_"LocationIdentity" .isImmutable locationIdentity)
            (let [
                #_"int" index (#_"List" .indexOf (:locationIdentities this), locationIdentity)
                index
                    (when (= index -1) => index
                        (#_"List" .indexOf (:locationIdentities this), (LocationIdentity/any))
                    )
            ]
                (nth (:nodes this) index)
            )
        )
    )

    (§ override! #_"Collection<LocationIdentity>" MemoryMapNode''getLocations-1 [#_"MemoryMapNode" this]
        (:locationIdentities this)
    )

    #_unused
    (§ method! #_"EconomicMap<LocationIdentity, MemoryNode>" MemoryMapNode''toMap-1 [#_"MemoryMapNode" this]
        (let [
            #_"EconomicMap<LocationIdentity, MemoryNode>" res (EconomicMap/create Equivalence/DEFAULT, (count (:locationIdentities this)))
        ]
            (dotimes [#_"int" i (count (:nodes this))]
                (#_"EconomicMap" .put res, (nth (:locationIdentities this) i), (nth (:nodes this) i))
            )
            res
        )
    )

    #_unused
    (§ override! #_"void" MemoryMapNode''generate-2 [#_"MemoryMapNode" this, #_"LIRBuilder" builder]
        ;; nothing to do...
        nil
    )
)

;;;
 ; This interface marks nodes that are part of the memory graph.
 ;;
(§ interface MemoryNode
)

;;;
 ; Memory PhiNodes merge memory dependencies at control flow merges.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(final-ns MemoryPhiNode (§ extends PhiNode) (§ implements MemoryNode)
    (§ def #_"NodeClass<MemoryPhiNode>" MemoryPhiNode'TYPE (NodeClass'create-1 MemoryPhiNode))

    ; @Input(InputType'Memory)
    (§ mutable #_"NodeInputList<ValueNode>" :values nil)
    (§ final #_"LocationIdentity" :locationIdentity nil)

    (§ defn #_"MemoryPhiNode" MemoryPhiNode'new-2 [#_"AbstractMergeNode" merge, #_"LocationIdentity" locationIdentity]
        (let [
            #_"MemoryPhiNode" this (PhiNode'new-3 MemoryPhiNode'TYPE, (StampFactory'forVoid-0), merge)
            this (assoc this :locationIdentity locationIdentity)
            this (assoc this :values (NodeInputList'new-1 this))
        ]
            this
        )
    )

    #_unused
    (§ defn #_"MemoryPhiNode" MemoryPhiNode'new-3 [#_"AbstractMergeNode" merge, #_"LocationIdentity" locationIdentity, #_"ValueNode[]" values]
        (let [
            #_"MemoryPhiNode" this (PhiNode'new-3 MemoryPhiNode'TYPE, (StampFactory'forVoid-0), merge)
            this (assoc this :locationIdentity locationIdentity)
            this (assoc this :values (NodeInputList'new-2 this, values))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"NodeInputList<ValueNode>" MemoryPhiNode''values-1 [#_"MemoryPhiNode" this]
        (:values this)
    )
)

;;;
 ; Reads an accessed value.
 ;;
(final-ns ReadNode (§ extends FloatableAccessNode) (§ implements LIRLowerableAccess, Canonicalizable, Virtualizable, GuardingNode)
    (§ def #_"NodeClass<ReadNode>" ReadNode'TYPE (NodeClass'create-1 ReadNode))

    (§ defn #_"ReadNode" ReadNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"BarrierType" barrierType]
        (ReadNode'new-8 ReadNode'TYPE, address, location, stamp, nil, barrierType, false, nil)
    )

    (§ defn #_"ReadNode" ReadNode'new-8 [#_"NodeClass<? extends ReadNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"Stamp" stamp, #_"GuardingNode" guard, #_"BarrierType" barrierType, #_"boolean" nullCheck, #_"FrameState" stateBefore]
        (FloatableAccessNode'new-8 c, address, location, stamp, guard, barrierType, nullCheck, stateBefore)
    )

    #_unused
    (§ override! #_"void" ReadNode''generate-2 [#_"ReadNode" this, #_"LIRBuilder" builder]
        (let [
            #_"LIRKind" readKind (Stamp''getLIRKind-1 (ReadNode''getAccessStamp-1 this))
        ]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitLoad-3 (:gen builder), readKind, (LIRBuilder''operand-2 builder, (:address this))))
        )
        nil
    )

    #_unused
    (§ override! #_"Node" ReadNode''canonical-2 [#_"ReadNode" this, #_"CanonicalizerTool" tool]
        (cond
            (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                nil ;; read without usages or guard can be safely removed
            (:nullCheck this)
                this ;; if this read is a nil-check, then replacing it with the value is incorrect for guard-type usages
            :else
                (ReadNode'canonicalizeRead-4 this, (FixedAccessNode''getAddress-1 this), (FixedAccessNode''getLocationIdentity-1 this), tool)
        )
    )

    #_unused
    (§ override! #_"FloatingAccessNode" ReadNode''asFloatingNode-2 [#_"ReadNode" this, #_"MemoryNode" lastLocationAccess]
        (Graph''add-2 (:graph this), (FloatingReadNode'new-6 (FixedAccessNode''getAddress-1 this), (FixedAccessNode''getLocationIdentity-1 this), lastLocationAccess, (:stamp this), (FixedAccessNode''getGuard-1 this), (FixedAccessNode''getBarrierType-1 this)))
    )

    #_unused
    (§ override! #_"boolean" ReadNode''isAllowedUsageType-2 [#_"ReadNode" this, #_"InputType" type]
        (or (and (:nullCheck this) (= type InputType'Guard)) (Node''isAllowedUsageType-2 (§ super ), type))
    )

    (§ defn #_"ValueNode" ReadNode'canonicalizeRead-4 [#_"ValueNode" read, #_"AddressNode" address, #_"LocationIdentity" locationIdentity, #_"CanonicalizerTool" tool]
        (when (and (CanonicalizerTool''canonicalizeReads-1 tool) (instance? OffsetAddressNode address)) => read
            (let [
                #_"ValueNode" object (OffsetAddressNode''getBase-1 address)
            ]
                (when (and (some? HotSpot'metaAccess) (instance? ConstantNode object) (not (ValueNode''isNullConstant-1 object)) (instance? ConstantNode (:offset address)))
                    (let [
                        #_"long" displacement (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset address)))
                        #_"int" stableDimension (:stableDimension object)
                    ]
                        (when (or (#_"LocationIdentity" .isImmutable locationIdentity) (pos? stableDimension))
                            (let [
                                #_"Constant" constant (Stamp''readConstant-4 (:stamp read), (#_"ConstantReflectionProvider" .getMemoryAccessProvider HotSpot'constantReflection), (:value object), displacement)
                                #_"boolean" isDefaultStable (or (#_"LocationIdentity" .isImmutable locationIdentity) (:isDefaultStable object))
                            ]
                                (when (and (some? constant) (or isDefaultStable (not (#_"Constant" .isDefaultForKind constant))))
                                    (§ return (ConstantNode'forConstant-4 (:stamp read), constant, (max (dec stableDimension) 0), isDefaultStable))
                                )
                            )
                        )
                    )
                )
                (when (= locationIdentity NamedLocationIdentity'ARRAY_LENGTH_LOCATION)
                    (let [
                        #_"ValueNode" length (GraphUtil'arrayLength-1 object)
                    ]
                        (when (some? length)
                            (§ return length)
                        )
                    )
                )
                (when (instance? CanonicalizableLocation locationIdentity) => read
                    (CanonicalizableLocation''canonicalizeRead-5 locationIdentity, read, address, object, tool)
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" ReadNode''virtualize-2 [#_"ReadNode" this, #_"VirtualizerTool" tool]
        (throw! "unexpected ReadNode before PEA")
    )

    #_unused
    (§ override! #_"boolean" ReadNode''canNullCheck-1 [#_"ReadNode" this]
        true
    )

    (§ override! #_"Stamp" ReadNode''getAccessStamp-1 [#_"ReadNode" this]
        (:stamp this)
    )
)

;;;
 ; Writes a given {@linkplain #value() value} a memory location.
 ;;
(final-ns WriteNode (§ extends AbstractWriteNode) (§ implements LIRLowerableAccess, Canonicalizable)
    (§ def #_"NodeClass<WriteNode>" WriteNode'TYPE (NodeClass'create-1 WriteNode))

    (§ defn #_"WriteNode" WriteNode'new-4 [#_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" value, #_"BarrierType" barrierType]
        (AbstractWriteNode'new-5 WriteNode'TYPE, address, location, value, barrierType)
    )

    #_unused
    (§ defn #_"WriteNode" WriteNode'new-5 [#_"NodeClass<? extends WriteNode>" c, #_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" value, #_"BarrierType" barrierType]
        (AbstractWriteNode'new-5 c, address, location, value, barrierType)
    )

    #_unused
    (§ override! #_"void" WriteNode''generate-2 [#_"WriteNode" this, #_"LIRBuilder" builder]
        (let [
            #_"LIRKind" writeKind (Stamp''getLIRKind-1 (:stamp (AbstractWriteNode''value-1 this)))
        ]
            (LIRGenerator''emitStore-4 (:gen builder), writeKind, (LIRBuilder''operand-2 builder, (:address this)), (LIRBuilder''operand-2 builder, (AbstractWriteNode''value-1 this)))
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" WriteNode''canNullCheck-1 [#_"WriteNode" this]
        true
    )

    (§ override! #_"Stamp" WriteNode''getAccessStamp-1 [#_"WriteNode" this]
        (:stamp (AbstractWriteNode''value-1 this))
    )

    #_unused
    (§ override! #_"Node" WriteNode''canonical-2 [#_"WriteNode" this, #_"CanonicalizerTool" tool]
        (when (and (CanonicalizerTool''canonicalizeReads-1 tool) (Node''hasExactlyOneUsage-1 this) (instance? WriteNode (:next this))) => this
            (let [
                #_"WriteNode" write (:next this)
            ]
                (when (and (= (:lastLocationAccess write) this) (= (FixedAccessNode''getAddress-1 write) (FixedAccessNode''getAddress-1 this)) (Stamp''isCompatible-2 (WriteNode''getAccessStamp-1 this), (WriteNode''getAccessStamp-1 write))) => this
                    (AbstractWriteNode''setLastLocationAccess-2 write, (:lastLocationAccess this))
                    write
                )
            )
        )
    )
)

;;;
 ; Denotes the merging of multiple control-flow paths.
 ;;
(final-ns MergeNode (§ extends AbstractMergeNode)
    (§ def #_"NodeClass<MergeNode>" MergeNode'TYPE (NodeClass'create-1 MergeNode))

    (§ defn #_"MergeNode" MergeNode'new-0 []
        (AbstractMergeNode'new-1 MergeNode'TYPE)
    )

    #_unused
    (§ defn #_"void" MergeNode'removeMergeIfDegenerated-1 [#_"MergeNode" node]
        (when (and (= (AbstractMergeNode''forwardEndCount-1 node) 1) (Node''hasNoUsages-1 node))
            (let [
                #_"FixedNode" currentNext (:next node)
            ]
                (§ ass! node (FixedWithNextNode''setNext-2 node, nil))
                (let [
                    #_"EndNode" forwardEnd (AbstractMergeNode''forwardEndAt-2 node, 0)
                ]
                    (Node''replaceAtPredecessor-2 forwardEnd, currentNext)
                    (Node''markDeleted-1 node)
                    (Node''markDeleted-1 forwardEnd)
                )
            )
        )
        nil
    )
)

;;;
 ; A LocationIdentity with a name.
 ;;
(class-ns NamedLocationIdentity (§ extends LocationIdentity)
    ;;;
     ; Denotes the location of a value that is guaranteed to be unchanging.
     ;;
    (§ def #_"LocationIdentity" NamedLocationIdentity'FINAL_LOCATION (NamedLocationIdentity'immutable-1 "FINAL_LOCATION"))

    ;;;
     ; Denotes the location of the length field of a Java array.
     ;;
    (§ def #_"LocationIdentity" NamedLocationIdentity'ARRAY_LENGTH_LOCATION (NamedLocationIdentity'immutable-1 "[].length"))

    (§ final #_"String" :name nil)
    (§ final #_"boolean" :immutable false)

    (§ defn #_"NamedLocationIdentity" NamedLocationIdentity'new-2 [#_"String" name, #_"boolean" immutable]
        (let [
            #_"NamedLocationIdentity" this (LocationIdentity.)
            this (assoc this :name name)
            this (assoc this :immutable immutable)
        ]
            this
        )
    )

    ;;;
     ; Creates a named unique location identity for read and write operations against mutable memory.
     ;
     ; @param name the name of the new location identity
     ;;
    (§ defn #_"NamedLocationIdentity" NamedLocationIdentity'mutable-1 [#_"String" name]
        (NamedLocationIdentity'create-2 name, false)
    )

    ;;;
     ; Creates a named unique location identity for read operations against immutable memory.
     ; Immutable memory will never have a visible write in the graph, which is more restrictive than Java final.
     ;
     ; @param name the name of the new location identity
     ;;
    (§ defn #_"NamedLocationIdentity" NamedLocationIdentity'immutable-1 [#_"String" name]
        (NamedLocationIdentity'create-2 name, true)
    )

    ;;;
     ; Creates a named unique location identity for read and write operations.
     ;
     ; @param name the name of the new location identity
     ; @param immutable true if the location is immutable
     ;;
    (§ defn- #_"NamedLocationIdentity" NamedLocationIdentity'create-2 [#_"String" name, #_"boolean" immutable]
        (NamedLocationIdentity'new-2 name, immutable)
    )

    #_unused
    (§ override #_"boolean" NamedLocationIdentity''isImmutable-1 [#_"NamedLocationIdentity" this]
        (:immutable this)
    )

    (§ def- #_"EnumMap<JavaKind, LocationIdentity>" NamedLocationIdentity'ARRAY_LOCATIONS
        (let [
            #_"EnumMap<JavaKind, LocationIdentity>" m (EnumMap. JavaKind)
        ]
            (doseq [#_"JavaKind" kind (JavaKind/values)]
                (#_"EnumMap" .put m, kind, (NamedLocationIdentity'mutable-1 (str "Array: " (#_"JavaKind" .getJavaName kind))))
            )
            m
        )
    )

    ;;;
     ; Returns the named location identity for an array of the given element kind. Array accesses of
     ; the same kind must have the same location identity unless an alias analysis guarantees that
     ; two distinct arrays are accessed.
     ;;
    (§ defn #_"LocationIdentity" NamedLocationIdentity'getArrayLocation-1 [#_"JavaKind" elementKind]
        (get NamedLocationIdentity'ARRAY_LOCATIONS elementKind)
    )
)

;;;
 ; The Parameter instruction is a placeholder for an incoming argument to a function call.
 ;;
(final-ns ParameterNode (§ extends AbstractLocalNode) (§ implements IterableNodeType, UncheckedInterfaceProvider)
    (§ def #_"NodeClass<ParameterNode>" ParameterNode'TYPE (NodeClass'create-1 ParameterNode))

    (§ mutable #_"Stamp" :uncheckedStamp nil)

    (§ defn #_"ParameterNode" ParameterNode'new-2 [#_"int" index, #_"StampPair" stamp]
        (let [
            #_"ParameterNode" this (AbstractLocalNode'new-3 ParameterNode'TYPE, index, (:trustedStamp stamp))
            this (assoc this :uncheckedStamp (:uncheckedStamp stamp))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Stamp" ParameterNode''uncheckedStamp-1 [#_"ParameterNode" this]
        (:uncheckedStamp this)
    )
)

;;;
 ; PhiNodes represent the merging of edges at a control flow merges (AbstractMergeNode
 ; or LoopBeginNode). For a AbstractMergeNode, the order of the values corresponds to the
 ; order of the ends. For LoopBeginNodes, the first value corresponds to the loop's predecessor,
 ; while the rest of the values correspond to the LoopEndNodes.
 ;;
(class-ns PhiNode (§ extends FloatingNode) (§ implements Canonicalizable)
    (§ def #_"NodeClass<PhiNode>" PhiNode'TYPE (NodeClass'create-1 PhiNode))

    ; @Input(InputType'Association)
    (§ mutable #_"AbstractMergeNode" :merge nil)

    (§ defn #_"PhiNode" PhiNode'new-3 [#_"NodeClass<? extends PhiNode>" c, #_"Stamp" stamp, #_"AbstractMergeNode" merge]
        (let [
            #_"PhiNode" this (FloatingNode'new-2 c, stamp)
            this (assoc this :merge merge)
        ]
            this
        )
    )

    (§ abstract #_"NodeInputList<ValueNode>" PhiNode''values-1 [#_"PhiNode" this])

    (§ method #_"AbstractMergeNode" PhiNode''merge-1 [#_"PhiNode" this]
        (:merge this)
    )

    #_unused
    (§ method! #_"PhiNode" PhiNode''setMerge-2 [#_"PhiNode" this, #_"AbstractMergeNode" merge]
        (Node''updateUsages-3 this, (:merge this), merge)
        (assoc this :merge merge)
    )

    ;;;
     ; Get the instruction that produces the value associated with the i'th predecessor of the merge.
     ;
     ; @param i the index of the predecessor
     ; @return the instruction that produced the value in the i'th predecessor
     ;;
    (§ method! #_"ValueNode" PhiNode''valueAt-2 [#_"PhiNode" this, #_"int" i]
        (nth (PhiNode''values-1 this) i)
    )

    ;;;
     ; Sets the value at the given index and makes sure that the values list is large enough.
     ;
     ; @param i the index at which to set the value
     ; @param x the new phi input value for the given location
     ;;
    (§ method! #_"void" PhiNode''initializeValueAt-3 [#_"PhiNode" this, #_"int" i, #_"ValueNode" x]
        (while (<= (count (PhiNode''values-1 this)) i)
            (NodeList''add-2 (PhiNode''values-1 this), nil)
        )
        (NodeList''set-3 (PhiNode''values-1 this), i, x)
        nil
    )

    (§ method! #_"void" PhiNode''setValueAt-3 [#_"PhiNode" this, #_"int" i, #_"ValueNode" x]
        (NodeList''set-3 (PhiNode''values-1 this), i, x)
        nil
    )

    (§ method! #_"void" PhiNode''setValueAt-3 [#_"PhiNode" this, #_"AbstractEndNode" end, #_"ValueNode" x]
        (PhiNode''setValueAt-3 this, (AbstractMergeNode''phiPredecessorIndex-2 (PhiNode''merge-1 this), end), x)
        nil
    )

    (§ method! #_"ValueNode" PhiNode''valueAt-2 [#_"PhiNode" this, #_"AbstractEndNode" pred]
        (PhiNode''valueAt-2 this, (AbstractMergeNode''phiPredecessorIndex-2 (PhiNode''merge-1 this), pred))
    )

    ;;;
     ; Get the number of inputs to this phi (i.e. the number of predecessors to the merge).
     ;
     ; @return the number of inputs in this phi
     ;;
    (§ method! #_"int" PhiNode''valueCount-1 [#_"PhiNode" this]
        (count (PhiNode''values-1 this))
    )

    #_unused
    (§ method! #_"void" PhiNode''clearValues-1 [#_"PhiNode" this]
        (NodeList''clear-1 (PhiNode''values-1 this))
        nil
    )

    (§ method! #_"void" PhiNode''addInput-2 [#_"PhiNode" this, #_"ValueNode" x]
        (NodeList''add-2 (PhiNode''values-1 this), x)
        nil
    )

    (§ method! #_"void" PhiNode''removeInput-2 [#_"PhiNode" this, #_"int" index]
        (NodeList''remove-2 (PhiNode''values-1 this), index)
        nil
    )

    ;;;
     ; If all inputs are the same value, this value is returned, otherwise {@code this}.
     ; Note that nil is a valid return value, since GuardPhiNodes can have nil inputs.
     ;;
    (§ method! #_"ValueNode" PhiNode''singleValueOrThis-1 [#_"PhiNode" this]
        (let [
            #_"ValueNode" singleValue (PhiNode''valueAt-2 this, 0)
        ]
            (loop-when [#_"int" i 1] (< i (PhiNode''valueCount-1 this)) => singleValue
                (recur-if (any = (PhiNode''valueAt-2 this, i) this singleValue) [(inc i)] => this)
            )
        )
    )

    ;;;
     ; If all inputs (but the first one) are the same value, the value is returned, otherwise {@code this}.
     ; Note that nil is a valid return value, since GuardPhiNodes can have nil inputs.
     ;;
    (§ method! #_"ValueNode" PhiNode''singleBackValueOrThis-1 [#_"PhiNode" this]
        (let [
            ;; Skip first value, assume second value as single value.
            #_"ValueNode" singleValue (PhiNode''valueAt-2 this, 1)
        ]
            (loop-when [#_"int" i 2] (< i (PhiNode''valueCount-1 this)) => singleValue
                (recur-if (= (PhiNode''valueAt-2 this, i) singleValue) [(inc i)] => this)
            )
        )
    )

    #_unused
    (§ override #_"ValueNode" PhiNode''canonical-2 [#_"PhiNode" this, #_"CanonicalizerTool" tool]
        (when (PhiNode''isLoopPhi-1 this) => (PhiNode''singleValueOrThis-1 this)
            (let [
                #_"int" n (PhiNode''valueCount-1 this)
                #_"int" i
                    (loop-when [i 1] (< i n) => i
                        (recur-if (= (PhiNode''valueAt-2 this, i) this) [(inc i)] => i)
                    )
            ]
                ;; All back edges are self-references => return forward edge input value.
                (when-not (= i n) => (PhiNode''firstValue-1 this)
                    (let [
                        #_"boolean" onlySelfUsage
                            (loop-when [#_"ISeq" s (seq (Node''usages-1 this))] (some? s) => true
                                (and (= (first s) this)
                                    (recur (next s))
                                )
                            )
                    ]
                        (when-not onlySelfUsage
                            (PhiNode''singleValueOrThis-1 this)
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"ValueNode" PhiNode''firstValue-1 [#_"PhiNode" this]
        (PhiNode''valueAt-2 this, 0)
    )

    (§ method! #_"boolean" PhiNode''isLoopPhi-1 [#_"PhiNode" this]
        (instance? LoopBeginNode (PhiNode''merge-1 this))
    )
)

;;;
 ; A PiNode that also provides an array length in addition to a more refined stamp. A usage
 ; that reads the array length, such as an ArrayLengthNode, can be canonicalized based on
 ; this information.
 ;;
(final-ns PiArrayNode (§ extends PiNode) (§ implements ArrayLengthProvider)
    (§ def #_"NodeClass<PiArrayNode>" PiArrayNode'TYPE (NodeClass'create-1 PiArrayNode))

    ; @Input
    (§ mutable #_"ValueNode" :length nil)

    (§ override! #_"ValueNode" ArrayLengthProvider''length-1 [#_"PiArrayNode" this]
        (:length this)
    )

    (§ defn #_"PiArrayNode" PiArrayNode'new-3 [#_"ValueNode" object, #_"ValueNode" length, #_"Stamp" stamp]
        (let [
            #_"PiArrayNode" this (PiNode'new-4 PiArrayNode'TYPE, object, stamp, nil)
            this (assoc this :length length)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Node" PiArrayNode''canonical-2 [#_"PiArrayNode" this, #_"CanonicalizerTool" tool]
        (when (= (GraphUtil'arrayLength-1 (:object this)) (PiNode''length-1 this)) => this
            (PiNode''canonical-2 (§ super ), tool)
        )
    )

    ;;;
     ; Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.
     ;;
    ; @NodeIntrinsic(ArrayPlaceholder.class)
    (§ native #_"Object" PiArrayNode'piArrayCastToSnippetReplaceeStamp-2 [#_"Object" object, #_"int" length])
)

;;;
 ; A placeholder node in a snippet that will be replaced with a PiArrayNode when the
 ; snippet is instantiated.
 ;
 ; @anno PiArrayNode.ArrayPlaceholder
 ;;
(final-ns ArrayPlaceholder (§ extends Placeholder)
    (§ def #_"NodeClass<ArrayPlaceholder>" ArrayPlaceholder'TYPE (NodeClass'create-1 ArrayPlaceholder))

    ; @Input
    (§ mutable #_"ValueNode" :length nil)

    #_unused
    (§ defn #_"ArrayPlaceholder" ArrayPlaceholder'new-2 [#_"ValueNode" object, #_"ValueNode" length]
        (let [
            #_"ArrayPlaceholder" this (Placeholder'new-2 ArrayPlaceholder'TYPE, object)
            this (assoc this :length length)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ArrayPlaceholder''makeReplacement-2 [#_"ArrayPlaceholder" this, #_"Stamp" snippetReplaceeStamp]
        (let [
            #_"PiArrayNode" piArray (Graph''add-2 (:graph this), (PiArrayNode'new-3 (:object this), (:length this), snippetReplaceeStamp))
        ]
            (§ ass! this (Node''replaceAndDelete-2 this, piArray))
        )
        nil
    )
)

;;;
 ; A node that changes the type of its input, usually narrowing it. For example, a PiNode
 ; refines the type of a receiver during type-guarded inlining to be the type tested by the guard.
 ;
 ; In contrast to a GuardedValueNode, a PiNode is useless as soon as the type of its
 ; input is as narrow or narrower than the PiNode's type. The PiNode, and therefore
 ; also the scheduling restriction enforced by the guard, will go away.
 ;;
(class-ns PiNode (§ extends FloatingGuardedNode) (§ implements LIRLowerable, Virtualizable, IterableNodeType, Canonicalizable, ValueProxy)
    (§ def #_"NodeClass<PiNode>" PiNode'TYPE (NodeClass'create-1 PiNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)
    (§ mutable #_"Stamp" :piStamp nil)

    (§ defn #_"PiNode" PiNode'new-4 [#_"NodeClass<? extends PiNode>" c, #_"ValueNode" object, #_"Stamp" stamp, #_"GuardingNode" guard]
        (let [
            #_"PiNode" this (FloatingGuardedNode'new-3 c, stamp, guard)
            this (assoc this :object object)
            this (assoc this :piStamp stamp)
        ]
            (PiNode''inferStamp-1 this)
            this
        )
    )

    (§ defn #_"PiNode" PiNode'new-2 [#_"ValueNode" object, #_"Stamp" stamp]
        (PiNode'new-3 object, stamp, nil)
    )

    (§ defn #_"PiNode" PiNode'new-3 [#_"ValueNode" object, #_"Stamp" stamp, #_"ValueNode" guard]
        (PiNode'new-4 PiNode'TYPE, object, stamp, guard)
    )

    (§ defn #_"PiNode" PiNode'new-2 [#_"ValueNode" object, #_"ValueNode" guard]
        (PiNode'new-3 object, (AbstractPointerStamp'pointerNonNull-1 (:stamp object)), guard)
    )

    (§ defn #_"PiNode" PiNode'new-4 [#_"ValueNode" object, #_"ResolvedJavaType" toType, #_"boolean" exactType, #_"boolean" never-nil?]
        (PiNode'new-2 object, (StampFactory'object-2 (if exactType (TypeReference'createExactTrusted-1 toType) (TypeReference'create-1 toType)), (or never-nil? (StampTool'isPointerNeverNull-1 (:stamp object)))))
    )

    (§ defn #_"ValueNode" PiNode'create-2 [#_"ValueNode" object, #_"Stamp" stamp]
        (or (PiNode'canonical-3 object, stamp, nil)
            (PiNode'new-2 object, stamp)
        )
    )

    (§ defn #_"ValueNode" PiNode'create-3 [#_"ValueNode" object, #_"Stamp" stamp, #_"ValueNode" guard]
        (or (PiNode'canonical-3 object, stamp, guard)
            (PiNode'new-3 object, stamp, guard)
        )
    )

    (§ defn #_"ValueNode" PiNode'create-2 [#_"ValueNode" object, #_"ValueNode" guard]
        (let [
            #_"Stamp" stamp (AbstractPointerStamp'pointerNonNull-1 (:stamp object))
        ]
            (or (PiNode'canonical-3 object, stamp, guard)
                (PiNode'new-3 object, stamp, guard)
            )
        )
    )

    #_unused
    (§ defn #_"boolean" PiNode'intrinsify-4 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode" object, #_"ValueNode" guard]
        (let [
            #_"Stamp" stamp (AbstractPointerStamp'pointerNonNull-1 (:stamp object))
            #_"ValueNode" value
                (or (PiNode'canonical-3 object, stamp, guard)
                    (PiNode'new-3 object, stamp, guard)
                )
        ]
            (BytecodeParser''push-3 parser, JavaKind/Object, (BytecodeParser''append-2 parser, value))
            true
        )
    )

    #_unused
    (§ defn #_"boolean" PiNode'intrinsify-6 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode" object, #_"ResolvedJavaType" toType, #_"boolean" exactType, #_"boolean" never-nil?]
        (let [
            #_"Stamp" stamp (StampFactory'object-2 (if exactType (TypeReference'createExactTrusted-1 toType) (TypeReference'create-1 toType)), (or never-nil? (StampTool'isPointerNeverNull-1 (:stamp object))))
            #_"ValueNode" value
                (or (PiNode'canonical-3 object, stamp, nil)
                    (PiNode'new-2 object, stamp)
                )
        ]
            (BytecodeParser''push-3 parser, JavaKind/Object, (BytecodeParser''append-2 parser, value))
            true
        )
    )

    #_unused
    (§ method! #_"PiNode" PiNode''strengthenPiStamp-2 [#_"PiNode" this, #_"Stamp" newPiStamp]
        (assoc this :piStamp newPiStamp)
    )

    #_unused
    (§ override #_"void" PiNode''generate-2 [#_"PiNode" this, #_"LIRBuilder" builder]
        (when (LIRBuilder''hasOperand-2 builder, (:object this))
            (LIRBuilder''setResult-3 builder, this, (LIRBuilder''operand-2 builder, (:object this)))
        )
        nil
    )

    (§ override #_"boolean" PiNode''inferStamp-1 [#_"PiNode" this]
        (ValueNode''updateStamp-2 this, (PiNode''computeStamp-1 this))
    )

    (§ method- #_"Stamp" PiNode''computeStamp-1 [#_"PiNode" this]
        (Stamp''improveWith-2 (:piStamp this), (:stamp (:object this)))
    )

    #_unused
    (§ override #_"void" PiNode''virtualize-2 [#_"PiNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" object (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (and (instance? VirtualObjectNode object) (some? (StampTool'typeOrNull-1 (:stamp this))) (#_"ResolvedJavaType" .isAssignableFrom (StampTool'typeOrNull-1 (:stamp this)), (VirtualObjectNode''type-1 object)))
                (VirtualizerTool''replaceWithVirtual-2 tool, object)
            )
        )
        nil
    )

    (§ defn #_"ValueNode" PiNode'canonical-3 [#_"ValueNode" object, #_"Stamp" stamp, #_"GuardingNode" guard]
        ;; Use most up to date stamp.
        (let [
            #_"Stamp" improved (Stamp''improveWith-2 stamp, (:stamp object))
        ]
            ;; The pi node does not give any additional information => skip it.
            (cond
                (= improved (:stamp object))
                    object
                (nil? guard) ;; Try to merge the pi node with a load node.
                    (when (and (instance? ReadNode object) (not (Node''hasMoreThanOneUsage-1 object)))
                        (§ ass! object (ValueNode''setStamp-2 object, (Stamp''improveWith-2 (:stamp object), stamp)))
                        object
                    )
                :else
                    (loop-when [#_"ISeq" s (seq (Node''usages-1 guard))] (some? s)
                        (let [
                            #_"Node" node (first s)
                        ]
                            ;; Two PiNodes with the same guard and same result, so return the one with the more precise piStamp.
                            (if (and (instance? PiNode node) (= (:object node) object) (= (:stamp node) improved) (= (:piStamp node) (Stamp''join-2 stamp, (:piStamp node))))
                                node
                                (recur (next s))
                            )
                        )
                    )
            )
        )
    )

    (§ override #_"Node" PiNode''canonical-2 [#_"PiNode" this, #_"CanonicalizerTool" tool]
        (or (PiNode'canonical-3 (:object this), (:stamp this), (FloatingGuardedNode''getGuard-1 this))
            this
        )
    )

    (§ override #_"ValueNode" PiNode''getOriginalNode-1 [#_"PiNode" this]
        (:object this)
    )

    #_unused
    (§ method! #_"PiNode" PiNode''setOriginalNode-2 [#_"PiNode" this, #_"ValueNode" newNode]
        (Node''updateUsages-3 this, (:object this), newNode)
        (assoc this :object newNode)
    )

    ;;;
     ; Casts an object to have an exact, non-nil stamp representing Class.
     ;;
    #_unused
    (§ defn #_"Class" PiNode'asNonNullClass-1 [#_"Object" object]
        (PiNode'asNonNullClassIntrinsic-4 object, Class, true, true)
    )

    ;;;
     ; Casts an object to have an exact, non-nil stamp representing Class.
     ;;
    #_unused
    (§ defn #_"Class" PiNode'asNonNullObject-1 [#_"Object" object]
        (PiNode'asNonNullClassIntrinsic-4 object, Object, false, true)
    )

    ; @NodeIntrinsic(PiNode.class)
    (§ native- #_"Class" PiNode'asNonNullClassIntrinsic-4 [#_"Object" object, #_@ConstantNodeParameter #_"Class" toType, #_@ConstantNodeParameter #_"boolean" exactType, #_@ConstantNodeParameter #_"boolean" never-nil?])

    ;;;
     ; Changes the stamp of an object inside a snippet to be the stamp of the node replaced by the snippet.
     ;;
    ; @NodeIntrinsic(Placeholder.class)
    (§ native #_"Object" PiNode'piCastToSnippetReplaceeStamp-1 [#_"Object" object])

    ;;;
     ; Changes the stamp of an object and ensures the newly stamped value is non-nil and does not
     ; float above a given guard.
     ;;
    ; @NodeIntrinsic
    (§ native #_"Object" PiNode'piCastNonNull-2 [#_"Object" object, #_"GuardingNode" guard])

    ;;;
     ; Changes the stamp of an object and ensures the newly stamped value is non-nil and does not
     ; float above a given guard.
     ;;
    ; @NodeIntrinsic
    (§ native #_"Class" PiNode'piCastNonNullClass-2 [#_"Class" type, #_"GuardingNode" guard])

    ;;;
     ; Changes the stamp of an object to represent a given type and to indicate that the object is not nil.
     ;;
    (§ defn #_"Object" PiNode'piCastNonNull-2 [#_"Object" object, #_@ConstantNodeParameter #_"Class" toType]
        (PiNode'piCast-4 object, toType, false, true)
    )

    ; @NodeIntrinsic
    (§ native #_"Object" PiNode'piCast-4 [#_"Object" object, #_@ConstantNodeParameter #_"Class" toType, #_@ConstantNodeParameter #_"boolean" exactType, #_@ConstantNodeParameter #_"boolean" never-nil?])
)

;;;
 ; A placeholder node in a snippet that will be replaced with a PiNode when the snippet
 ; is instantiated.
 ;
 ; @anno PiNode.Placeholder
 ;;
(class-ns Placeholder (§ extends FloatingGuardedNode)
    (§ def #_"NodeClass<Placeholder>" Placeholder'TYPE (NodeClass'create-1 Placeholder))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)

    (§ defn #_"Placeholder" Placeholder'new-2 [#_"NodeClass<? extends Placeholder>" c, #_"ValueNode" object]
        (let [
            #_"Placeholder" this (FloatingGuardedNode'new-3 c, PlaceholderStamp'SINGLETON, nil)
            this (assoc this :object object)
        ]
            this
        )
    )

    #_unused
    (§ defn #_"Placeholder" Placeholder'new-1 [#_"ValueNode" object]
        (Placeholder'new-2 Placeholder'TYPE, object)
    )

    ;;;
     ; Replaces this node with a PiNode during snippet instantiation.
     ;
     ; @param snippetReplaceeStamp the stamp of the node being replace by the snippet
     ;;
    (§ method #_"void" Placeholder''makeReplacement-2 [#_"Placeholder" this, #_"Stamp" snippetReplaceeStamp]
        (§ ass! this (Node''replaceAndDelete-2 this, (Graph''maybeAddOrUnique-2 (:graph this), (PiNode'create-3 (:object this), snippetReplaceeStamp, nil))))
        nil
    )
)

;;;
 ; A stamp for Placeholder nodes which are only used in snippets. It is replaced by an
 ; actual stamp when the snippet is instantiated.
 ;
 ; @anno PiNode.PlaceholderStamp
 ;;
(final-ns PlaceholderStamp (§ extends ObjectStamp)
    (§ def- #_"PlaceholderStamp" PlaceholderStamp'SINGLETON (PlaceholderStamp'new-0))

    (§ defn- #_"PlaceholderStamp" PlaceholderStamp'new-0 []
        (ObjectStamp'new-4 nil, false, false, false)
    )

    (§ override! #_"boolean" #_"Object" .equals [#_"PlaceholderStamp" this, #_"Object" obj]
        (= this obj)
    )
)

(final-ns PrefetchAllocateNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<PrefetchAllocateNode>" PrefetchAllocateNode'TYPE (NodeClass'create-1 PrefetchAllocateNode))

    ; @Input(InputType'Association)
    (§ mutable #_"AddressNode" :address nil)

    #_unused
    (§ defn #_"PrefetchAllocateNode" PrefetchAllocateNode'new-1 [#_"AddressNode" address]
        (let [
            #_"PrefetchAllocateNode" this (FixedWithNextNode'new-2 PrefetchAllocateNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :address address)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" PrefetchAllocateNode''generate-2 [#_"PrefetchAllocateNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''emitPrefetchAllocate-2 (:gen builder), (LIRBuilder''operand-2 builder, (:address this)))
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"void" PrefetchAllocateNode'prefetch-1 [#_"Address" address])
)

;;;
 ; A proxy is inserted at loop exits for any value that is created inside the loop (i.e. was not
 ; live on entry to the loop) and is (potentially) used after the loop.
 ;;
(class-ns ProxyNode (§ extends FloatingNode)
    (§ def #_"NodeClass<ProxyNode>" ProxyNode'TYPE (NodeClass'create-1 ProxyNode))

    ; @Input(InputType'Association)
    (§ mutable #_"LoopExitNode" :loopExit nil)

    (§ defn #_"ProxyNode" ProxyNode'new-3 [#_"NodeClass<? extends ProxyNode>" c, #_"Stamp" stamp, #_"LoopExitNode" proxyPoint]
        (let [
            #_"ProxyNode" this (FloatingNode'new-2 c, stamp)
            this (assoc this :loopExit proxyPoint)
        ]
            this
        )
    )

    (§ abstract #_"ValueNode" ProxyNode''value-1 [#_"ProxyNode" this])

    (§ defn #_"ValueProxyNode" ProxyNode'forValue-3 [#_"ValueNode" value, #_"LoopExitNode" exit, #_"Graph" graph]
        (Graph''add-2 graph, (ValueProxyNode'new-2 value, exit))
    )

    (§ defn #_"GuardProxyNode" ProxyNode'forGuard-3 [#_"GuardingNode" value, #_"LoopExitNode" exit, #_"Graph" graph]
        (Graph''add-2 graph, (GuardProxyNode'new-2 value, exit))
    )
)

(final-ns ReturnNode (§ extends ControlSinkNode) (§ implements LIRLowerable, IterableNodeType)
    (§ def #_"NodeClass<ReturnNode>" ReturnNode'TYPE (NodeClass'create-1 ReturnNode))

    ; @OptionalInput
    (§ mutable #_"ValueNode" :result nil)
    ; @OptionalInput(InputType'Extension)
    (§ mutable #_"MemoryMapNode" :memoryMap nil)

    (§ defn #_"ReturnNode" ReturnNode'new-1 [#_"ValueNode" result]
        (ReturnNode'new-2 result, nil)
    )

    (§ defn #_"ReturnNode" ReturnNode'new-2 [#_"ValueNode" result, #_"MemoryMapNode" memoryMap]
        (let [
            #_"ReturnNode" this (ControlSinkNode'new-2 ReturnNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :result result)
            this (assoc this :memoryMap memoryMap)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ReturnNode''generate-2 [#_"ReturnNode" this, #_"LIRBuilder" builder]
        (if (nil? (:result this))
            (§ ass! (:gen builder) (LIRGenerator''emitReturn-3 (:gen builder), JavaKind/Void, nil))
            (§ ass! (:gen builder) (LIRGenerator''emitReturn-3 (:gen builder), (ValueNode''getStackKind-1 (:result this)), (LIRBuilder''operand-2 builder, (:result this))))
        )
        nil
    )

    (§ method! #_"ReturnNode" ReturnNode''setMemoryMap-2 [#_"ReturnNode" this, #_"MemoryMapNode" memoryMap]
        (Node''updateUsages-3 this, (:memoryMap this), memoryMap)
        (assoc this :memoryMap memoryMap)
    )
)

;;;
 ; Marks a position in the graph where a safepoint should be emitted.
 ;;
(final-ns SafepointNode (§ extends DeoptimizingFixedWithNextNode) (§ implements Lowerable, LIRLowerable)
    (§ def #_"NodeClass<SafepointNode>" SafepointNode'TYPE (NodeClass'create-1 SafepointNode))

    (§ defn #_"SafepointNode" SafepointNode'new-0 []
        (DeoptimizingFixedWithNextNode'new-2 SafepointNode'TYPE, (StampFactory'forVoid-0))
    )

    #_unused
    (§ override! #_"void" SafepointNode''lower-2 [#_"SafepointNode" this, #_"LoweringTool" lowerer]
        nil ;; No lowering, we generate LIR directly for this node.
    )

    #_unused
    (§ override! #_"void" SafepointNode''generate-2 [#_"SafepointNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''visitSafepointNode-2 builder, this)
        nil
    )

    #_unused
    (§ override! #_"boolean" SafepointNode''canDeoptimize-1 [#_"SafepointNode" this]
        true
    )
)

(final-ns ShortCircuitOrNode (§ extends LogicNode) (§ implements IterableNodeType, Binary #_"<LogicNode>")
    (§ def #_"NodeClass<ShortCircuitOrNode>" ShortCircuitOrNode'TYPE (NodeClass'create-1 ShortCircuitOrNode))

    ; @Input(InputType'ConditionI)
    (§ mutable #_"LogicNode" :x nil)
    ; @Input(InputType'ConditionI)
    (§ mutable #_"LogicNode" :y nil)
    (§ mutable #_"boolean" :xNegated false)
    (§ mutable #_"boolean" :yNegated false)
    ;;;
     ; The probability that the {@link #getY() y} part of this binary node is <b>not</b>
     ; evaluated. This is the probability that this operator will short-circuit its execution.
     ;;
    (§ mutable #_"double" :shortCircuitProbability 0.0)

    (§ defn #_"ShortCircuitOrNode" ShortCircuitOrNode'new-5 [#_"LogicNode" x, #_"boolean" xNegated, #_"LogicNode" y, #_"boolean" yNegated, #_"double" shortCircuitProbability]
        (let [
            #_"ShortCircuitOrNode" this (LogicNode'new-1 ShortCircuitOrNode'TYPE)
            this (assoc this :x x)
            this (assoc this :xNegated xNegated)
            this (assoc this :y y)
            this (assoc this :yNegated yNegated)
            this (assoc this :shortCircuitProbability shortCircuitProbability)
        ]
            this
        )
    )

    (§ method! #_"ShortCircuitOrNode" ShortCircuitOrNode''canonicalizeNegation-3 [#_"ShortCircuitOrNode" this, #_"LogicNode" forX, #_"LogicNode" forY]
        (let [
            [#_"LogicNode" xCond #_"boolean" xNeg]
                (loop-when-recur [xCond forX xNeg (:xNegated this)]
                                 (instance? LogicNegationNode xCond)
                                 [(LogicNegationNode''getValue-1 xCond) (not xNeg)]
                              => [xCond xNeg]
                )
            [#_"LogicNode" yCond #_"boolean" yNeg]
                (loop-when-recur [yCond forY yNeg (:yNegated this)]
                                 (instance? LogicNegationNode yCond)
                                 [(LogicNegationNode''getValue-1 yCond) (not yNeg)]
                              => [yCond yNeg]
                )
        ]
            (when-not (and (= xCond forX) (= yCond forY)) => this
                (ShortCircuitOrNode'new-5 xCond, xNeg, yCond, yNeg, (:shortCircuitProbability this))
            )
        )
    )

    (§ override! #_"LogicNode" ShortCircuitOrNode''canonical-4 [#_"ShortCircuitOrNode" this, #_"CanonicalizerTool" tool, #_"LogicNode" forX, #_"LogicNode" forY]
        (let [
            #_"ShortCircuitOrNode" canon (ShortCircuitOrNode''canonicalizeNegation-3 this, forX, forY)
        ]
            (when (= canon this) => canon
                (cond
                    (= forX forY)
                        ;;  a ||  a = a
                        ;;  a || !a = true
                        ;; !a ||  a = true
                        ;; !a || !a = !a
                        (if (:xNegated this)
                            (if (:yNegated this) (LogicNegationNode'create-1 forX) (LogicConstantNode'tautology-0))
                            (if (:yNegated this) (LogicConstantNode'tautology-0) forX)
                        )
                    (instance? LogicConstantNode forX)
                        (if (bit-xor (:value forX) (:xNegated this))
                            (LogicConstantNode'tautology-0)
                            (if (:yNegated this) (LogicNegationNode'new-1 forY) forY)
                        )
                    (instance? LogicConstantNode forY)
                        (if (bit-xor (:value forY) (:yNegated this))
                            (LogicConstantNode'tautology-0)
                            (if (:xNegated this) (LogicNegationNode'new-1 forX) forX)
                        )
                    :else
                    (do
                        (cond
                            (instance? ShortCircuitOrNode forX)
                                (cond
                                    (= forY (:x forX))
                                        (§ return (ShortCircuitOrNode'optimizeShortCircuit-4 forX, (:xNegated this), (:yNegated this), true))
                                    (= forY (:y forX))
                                        (§ return (ShortCircuitOrNode'optimizeShortCircuit-4 forX, (:xNegated this), (:yNegated this), false))
                                )
                            (instance? ShortCircuitOrNode forY)
                                (cond
                                    (= (:x forY) forX)
                                        (§ return (ShortCircuitOrNode'optimizeShortCircuit-4 forY, (:yNegated this), (:xNegated this), true))
                                    (= (:y forY) forX)
                                        (§ return (ShortCircuitOrNode'optimizeShortCircuit-4 forY, (:yNegated this), (:xNegated this), false))
                                )
                        )

                        ;; check whether !X => Y constant
                        (when (and (instance? UnaryOpLogicNode forX) (instance? UnaryOpLogicNode forY) (= (ShortCircuitOrNode'skipThroughPisAndProxies-1 (UnaryOpLogicNode''getValue-1 forX)) (ShortCircuitOrNode'skipThroughPisAndProxies-1 (UnaryOpLogicNode''getValue-1 forY)))) => this
                            (let [
                                #_"TriState" fold (UnaryOpLogicNode''tryFold-2 forY, (UnaryOpLogicNode''getSucceedingStampForValue-2 forX, (not (:xNegated this))))
                            ]
                                (when (#_"TriState" .isKnown fold) => this
                                    (cond
                                        (bit-xor (#_"TriState" .toBoolean fold) (:yNegated this)) (LogicConstantNode'tautology-0)
                                        (:xNegated this)                                        (LogicNegationNode'create-1 forX)
                                        :else                                                   forX
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"ValueNode" ShortCircuitOrNode'skipThroughPisAndProxies-1 [#_"ValueNode" node]
        (loop [node node]
            (condp instance? node
                PiNode     (recur (PiNode''getOriginalNode-1 node))
                ValueProxy (recur (Proxy''getOriginalNode-1 node))
                node
            )
        )
    )

    (§ defn- #_"LogicNode" ShortCircuitOrNode'optimizeShortCircuit-4 [#_"ShortCircuitOrNode" inner, #_"boolean" innerNegated, #_"boolean" matchNegated, #_"boolean" matchIsInnerX]
        (let [
            #_"boolean" innerMatchNegated (if matchIsInnerX (:xNegated inner) (:yNegated inner))
        ]
            (if (not innerNegated)
                ;; The four digit results of the expression used in the 16 subsequent formula
                ;; comments correspond to results when using the following truth table for
                ;; inputs a and b and testing all 4 possible input combinations:
                ;; _ 1234
                ;; a 1100
                ;; b 1010
                (if (= innerMatchNegated matchNegated)
                    ;; ( (!a ||!b) ||!a) => 0111 (!a ||!b)
                    ;; ( (!a || b) ||!a) => 1011 (!a || b)
                    ;; ( ( a ||!b) || a) => 1101 ( a ||!b)
                    ;; ( ( a || b) || a) => 1110 ( a || b)
                    ;; Only the inner or is relevant, the outer or never adds information.
                    inner
                    ;; ( ( a || b) ||!a) => 1111 (true)
                    ;; ( (!a ||!b) || a) => 1111 (true)
                    ;; ( (!a || b) || a) => 1111 (true)
                    ;; ( ( a ||!b) ||!a) => 1111 (true)
                    ;; The result of the expression is always true.
                    (LogicConstantNode'tautology-0)
                )
                (if (= innerMatchNegated matchNegated)
                    ;; (!(!a ||!b) ||!a) => 1011 (!a || b)
                    ;; (!(!a || b) ||!a) => 0111 (!a ||!b)
                    ;; (!( a ||!b) || a) => 1110 ( a || b)
                    ;; (!( a || b) || a) => 1101 ( a ||!b)
                    (let [
                        #_"boolean" newInnerXNegated (:xNegated inner)
                        #_"boolean" newInnerYNegated (:yNegated inner)
                        #_"double" newProbability (:shortCircuitProbability inner)
                        [newInnerXNegated newInnerYNegated newProbability]
                            (if matchIsInnerX
                                [newInnerXNegated (not newInnerYNegated) newProbability]
                                [(not newInnerXNegated) newInnerYNegated (- 1.0 newProbability)]
                            )
                    ]
                        ;; The expression can be transformed into a single or.
                        (ShortCircuitOrNode'new-5 (:x inner), newInnerXNegated, (:y inner), newInnerYNegated, newProbability)
                    )
                    ;; (!(!a ||!b) || a) => 1100 (a)
                    ;; (!(!a || b) || a) => 1100 (a)
                    ;; (!( a ||!b) ||!a) => 0011 (!a)
                    ;; (!( a || b) ||!a) => 0011 (!a)
                    (let [
                        #_"LogicNode" result (if matchIsInnerX (:x inner) (:y inner))
                    ]
                        ;; Only the second part of the outer or is relevant.
                        (if matchNegated (LogicNegationNode'create-1 result) result)
                    )
                )
            )
        )
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Value, InputType.Anchor, InputType.Guard"
(final-ns SnippetAnchorNode (§ extends FixedWithNextNode) (§ implements Simplifiable, GuardingNode)
    (§ def #_"NodeClass<SnippetAnchorNode>" SnippetAnchorNode'TYPE (NodeClass'create-1 SnippetAnchorNode))

    #_unused
    (§ defn #_"SnippetAnchorNode" SnippetAnchorNode'new-0 []
        (FixedWithNextNode'new-2 SnippetAnchorNode'TYPE, StampFactory'objectStamp)
    )

    #_unused
    (§ override! #_"void" SnippetAnchorNode''simplify-2 [#_"SnippetAnchorNode" this, #_"SimplifierTool" tool]
        (let [
            #_"AbstractBeginNode" prevBegin (AbstractBeginNode'prevBegin-1 this)
        ]
            (Node''replaceAtUsages-3 this, InputType'Anchor, prevBegin)
            (Node''replaceAtUsages-3 this, InputType'Guard, prevBegin)
            (when (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                (Graph''removeFixed-2 (:graph this), this)
            )
        )
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"GuardingNode" SnippetAnchorNode'anchor-0 [])
)

(§ interface ArrayLengthProvider
    ;;;
     ; @return the length of the array described by this node, or nil if it is not available
     ;;
    (§ abstract #_"ValueNode" ArrayLengthProvider''length-1 [#_"ArrayLengthProvider" this])
)

;;;
 ; This interface is like the derived ValueProxy. The difference is that only the graph builder
 ; should see through the proxy for doing some checks. Optimizations should not see through
 ; this proxy and therefore should only test for ValueProxy.
 ;;
(§ interface LimitedValueProxy (§ extends Proxy)
    (§ abstract #_"ValueNode" LimitedValueProxy''getOriginalNode-1 [#_"LimitedValueProxy" this])
)

(§ interface LIRLowerable
    (§ abstract #_"void" LIRLowerable''generate-2 [#_"LIRLowerable" this, #_"LIRBuilder" builder])
)

;;;
 ; Interface implemented by nodes that can replace themselves with lower level nodes during a phase
 ; that transforms a graph to replace higher level nodes with lower level nodes.
 ;;
(§ interface Lowerable
    ;;;
     ; Expand this node into lower level nodes expressing the same semantics. If the introduced
     ; nodes are themselves lowerable, they should be recursively lowered as part of this call.
     ;;
    (§ abstract #_"void" Lowerable''lower-2 [#_"Lowerable" this, #_"LoweringTool" lowerer])
)

;;;
 ; The lowering stages used in a standard Graal phase plan. Lowering is called 3 times,
 ; during every tier of compilation.
 ;
 ; @anno LoweringTool.LoweringStage
 ;;
(value-ns LoweringStage
    (§ enum LoweringStage'HIGH_TIER)
    (§ enum LoweringStage'MID_TIER)
    (§ enum LoweringStage'LOW_TIER)
)

;;;
 ; Interface for nodes which have FrameState nodes as input.
 ;;
(§ interface NodeWithState
    (§ default! #_"NodeIterable<FrameState>" NodeWithState''states-1 [#_"NodeWithState" this]
        (NodeIterable''filter-2 (Node''inputs-1 this), FrameState)
    )
)

;;;
 ; This interface marks nodes whose result is the same as one of their inputs. Such nodes are used
 ; to add type information, to introduce scheduling restrictions, etc.
 ;
 ; For some algorithms it is necessary or advantageous to see through these proxies.
 ;;
(§ interface Proxy
    (§ abstract #_"Node" Proxy''getOriginalNode-1 [#_"Proxy" this])
)

(§ interface StampInverter
    ;;;
     ; Computes the stamp of the input for the given output stamp.
     ;;
    (§ abstract #_"Stamp" StampInverter''invertStamp-2 [#_"StampInverter" this, #_"Stamp" outStamp])

    ;;;
     ; Gets the input node.
     ;;
    (§ abstract #_"ValueNode" StampInverter''getValue-1 [#_"StampInverter" this])
)

(§ interface UncheckedInterfaceProvider
    ;;;
     ; Returns a stamp containing information about interface types that has not been verified or nil
     ; if no such stamp is available. A type check is needed before using informations from this stamp.
     ;;
    #_unused
    (§ abstract #_"Stamp" UncheckedInterfaceProvider''uncheckedStamp-1 [#_"UncheckedInterfaceProvider" this])
)

;;;
 ; This interface marks nodes whose result is the same as one of their inputs. Such nodes are used
 ; to add type information, to introduce scheduling restrictions, etc.
 ;
 ; For some algorithms it is necessary or advantageous to see through these proxies.
 ;;
(§ interface ValueProxy (§ extends LimitedValueProxy)
    #_unused
    (§ abstract #_"GuardingNode" ValueProxy''getGuard-1 [#_"ValueProxy" this])
)

;;;
 ; This interface allows a node to convey information about what its effect would be if some of its
 ; inputs were virtualized. The #virtualize(VirtualizerTool) method will only be called for
 ; nodes that have some interaction with virtualized nodes. However, the virtualized nodes might
 ; have been re-materialized in the meantime.
 ;;
(§ interface Virtualizable
    ;;;
     ; A node class can implement this method to convey information about what its effect would be
     ; if some of its inputs were virtualized. All modifications must be made through the supplied
     ; tool, and not directly on the node, because by the time this method is called the
     ; virtualized/non-virtualized state is still speculative and might not hold because of loops, etc.
     ;
     ; @param tool the tool used to describe the effects of this node
     ;;
    (§ abstract #_"void" Virtualizable''virtualize-2 [#_"Virtualizable" this, #_"VirtualizerTool" tool])
)

;;;
 ; This interface allows a node to convey information about what its effect would be if some of its
 ; inputs were virtualized.
 ;
 ; The difference to Virtualizable is that the #virtualize(VirtualizerTool) method
 ; will be called regardless of whether this node had any interaction with virtualized nodes. This
 ; interface can therefore be used for object allocations, for which virtualization introduces new
 ; virtualized objects.
 ;;
(§ interface VirtualizableAllocation (§ extends Virtualizable)
)

;;;
 ; This tool can be used to query the current state (normal/virtualized/re-materialized) of values
 ; and to describe the actions that would be taken for this state.
 ;
 ; See also Virtualizable.
 ;;
(§ interface VirtualizerTool
    ;;;
     ; This method should be used to query the maximum size of virtualized objects before attempting virtualization.
     ;
     ; @return the maximum number of entries for virtualized objects
     ;;
    (§ abstract #_"int" VirtualizerTool''getMaximumEntryCount-1 [#_"VirtualizerTool" this])

    ;; methods working on virtualized/materialized objects

    ;;;
     ; Introduces a new virtual object to the current state.
     ;
     ; @param virtualObject the new virtual object.
     ; @param entryState the initial state of the virtual object's fields.
     ; @param locks the initial locking depths.
     ; @param ensureVirtualized true if this object needs to stay virtual
     ;;
    (§ abstract #_"void" VirtualizerTool''createVirtualObject-5 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"ValueNode[]" entryState, #_"List<MonitorIdNode>" locks, #_"boolean" ensureVirtualized])

    ;;;
     ; Returns a VirtualObjectNode if the given value is aliased with a virtual object that is still
     ; virtual, the materialized value of the given value is aliased with a virtual object that was
     ; materialized, the replacement if the give value was replaced, otherwise the given value.
     ;
     ; Replacements via #replaceWithValue(ValueNode) are not immediately committed. This method can be
     ; used to determine if a value was replaced by another one (e.g. a load field by the loaded value).
     ;;
    (§ abstract #_"ValueNode" VirtualizerTool''getAlias-2 [#_"VirtualizerTool" this, #_"ValueNode" value])

    ;;;
     ; Sets the entry (field or array element) with the given index in the virtualized object.
     ;
     ; @param index the index to be set.
     ; @param value the new value for the given index.
     ; @param accessKind the kind of the store which might be different than VirtualObjectNode#entryKind(int)
     ; @return true if the operation was permitted
     ;;
    (§ abstract #_"boolean" VirtualizerTool''setVirtualEntry-6 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"int" index, #_"ValueNode" value, #_"JavaKind" accessKind, #_"long" offset])

    (§ default #_"void" VirtualizerTool''setVirtualEntry-4 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"int" index, #_"ValueNode" value]
        (when-not (VirtualizerTool''setVirtualEntry-6 this, virtualObject, index, value, nil, 0)
            (throw! "unexpected failure when updating virtual entry")
        )
        nil
    )

    (§ abstract #_"ValueNode" VirtualizerTool''getEntry-3 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"int" index])

    (§ abstract #_"void" VirtualizerTool''addLock-3 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"MonitorIdNode" monitorId])

    (§ abstract #_"MonitorIdNode" VirtualizerTool''removeLock-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject])

    (§ abstract #_"void" VirtualizerTool''setEnsureVirtualized-3 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject, #_"boolean" ensureVirtualized])

    #_unused
    (§ abstract #_"boolean" VirtualizerTool''getEnsureVirtualized-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject])

    ;; operations on the current node

    ;;;
     ; Deletes the current node and replaces it with the given virtualized object.
     ;
     ; @param virtualObject the virtualized object that should replace the current node.
     ;;
    (§ abstract #_"void" VirtualizerTool''replaceWithVirtual-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject])

    ;;;
     ; Deletes the current node and replaces it with the given value.
     ;
     ; @param replacement the value that should replace the current node.
     ;;
    (§ abstract #_"void" VirtualizerTool''replaceWithValue-2 [#_"VirtualizerTool" this, #_"ValueNode" replacement])

    ;;;
     ; Deletes the current node.
     ;;
    (§ abstract #_"void" VirtualizerTool''delete-1 [#_"VirtualizerTool" this])

    ;;;
     ; Replaces an input of the current node.
     ;
     ; @param oldInput the old input value.
     ; @param replacement the new input value.
     ;;
    #_unused
    (§ abstract #_"void" VirtualizerTool''replaceFirstInput-3 [#_"VirtualizerTool" this, #_"Node" oldInput, #_"Node" replacement])

    ;;;
     ; Adds the given node to the graph.This action will only be performed when, and if, the changes are committed.
     ;
     ; @param node the node to add.
     ;;
    (§ abstract #_"void" VirtualizerTool''addNode-2 [#_"VirtualizerTool" this, #_"ValueNode" node])

    ;;;
     ; This method performs either #replaceWithValue(ValueNode) or #replaceWithVirtual(VirtualObjectNode),
     ; depending on the given value.
     ;
     ; @param value the replacement value
     ;;
    (§ abstract #_"void" VirtualizerTool''replaceWith-2 [#_"VirtualizerTool" this, #_"ValueNode" value])

    ;;;
     ; If state is virtual, materialization is performed for the given state.
     ;
     ; @return true if materialization happened, false if not
     ;;
    #_unused
    (§ abstract #_"boolean" VirtualizerTool''ensureMaterialized-2 [#_"VirtualizerTool" this, #_"VirtualObjectNode" virtualObject])
)

;;;
 ; The start node of a graph.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.Memory"
(class-ns StartNode (§ extends BeginStateSplitNode) (§ implements Single)
    (§ def #_"NodeClass<StartNode>" StartNode'TYPE (NodeClass'create-1 StartNode))

    (§ defn #_"StartNode" StartNode'new-1 [#_"NodeClass<? extends StartNode>" c]
        (BeginStateSplitNode'new-1 c)
    )

    (§ defn #_"StartNode" StartNode'new-0 []
        (BeginStateSplitNode'new-1 StartNode'TYPE)
    )

    #_unused
    (§ override #_"LocationIdentity" StartNode''getLocationIdentity-1 [#_"StartNode" this]
        (LocationIdentity/any)
    )
)

;;;
 ; A state split is a node that may have a frame state associated with it.
 ;;
(§ interface StateSplit (§ extends NodeWithState)
    ;;;
     ; Gets the FrameState corresponding to the state of the JVM after execution of this node.
     ;;
    (§ abstract #_"FrameState" StateSplit''stateAfter-1 [#_"StateSplit" this])

    ;;;
     ; Sets the FrameState corresponding to the state of the JVM after execution of this node.
     ;;
    (§ abstract #_"void" StateSplit''setStateAfter-2 [#_"StateSplit" this, #_"FrameState" x])

    ;;;
     ; Determines if this node has a side-effect. Such nodes cannot be safely re-executed because
     ; they modify state which is visible to other threads or modify state beyond what is captured
     ; in FrameState nodes.
     ;;
    (§ abstract #_"boolean" StateSplit''hasSideEffect-1 [#_"StateSplit" this])
)

(§ interface StaticDeoptimizingNode
    #_unused
    (§ abstract #_"void" StaticDeoptimizingNode''setReason-2 [#_"StaticDeoptimizingNode" this, #_"DeoptimizationReason" reason])

    #_unused
    (§ abstract #_"void" StaticDeoptimizingNode''setAction-2 [#_"StaticDeoptimizingNode" this, #_"DeoptimizationAction" action])

    (§ default! #_"GuardPriority" StaticDeoptimizingNode''computePriority-1 [#_"StaticDeoptimizingNode" this]
        (if (and (some? (:speculation this)) (#_"JavaConstant" .isNonNull (:speculation this)))
            GuardPriority'Speculation
            (condp =? (:action this)
                [DeoptimizationAction/InvalidateReprofile DeoptimizationAction/InvalidateRecompile]                                    GuardPriority'Profile
                [DeoptimizationAction/RecompileIfTooManyDeopts DeoptimizationAction/InvalidateStopCompiling DeoptimizationAction/None] GuardPriority'None
            )
        )
    )

    (§ defn #_"DeoptimizationAction" StaticDeoptimizingNode'mergeActions-2 [#_"DeoptimizationAction" a1, #_"DeoptimizationAction" a2]
        (when-not (= a1 a2) => a1
            (when (or (and (= a1 DeoptimizationAction/InvalidateRecompile) (= a2 DeoptimizationAction/InvalidateReprofile))
                      (and (= a1 DeoptimizationAction/InvalidateReprofile) (= a2 DeoptimizationAction/InvalidateRecompile))
                  )
                DeoptimizationAction/InvalidateReprofile
            )
        )
    )
)

;;;
 ; Describes how much information is gathered when deoptimization triggers.
 ;
 ; This enum is Comparable and orders its element from highest priority to lowest priority.
 ;
 ; @anno StaticDeoptimizingNode.GuardPriority
 ;;
(value-ns GuardPriority
    (§ enum GuardPriority'Speculation)
    (§ enum GuardPriority'Profile)
    (§ enum GuardPriority'None)

    (§ defn #_"boolean" GuardPriority'isHigherPriorityThan-2 [#_"GuardPriority" a, #_"GuardPriority" b]
        (neg? (GuardPriority''compareTo-2 a, b))
    )

    (§ defn #_"boolean" GuardPriority'isLowerPriorityThan-2 [#_"GuardPriority" a, #_"GuardPriority" b]
        (pos? (GuardPriority''compareTo-2 a, b))
    )

    (§ defn #_"GuardPriority" GuardPriority'highest-0 []
        GuardPriority'Speculation
    )
)

;;;
 ; This class is a graph container, it contains the set of nodes that belong to this graph.
 ; A graph contains at least one distinguished node, the {@link #start() start} node.
 ; This node is the start of the control flow of the graph.
 ;;
(final-ns Graph
    ;;;
     ; The set of nodes in the graph, ordered by {@linkplain #register(Node) registration} time.
     ;;
    (§ mutable #_"Node[]" :nodes nil)
    ;;;
     ; The number of valid entries in #nodes.
     ;;
    (§ mutable #_"int" :nodesSize 0)

    ;; these two arrays contain one entry for each NodeClass, indexed by NodeClass.iterableId.
    ;; they contain the first and last pointer to a linked list of all nodes with this type.
    (§ final #_"ArrayList<Node>" :iterableNodesFirst nil)
    (§ final #_"ArrayList<Node>" :iterableNodesLast nil)

    ;;;
     ; The number of nodes which have been deleted from this graph.
     ;;
    (§ mutable #_"int" :nodesDeleted 0)

    (§ mutable #_"NodeEventListener" :nodeEventListener nil)

    ;;;
     ; Indicates that the graph should no longer be modified. Frozen graphs can be used by multiple
     ; threads so it's only safe to read them.
     ;;
    (§ mutable #_"boolean" :frozen false)

    (def #_"long" Graph'INVALID_GRAPH_ID -1)
    (§ def- #_"AtomicLong" Graph'uniqueGraphIds (AtomicLong.))

    (§ mutable #_"StartNode" :start nil)

    ;;;
     ; The root method from which this graph was built.
     ;
     ; nil if this method was not built from a method or the method is not available
     ;;
    (§ mutable #_"ResolvedJavaMethod" :rootMethod nil)

    (§ final #_"long" :graphId 0)
    (§ mutable #_"GuardsStage" :guardsStage GuardsStage'FLOATING_GUARDS)
    (§ mutable #_"boolean" :isAfterFloatingReadPhase false)
    (§ mutable #_"boolean" :isAfterFixedReadPhase false)
    (§ mutable #_"boolean" :hasValueProxies true)
    (§ mutable #_"boolean" :isAfterExpandLogic false)

    (§ mutable #_"ScheduleResult" :lastSchedule nil)

    (§ defn #_"Graph" Graph'new-1 [#_"ResolvedJavaMethod" method]
        (let [
            #_"Graph" this (Object.)
            this (assoc this :nodes (make-array Node 32))
            this (assoc this :iterableNodesFirst (ArrayList.))
            this (assoc this :iterableNodesLast (ArrayList.))
        ]
            (§ ass! this (Graph''setStart-2 this, (Graph''add-2 this, (StartNode'new-0))))
            (let [
                this (assoc this :rootMethod method)
                this (assoc this :graphId (#_"AtomicLong" .incrementAndGet Graph'uniqueGraphIds))
            ]
                this
            )
        )
    )

    (§ method! #_"Graph" Graph''copy-1 [#_"Graph" this]
        (let [
            #_"Graph" copy (Graph'new-1 (:rootMethod this))
        ]
            (§ ass! copy (Graph''setGuardsStage-2 copy, (:guardsStage this)))
            (let [
                copy (assoc copy :isAfterFloatingReadPhase (:isAfterFloatingReadPhase this))
                copy (assoc copy :hasValueProxies (:hasValueProxies this))
                copy (assoc copy :isAfterExpandLogic (:isAfterExpandLogic this))
            ]
                copy
            )
        )
    )

    ;;;
     ; Gets the number of live nodes in this graph. That is the number of nodes which have been
     ; added to the graph minus the number of deleted nodes.
     ;
     ; @return the number of live nodes in this graph
     ;;
    (§ method! #_"int" Graph''getNodeCount-1 [#_"Graph" this]
        (- (:nodesSize this) (:nodesDeleted this))
    )

    ;;;
     ; Adds a new node to the graph.
     ;;
    (§ method! #_"Node" Graph''add-2 [#_"Graph" this, #_"Node" node]
        (Node''initialize-2 node, this)
        node
    )

    (§ method! #_"Node" Graph''maybeAddOrUnique-2 [#_"Graph" this, #_"Node" node]
        (when-not (Node''isAlive-1 node) => node
            (Graph''add-2 this, node)
        )
    )

    (§ method! #_"Node" Graph''addOrUniqueWithInputs-2 [#_"Graph" this, #_"Node" node]
        (when-not (Node''isAlive-1 node) => node
            (Graph''addInputs-2 this, node)
            (Graph''add-2 this, node)
        )
    )

    (§ method- #_"void" Graph''addInputs-2 [#_"Graph" this, #_"Node" node]
        (let [
            #_"Graph" graph this
            #_"EdgeVisitor" addInputsFilter
                (§ reify #_"EdgeVisitor" (EdgeVisitor'new-0)
                    (§ override! #_"Node" EdgeVisitor''apply-3 [#_"EdgeVisitor" this, #_"Node" self, #_"Node" input]
                        (if (Node''isAlive-1 input) input (Graph''addOrUniqueWithInputs-2 graph, input))
                    )
                )
        ]
            (Node''applyInputs-2 node, addInputsFilter)
        )
        nil
    )

    ;;;
     ; Registers a given NodeEventListener with this graph. This should be used in
     ; conjunction with try-with-resources statement as follows:
     ;
     ; try (NodeEventScope nes = graph.trackNodeEvents(listener)) {
     ;     // make changes to the graph
     ; }
     ;;
    (§ method! #_"NodeEventScope" Graph''trackNodeEvents-2 [#_"Graph" this, #_"NodeEventListener" listener]
        (NodeEventScope'new-2 this, listener)
    )

    ;;;
     ; Returns an Iterable providing all nodes added since the last {@link Graph#getMark() mark}.
     ;;
    (§ method! #_"NodeIterable<Node>" Graph''getNewNodes-2 [#_"Graph" this, #_"NodeMark" mark]
        (let [
            #_"Graph" graph this
            #_"int" index (if (some? mark) (:value mark) 0)
        ]
            (§ reify #_"NodeIterable<Node>" (NodeIterable'reify-0)
                (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"NodeIterable<Node>" this]
                    (GraphNodeIterator'new-2 graph, index)
                )
            )
        )
    )

    ;;;
     ; Returns an Iterable providing all the live nodes.
     ;;
    (§ method! #_"NodeIterable<Node>" Graph''getNodes-1 [#_"Graph" this]
        (let [
            #_"Graph" graph this
        ]
            (§ reify #_"NodeIterable<Node>" (NodeIterable'reify-0)
                (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"NodeIterable<Node>" this]
                    (GraphNodeIterator'new-1 graph)
                )

                (§ override! #_"int" NodeIterable''count-1 [#_"NodeIterable<Node>" this]
                    (Graph''getNodeCount-1 graph)
                )
            )
        )
    )

    ;;;
     ; Returns an Iterable providing all the live nodes whose type is compatible with {@code type}.
     ;
     ; @param nodeClass the type of node to return
     ; @return an Iterable providing all the matching nodes
     ;;
    (§ method! #_"NodeIterable<Node>" Graph''getNodes-2 [#_"Graph" this, #_"NodeClass<Node>" nodeClass]
        (let [
            #_"Graph" graph this
        ]
            (§ reify #_"NodeIterable<Node>" (NodeIterable'reify-0)
                (§ override! #_"Iterator<Node>" #_"Iterable" .iterator [#_"NodeIterable<Node>" this]
                    (TypedGraphNodeIterator'new-2 nodeClass, graph)
                )
            )
        )
    )

    ;;;
     ; Returns whether the graph contains at least one node of the given type.
     ;
     ; @param type the type of node that is checked for occurrence
     ; @return whether there is at least one such node
     ;;
    (§ method! #_"boolean" Graph''hasNode-2 [#_"Graph" this, #_"NodeClass<Node>" type]
        (#_"Iterator" .hasNext (#_"Iterable" .iterator (Graph''getNodes-2 this, type)))
    )

    ;;;
     ; @return the first live Node with a matching iterableId
     ;;
    (§ method! #_"Node" Graph''getIterableNodeStart-2 [#_"Graph" this, #_"int" iterableId]
        (when (< iterableId (count (:iterableNodesFirst this)))
            (let [
                #_"Node" node (nth (:iterableNodesFirst this) iterableId)
            ]
                (when (and (some? node) (Node''isDeleted-1 node)) => node
                    (Graph''findFirstLiveIterable-3 this, iterableId, node)
                )
            )
        )
    )

    (§ method- #_"Node" Graph''findFirstLiveIterable-3 [#_"Graph" this, #_"int" iterableId, #_"Node" node]
        (let [
            node (loop-when-recur node (and (some? node) (Node''isDeleted-1 node)) (:typeCacheNext node) => node)
        ]
            ;; Multiple threads iterating nodes can update this cache simultaneously.
            ;; This is a benign race, since all threads update it to the same value.
            (#_"ArrayList" .set (:iterableNodesFirst this), iterableId, node)
            (when (nil? node)
                (#_"ArrayList" .set (:iterableNodesLast this), iterableId, node)
            )
            node
        )
    )

    ;;;
     ; @return return the first live Node with a matching iterableId starting from {@code node}
     ;;
    (§ method! #_"Node" Graph''getIterableNodeNext-2 [#_"Graph" this, #_"Node" node]
        (when (and (some? node) (Node''isDeleted-1 node)) => node
            (Graph''findNextLiveiterable-2 this, node)
        )
    )

    (§ method- #_"Node" Graph''findNextLiveiterable-2 [#_"Graph" this, #_"Node" start]
        (let [
            #_"Node" node start
            node (loop-when-recur node (and (some? node) (Node''isDeleted-1 node)) (:typeCacheNext node) => node)
        ]
            (if (nil? node)
                (do
                    ;; only dead nodes after this one
                    (§ ass! start (assoc start :typeCacheNext nil))
                    (#_"ArrayList" .set (:iterableNodesLast this), (:iterableId (:nodeClass start)), start)
                )
                (do
                    ;; everything in between is dead
                    (§ ass! start (assoc start :typeCacheNext node))
                )
            )
            node
        )
    )

    (§ method- #_"Graph" Graph''grow-1 [#_"Graph" this]
        (let [
            #_"Node[]" nodes (make-array Node (inc (* (:nodesSize this) 2)))
        ]
            (System/arraycopy (:nodes this), 0, nodes, 0, (:nodesSize this))
            (assoc this :nodes nodes)
        )
    )

    (§ method- #_"void" Graph''updateNodeCaches-2 [#_"Graph" this, #_"Node" node]
        (let [
            #_"int" id (:iterableId (:nodeClass node))
        ]
            (when-not (= id Node'NOT_ITERABLE)
                (while (<= (count (:iterableNodesFirst this)) id)
                    (#_"ArrayList" .add (:iterableNodesFirst this), nil)
                    (#_"ArrayList" .add (:iterableNodesLast this), nil)
                )
                (let [
                    #_"Node" prev (nth (:iterableNodesLast this) id)
                ]
                    (if (some? prev)
                        (§ ass prev (assoc prev :typeCacheNext node))
                        (#_"ArrayList" .set (:iterableNodesFirst this), id, node)
                    )
                    (#_"ArrayList" .set (:iterableNodesLast this), id, node)
                )
            )
        )
        nil
    )

    (§ method! #_"Graph" Graph''register-2 [#_"Graph" this, #_"Node" node]
        (let [
            this
                (when (= (count (:nodes this)) (:nodesSize this)) => this
                    (Graph''grow-1 this)
                )
            #_"int" id (:nodesSize this)
            this (update this :nodesSize inc)
            _ (aset (:nodes this) id node)
            _ (§ ass node (assoc node :id id))
        ]
            (Graph''updateNodeCaches-2 this, node)
            (when (some? (:nodeEventListener this))
                (NodeEventListener''event-3 (:nodeEventListener this), NodeEvent'NODE_ADDED, node)
            )
            this
        )
    )

    (§ method! #_"Graph" Graph''unregister-2 [#_"Graph" this, #_"Node" node]
        (let [
            _ (aset (:nodes this) (:id node) nil)
            this (update this :nodesDeleted inc)
        ]
            (when (some? (:nodeEventListener this))
                (NodeEventListener''event-3 (:nodeEventListener this), NodeEvent'NODE_ADDED, node)
            )
            ;; nodes aren't removed from the type cache here - they will be removed during iteration
            this
        )
    )

    ;;;
     ; Adds duplicates of the nodes in {@code newNodes} to this graph. This will recreate any edges
     ; between the duplicate nodes. The {@code replacement} map can be used to replace a node from
     ; the source graph by a given node (which must already be in this graph). Edges between
     ; duplicate and replacement nodes will also be recreated so care should be taken regarding the
     ; matching of node types in the replacement map.
     ;
     ; @param newNodes the nodes to be duplicated
     ; @param replacementsMap the replacement map (can be nil if no replacement is to be performed)
     ; @return a map which associates the original nodes from {@code nodes} to their duplicates
     ;;
    (§ method! #_"UnmodifiableEconomicMap<Node, Node>" Graph''addDuplicates-5 [#_"Graph" this, #_"Iterable<? extends Node>" newNodes, #_"Graph" oldGraph, #_"int" estimatedNodeCount, #_"EconomicMap<Node, Node>" replacementsMap]
        (Graph''addDuplicates-5 this, newNodes, oldGraph, estimatedNodeCount, (when (some? replacementsMap) (MapReplacement'new-1 replacementsMap)))
    )

    (§ method! #_"EconomicMap<Node, Node>" Graph''addDuplicates-5 [#_"Graph" this, #_"Iterable<? extends Node>" newNodes, #_"Graph" oldGraph, #_"int" estimatedNodeCount, #_"DuplicationReplacement" replacements]
        (NodeClass'addGraphDuplicate-5 this, oldGraph, estimatedNodeCount, newNodes, replacements)
    )

    (§ method! #_"boolean" Graph''isFrozen-1 [#_"Graph" this]
        (:frozen this)
    )

    (§ method! #_"Graph" Graph''freeze-1 [#_"Graph" this]
        (assoc this :frozen true)
    )

    (§ method! #_"Graph" Graph''setLastSchedule-2 [#_"Graph" this, #_"ScheduleResult" result]
        (assoc this :lastSchedule result)
    )

    #_unused
    (§ method! #_"Stamp" Graph''getReturnStamp-1 [#_"Graph" this]
        (loop-when [#_"Stamp" stamp nil #_"ISeq" s (seq (Graph''getNodes-2 this, ReturnNode'TYPE))] (some? s) => stamp
            (let [
                #_"ValueNode" result (:result (first s))
                stamp
                    (cond
                        (nil? result) stamp
                        (nil? stamp)  (:stamp result)
                        :else         (Stamp''meet-2 stamp, (:stamp result))
                    )
            ]
                (recur stamp (next s))
            )
        )
    )

    (§ method! #_"Graph" Graph''setStart-2 [#_"Graph" this, #_"StartNode" start]
        (assoc this :start start)
    )

    (§ method! #_"ParameterNode" Graph''getParameter-2 [#_"Graph" this, #_"int" index]
        (loop-when [#_"ISeq" s (seq (Graph''getNodes-2 this, ParameterNode'TYPE))] (some? s)
            (let [
                #_"ParameterNode" param (first s)
            ]
                (if (= (AbstractLocalNode''index-1 param) index)
                    param
                    (recur (next s))
                )
            )
        )
    )

    (§ method! #_"Iterable<InvokeNode>" Graph''getInvokes-1 [#_"Graph" this]
        (let [
            #_"Iterator<MethodCallTargetNode>" callTargets (#_"Iterable" .iterator (Graph''getNodes-2 this, MethodCallTargetNode'TYPE))
        ]
            (§ reify #_"Iterable<InvokeNode>" (Iterable.)
                (§ mutable #_"InvokeNode" :next nil)

                (§ override! #_"Iterator<InvokeNode>" #_"Iterable" .iterator [#_"Iterable<InvokeNode>" this]
                    (let [
                        #_"Iterable<InvokeNode>" iterable this
                    ]
                        (§ reify #_"Iterator<InvokeNode>" (Iterator.)
                            (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<InvokeNode>" this]
                                (or (some? (:next iterable))
                                    (loop-when [] (#_"Iterator" .hasNext callTargets) => false
                                        (let [
                                            #_"InvokeNode" i (MethodCallTargetNode''invoke-1 (#_"Iterator" .next callTargets))
                                        ]
                                            (when (some? i) => (recur)
                                                (§ ass! iterable (assoc iterable :next i))
                                                true
                                            )
                                        )
                                    )
                                )
                            )

                            (§ override! #_"InvokeNode" #_"Iterator" .next [#_"Iterator<InvokeNode>" this]
                                (try
                                    (:next iterable)
                                    (finally
                                        (§ ass! iterable (assoc iterable :next nil))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"boolean" Graph''hasLoops-1 [#_"Graph" this]
        (Graph''hasNode-2 this, LoopBeginNode'TYPE)
    )

    ;;;
     ; Unlinks a node from all its control flow neighbors and then removes it from its graph.
     ; The node must have no {@linkplain Node#usages() usages}.
     ;
     ; @param node the node to be unlinked and removed
     ;;
    (§ method! #_"void" Graph''removeFixed-2 [#_"Graph" this, #_"FixedWithNextNode" node]
        (when (instance? AbstractBeginNode node)
            (AbstractBeginNode''prepareDelete-1 node)
        )
        (GraphUtil'unlinkFixedNode-1 node)
        (Node''safeDelete-1 node)
        nil
    )

    (§ method! #_"Graph" Graph''replaceFixedWithFixed-3 [#_"Graph" this, #_"FixedWithNextNode" node, #_"FixedWithNextNode" replacement]
        (let [
            #_"FixedNode" next (:next node)
            _ (§ ass! node (FixedWithNextNode''setNext-2 node, nil))
            _ (§ ass! replacement (FixedWithNextNode''setNext-2 replacement, next))
            _ (§ ass! node (Node''replaceAndDelete-2 node, replacement))
        ]
            (when (= node (:start this)) => this
                (Graph''setStart-2 this, (§ cast #_"StartNode" replacement))
            )
        )
    )

    (§ method! #_"Graph" Graph''replaceFixedWithFloating-3 [#_"Graph" this, #_"FixedWithNextNode" node, #_"ValueNode" replacement]
        (GraphUtil'unlinkFixedNode-1 node)
        (Node''replaceAtUsagesAndDelete-2 node, replacement)
        this
    )

    (§ method! #_"Graph" Graph''replaceFixed-3 [#_"Graph" this, #_"FixedWithNextNode" node, #_"Node" replacement]
        (if (instance? FixedWithNextNode replacement)
            (Graph''replaceFixedWithFixed-3 this, node, replacement)
            (Graph''replaceFixedWithFloating-3 this, node, replacement)
        )
    )

    (§ method! #_"void" Graph''removeSplit-3 [#_"Graph" this, #_"ControlSplitNode" node, #_"AbstractBeginNode" survivingSuccessor]
        (Node''clearSuccessors-1 node)
        (Node''replaceAtPredecessor-2 node, survivingSuccessor)
        (Node''safeDelete-1 node)
        nil
    )

    (§ method! #_"void" Graph''removeSplitPropagate-3 [#_"Graph" this, #_"ControlSplitNode" node, #_"AbstractBeginNode" survivingSuccessor]
        (let [
            #_"List<Node>" snapshot (NodeIterable''snapshot-1 (Node''successors-1 node))
        ]
            (Node''clearSuccessors-1 node)
            (Node''replaceAtPredecessor-2 node, survivingSuccessor)
            (Node''safeDelete-1 node)
            (doseq [#_"Node" successor snapshot]
                (when (and (some? successor) (Node''isAlive-1 successor) (not (= successor survivingSuccessor)))
                    (GraphUtil'killCFG-1 successor)
                )
            )
        )
        nil
    )

    (§ method! #_"void" Graph''replaceSplit-4 [#_"Graph" this, #_"ControlSplitNode" node, #_"Node" replacement, #_"AbstractBeginNode" survivingSuccessor]
        (if (instance? FixedWithNextNode replacement)
            (Graph''replaceSplitWithFixed-4 this, node, replacement, survivingSuccessor)
            (Graph''replaceSplitWithFloating-4 this, node, replacement, survivingSuccessor)
        )
        nil
    )

    (§ method! #_"void" Graph''replaceSplitWithFixed-4 [#_"Graph" this, #_"ControlSplitNode" node, #_"FixedWithNextNode" replacement, #_"AbstractBeginNode" survivingSuccessor]
        (Node''clearSuccessors-1 node)
        (§ ass! replacement (FixedWithNextNode''setNext-2 replacement, survivingSuccessor))
        (§ ass! node (Node''replaceAndDelete-2 node, replacement))
        nil
    )

    (§ method! #_"void" Graph''replaceSplitWithFloating-4 [#_"Graph" this, #_"ControlSplitNode" node, #_"FloatingNode" replacement, #_"AbstractBeginNode" survivingSuccessor]
        (Node''clearSuccessors-1 node)
        (Node''replaceAtPredecessor-2 node, survivingSuccessor)
        (Node''replaceAtUsagesAndDelete-2 node, replacement)
        nil
    )

    (§ method! #_"void" Graph''addAfterFixed-3 [#_"Graph" this, #_"FixedWithNextNode" node, #_"FixedNode" newNode]
        (let [
            #_"FixedNode" next (:next node)
        ]
            (§ ass! node (FixedWithNextNode''setNext-2 node, newNode))
            (when (some? next)
                (§ ass! newNode (FixedWithNextNode''setNext-2 newNode, next))
            )
        )
        nil
    )

    (§ method! #_"void" Graph''addBeforeFixed-3 [#_"Graph" this, #_"FixedNode" node, #_"FixedWithNextNode" newNode]
        (§ ass! (:predecessor node) (FixedWithNextNode''setNext-2 (:predecessor node), newNode))
        (§ ass! newNode (FixedWithNextNode''setNext-2 newNode, node))
        nil
    )

    (§ method! #_"Graph" Graph''reduceDegenerateLoopBegin-2 [#_"Graph" this, #_"LoopBeginNode" begin]
        (if (= (AbstractMergeNode''forwardEndCount-1 begin) 1)
            ;; bypass merge and remove
            (do
                (Graph''reduceTrivialMerge-2 this, begin)
                this
            )
            ;; convert to merge
            (let [
                #_"AbstractMergeNode" merge (Graph''add-2 this, (MergeNode'new-0))
            ]
                (doseq [#_"EndNode" end (AbstractMergeNode''forwardEnds-1 begin)]
                    (AbstractMergeNode''addForwardEnd-2 merge, end)
                )
                (Graph''replaceFixedWithFixed-3 this, begin, merge)
            )
        )
    )

    (§ method! #_"void" Graph''reduceTrivialMerge-2 [#_"Graph" this, #_"AbstractMergeNode" merge]
        (doseq [#_"PhiNode" phi (NodeIterable''snapshot-1 (AbstractMergeNode''phis-1 merge))]
            (let [
                #_"ValueNode" singleValue (PhiNode''valueAt-2 phi, 0)
            ]
                (if (Node''hasUsages-1 phi)
                    (Node''replaceAtUsagesAndDelete-2 phi, singleValue)
                    (do
                        (Node''safeDelete-1 phi)
                        (when (some? singleValue)
                            (GraphUtil'tryKillUnused-1 singleValue)
                        )
                    )
                )
            )
        )
        ;; remove loop exits
        (when (instance? LoopBeginNode merge)
            (LoopBeginNode''removeExits-1 merge)
        )
        (let [
            #_"AbstractEndNode" singleEnd (AbstractMergeNode''forwardEndAt-2 merge, 0)
            #_"FixedNode" sux (:next merge)
            #_"FrameState" stateAfter (BeginStateSplitNode''stateAfter-1 merge)
        ]
            ;; evacuateGuards
            (AbstractBeginNode''prepareDelete-2 merge, (:predecessor singleEnd))
            (Node''safeDelete-1 merge)
            (when (some? stateAfter)
                (GraphUtil'tryKillUnused-1 stateAfter)
            )
            (when (nil? sux) => (§ ass! singleEnd (Node''replaceAndDelete-2 singleEnd, sux))
                (Node''replaceAtPredecessor-2 singleEnd, nil)
                (Node''safeDelete-1 singleEnd)
            )
        )
        nil
    )

    (§ method! #_"Graph" Graph''setGuardsStage-2 [#_"Graph" this, #_"GuardsStage" guardsStage]
        (assoc this :guardsStage guardsStage)
    )

    (§ method! #_"Graph" Graph''setAfterFloatingReadPhase-2 [#_"Graph" this, #_"boolean" state]
        (assoc this :isAfterFloatingReadPhase state)
    )

    (§ method! #_"Graph" Graph''setAfterFixReadPhase-2 [#_"Graph" this, #_"boolean" state]
        (assoc this :isAfterFixedReadPhase state)
    )

    (§ method! #_"Graph" Graph''setHasValueProxies-2 [#_"Graph" this, #_"boolean" state]
        (assoc this :hasValueProxies state)
    )

    (§ method! #_"Graph" Graph''setAfterExpandLogic-1 [#_"Graph" this]
        (assoc this :isAfterExpandLogic true)
    )

    (§ method! #_"void" Graph''clearAllStateAfter-1 [#_"Graph" this]
        (doseq [#_"Node" node (Graph''getNodes-1 this)]
            (when (instance? StateSplit node)
                (let [
                    #_"FrameState" stateAfter (StateSplit''stateAfter-1 node)
                ]
                    (when (some? stateAfter)
                        (StateSplit''setStateAfter-2 node, nil)
                        ;; 2 nodes referencing the same framestate
                        (when (Node''isAlive-1 stateAfter)
                            (GraphUtil'killWithUnusedFloatingInputs-1 stateAfter)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"boolean" Graph''hasVirtualizableAllocation-1 [#_"Graph" this]
        (loop [#_"ISeq" s (seq (Graph''getNodes-1 this))]
            (and (some? s)
                (or (instance? VirtualizableAllocation (first s))
                    (recur (next s))
                )
            )
        )
    )
)

;;;
 ; The type of events sent to a NodeEventListener.
 ;
 ; @anno Graph.NodeEvent
 ;;
(value-ns NodeEvent
    ;;;
     ; A node's input is changed.
     ;;
    (§ enum NodeEvent'INPUT_CHANGED)
    ;;;
     ; A node's {@linkplain Node#usages() usages} count dropped to zero.
     ;;
    (§ enum NodeEvent'ZERO_USAGES)
    ;;;
     ; A node was added to a graph.
     ;;
    (§ enum NodeEvent'NODE_ADDED)
    ;;;
     ; A node was removed from the graph.
     ;;
    (§ enum NodeEvent'NODE_REMOVED)
)

;;;
 ; Client interested in one or more node related events.
 ;
 ; @anno Graph.NodeEventListener
 ;;
(class-ns NodeEventListener
    (§ defn #_"NodeEventListener" NodeEventListener'new-0 []
        (Object.)
    )

    ;;;
     ; A method called when a change event occurs.
     ;
     ; This method dispatches the event to user-defined triggers. The methods that change the
     ; graph (typically in Graph and Node) must call this method to dispatch the event.
     ;
     ; @param e an event
     ; @param node the node related to {@code e}
     ;;
    (§ method! #_"void" NodeEventListener''event-3 [#_"NodeEventListener" this, #_"NodeEvent" e, #_"Node" node]
        (condp = e
            NodeEvent'INPUT_CHANGED (NodeEventListener''inputChanged-2 this, node)
            NodeEvent'ZERO_USAGES   (NodeEventListener''usagesDroppedToZero-2 this, node)
            NodeEvent'NODE_ADDED    (NodeEventListener''nodeAdded-2 this, node)
            NodeEvent'NODE_REMOVED  (NodeEventListener''nodeRemoved-2 this, node)
            nil
        )
        (NodeEventListener''changed-3 this, e, node)
        nil
    )

    ;;;
     ; Notifies this listener about any change event in the graph.
     ;
     ; @param e an event
     ; @param node the node related to {@code e}
     ;;
    (§ method #_"void" NodeEventListener''changed-3 [#_"NodeEventListener" this, #_"NodeEvent" e, #_"Node" node]
        nil
    )

    ;;;
     ; Notifies this listener about a change in a node's inputs.
     ;
     ; @param node a node who has had one of its inputs changed
     ;;
    (§ method #_"void" NodeEventListener''inputChanged-2 [#_"NodeEventListener" this, #_"Node" node]
        nil
    )

    ;;;
     ; Notifies this listener of a node becoming unused.
     ;
     ; @param node a node whose Node#usages() just became empty
     ;;
    (§ method #_"void" NodeEventListener''usagesDroppedToZero-2 [#_"NodeEventListener" this, #_"Node" node]
        nil
    )

    ;;;
     ; Notifies this listener of an added node.
     ;
     ; @param node a node that was just added to the graph
     ;;
    (§ method #_"void" NodeEventListener''nodeAdded-2 [#_"NodeEventListener" this, #_"Node" node]
        nil
    )

    ;;;
     ; Notifies this listener of a removed node.
     ;;
    (§ method #_"void" NodeEventListener''nodeRemoved-2 [#_"NodeEventListener" this, #_"Node" node]
        nil
    )
)

;;;
 ; @anno Graph.ChainedNodeEventListener
 ;;
(final-ns ChainedNodeEventListener (§ extends NodeEventListener)
    (§ mutable #_"NodeEventListener" :head nil)
    (§ mutable #_"NodeEventListener" :next nil)

    (§ defn #_"ChainedNodeEventListener" ChainedNodeEventListener'new-2 [#_"NodeEventListener" head, #_"NodeEventListener" next]
        (let [
            #_"ChainedNodeEventListener" this (NodeEventListener'new-0)
            this (assoc this :head head)
            this (assoc this :next next)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ChainedNodeEventListener''nodeAdded-2 [#_"ChainedNodeEventListener" this, #_"Node" node]
        (NodeEventListener''event-3 (:head this), NodeEvent'NODE_ADDED, node)
        (NodeEventListener''event-3 (:next this), NodeEvent'NODE_ADDED, node)
        nil
    )

    #_unused
    (§ override! #_"void" ChainedNodeEventListener''inputChanged-2 [#_"ChainedNodeEventListener" this, #_"Node" node]
        (NodeEventListener''event-3 (:head this), NodeEvent'INPUT_CHANGED, node)
        (NodeEventListener''event-3 (:next this), NodeEvent'INPUT_CHANGED, node)
        nil
    )

    #_unused
    (§ override! #_"void" ChainedNodeEventListener''usagesDroppedToZero-2 [#_"ChainedNodeEventListener" this, #_"Node" node]
        (NodeEventListener''event-3 (:head this), NodeEvent'ZERO_USAGES, node)
        (NodeEventListener''event-3 (:next this), NodeEvent'ZERO_USAGES, node)
        nil
    )

    #_unused
    (§ override! #_"void" ChainedNodeEventListener''nodeRemoved-2 [#_"ChainedNodeEventListener" this, #_"Node" node]
        (NodeEventListener''event-3 (:head this), NodeEvent'NODE_REMOVED, node)
        (NodeEventListener''event-3 (:next this), NodeEvent'NODE_REMOVED, node)
        nil
    )

    #_unused
    (§ override! #_"void" ChainedNodeEventListener''changed-3 [#_"ChainedNodeEventListener" this, #_"NodeEvent" e, #_"Node" node]
        (NodeEventListener''event-3 (:head this), e, node)
        (NodeEventListener''event-3 (:next this), e, node)
        nil
    )
)

;;;
 ; Registers a given NodeEventListener with the enclosing graph until this object is {@linkplain #close() closed}.
 ;
 ; @anno Graph.NodeEventScope
 ;;
(final-ns NodeEventScope (§ implements AutoCloseable)
    (§ final #_"Graph" :graph nil)

    (§ defn #_"NodeEventScope" NodeEventScope'new-2 [#_"Graph" graph, #_"NodeEventListener" listener]
        (let [
            #_"NodeEventScope" this (Object.)
            this (assoc this :graph graph)
        ]
            (if (nil? (:nodeEventListener (:graph this)))
                (§ ass! (:nodeEventListener (:graph this)) listener)
                (§ ass! (:nodeEventListener (:graph this)) (ChainedNodeEventListener'new-2 listener, (:nodeEventListener (:graph this))))
            )
            this
        )
    )

    #_unused
    (§ override! #_"void" NodeEventScope''close-1 [#_"NodeEventScope" this]
        (if (instance? ChainedNodeEventListener (:nodeEventListener (:graph this)))
            (§ ass! (:nodeEventListener (:graph this)) (:next (:nodeEventListener (:graph this))))
            (§ ass! (:nodeEventListener (:graph this)) nil)
        )
        nil
    )
)

;;;
 ; A snapshot of the {@linkplain Graph#getNodeCount() live node count} in a graph.
 ;
 ; @anno Graph.NodeMark
 ;;
(final-ns NodeMark
    (§ final #_"Graph" :graph nil)
    ;;;
     ; Live node count of the associated graph when this object was created.
     ;;
    (§ final #_"int" :value 0)

    (§ defn #_"NodeMark" NodeMark'new-1 [#_"Graph" graph]
        (let [
            #_"NodeMark" this (Object.)
            this (assoc this :graph graph)
            this (assoc this :value (:nodesSize graph))
        ]
            this
        )
    )

    ;;;
     ; Determines if this mark is positioned at the first live node in the graph.
     ;;
    (§ method! #_"boolean" NodeMark''isStart-1 [#_"NodeMark" this]
        (zero? (:value this))
    )

    ;;;
     ; Determines if this mark still represents the {@linkplain Graph#getNodeCount() live node count} of the graph.
     ;;
    #_unused
    (§ method! #_"boolean" NodeMark''isCurrent-1 [#_"NodeMark" this]
        (= (:value this) (:nodesSize (:graph this)))
    )
)

;;;
 ; @anno Graph.PlaceHolderNode
 ;;
(final-ns PlaceHolderNode (§ extends Node)
    (§ def #_"NodeClass<PlaceHolderNode>" PlaceHolderNode'TYPE (NodeClass'create-1 PlaceHolderNode))

    #_unused
    (§ defn #_"PlaceHolderNode" PlaceHolderNode'new-0 []
        (Node'new-1 PlaceHolderNode'TYPE)
    )
)

;;;
 ; @anno Graph.DuplicationReplacement
 ;;
(§ interface DuplicationReplacement
    (§ abstract #_"Node" DuplicationReplacement''replacement-2 [#_"DuplicationReplacement" this, #_"Node" original])
)

;;;
 ; @anno Graph.MapReplacement
 ;;
(final-ns MapReplacement (§ implements DuplicationReplacement)
    (§ final #_"EconomicMap<Node, Node>" :map nil)

    (§ defn #_"MapReplacement" MapReplacement'new-1 [#_"EconomicMap<Node, Node>" map]
        (let [
            #_"MapReplacement" this (Object.)
            this (assoc this :map map)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Node" MapReplacement''replacement-2 [#_"MapReplacement" this, #_"Node" original]
        (or (get (:map this) original) original)
    )
)

;;;
 ; The different stages of the compilation of a Graph regarding the status of {@link GuardNode guards},
 ; {@link DeoptimizingNode deoptimizations} and {@link FrameState framestates}.
 ; The stage of a graph progresses monotonously.
 ;
 ; @anno Graph.GuardsStage
 ;;
(value-ns GuardsStage
    ;;;
     ; During this stage, there can be {@link FloatingNode floating} DeoptimizingNodes
     ; such as GuardNodes. New DeoptimizingNodes can be introduced without constraints.
     ; FrameState nodes are associated with StateSplit nodes.
     ;;
    (§ enum GuardsStage'FLOATING_GUARDS)
    ;;;
     ; During this stage, all DeoptimizingNodes must be {@link FixedNode fixed},
     ; but new DeoptimizingNodes can still be introduced.
     ; FrameState nodes are still associated with StateSplit nodes.
     ;;
    (§ enum GuardsStage'FIXED_DEOPTS)
    ;;;
     ; During this stage, all DeoptimizingNodes must be {@link FixedNode fixed}.
     ; New DeoptimizingNodes can not be introduced any more.
     ; FrameState nodes are now associated with DeoptimizingNode nodes.
     ;;
    (§ enum GuardsStage'AFTER_FSA)

    (§ defn #_"boolean" GuardsStage'allowsFloatingGuards-1 [#_"GuardsStage" self]
        (= self GuardsStage'FLOATING_GUARDS)
    )

    (§ defn #_"boolean" GuardsStage'areFrameStatesAtDeopts-1 [#_"GuardsStage" self]
        (= self GuardsStage'AFTER_FSA)
    )

    (§ defn #_"boolean" GuardsStage'areFrameStatesAtSideEffects-1 [#_"GuardsStage" self]
        (not (GuardsStage'areFrameStatesAtDeopts-1 self))
    )

    (§ defn #_"boolean" GuardsStage'areDeoptsFixed-1 [#_"GuardsStage" self]
        (<= (GuardsStage''ordinal-1 GuardsStage'FIXED_DEOPTS) (GuardsStage''ordinal-1 self))
    )
)

;;;
 ; @anno Graph.ScheduleResult
 ;;
(final-ns ScheduleResult
    (§ final #_"ControlFlowGraph" :cfg nil)
    (§ final #_"NodeMap<Block>" :nodeToBlockMap nil)
    (§ final #_"BlockMap<List<Node>>" :blockToNodesMap nil)

    (§ defn #_"ScheduleResult" ScheduleResult'new-3 [#_"ControlFlowGraph" cfg, #_"NodeMap<Block>" nodeToBlockMap, #_"BlockMap<List<Node>>" blockToNodesMap]
        (let [
            #_"ScheduleResult" this (Object.)
            this (assoc this :cfg cfg)
            this (assoc this :nodeToBlockMap nodeToBlockMap)
            this (assoc this :blockToNodesMap blockToNodesMap)
        ]
            this
        )
    )

    (§ method! #_"List<Node>" ScheduleResult''nodesFor-2 [#_"ScheduleResult" this, #_"Block" block]
        (BlockMap''get-2 (:blockToNodesMap this), block)
    )
)

(class-ns NarrowOopStamp (§ extends AbstractObjectStamp)
    (§ final #_"CompressEncoding" :encoding nil)

    (§ defn #_"NarrowOopStamp" NarrowOopStamp'new-5 [#_"ResolvedJavaType" type, #_"boolean" exactType, #_"boolean" never-nil?, #_"boolean" always-nil?, #_"CompressEncoding" encoding]
        (let [
            #_"NarrowOopStamp" this (AbstractObjectStamp'new-4 type, exactType, never-nil?, always-nil?)
            this (assoc this :encoding encoding)
        ]
            this
        )
    )

    #_unused
    (§ abstract #_"AbstractObjectStamp" NarrowOopStamp''copyWith-5 [#_"NarrowOopStamp" this, #_"ResolvedJavaType" type, #_"boolean" exactType, #_"boolean" never-nil?, #_"boolean" always-nil?])

    (§ method #_"Stamp" NarrowOopStamp''uncompressed-1 [#_"NarrowOopStamp" this]
        (ObjectStamp'new-4 (AbstractObjectStamp''type-1 this), (AbstractObjectStamp''isExactType-1 this), (:never-nil? this), (:always-nil? this))
    )

    (§ method #_"CompressEncoding" NarrowOopStamp''getEncoding-1 [#_"NarrowOopStamp" this]
        (:encoding this)
    )

    #_unused
    (§ override #_"LIRKind" NarrowOopStamp''getLIRKind-1 [#_"NarrowOopStamp" this]
        (LIRKindTool'getNarrowOopKind-0)
    )

    #_unused
    (§ override #_"boolean" NarrowOopStamp''isCompatible-2 [#_"NarrowOopStamp" this, #_"Stamp" other]
        (or (= this other)
            (and (instance? NarrowOopStamp other)
                (= (:encoding this) (:encoding other))
            )
        )
    )

    #_unused
    (§ abstract #_"Constant" NarrowOopStamp''readConstant-4 [#_"NarrowOopStamp" this, #_"MemoryAccessProvider" provider, #_"Constant" base, #_"long" displacement])

    #_unused
    (§ abstract #_"JavaConstant" NarrowOopStamp''asConstant-1 [#_"NarrowOopStamp" this])

    #_unused
    (§ abstract #_"boolean" NarrowOopStamp''isCompatible-2 [#_"NarrowOopStamp" this, #_"Constant" other])
)

;;;
 ; Helper class that is used to keep all stamp-related operations in one place.
 ;;
(value-ns StampTool
    #_unused
    (§ defn #_"Stamp" StampTool'meet-1 [#_"Iterable<? extends ValueNode>" values]
        (or (StampTool'meetOrNull-2 values, nil) (StampFactory'forVoid-0))
    )

    ;;;
     ; Meet a collection of ValueNodes optionally excluding {@code self}. If no values
     ; are encountered then return nil.
     ;;
    (§ defn #_"Stamp" StampTool'meetOrNull-2 [#_"Iterable<? extends ValueNode>" values, #_"ValueNode" self]
        (let [
            #_"Iterator<? extends ValueNode>" it (#_"Iterable" .iterator values)
        ]
            (loop-when [#_"Stamp" stamp nil] (#_"Iterator" .hasNext it) => stamp
                (let [
                    #_"ValueNode" value (#_"Iterator" .next it)
                    stamp
                        (when-not (= value self) => stamp
                            (if (some? stamp) (Stamp''meet-2 stamp, (:stamp value)) (:stamp value))
                        )
                ]
                    (recur stamp)
                )
            )
        )
    )

    ;;;
     ; Compute the stamp resulting from the unsigned comparison being true.
     ;
     ; @return nil if it's can't be true or it nothing useful can be encoded
     ;;
    #_unused
    (§ defn #_"Stamp" StampTool'unsignedCompare-2 [#_"Stamp" a, #_"Stamp" b]
        (cond
            (and (IntegerStamp''isUnrestricted-1 a) (IntegerStamp''isUnrestricted-1 b))
                ;; don't know anything
                nil
            ;; c <| n, where c is a constant and n is known to be positive
            (= (:lowerBound a) (:upperBound a))
                (when (IntegerStamp''isPositive-1 b)
                    (cond
                        ;; constant is MAX_VALUE which must fail
                        (= (:lowerBound a) (dec (<< 1 (:bits a)))) nil
                        ;; test will fail - return illegalStamp instead?
                        (<= (:lowerBound a) (:lowerBound b)) nil
                        ;; when test succeeds, n is at greater than c, so the bounds are [c+1..-n.upperBound]
                        :else (StampFactory'forInteger-3 (:bits a), (inc (:lowerBound a)), (:upperBound b))
                    )
                )
            ;; n <| c, where c is a strictly positive constant
            (and (= (:lowerBound b) (:upperBound b)) (IntegerStamp''isStrictlyPositive-1 b))
                ;; the test proves that n is positive and less than c, [0..c-1]
                (StampFactory'forInteger-3 (:bits b), 0, (dec (:lowerBound b)))
        )
    )

    (§ defn #_"Stamp" StampTool'stampForLeadingZeros-1 [#_"IntegerStamp" stamp]
        (let [
            #_"long" mask (CodeUtil/mask (:bits stamp))
            ;; Don't count zeros from the mask in the result.
            #_"int" adjust (Long/numberOfLeadingZeros mask)
            #_"int" lower (- (Long/numberOfLeadingZeros (& (:upMask stamp) mask)) adjust)
            #_"int" upper (- (Long/numberOfLeadingZeros (& (:downMask stamp) mask)) adjust)
        ]
            (StampFactory'forInteger-3 JavaKind/Int, lower, upper)
        )
    )

    (§ defn #_"Stamp" StampTool'stampForTrailingZeros-1 [#_"IntegerStamp" stamp]
        (let [
            #_"long" mask (CodeUtil/mask (:bits stamp))
            #_"int" lower (Long/numberOfTrailingZeros (& (:upMask stamp) mask))
            #_"int" upper (Long/numberOfTrailingZeros (& (:downMask stamp) mask))
        ]
            (StampFactory'forInteger-3 JavaKind/Int, lower, upper)
        )
    )

    ;;;
     ; Checks whether this Stamp represents a {@linkplain Stamp#hasValues() legal} pointer
     ; stamp whose values are known to be always nil.
     ;
     ; @return true if this stamp represents a legal object stamp whose values are known to be always nil
     ;;
    (§ defn #_"boolean" StampTool'isPointerAlwaysNull-1 [#_"Stamp" stamp]
        (and (instance? AbstractPointerStamp stamp) (Stamp''hasValues-1 stamp)
            (:always-nil? stamp)
        )
    )

    ;;;
     ; Checks whether this Stamp represents a {@linkplain Stamp#hasValues() legal} pointer
     ; stamp whose values are known to be never nil.
     ;
     ; @return true if this stamp represents a legal object stamp whose values are known to be never nil
     ;;
    (§ defn #_"boolean" StampTool'isPointerNeverNull-1 [#_"Stamp" stamp]
        (and (instance? AbstractPointerStamp stamp)
            (:never-nil? stamp)
        )
    )

    ;;;
     ; Returns the Java type this Stamp has if it is a {@linkplain Stamp#hasValues() legal} Object stamp.
     ;
     ; @return the Java type this stamp has if it is a legal Object stamp, nil otherwise
     ;;
    (§ defn #_"TypeReference" StampTool'typeReferenceOrNull-1 [#_"Stamp" stamp]
        (when (and (instance? AbstractObjectStamp stamp) (Stamp''hasValues-1 stamp))
            (if (AbstractObjectStamp''isExactType-1 stamp)
                (TypeReference'createExactTrusted-1 (AbstractObjectStamp''type-1 stamp))
                (TypeReference'createTrusted-1 (AbstractObjectStamp''type-1 stamp))
            )
        )
    )

    (§ defn #_"ResolvedJavaType" StampTool'typeOrNull-1 [#_"Stamp" stamp]
        (let [
            #_"TypeReference" type (StampTool'typeReferenceOrNull-1 stamp)
        ]
            (when (some? type) (:type type))
        )
    )

    #_unused
    (§ defn #_"ResolvedJavaType" StampTool'objectTypeOrNull-1 [#_"Stamp" stamp]
        (when (and (instance? AbstractObjectStamp stamp) (Stamp''hasValues-1 stamp))
            (or (AbstractObjectStamp''type-1 stamp)
                (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, Object)
            )
        )
    )

    ;;;
     ; Checks whether this Stamp represents a {@linkplain Stamp#hasValues() legal} Object
     ; stamp whose Java type is known exactly. If this method returns
     ; true then the Java type returned by #typeReferenceOrNull(Stamp) is the only concrete
     ; dynamic/runtime Java type possible for values of this stamp.
     ;
     ; @return true if this node represents a legal object stamp whose Java type is known exactly
     ;;
    #_unused
    (§ defn #_"boolean" StampTool'isExactType-1 [#_"Stamp" stamp]
        (and (instance? AbstractObjectStamp stamp) (Stamp''hasValues-1 stamp)
            (AbstractObjectStamp''isExactType-1 stamp)
        )
    )
)

(class-ns UnaryOpLogicNode (§ extends LogicNode) (§ implements LIRLowerable, Unary #_"<ValueNode>")
    (§ def #_"NodeClass<UnaryOpLogicNode>" UnaryOpLogicNode'TYPE (NodeClass'create-1 UnaryOpLogicNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)

    (§ override #_"ValueNode" UnaryOpLogicNode''getValue-1 [#_"UnaryOpLogicNode" this]
        (:value this)
    )

    (§ defn #_"UnaryOpLogicNode" UnaryOpLogicNode'new-2 [#_"NodeClass<? extends UnaryOpLogicNode>" c, #_"ValueNode" value]
        (let [
            #_"UnaryOpLogicNode" this (LogicNode'new-1 c)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override #_"void" UnaryOpLogicNode''generate-2 [#_"UnaryOpLogicNode" this, #_"LIRBuilder" builder]
        nil
    )

    #_unused
    (§ method #_"Stamp" UnaryOpLogicNode''getSucceedingStampForValue-3 [#_"UnaryOpLogicNode" this, #_"boolean" negated?, #_"Stamp" valueStamp]
        (let [
            #_"Stamp" succStamp (UnaryOpLogicNode''getSucceedingStampForValue-2 this, negated?)
        ]
            (when (some? succStamp)
                (Stamp''join-2 succStamp, valueStamp)
            )
        )
    )

    (§ abstract #_"Stamp" UnaryOpLogicNode''getSucceedingStampForValue-2 [#_"UnaryOpLogicNode" this, #_"boolean" negated?])

    (§ abstract #_"TriState" UnaryOpLogicNode''tryFold-2 [#_"UnaryOpLogicNode" this, #_"Stamp" valueStamp])
)

(value-ns GraphUtil
    (§ defn- #_"void" GraphUtil'markFixedNodes-3 [#_"FixedNode" node, #_"EconomicSet<Node>" markedNodes, #_"EconomicMap<AbstractMergeNode, List<AbstractEndNode>>" unmarkedMerges]
        (let [
            #_"NodeStack" stack (NodeStack'new-0)
            _ (§ ass! stack (NodeStack''push-2 stack, node))
        ]
            (while (not (NodeStack''isEmpty-1 stack))
                (let [
                    #_"Node" node (NodeStack''pop-1 stack)
                ]
                    (#_"EconomicSet" .add markedNodes, node)
                    (when (instance? AbstractMergeNode node)
                        (#_"EconomicMap" .removeKey unmarkedMerges, node)
                    )
                    (let [
                        node
                            (loop-when node (instance? FixedWithNextNode node) => node
                                (let [
                                    node (:next node)
                                ]
                                    (when (some? node)
                                        (#_"EconomicSet" .add markedNodes, node)
                                    )
                                    (recur node)
                                )
                            )
                    ]
                        (condp instance? node
                            ControlSplitNode
                                (doseq [#_"Node" successor (Node''successors-1 node)]
                                    (§ ass! stack (NodeStack''push-2 stack, successor))
                                )
                            AbstractEndNode
                                (let [
                                    #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 node)
                                ]
                                    (when (some? merge)
                                        (when (instance? LoopBeginNode merge)
                                            (when (= node (LoopBeginNode''forwardEnd-1 merge))
                                                (§ ass! stack (NodeStack''push-2 stack, merge))
                                                (§ continue )
                                            )
                                            (when (contains? markedNodes merge)
                                                (§ continue )
                                            )
                                        )
                                        (let [
                                            #_"List<AbstractEndNode>" endsSeen (get unmarkedMerges merge)
                                        ]
                                            (when (nil? endsSeen)
                                                (§ ass endsSeen (ArrayList.))
                                                (#_"EconomicMap" .put unmarkedMerges, merge, endsSeen)
                                            )
                                            (#_"List" .add endsSeen, node)
                                            (when (and (not (instance? LoopEndNode node)) (= (count endsSeen) (AbstractMergeNode''forwardEndCount-1 merge)))
                                                ;; all this merge's forward ends are marked: it needs to be killed
                                                (§ ass! stack (NodeStack''push-2 stack, merge))
                                            )
                                        )
                                    )
                                )
                            nil
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" GraphUtil'fixSurvivingAffectedMerges-2 [#_"EconomicSet<Node>" markedNodes, #_"EconomicMap<AbstractMergeNode, List<AbstractEndNode>>" unmarkedMerges]
        (let [
            #_"MapCursor<AbstractMergeNode, List<AbstractEndNode>>" cursor (#_"EconomicMap" .getEntries unmarkedMerges)
        ]
            (while (#_"MapCursor" .advance cursor)
                (let [
                    #_"AbstractMergeNode" merge (#_"MapCursor" .getKey cursor)
                ]
                    (doseq [#_"AbstractEndNode" end (#_"MapCursor" .getValue cursor)]
                        (AbstractMergeNode''removeEnd-2 merge, end)
                    )
                    (when (= (AbstractMergeNode''phiPredecessorCount-1 merge) 1)
                        (if (instance? LoopBeginNode merge)
                            (do
                                (doseq [#_"LoopExitNode" exit (NodeIterable''snapshot-1 (LoopBeginNode''loopExits-1 merge))]
                                    (when (contains? markedNodes exit)
                                        ;; disconnect from loop begin so that reduceDegenerateLoopBegin doesn't transform it into a new beginNode
                                        (Node''replaceFirstInput-3 exit, merge, nil)
                                    )
                                )
                                (§ ass! (:graph merge) (Graph''reduceDegenerateLoopBegin-2 (:graph merge), merge))
                            )
                            (Graph''reduceTrivialMerge-2 (:graph merge), merge)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" GraphUtil'markUsages-1 [#_"EconomicSet<Node>" markedNodes]
        (let [
            #_"NodeStack" stack (NodeStack'new-1 (+ (count markedNodes) 4))
            _
                (doseq [#_"Node" marked markedNodes]
                    (§ ass! stack (NodeStack''push-2 stack, marked))
                )
        ]
            (while (not (NodeStack''isEmpty-1 stack))
                (let [
                    #_"Node" marked (NodeStack''pop-1 stack)
                ]
                    (doseq [#_"Node" usage (Node''usages-1 marked)]
                        (when-not (contains? markedNodes usage)
                            (§ ass! stack (NodeStack''push-2 stack, usage))
                            (#_"EconomicSet" .add markedNodes, usage)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"void" GraphUtil'killCFG-1 [#_"FixedNode" node]
        (let [
            #_"EconomicSet<Node>" markedNodes (EconomicSet/create)
            #_"EconomicMap<AbstractMergeNode, List<AbstractEndNode>>" unmarkedMerges (EconomicMap/create)
        ]
            ;; detach this node from CFG
            (Node''replaceAtPredecessor-2 node, nil)

            (GraphUtil'markFixedNodes-3 node, markedNodes, unmarkedMerges)

            (GraphUtil'fixSurvivingAffectedMerges-2 markedNodes, unmarkedMerges)

            ;; mark non-fixed nodes
            (GraphUtil'markUsages-1 markedNodes)

            ;; detach marked nodes from non-marked nodes
            (doseq [#_"Node" marked markedNodes]
                (doseq [#_"Node" input (Node''inputs-1 marked)]
                    (when-not (contains? markedNodes input)
                        (Node''replaceFirstInput-3 marked, input, nil)
                        (GraphUtil'tryKillUnused-1 input)
                    )
                )
            )
            ;; kill marked nodes
            (doseq [#_"Node" marked markedNodes]
                (when (Node''isAlive-1 marked)
                    (Node''markDeleted-1 marked)
                )
            )
        )
        nil
    )

    (§ defn #_"boolean" GraphUtil'isFloatingNode-1 [#_"Node" n]
        (not (instance? FixedNode n))
    )

    (§ defn #_"void" GraphUtil'killWithUnusedFloatingInputs-1 [#_"Node" node]
        (GraphUtil'killWithUnusedFloatingInputs-2 node, false)
        nil
    )

    (§ defn #_"void" GraphUtil'killWithUnusedFloatingInputs-2 [#_"Node" node, #_"boolean" mayKillGuard]
        (Node''markDeleted-1 node)
        (doseq [#_"Node" in (Node''inputs-1 node)]
            (when (Node''isAlive-1 in)
                (Node''removeUsage-2 in, node)
                (when (Node''hasNoUsages-1 in)
                    (Node''maybeNotifyZeroUsages-2 node, in)
                )
                (when (GraphUtil'isFloatingNode-1 in)
                    (cond
                        (Node''hasNoUsages-1 in)
                            (if (instance? GuardNode in)
                                nil ;; Guard nodes are only killed if their anchor dies.
                                (GraphUtil'killWithUnusedFloatingInputs-1 in)
                            )
                        (instance? PhiNode in)
                            (loop [#_"ISeq" s (seq (Node''usages-1 in))]
                                (if (some? s)
                                    (when (= (first s) in)
                                        (recur (next s))
                                    )
                                    (do
                                        (§ ass! in (Node''replaceAtUsages-2 in, nil))
                                        (GraphUtil'killWithUnusedFloatingInputs-1 in)
                                    )
                                )
                            )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"void" GraphUtil'removeFixedWithUnusedInputs-1 [#_"FixedWithNextNode" fixed]
        (when (instance? StateSplit fixed)
            (let [
                #_"FrameState" stateAfter (StateSplit''stateAfter-1 fixed)
            ]
                (when (some? stateAfter)
                    (StateSplit''setStateAfter-2 fixed, nil)
                    (when (Node''hasNoUsages-1 stateAfter)
                        (GraphUtil'killWithUnusedFloatingInputs-1 stateAfter)
                    )
                )
            )
        )
        (GraphUtil'unlinkFixedNode-1 fixed)
        (GraphUtil'killWithUnusedFloatingInputs-1 fixed)
        nil
    )

    (§ defn #_"void" GraphUtil'unlinkFixedNode-1 [#_"FixedWithNextNode" fixed]
        (let [
            #_"FixedNode" next (:next fixed)
        ]
            (§ ass! fixed (FixedWithNextNode''setNext-2 fixed, nil))
            (Node''replaceAtPredecessor-2 fixed, next)
        )
        nil
    )

    (§ defn #_"void" GraphUtil'checkRedundantPhi-1 [#_"PhiNode" phiNode]
        (when-not (or (Node''isDeleted-1 phiNode) (= (PhiNode''valueCount-1 phiNode) 1))
            (let [
                #_"ValueNode" singleValue (PhiNode''singleValueOrThis-1 phiNode)
            ]
                (when-not (= singleValue phiNode)
                    (Node''replaceAtUsagesAndDelete-2 phiNode, singleValue)
                    (doseq [#_"PhiNode" phi (-> (Node''usages-1 phiNode) (NodeIterable''filter-2 PhiNode) (NodeIterable''snapshot-1))]
                        (GraphUtil'checkRedundantPhi-1 phi)
                    )
                    (doseq [#_"ProxyNode" proxy (-> (Node''usages-1 phiNode) (NodeIterable''filter-2 ProxyNode) (NodeIterable''snapshot-1))]
                        (GraphUtil'checkRedundantProxy-1 proxy)
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"void" GraphUtil'checkRedundantProxy-1 [#_"ProxyNode" vpn]
        (when-not (Node''isDeleted-1 vpn)
            (let [
                #_"AbstractBeginNode" proxyPoint (:loopExit vpn)
            ]
                (when (instance? LoopExitNode proxyPoint)
                    (let [
                        #_"LoopBeginNode" loopBegin (:loopBegin proxyPoint)
                        #_"Node" vpnValue (ProxyNode''value-1 vpn)
                    ]
                        (loop-when [#_"ISeq" s (seq (:values (BeginStateSplitNode''stateAfter-1 loopBegin)))] (some? s)
                            (let [
                                #_"ValueNode" v (first s)
                                v
                                    (when (AbstractMergeNode''isPhiAtMerge-2 loopBegin, v) => v
                                        (PhiNode''valueAt-2 v, (LoopBeginNode''forwardEnd-1 loopBegin))
                                    )
                            ]
                                (when (= vpnValue v) => (recur (next s))
                                    (Node''replaceAtUsagesAndDelete-2 vpn, vpnValue)
                                    (doseq [#_"PhiNode" phi (-> (Node''usages-1 vpn) (NodeIterable''filter-2 PhiNode) (NodeIterable''snapshot-1))]
                                        (GraphUtil'checkRedundantPhi-1 phi)
                                    )
                                    (doseq [#_"ProxyNode" proxy (-> (Node''usages-1 vpn) (NodeIterable''filter-2 ProxyNode) (NodeIterable''snapshot-1))]
                                        (GraphUtil'checkRedundantProxy-1 proxy)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Remove loop header without loop ends. This can happen with degenerated loops like this one:
     ;
     ; for ( ; ; ) {
     ;     try {
     ;         break;
     ;     } catch (UnresolvedException iioe) {
     ;     }
     ; }
     ;;
    (§ defn #_"void" GraphUtil'normalizeLoops-1 [#_"Graph" graph]
        (let [
            #_"boolean" removed?
                (loop-when [removed? false #_"ISeq" s (seq (Graph''getNodes-2 graph, LoopBeginNode'TYPE))] (some? s) => removed?
                    (let [
                        #_"LoopBeginNode" begin (first s)
                        removed?
                            (if (NodeIterable''isEmpty-1 (LoopBeginNode''loopEnds-1 begin))
                                (do
                                    (§ ass! graph (Graph''reduceDegenerateLoopBegin-2 graph, begin))
                                    true
                                )
                                (do
                                    (GraphUtil'normalizeLoopBegin-1 begin)
                                    removed?
                                )
                            )
                    ]
                        (recur removed? (next s))
                    )
                )
        ]
            (when removed?
                ;; Removing a degenerated loop can make non-loop phi functions unnecessary. Therefore,
                ;; we re-check all phi functions and remove redundant ones.
                (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                    (when (instance? PhiNode node)
                        (GraphUtil'checkRedundantPhi-1 node)
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" GraphUtil'normalizeLoopBegin-1 [#_"LoopBeginNode" begin]
        ;; Delete unnecessary loop phi functions, i.e. phi functions where all inputs are either the same or the phi itself.
        (doseq [#_"PhiNode" phi (NodeIterable''snapshot-1 (AbstractMergeNode''phis-1 begin))]
            (GraphUtil'checkRedundantPhi-1 phi)
        )
        (doseq [#_"LoopExitNode" exit (LoopBeginNode''loopExits-1 begin)]
            (doseq [#_"ProxyNode" vpn (NodeIterable''snapshot-1 (LoopExitNode''proxies-1 exit))]
                (GraphUtil'checkRedundantProxy-1 vpn)
            )
        )
        nil
    )

    ;;;
     ; Gets the original value by iterating through all {@link ValueProxy ValueProxies}.
     ;
     ; @param value the start value.
     ; @return the first non-proxy value encountered
     ;;
    (§ defn #_"ValueNode" GraphUtil'unproxify-1 [#_"ValueNode" value]
        (if (instance? ValueProxy value) (GraphUtil'unproxify-1 value) value)
    )

    ;;;
     ; Gets the original value by iterating through all {@link ValueProxy ValueProxies}.
     ;
     ; @param value the start value proxy.
     ; @return the first non-proxy value encountered
     ;;
    (§ defn #_"ValueNode" GraphUtil'unproxify-1 [#_"ValueProxy" value]
        (when (some? value)
            (loop-when-recur [#_"ValueNode" n (Proxy''getOriginalNode-1 value)] (instance? ValueProxy n) [(Proxy''getOriginalNode-1 n)] => n)
        )
    )

    (§ defn #_"ValueNode" GraphUtil'skipPi-1 [#_"ValueNode" node]
        (loop-when-recur node (instance? PiNode node) (PiNode''getOriginalNode-1 node) => node)
    )

    (§ defn #_"ValueNode" GraphUtil'skipPiWhileNonNull-1 [#_"ValueNode" node]
        (loop-when node (instance? PiNode node) => node
            (recur-if (:never-nil? (:stamp (PiNode''getOriginalNode-1 node))) (PiNode''getOriginalNode-1 node) => node)
        )
    )

    ;;;
     ; Looks for an ArrayLengthProvider while iterating through all {@link ValueProxy ValueProxies}.
     ;
     ; @param value The start value.
     ; @return the array length if one was found, or nil otherwise
     ;;
    (§ defn #_"ValueNode" GraphUtil'arrayLength-1 [#_"ValueNode" value]
        (loop [value value]
            (when (instance? ArrayLengthProvider value)
                (let [
                    #_"ValueNode" length (ArrayLengthProvider''length-1 value)
                ]
                    (when (some? length)
                        (§ return length)
                    )
                )
            )
            (when (instance? ValueProxy value)
                (recur (Proxy''getOriginalNode-1 value))
            )
        )
    )

    (§ defn- #_"ValueNode" GraphUtil'originalValueForProxy-1 [#_"ValueNode" value]
        (loop-when-recur value (instance? LimitedValueProxy value) (LimitedValueProxy''getOriginalNode-1 value) => value)
    )

    ;;;
     ; Handling complicated nestings of phi functions. We reduce them recursively using a temporary map
     ; of visited nodes to avoid endless recursion of cycles.
     ;;
    (§ defn- #_"ValueNode" GraphUtil'originalValueForComplicatedPhi-2 [#_"PhiNode" phi, #_"NodeBitMap" visited]
        ;; Else found a phi function that was already seen. Either a cycle, or just a second phi input
        ;; to a path we have already processed.
        (when-not (NodeBitMap''isMarked-2 visited, phi)
            (NodeBitMap''mark-2 visited, phi)

            (loop-when [#_"ValueNode" prior nil #_"int" i 0] (< i (PhiNode''valueCount-1 phi)) => prior
                (let [
                    #_"ValueNode" value (GraphUtil'originalValueForProxy-1 (PhiNode''valueAt-2 phi, i))
                    value
                        (when (instance? PhiNode value) => value
                            ;; Recursively process a phi function input.
                            (GraphUtil'originalValueForComplicatedPhi-2 value, visited)
                        )
                ]
                    (cond
                        ;; Cycle to a phi function that was already seen. We can ignore this input.
                        (nil? value)       (recur prior (inc i))
                        ;; The first input.
                        (nil? prior)       (recur value (inc i))
                        ;; Another input that is different from the first input. Since we already
                        ;; recursively looked through other phi functions, we now know that this phi
                        ;; function cannot be reduced any further, hence it is the original value.
                        (not= value prior) phi
                        :else              (recur prior (inc i))
                    )
                )
            )
        )
    )

    ;;;
     ; Tries to find an original value of the given node by traversing through proxies and
     ; unambiguous phis. Note that this method will perform an exhaustive search through phis. It is
     ; intended to be used during graph building, when phi nodes aren't yet canonicalized.
     ;
     ; @param value The node whose original value should be determined.
     ; @return the original value (which might be the input value itself)
     ;;
    (§ defn #_"ValueNode" GraphUtil'originalValue-1 [#_"ValueNode" value]
        ;; The very simple case: look through proxies.
        (loop-when [#_"ValueNode" node (GraphUtil'originalValueForProxy-1 value)] (instance? PhiNode node) => node ;; We reached a "normal" node, which is the original value.
            ;; We found a phi function. Check if we can analyze it without allocating temporary data structures.
            (let [
                #_"ValueNode" phiSingleValue
                    (loop-when [phiSingleValue nil #_"int" i 0] (< i (PhiNode''valueCount-1 node)) => phiSingleValue
                        (let [
                            #_"ValueNode" phiCurValue (GraphUtil'originalValueForProxy-1 (PhiNode''valueAt-2 node, i))
                            phiSingleValue
                                (cond
                                    (= phiCurValue node)           phiSingleValue ;; Simple cycle, we can ignore the input value.
                                    (nil? phiSingleValue)          phiCurValue    ;; The first input.
                                    (= phiSingleValue phiCurValue) phiSingleValue
                                    :else
                                        ;; Another input that is different from the first input.
                                        (if (or (instance? PhiNode phiSingleValue) (instance? PhiNode phiCurValue))
                                            ;; We have two different input values for the phi function, and at least one
                                            ;; of the inputs is another phi function. We need to do a complicated
                                            ;; exhaustive check.
                                            (§ return (GraphUtil'originalValueForComplicatedPhi-2 node, (NodeBitMap'new-1 (:graph value))))
                                            ;; We have two different input values for the phi function, but none of them
                                            ;; is another phi function. This phi function cannot be reduce any further,
                                            ;; so the phi function is the original value.
                                            (§ return node)
                                        )
                                )
                        ]
                            (recur phiSingleValue (inc i))
                        )
                    )
            ]
                ;; Successfully reduced the phi function to a single input value. The single input value
                ;; can itself be a phi function again, so we might take another loop iteration.
                (recur phiSingleValue)
            )
        )
    )

    (§ defn #_"boolean" GraphUtil'tryKillUnused-1 [#_"Node" node]
        (and (Node''isAlive-1 node) (GraphUtil'isFloatingNode-1 node) (Node''hasNoUsages-1 node) (not (instance? GuardNode node))
            (do
                (GraphUtil'killWithUnusedFloatingInputs-1 node)
                true
            )
        )
    )

    ;;;
     ; Returns an iterator that will return the given node followed by all its predecessors,
     ; up until the point where Node#predecessor() returns nil.
     ;
     ; @param start the node at which to start iterating
     ;;
    (§ defn #_"NodeIterable<FixedNode>" GraphUtil'predecessorIterable-1 [#_"FixedNode" start]
        (§ reify #_"NodeIterable<FixedNode>" (NodeIterable'reify-0)
            (§ override! #_"Iterator<FixedNode>" #_"Iterable" .iterator [#_"NodeIterable<FixedNode>" this]
                (§ reify #_"Iterator<FixedNode>" (Iterator.)
                    (§ mutable #_"FixedNode" :current start)

                    (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<FixedNode>" this]
                        (some? (:current this))
                    )

                    (§ override! #_"FixedNode" #_"Iterator" .next [#_"Iterator<FixedNode>" this]
                        (try
                            (:current this)
                            (finally
                                (§ ass! this (assoc this :current (:predecessor (:current this))))
                            )
                        )
                    )
                )
            )
        )
    )
)

;;;
 ; @anno GraphUtil.DefaultSimplifierTool
 ;;
(final-ns DefaultSimplifierTool (§ implements SimplifierTool)
    (§ final #_"boolean" :canonicalizeReads false)

    (§ defn #_"DefaultSimplifierTool" DefaultSimplifierTool'new-1 [#_"boolean" canonicalizeReads]
        (let [
            #_"DefaultSimplifierTool" this (Object.)
            this (assoc this :canonicalizeReads canonicalizeReads)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" DefaultSimplifierTool''canonicalizeReads-1 [#_"DefaultSimplifierTool" this]
        (:canonicalizeReads this)
    )

    #_unused
    (§ override! #_"boolean" DefaultSimplifierTool''allUsagesAvailable-1 [#_"DefaultSimplifierTool" this]
        true
    )

    #_unused
    (§ override! #_"void" DefaultSimplifierTool''deleteBranch-2 [#_"DefaultSimplifierTool" this, #_"Node" branch]
        (Node''replaceFirstSuccessor-3 (:predecessor branch), branch, nil)
        (GraphUtil'killCFG-1 branch)
        nil
    )

    #_unused
    (§ override! #_"void" DefaultSimplifierTool''removeIfUnused-2 [#_"DefaultSimplifierTool" this, #_"Node" node]
        (GraphUtil'tryKillUnused-1 node)
        nil
    )

    #_unused
    (§ override! #_"void" DefaultSimplifierTool''addToWorkList-2 [#_"DefaultSimplifierTool" this, #_"Node" node]
        nil
    )

    #_unused
    (§ override! #_"void" DefaultSimplifierTool''addToWorkList-2 [#_"DefaultSimplifierTool" this, #_"Iterable<? extends Node>" nodes]
        nil
    )

    #_unused
    (§ override! #_"Integer" DefaultSimplifierTool''smallestCompareWidth-1 [#_"DefaultSimplifierTool" this]
        (Lowerer'smallestCompareWidth-0)
    )
)

;;;
 ; This class represents a value within the graph, including local variables, phis, and all other instructions.
 ;;
(class-ns ValueNode (§ extends Node)
    (§ def #_"NodeClass<ValueNode>" ValueNode'TYPE (NodeClass'create-1 ValueNode))

    ;;;
     ; The kind of this value. This is JavaKind#Void for instructions that produce no value.
     ; This kind is guaranteed to be a {@linkplain JavaKind#getStackKind() stack kind}.
     ;;
    (§ mutable #_"Stamp" :stamp nil)

    (§ defn #_"ValueNode" ValueNode'new-2 [#_"NodeClass<? extends ValueNode>" c, #_"Stamp" stamp]
        (let [
            #_"ValueNode" this (Node'new-1 c)
            this (assoc this :stamp stamp)
        ]
            this
        )
    )

    (§ method! #_"ValueNode" ValueNode''setStamp-2 [#_"ValueNode" this, #_"Stamp" stamp]
        (assoc this :stamp stamp)
    )

    ;;;
     ; Checks if the given stamp is different than the current one ({@code newStamp.equals(oldStamp) == false}).
     ; If it is different then the new stamp will become the current stamp for this node.
     ;
     ; @return true if the stamp has changed, false otherwise
     ;;
    (§ method! #_"boolean" ValueNode''updateStamp-2 [#_"ValueNode" this, #_"Stamp" stamp]
        (and (some? stamp) (not= stamp (:stamp this))
            (do
                (§ ass! this (assoc this :stamp stamp))
                true
            )
        )
    )

    ;;;
     ; This method can be overridden by subclasses of ValueNode if they need to recompute
     ; their stamp if their inputs change. A typical implementation will compute the stamp and pass
     ; it to #updateStamp(Stamp), whose return value can be used as the result of this method.
     ;
     ; @return true if the stamp has changed, false otherwise
     ;;
    (§ method #_"boolean" ValueNode''inferStamp-1 [#_"ValueNode" this]
        false
    )

    (§ method! #_"JavaKind" ValueNode''getStackKind-1 [#_"ValueNode" this]
        (Stamp''getStackKind-1 (:stamp this))
    )

    (§ def- #_"NodePredicate" ValueNode'IS_CONSTANT
        (§ reify #_"NodePredicate" (NodePredicate'new-0)
            (§ override! #_"boolean" NodePredicate''apply-2 [#_"NodePredicate" this, #_"Node" node]
                (instance? ConstantNode node)
            )
        )
    )

    (§ defn #_"NodePredicate" ValueNode'isConstantPredicate-0 []
        ValueNode'IS_CONSTANT
    )

    ;;;
     ; Checks whether this value represents the nil constant.
     ;
     ; @return true if this value represents the nil constant
     ;;
    (§ method! #_"boolean" ValueNode''isNullConstant-1 [#_"ValueNode" this]
        (let [
            #_"JavaConstant" value (ValueNode''asJavaConstant-1 this)
        ]
            (and (some? value) (#_"JavaConstant" .isNull value))
        )
    )

    ;;;
     ; Convert this value to a constant if it is a constant, otherwise return nil.
     ;
     ; @return the JavaConstant represented by this value if it is a constant; nil otherwise
     ;;
    (§ method! #_"Constant" ValueNode''asConstant-1 [#_"ValueNode" this]
        (when (instance? ConstantNode this) (:value this))
    )

    (§ method! #_"boolean" ValueNode''isJavaConstant-1 [#_"ValueNode" this]
        (and (instance? ConstantNode this) (instance? JavaConstant (:value this)))
    )

    (§ method! #_"JavaConstant" ValueNode''asJavaConstant-1 [#_"ValueNode" this]
        (let [
            #_"Constant" value (ValueNode''asConstant-1 this)
        ]
            (when (instance? JavaConstant value)
                value
            )
        )
    )

    #_unused
    (§ override #_"boolean" ValueNode''isAllowedUsageType-2 [#_"ValueNode" this, #_"InputType" type]
        (or (and (not= (ValueNode''getStackKind-1 this) JavaKind/Void) (= type InputType'Value)) (Node''isAllowedUsageType-2 (§ super ), type))
    )

    ;;;
     ; Checks if this node has usages other than the given node {@code node}.
     ;
     ; @param node node which is ignored when searching for usages
     ; @return true if this node has other usages, false otherwise
     ;;
    (§ method! #_"boolean" ValueNode''hasUsagesOtherThan-3 [#_"ValueNode" this, #_"ValueNode" node, #_"LIRBuilder" builder]
        (loop-when [#_"ISeq" s (seq (Node''usages-1 this))] (some? s) => false
            (let [
                #_"Node" usage (first s)
            ]
                (or (and (not= usage node) (instance? ValueNode usage) (LIRBuilder''hasOperand-2 builder, usage))
                    (recur (next s))
                )
            )
        )
    )
)

;;;
 ; Value PhiNodes merge data flow values at control flow merges.
 ;;
(final-ns ValuePhiNode (§ extends PhiNode) (§ implements ArrayLengthProvider)
    (§ def #_"NodeClass<ValuePhiNode>" ValuePhiNode'TYPE (NodeClass'create-1 ValuePhiNode))

    ; @Input
    (§ mutable #_"NodeInputList<ValueNode>" :values nil)

    (§ defn #_"ValuePhiNode" ValuePhiNode'new-2 [#_"Stamp" stamp, #_"AbstractMergeNode" merge]
        (ValuePhiNode'new-3 ValuePhiNode'TYPE, stamp, merge)
    )

    (§ defn #_"ValuePhiNode" ValuePhiNode'new-3 [#_"NodeClass<? extends ValuePhiNode>" c, #_"Stamp" stamp, #_"AbstractMergeNode" merge]
        (let [
            #_"ValuePhiNode" this (PhiNode'new-3 c, stamp, merge)
            this (assoc this :values (NodeInputList'new-1 this))
        ]
            this
        )
    )

    (§ defn #_"ValuePhiNode" ValuePhiNode'new-3 [#_"Stamp" stamp, #_"AbstractMergeNode" merge, #_"ValueNode[]" values]
        (let [
            #_"ValuePhiNode" this (PhiNode'new-3 ValuePhiNode'TYPE, stamp, merge)
            this (assoc this :values (NodeInputList'new-2 this, values))
        ]
            this
        )
    )

    (§ override! #_"NodeInputList<ValueNode>" ValuePhiNode''values-1 [#_"ValuePhiNode" this]
        (:values this)
    )

    #_unused
    (§ override! #_"boolean" ValuePhiNode''inferStamp-1 [#_"ValuePhiNode" this]
        ;; Meet all the values feeding this Phi but don't use the stamp of this Phi since that's what's being computed.
        (let [
            #_"Stamp" stamp (StampTool'meetOrNull-2 (ValuePhiNode''values-1 this), this)
            stamp
                (cond
                    (nil? stamp)                                 (:stamp this)
                    (Stamp''isCompatible-2 (:stamp this), stamp) (Stamp''join-2 (:stamp this), stamp)
                    :else                                        stamp
                )
        ]
            (ValueNode''updateStamp-2 this, stamp)
        )
    )

    (§ override! #_"ValueNode" ArrayLengthProvider''length-1 [#_"ValuePhiNode" this]
        (when-not (instance? LoopBeginNode (PhiNode''merge-1 this))
            (loop-when [#_"ValueNode" n nil #_"ISeq" s (seq (ValuePhiNode''values-1 this))] (some? s) => n
                (let [
                    #_"ValueNode" l (GraphUtil'arrayLength-1 (first s))
                ]
                    (when (some? l)
                        (when (some? n) => (recur l (next s))
                            (when (= n l)
                                (recur n (next s))
                            )
                        )
                    )
                )
            )
        )
    )
)

(final-ns ValueProxyNode (§ extends ProxyNode) (§ implements Canonicalizable, Virtualizable, ValueProxy)
    (§ def #_"NodeClass<ValueProxyNode>" ValueProxyNode'TYPE (NodeClass'create-1 ValueProxyNode))

    ; @Input
    (§ mutable #_"ValueNode" :value nil)
    (§ final #_"boolean" :loopPhiProxy false)

    (§ defn #_"ValueProxyNode" ValueProxyNode'new-2 [#_"ValueNode" value, #_"LoopExitNode" loopExit]
        (let [
            #_"ValueProxyNode" this (ProxyNode'new-3 ValueProxyNode'TYPE, (:stamp value), loopExit)
            this (assoc this :value value)
            this (assoc this :loopPhiProxy (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin loopExit), value))
        ]
            this
        )
    )

    (§ override! #_"ValueNode" ValueProxyNode''value-1 [#_"ValueProxyNode" this]
        (:value this)
    )

    #_unused
    (§ override! #_"boolean" ValueProxyNode''inferStamp-1 [#_"ValueProxyNode" this]
        (ValueNode''updateStamp-2 this, (:stamp (:value this)))
    )

    #_unused
    (§ override! #_"Node" ValueProxyNode''canonical-2 [#_"ValueProxyNode" this, #_"CanonicalizerTool" tool]
        (if (or (instance? ConstantNode (:value this))
                (and (:loopPhiProxy this) (not (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin (:loopExit this)), (:value this))))
            )
            (:value this)
            this
        )
    )

    #_unused
    (§ override! #_"void" ValueProxyNode''virtualize-2 [#_"ValueProxyNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" alias (VirtualizerTool''getAlias-2 tool, (:value this))
        ]
            (when (instance? VirtualObjectNode alias)
                (VirtualizerTool''replaceWithVirtual-2 tool, alias)
            )
        )
        nil
    )

    (§ override! #_"ValueNode" ValueProxyNode''getOriginalNode-1 [#_"ValueProxyNode" this]
        (ValueProxyNode''value-1 this)
    )

    #_unused
    (§ override! #_"GuardingNode" ValueProxyNode''getGuard-1 [#_"ValueProxyNode" this]
        (:loopExit this)
    )
)

;;;
 ; Selects one object from a CommitAllocationNode. The object is identified by its
 ; VirtualObjectNode.
 ;;
(final-ns AllocatedObjectNode (§ extends FloatingNode) (§ implements Virtualizable, ArrayLengthProvider)
    (§ def #_"NodeClass<AllocatedObjectNode>" AllocatedObjectNode'TYPE (NodeClass'create-1 AllocatedObjectNode))

    ; @Input
    (§ mutable #_"VirtualObjectNode" :virtualObject nil)
    ; @Input(InputType'Extension)
    (§ mutable #_"CommitAllocationNode" :commit nil)

    (§ defn #_"AllocatedObjectNode" AllocatedObjectNode'new-1 [#_"VirtualObjectNode" virtualObject]
        (let [
            #_"AllocatedObjectNode" this (FloatingNode'new-2 AllocatedObjectNode'TYPE, (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 (VirtualObjectNode''type-1 virtualObject))))
            this (assoc this :virtualObject virtualObject)
        ]
            this
        )
    )

    (§ method! #_"AllocatedObjectNode" AllocatedObjectNode''setCommit-2 [#_"AllocatedObjectNode" this, #_"CommitAllocationNode" node]
        (Node''updateUsages-3 this, (:commit this), node)
        (assoc this :commit node)
    )

    #_unused
    (§ override! #_"void" AllocatedObjectNode''virtualize-2 [#_"AllocatedObjectNode" this, #_"VirtualizerTool" tool]
        (VirtualizerTool''replaceWithVirtual-2 tool, (:virtualObject this))
        nil
    )

    (§ override! #_"ValueNode" ArrayLengthProvider''length-1 [#_"AllocatedObjectNode" this]
        (when (instance? ArrayLengthProvider (:virtualObject this))
            (ArrayLengthProvider''length-1 (:virtualObject this))
        )
    )
)

;; @NodeInfo.allowedUsageTypes "InputType.Extension, InputType.Memory"
(final-ns CommitAllocationNode (§ extends FixedWithNextNode) (§ implements VirtualizableAllocation, Lowerable, Simplifiable, Single)
    (§ def #_"NodeClass<CommitAllocationNode>" CommitAllocationNode'TYPE (NodeClass'create-1 CommitAllocationNode))

    ; @Input
    (§ mutable #_"NodeInputList<VirtualObjectNode>" :virtualObjects (NodeInputList'new-1 this))
    ; @Input
    (§ mutable #_"NodeInputList<ValueNode>" :values (NodeInputList'new-1 this))
    ; @Input(InputType'Association)
    (§ mutable #_"NodeInputList<MonitorIdNode>" :locks (NodeInputList'new-1 this))
    (§ mutable #_"ArrayList<Integer>" :lockIndexes (ArrayList. (Arrays/asList 0)))
    (§ mutable #_"ArrayList<Boolean>" :ensureVirtual (ArrayList.))

    (§ defn #_"CommitAllocationNode" CommitAllocationNode'new-0 []
        (FixedWithNextNode'new-2 CommitAllocationNode'TYPE, (StampFactory'forVoid-0))
    )

    (§ method! #_"List<MonitorIdNode>" CommitAllocationNode''getLocks-2 [#_"CommitAllocationNode" this, #_"int" objIndex]
        (#_"List" .subList (:locks this), (nth (:lockIndexes this) objIndex), (nth (:lockIndexes this) (inc objIndex)))
    )

    #_unused
    (§ override! #_"void" CommitAllocationNode''lower-2 [#_"CommitAllocationNode" this, #_"LoweringTool" lowerer]
        (dotimes [#_"int" i (count (:virtualObjects this))]
            (when (nth (:ensureVirtual this) i)
                (EnsureVirtualizedNode'ensureVirtualFailure-2 this, (:stamp (nth (:virtualObjects this) i)))
            )
        )
        (Lowerer'lowerCommitAllocationNode-2 this, lowerer)
        nil
    )

    #_unused
    (§ override! #_"LocationIdentity" CommitAllocationNode''getLocationIdentity-1 [#_"CommitAllocationNode" this]
        (if (empty? (:locks this)) (LocationIdentity/init) (LocationIdentity/any))
    )

    #_unused
    (§ override! #_"void" CommitAllocationNode''afterClone-2 [#_"CommitAllocationNode" this, #_"Node" other]
        (§ ass! this (assoc this :lockIndexes (ArrayList. (:lockIndexes this))))
        nil
    )

    (§ method! #_"void" CommitAllocationNode''addLocks-2 [#_"CommitAllocationNode" this, #_"List<MonitorIdNode>" monitorIds]
        (NodeList''addAll-2 (:locks this), monitorIds)
        (#_"ArrayList" .add (:lockIndexes this), (count (:locks this)))
        nil
    )

    #_unused
    (§ override! #_"void" CommitAllocationNode''virtualize-2 [#_"CommitAllocationNode" this, #_"VirtualizerTool" tool]
        (loop-when [#_"int" pos 0 #_"int" i 0] (< i (count (:virtualObjects this)))
            (let [
                #_"VirtualObjectNode" virtualObject (nth (:virtualObjects this) i)
                #_"int" entryCount (VirtualObjectNode''entryCount-1 virtualObject)
            ]
                (VirtualizerTool''createVirtualObject-5 tool, virtualObject, (#_"List" .toArray (#_"List" .subList (:values this), pos, (+ pos entryCount)), (make-array ValueNode entryCount)), (CommitAllocationNode''getLocks-2 this, i), (nth (:ensureVirtual this) i))
                (recur (+ pos entryCount) (inc i))
            )
        )
        (VirtualizerTool''delete-1 tool)
        nil
    )

    #_unused
    (§ override! #_"void" CommitAllocationNode''simplify-2 [#_"CommitAllocationNode" this, #_"SimplifierTool" tool]
        (let [
            #_"boolean[]" used (boolean-array (count (:virtualObjects this)))
            #_"int" usedCount
                (loop-when [usedCount 0 #_"ISeq" s (seq (NodeIterable''filter-2 (Node''usages-1 this), AllocatedObjectNode))] (some? s) => usedCount
                    (aset used (NodeList''indexOf-2 (:virtualObjects this), (:virtualObject (first s))) true)
                    (recur (inc usedCount) (next s))
                )
        ]
            (if (zero? usedCount)
                (let [
                    #_"List<Node>" inputSnapshot (NodeIterable''snapshot-1 (Node''inputs-1 this))
                ]
                    (Graph''removeFixed-2 (:graph this), this)
                    (doseq [#_"Node" input inputSnapshot]
                        (SimplifierTool''removeIfUnused-2 tool, input)
                    )
                )
                (let [
                    usedCount
                        (loop [usedCount usedCount]
                            (let [
                                [usedCount #_"boolean" progress?]
                                    (loop-when [usedCount usedCount progress? false #_"int" valuePos 0 #_"int" objIndex 0] (< objIndex (count (:virtualObjects this))) => [usedCount progress?]
                                        (let [
                                            #_"VirtualObjectNode" virtualObject (nth (:virtualObjects this) objIndex)
                                            [usedCount progress?]
                                                (when (nth used objIndex) => [usedCount progress?]
                                                    (loop-when [usedCount usedCount progress? progress? #_"int" i 0] (< i (VirtualObjectNode''entryCount-1 virtualObject)) => [usedCount progress?]
                                                        (let [
                                                            #_"int" index (NodeList''indexOf-2 (:virtualObjects this), (nth (:values this) (+ valuePos i)))
                                                            [usedCount progress?]
                                                                (when (and (not= index -1) (not (nth used index))) => [usedCount progress?]
                                                                    (aset used index true)
                                                                    [(inc usedCount) true]
                                                                )
                                                        ]
                                                            (recur usedCount progress? (inc i))
                                                        )
                                                    )
                                                )
                                        ]
                                            (recur usedCount progress? (+ valuePos (VirtualObjectNode''entryCount-1 virtualObject)) (inc objIndex))
                                        )
                                    )
                            ]
                                (recur-if progress? [usedCount] => usedCount)
                            )
                        )
                ]
                    (when (< usedCount (count (:virtualObjects this)))
                        (let [
                            #_"List<VirtualObjectNode>" newVirtualObjects (ArrayList.)
                            #_"List<MonitorIdNode>" newLocks (ArrayList.)
                            #_"ArrayList<Integer>" newLockIndexes (ArrayList.)
                            #_"ArrayList<Boolean>" newEnsureVirtual (ArrayList.)
                        ]
                            (#_"ArrayList" .add newLockIndexes, 0)
                            (let [
                                #_"List<ValueNode>" newValues (ArrayList.)
                                #_"int" valuePos
                                    (loop-when [valuePos 0 #_"int" objIndex 0] (< objIndex (count (:virtualObjects this))) => valuePos
                                        (let [
                                            #_"VirtualObjectNode" virtualObject (nth (:virtualObjects this) objIndex)
                                        ]
                                            (when (nth used objIndex)
                                                (#_"List" .add newVirtualObjects, virtualObject)
                                                (#_"List" .addAll newLocks, (CommitAllocationNode''getLocks-2 this, objIndex))
                                                (#_"ArrayList" .add newLockIndexes, (count newLocks))
                                                (#_"List" .addAll newValues, (#_"List" .subList (:values this), valuePos, (+ valuePos (VirtualObjectNode''entryCount-1 virtualObject))))
                                                (#_"ArrayList" .add newEnsureVirtual, (nth (:ensureVirtual this) objIndex))
                                            )
                                            (recur (+ valuePos (VirtualObjectNode''entryCount-1 virtualObject)) (inc objIndex))
                                        )
                                    )
                            ]
                                (NodeList''clear-1 (:virtualObjects this))
                                (NodeList''addAll-2 (:virtualObjects this), newVirtualObjects)
                                (NodeList''clear-1 (:locks this))
                                (NodeList''addAll-2 (:locks this), newLocks)
                                (NodeList''clear-1 (:values this))
                                (NodeList''addAll-2 (:values this), newValues)
                                (§ ass! this (assoc this :lockIndexes newLockIndexes))
                                (§ ass! this (assoc this :ensureVirtual newEnsureVirtual))
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

(final-ns EnsureVirtualizedNode (§ extends FixedWithNextNode) (§ implements Virtualizable, Lowerable)
    (§ def #_"NodeClass<EnsureVirtualizedNode>" EnsureVirtualizedNode'TYPE (NodeClass'create-1 EnsureVirtualizedNode))

    ; @Input
    (§ mutable #_"ValueNode" :object nil)
    (§ final #_"boolean" :localOnly false)

    #_unused
    (§ defn #_"EnsureVirtualizedNode" EnsureVirtualizedNode'new-2 [#_"ValueNode" object, #_"boolean" localOnly]
        (let [
            #_"EnsureVirtualizedNode" this (FixedWithNextNode'new-2 EnsureVirtualizedNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :object object)
            this (assoc this :localOnly localOnly)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" EnsureVirtualizedNode''virtualize-2 [#_"EnsureVirtualizedNode" this, #_"VirtualizerTool" tool]
        (let [
            #_"ValueNode" object (VirtualizerTool''getAlias-2 tool, (:object this))
        ]
            (when (instance? VirtualObjectNode object)
                (when (instance? VirtualBoxingNode object)
                    (throw! (str "ensureVirtual is not valid for boxing objects: " (#_"ResolvedJavaType" .getName (VirtualObjectNode''type-1 object))))
                )
                (when-not (:localOnly this)
                    (VirtualizerTool''setEnsureVirtualized-3 tool, object, true)
                )
                (VirtualizerTool''delete-1 tool)
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" EnsureVirtualizedNode''lower-2 [#_"EnsureVirtualizedNode" this, #_"LoweringTool" lowerer]
        (EnsureVirtualizedNode'ensureVirtualFailure-2 this, (:stamp (:object this)))
        nil
    )

    (§ defn #_"void" EnsureVirtualizedNode'ensureVirtualFailure-2 [#_"Node" location, #_"Stamp" stamp]
        (let [
            #_"String" additionalReason
                (when (and (instance? FixedWithNextNode location) (not (instance? EnsureVirtualizedNode location))) => ""
                    (let [
                        #_"FixedNode" next (:next location)
                    ]
                        (condp instance? next
                            StoreFieldNode " (must not store virtual object into a field)"
                            InvokeNode     " (must not pass virtual object into an invoke that cannot be inlined)"
                                      (str " (must not let virtual object escape at node " next ")")
                        )
                    )
                )
        ]
            (throw! (str "instance of type " (#_"ResolvedJavaType" .getName (StampTool'typeOrNull-1 stamp)) " should not be materialized" additionalReason))
        )
        nil
    )
)

(class-ns EscapeObjectState (§ extends VirtualState)
    (§ def #_"NodeClass<EscapeObjectState>" EscapeObjectState'TYPE (NodeClass'create-1 EscapeObjectState))

    ; @Input
    (§ mutable #_"VirtualObjectNode" :object nil)

    (§ defn #_"EscapeObjectState" EscapeObjectState'new-2 [#_"NodeClass<? extends EscapeObjectState>" c, #_"VirtualObjectNode" object]
        (let [
            #_"EscapeObjectState" this (VirtualState'new-1 c)
            this (assoc this :object object)
        ]
            this
        )
    )

    (§ abstract #_"EscapeObjectState" EscapeObjectState''duplicateWithVirtualState-1 [#_"EscapeObjectState" this])

    (§ override #_"boolean" EscapeObjectState''isPartOfThisState-2 [#_"EscapeObjectState" this, #_"VirtualState" state]
        (= this state)
    )

    (§ override #_"void" EscapeObjectState''applyToVirtual-2 [#_"EscapeObjectState" this, #_"VirtualClosure" closure]
        (VirtualClosure''apply-2 closure, this)
        nil
    )
)

;;;
 ; The class implements a simple linked list of MonitorIdNodes, which can be used to describe the
 ; current lock state of an object.
 ;;
(final-ns LockState
    (§ final #_"MonitorIdNode" :monitorId nil)
    (§ final #_"LockState" :next nil)

    (§ defn #_"LockState" LockState'new-2 [#_"MonitorIdNode" monitorId, #_"LockState" next]
        (let [
            #_"LockState" this (Object.)
            this (assoc this :monitorId monitorId)
            this (assoc this :next next)
        ]
            this
        )
    )

    (§ defn #_"List<MonitorIdNode>" LockState'asList-1 [#_"LockState" state]
        (when (some? state) => (Collections/emptyList)
            (let [
                #_"ArrayList<MonitorIdNode>" list (ArrayList.)
            ]
                (loop [state state]
                    (#_"ArrayList" .add list, (:monitorId state))
                    (let [
                        state (:next state)
                    ]
                        (recur-if (some? state) [state] => list)
                    )
                )
            )
        )
    )
)

(final-ns VirtualArrayNode (§ extends VirtualObjectNode) (§ implements ArrayLengthProvider)
    (§ def #_"NodeClass<VirtualArrayNode>" VirtualArrayNode'TYPE (NodeClass'create-1 VirtualArrayNode))

    (§ final #_"ResolvedJavaType" :componentType nil)
    (§ final #_"int" :length 0)

    (§ defn #_"VirtualArrayNode" VirtualArrayNode'new-2 [#_"ResolvedJavaType" componentType, #_"int" length]
        (VirtualArrayNode'new-3 VirtualArrayNode'TYPE, componentType, length)
    )

    (§ defn #_"VirtualArrayNode" VirtualArrayNode'new-3 [#_"NodeClass<? extends VirtualObjectNode>" c, #_"ResolvedJavaType" componentType, #_"int" length]
        (let [
            #_"VirtualArrayNode" this (VirtualObjectNode'new-3 c, (#_"ResolvedJavaType" .getArrayClass componentType), true)
            this (assoc this :componentType componentType)
            this (assoc this :length length)
        ]
            this
        )
    )

    (§ override! #_"ResolvedJavaType" VirtualArrayNode''type-1 [#_"VirtualArrayNode" this]
        (#_"ResolvedJavaType" .getArrayClass (:componentType this))
    )

    (§ override! #_"int" VirtualArrayNode''entryCount-1 [#_"VirtualArrayNode" this]
        (:length this)
    )

    #_unused
    (§ override! #_"void" VirtualArrayNode''generate-2 [#_"VirtualArrayNode" this, #_"LIRBuilder" builder]
        ;; nothing to do...
        nil
    )

    #_unused
    (§ override! #_"String" VirtualArrayNode''entryName-2 [#_"VirtualArrayNode" this, #_"int" index]
        (str "[" index "]")
    )

    #_unused
    (§ override! #_"int" VirtualArrayNode''entryIndexForOffset-3 [#_"VirtualArrayNode" this, #_"long" constantOffset, #_"JavaKind" expectedEntryKind]
        (VirtualArrayNode'entryIndexForOffset-4 constantOffset, expectedEntryKind, (:componentType this), (:length this))
    )

    (§ defn #_"int" VirtualArrayNode'entryIndexForOffset-4 [#_"long" constantOffset, #_"JavaKind" expectedEntryKind, #_"ResolvedJavaType" componentType, #_"int" length]
        (let [
            #_"int" baseOffset (HotSpot'arrayBaseOffset-1 (#_"ResolvedJavaType" .getJavaKind componentType))
            #_"int" indexScale (HotSpot'arrayIndexScale-1 (#_"ResolvedJavaType" .getJavaKind componentType))
            #_"long" offset
                (when (and (= (ByteOrder/nativeOrder) ByteOrder/BIG_ENDIAN) (#_"ResolvedJavaType" .isPrimitive componentType)) => constantOffset
                    ;; on big endian, we expect the value to be correctly aligned in memory
                    (let [
                        #_"int" componentByteCount (#_"JavaKind" .getByteCount (#_"ResolvedJavaType" .getJavaKind componentType))
                    ]
                        (- constantOffset (- componentByteCount (min componentByteCount (+ 4 (#_"JavaKind" .getByteCount expectedEntryKind)))))
                    )
                )
            #_"long" index (- offset baseOffset)
        ]
            (when (zero? (% index indexScale)) => -1
                (let [
                    #_"long" elementIndex (quot index indexScale)
                ]
                    (when (< -1 elementIndex length) => -1
                        (int elementIndex)
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"JavaKind" VirtualArrayNode''entryKind-2 [#_"VirtualArrayNode" this, #_"int" index]
        (#_"ResolvedJavaType" .getJavaKind (:componentType this))
    )

    #_unused
    (§ override! #_"VirtualArrayNode" VirtualArrayNode''duplicate-1 [#_"VirtualArrayNode" this]
        (VirtualArrayNode'new-2 (:componentType this), (:length this))
    )

    #_unused
    (§ override! #_"ValueNode" VirtualArrayNode''getMaterializedRepresentation-4 [#_"VirtualArrayNode" this, #_"FixedNode" fixed, #_"ValueNode[]" entries, #_"LockState" locks]
        (AllocatedObjectNode'new-1 this)
    )

    (§ override! #_"ValueNode" ArrayLengthProvider''length-1 [#_"VirtualArrayNode" this]
        (ConstantNode'forInt-1 (:length this))
    )
)

(final-ns VirtualBoxingNode (§ extends VirtualInstanceNode)
    (§ def #_"NodeClass<VirtualBoxingNode>" VirtualBoxingNode'TYPE (NodeClass'create-1 VirtualBoxingNode))

    (§ final #_"JavaKind" :boxingKind nil)

    (§ defn #_"VirtualBoxingNode" VirtualBoxingNode'new-2 [#_"ResolvedJavaType" type, #_"JavaKind" boxingKind]
        (VirtualBoxingNode'new-3 VirtualBoxingNode'TYPE, type, boxingKind)
    )

    (§ defn #_"VirtualBoxingNode" VirtualBoxingNode'new-3 [#_"NodeClass<? extends VirtualBoxingNode>" c, #_"ResolvedJavaType" type, #_"JavaKind" boxingKind]
        (let [
            #_"VirtualBoxingNode" this (VirtualInstanceNode'new-3 c, type, false)
            this (assoc this :boxingKind boxingKind)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"VirtualBoxingNode" VirtualBoxingNode''duplicate-1 [#_"VirtualBoxingNode" this]
        (VirtualBoxingNode'new-2 (VirtualObjectNode''type-1 this), (:boxingKind this))
    )

    #_unused
    (§ override! #_"ValueNode" VirtualBoxingNode''getMaterializedRepresentation-4 [#_"VirtualBoxingNode" this, #_"FixedNode" fixed, #_"ValueNode[]" entries, #_"LockState" locks]
        (BoxNode'new-3 (nth entries 0), (VirtualObjectNode''type-1 this), (:boxingKind this))
    )

    (§ method! #_"ValueNode" VirtualBoxingNode''getBoxedValue-2 [#_"VirtualBoxingNode" this, #_"VirtualizerTool" tool]
        (VirtualizerTool''getEntry-3 tool, this, 0)
    )
)

(class-ns VirtualInstanceNode (§ extends VirtualObjectNode)
    (§ def #_"NodeClass<VirtualInstanceNode>" VirtualInstanceNode'TYPE (NodeClass'create-1 VirtualInstanceNode))

    (§ final #_"ResolvedJavaType" :type nil)
    (§ final #_"ResolvedJavaField[]" :fields nil)

    (§ defn #_"VirtualInstanceNode" VirtualInstanceNode'new-2 [#_"ResolvedJavaType" type, #_"boolean" hasIdentity]
        (VirtualInstanceNode'new-3 type, (#_"ResolvedJavaType" .getInstanceFields type, true), hasIdentity)
    )

    (§ defn #_"VirtualInstanceNode" VirtualInstanceNode'new-3 [#_"ResolvedJavaType" type, #_"ResolvedJavaField[]" fields, #_"boolean" hasIdentity]
        (VirtualInstanceNode'new-4 VirtualInstanceNode'TYPE, type, fields, hasIdentity)
    )

    (§ defn #_"VirtualInstanceNode" VirtualInstanceNode'new-3 [#_"NodeClass<? extends VirtualInstanceNode>" c, #_"ResolvedJavaType" type, #_"boolean" hasIdentity]
        (VirtualInstanceNode'new-4 c, type, (#_"ResolvedJavaType" .getInstanceFields type, true), hasIdentity)
    )

    (§ defn #_"VirtualInstanceNode" VirtualInstanceNode'new-4 [#_"NodeClass<? extends VirtualInstanceNode>" c, #_"ResolvedJavaType" type, #_"ResolvedJavaField[]" fields, #_"boolean" hasIdentity]
        (let [
            #_"VirtualInstanceNode" this (VirtualObjectNode'new-3 c, type, hasIdentity)
            this (assoc this :type type)
            this (assoc this :fields fields)
        ]
            this
        )
    )

    #_unused
    (§ override #_"ResolvedJavaType" VirtualInstanceNode''type-1 [#_"VirtualInstanceNode" this]
        (:type this)
    )

    (§ override #_"int" VirtualInstanceNode''entryCount-1 [#_"VirtualInstanceNode" this]
        (count (:fields this))
    )

    (§ method #_"ResolvedJavaField" VirtualInstanceNode''field-2 [#_"VirtualInstanceNode" this, #_"int" index]
        (nth (:fields this) index)
    )

    (§ method #_"ResolvedJavaField[]" VirtualInstanceNode''getFields-1 [#_"VirtualInstanceNode" this]
        (:fields this)
    )

    #_unused
    (§ override #_"String" VirtualInstanceNode''entryName-2 [#_"VirtualInstanceNode" this, #_"int" index]
        (#_"ResolvedJavaField" .getName (nth (:fields this) index))
    )

    (§ method! #_"int" VirtualInstanceNode''fieldIndex-2 [#_"VirtualInstanceNode" this, #_"ResolvedJavaField" field]
        ;; on average fields.length == ~6, so a linear search is fast enough
        (loop-when [#_"int" i 0] (< i (count (:fields this))) => -1
            (if (= (nth (:fields this) i) field)
                i
                (recur (inc i))
            )
        )
    )

    #_unused
    (§ override #_"int" VirtualInstanceNode''entryIndexForOffset-3 [#_"VirtualInstanceNode" this, #_"long" constantOffset, #_"JavaKind" expectedEntryKind]
        (VirtualInstanceNode''fieldIndex-2 this, (#_"ResolvedJavaType" .findInstanceFieldWithOffset (:type this), constantOffset, expectedEntryKind))
    )

    #_unused
    (§ override #_"JavaKind" VirtualInstanceNode''entryKind-2 [#_"VirtualInstanceNode" this, #_"int" index]
        (#_"ResolvedJavaField" .getJavaKind (nth (:fields this) index))
    )

    #_unused
    (§ override #_"VirtualInstanceNode" VirtualInstanceNode''duplicate-1 [#_"VirtualInstanceNode" this]
        (VirtualInstanceNode'new-3 (:type this), (:fields this), (VirtualObjectNode''hasIdentity-1 (§ super )))
    )

    #_unused
    (§ override #_"ValueNode" VirtualInstanceNode''getMaterializedRepresentation-4 [#_"VirtualInstanceNode" this, #_"FixedNode" fixed, #_"ValueNode[]" entries, #_"LockState" locks]
        (AllocatedObjectNode'new-1 this)
    )
)

(class-ns VirtualObjectNode (§ extends ValueNode) (§ implements LIRLowerable, IterableNodeType)
    (§ def #_"NodeClass<VirtualObjectNode>" VirtualObjectNode'TYPE (NodeClass'create-1 VirtualObjectNode))

    (§ mutable #_"boolean" :hasIdentity false)
    (§ mutable #_"int" :objectId -1)

    (§ defn #_"VirtualObjectNode" VirtualObjectNode'new-3 [#_"NodeClass<? extends VirtualObjectNode>" c, #_"ResolvedJavaType" type, #_"boolean" hasIdentity]
        (let [
            #_"VirtualObjectNode" this (ValueNode'new-2 c, (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 type)))
            this (assoc this :hasIdentity hasIdentity)
        ]
            this
        )
    )

    (§ method! #_"int" VirtualObjectNode''getObjectId-1 [#_"VirtualObjectNode" this]
        (:objectId this)
    )

    (§ method! #_"VirtualObjectNode" VirtualObjectNode''resetObjectId-1 [#_"VirtualObjectNode" this]
        (assoc this :objectId -1)
    )

    (§ method! #_"VirtualObjectNode" VirtualObjectNode''setObjectId-2 [#_"VirtualObjectNode" this, #_"int" objectId]
        (assoc this :objectId objectId)
    )

    #_unused
    (§ override #_"void" VirtualObjectNode''afterClone-2 [#_"VirtualObjectNode" this, #_"Node" other]
        (Node''afterClone-2 (§ super ), other)
        (§ ass! this (VirtualObjectNode''resetObjectId-1 this))
        nil
    )

    ;;;
     ; The type of object described by this VirtualObjectNode. In case of arrays, this is
     ; the array type (and not the component type).
     ;;
    (§ abstract #_"ResolvedJavaType" VirtualObjectNode''type-1 [#_"VirtualObjectNode" this])

    ;;;
     ; The number of entries this virtual object has. Either the number of fields or the number of
     ; array elements.
     ;;
    (§ abstract #_"int" VirtualObjectNode''entryCount-1 [#_"VirtualObjectNode" this])

    ;;;
     ; Returns the name of the entry at the given index. Only used for debugging purposes.
     ;;
    #_unused
    (§ abstract #_"String" VirtualObjectNode''entryName-2 [#_"VirtualObjectNode" this, #_"int" i])

    ;;;
     ; If the given index denotes an entry in this virtual object, the index of this entry is
     ; returned. If no such entry can be found, this method returns -1.
     ;
     ; @param constantOffset offset, where the value is placed.
     ; @param expectedEntryKind specifies which type is expected at this offset, important when
     ;            doing implicit casts, especially on big endian systems
     ;;
    (§ abstract #_"int" VirtualObjectNode''entryIndexForOffset-3 [#_"VirtualObjectNode" this, #_"long" constantOffset, #_"JavaKind" expectedEntryKind])

    ;;;
     ; Returns the JavaKind of the entry at the given index.
     ;;
    (§ abstract #_"JavaKind" VirtualObjectNode''entryKind-2 [#_"VirtualObjectNode" this, #_"int" index])

    ;;;
     ; Returns an exact duplicate of this virtual object node, which has not been added to the graph yet.
     ;;
    (§ abstract #_"VirtualObjectNode" VirtualObjectNode''duplicate-1 [#_"VirtualObjectNode" this])

    ;;;
     ; Specifies whether this virtual object has an object identity. If not, then the result of a
     ; comparison of two virtual objects is determined by comparing their contents.
     ;;
    (§ method! #_"boolean" VirtualObjectNode''hasIdentity-1 [#_"VirtualObjectNode" this]
        (:hasIdentity this)
    )

    #_unused
    (§ method! #_"VirtualObjectNode" VirtualObjectNode''setIdentity-2 [#_"VirtualObjectNode" this, #_"boolean" identity]
        (assoc this :hasIdentity identity)
    )

    ;;;
     ; Returns a node that can be used to materialize this virtual object. If this returns an
     ; AllocatedObjectNode then this node will be attached to a CommitAllocationNode,
     ; otherwise the node will just be added to the graph.
     ;;
    (§ abstract #_"ValueNode" VirtualObjectNode''getMaterializedRepresentation-4 [#_"VirtualObjectNode" this, #_"FixedNode" fixed, #_"ValueNode[]" entries, #_"LockState" locks])

    #_unused
    (§ override #_"void" VirtualObjectNode''generate-2 [#_"VirtualObjectNode" this, #_"LIRBuilder" builder]
        ;; nothing to do...
        nil
    )
)

;;;
 ; Base class for nodes that contain "virtual" state, like FrameState and VirtualObjectState.
 ; Subclasses of this class will be treated in a special way by the scheduler.
 ;;
;; @NodeInfo.allowedUsageTypes "InputType.StateI"
(class-ns VirtualState (§ extends Node)
    (§ defn #_"VirtualState" VirtualState'new-1 [#_"NodeClass<? extends VirtualState>" c]
        (Node'new-1 c)
    )

    (§ def #_"NodeClass<VirtualState>" VirtualState'TYPE (NodeClass'create-1 VirtualState))

    #_unused
    (§ abstract #_"VirtualState" VirtualState''duplicateWithVirtualState-1 [#_"VirtualState" this])

    (§ abstract #_"void" VirtualState''applyToNonVirtual-2 [#_"VirtualState" this, #_"NodeClosure<? super ValueNode>" closure])

    ;;;
     ; Performs a <b>pre-order</b> iteration over all elements reachable from this state that
     ; are a subclass of VirtualState.
     ;;
    #_unused
    (§ abstract #_"void" VirtualState''applyToVirtual-2 [#_"VirtualState" this, #_"VirtualClosure" closure])

    #_unused
    (§ abstract #_"boolean" VirtualState''isPartOfThisState-2 [#_"VirtualState" this, #_"VirtualState" state])
)

;;;
 ; @anno VirtualState.NodeClosure
 ;;
(class-ns NodeClosure #_"<T extends Node>"
    (§ defn #_"NodeClosure" NodeClosure'new-0 []
        (Object.)
    )

    (§ abstract #_"void" NodeClosure''apply-3 [#_"NodeClosure<T extends Node>" this, #_"Node" usage, #_"T" node])
)

;;;
 ; @anno VirtualState.VirtualClosure
 ;;
(§ interface VirtualClosure
    (§ abstract #_"void" VirtualClosure''apply-2 [#_"VirtualClosure" this, #_"VirtualState" node])
)

;;;
 ; Base class for all compiler phases. Subclasses should be stateless. There will be one global
 ; instance for each compiler phase that is shared for all compilations. VM-, target- and
 ; compilation-specific data can be passed with a context object.
 ;;
(class-ns BasePhase #_"<C>"
    (§ defn #_"BasePhase" BasePhase'new-0 []
        (Object.)
    )

    (§ abstract #_"void" BasePhase''run-3 [#_"BasePhase<C>" this, #_"Graph" graph, #_"C" context])

    (§ method! #_"void" BasePhase''apply-3 [#_"BasePhase<C>" this, #_"Graph" graph, #_"C" context]
        (BasePhase''run-3 this, graph, context)
        nil
    )
)

;;;
 ; Common superclass for phases that perform inlining.
 ;;
(class-ns AbstractInliningPhase (§ extends BasePhase #_"<HighTierContext>")
    (§ defn #_"AbstractInliningPhase" AbstractInliningPhase'new-0 []
        (BasePhase'new-0)
    )
)

(final-ns AddressLoweringPhase (§ extends Phase)
    (§ final #_"AddressLowering" :lowering nil)

    (§ defn #_"AddressLoweringPhase" AddressLoweringPhase'new-1 [#_"AddressLowering" lowering]
        (let [
            #_"AddressLoweringPhase" this (Phase'new-0)
            this (assoc this :lowering lowering)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" AddressLoweringPhase''run-2 [#_"AddressLoweringPhase" this, #_"Graph" graph]
        (AddressLowering''preProcess-2 (:lowering this), graph)
        (loop-when-recur [#_"ISeq" s (seq (Graph''getNodes-1 graph))] (some? s) [(next s)]
            (let [
                #_"Node" node (first s)
            ]
                (when (instance? OffsetAddressNode node)
                    (let [
                        #_"AddressNode" lowered (AddressLowering''lower-3 (:lowering this), (OffsetAddressNode''getBase-1 node), (:offset node))
                    ]
                        (AddressLowering''postProcess-2 (:lowering this), lowered)
                        (§ ass! node (Node''replaceAtUsages-2 node, lowered))
                        (GraphUtil'killWithUnusedFloatingInputs-1 node)
                    )
                )
            )
        )
        nil
    )
)

(final-ns CanonicalizerPhase (§ extends BasePhase #_"<PhaseContext>")
    (def- #_"int" CanonicalizerPhase'MAX_ITERATION_PER_NODE 10)

    (§ mutable #_"boolean" :canonicalizeReads true)

    (§ defn #_"CanonicalizerPhase" CanonicalizerPhase'new-0 []
        (BasePhase'new-0)
    )

    ;;;
     ; @param newNodesMark only the {@linkplain Graph#getNewNodes(NodeMark) new nodes} specified by this mark are processed
     ;;
    (§ method! #_"void" CanonicalizerPhase''applyIncremental-4 [#_"CanonicalizerPhase" this, #_"Graph" graph, #_"PhaseContext" context, #_"NodeMark" newNodesMark]
        (Phase''apply-2 (CanonicalizerInstance'new-3 this, context, newNodesMark), graph)
        nil
    )

    ;;;
     ; @param workingSet the initial working set of nodes on which the canonicalizer works, should be an auto-grow node bitmap
     ;;
    (§ method! #_"void" CanonicalizerPhase''applyIncremental-4 [#_"CanonicalizerPhase" this, #_"Graph" graph, #_"PhaseContext" context, #_"Iterable<? extends Node>" workingSet]
        (Phase''apply-2 (CanonicalizerInstance'new-3 this, context, workingSet), graph)
        nil
    )

    (§ method! #_"void" CanonicalizerPhase''applyIncremental-5 [#_"CanonicalizerPhase" this, #_"Graph" graph, #_"PhaseContext" context, #_"Iterable<? extends Node>" workingSet, #_"NodeMark" newNodesMark]
        (Phase''apply-2 (CanonicalizerInstance'new-4 this, context, workingSet, newNodesMark), graph)
        nil
    )

    #_unused
    (§ override! #_"void" CanonicalizerPhase''run-3 [#_"CanonicalizerPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (CanonicalizerInstance''run-2 (CanonicalizerInstance'new-2 this, context), graph)
        nil
    )
)

;;;
 ; @anno CanonicalizerPhase.CanonicalizerInstance
 ;;
(final-ns CanonicalizerInstance (§ extends Phase)
    (§ final #_"CanonicalizerPhase" :phase nil)

    (§ final #_"NodeMark" :newNodesMark nil)
    (§ final #_"PhaseContext" :context nil)
    (§ final #_"Iterable<? extends Node>" :initWorkingSet nil)

    (§ mutable #_"NodeWorkList" :workList nil)
    (§ mutable #_"Tool" :tool nil)

    (§ defn- #_"CanonicalizerInstance" CanonicalizerInstance'new-2 [#_"CanonicalizerPhase" phase, #_"PhaseContext" context]
        (CanonicalizerInstance'new-4 phase, context, nil, nil)
    )

    (§ defn- #_"CanonicalizerInstance" CanonicalizerInstance'new-3 [#_"CanonicalizerPhase" phase, #_"PhaseContext" context, #_"Iterable<? extends Node>" workingSet]
        (CanonicalizerInstance'new-4 phase, context, workingSet, nil)
    )

    (§ defn- #_"CanonicalizerInstance" CanonicalizerInstance'new-3 [#_"CanonicalizerPhase" phase, #_"PhaseContext" context, #_"NodeMark" newNodesMark]
        (CanonicalizerInstance'new-4 phase, context, nil, newNodesMark)
    )

    (§ defn- #_"CanonicalizerInstance" CanonicalizerInstance'new-4 [#_"CanonicalizerPhase" phase, #_"PhaseContext" context, #_"Iterable<? extends Node>" workingSet, #_"NodeMark" newNodesMark]
        (let [
            #_"CanonicalizerInstance" this (Phase'new-0)
            this (assoc this :phase phase)
            this (assoc this :newNodesMark newNodesMark)
            this (assoc this :context context)
            this (assoc this :initWorkingSet workingSet)
        ]
            this
        )
    )

    (§ override! #_"void" CanonicalizerInstance''run-2 [#_"CanonicalizerInstance" this, #_"Graph" graph]
        (let [
            #_"boolean" wholeGraph (or (nil? (:newNodesMark this)) (NodeMark''isStart-1 (:newNodesMark this)))
        ]
            (if (nil? (:initWorkingSet this))
                (§ ass! this (assoc this :workList (IterativeNodeWorkList'new-3 graph, wholeGraph, CanonicalizerPhase'MAX_ITERATION_PER_NODE)))
                (do
                    (§ ass! this (assoc this :workList (IterativeNodeWorkList'new-3 graph, false, CanonicalizerPhase'MAX_ITERATION_PER_NODE)))
                    (NodeWorkList''addAll-2 (:workList this), (:initWorkingSet this))
                )
            )
            (when-not wholeGraph
                (NodeWorkList''addAll-2 (:workList this), (Graph''getNewNodes-2 graph, (:newNodesMark this)))
            )
            (§ ass! this (assoc this :tool (Tool'new-1 this)))
            (CanonicalizerInstance''processWorkSet-2 this, graph)
        )
        nil
    )

    ; @SuppressWarnings("try")
    (§ method- #_"void" CanonicalizerInstance''processWorkSet-2 [#_"CanonicalizerInstance" this, #_"Graph" graph]
        (let [
            #_"CanonicalizerInstance" instance this
            #_"NodeEventListener" listener
                (§ reify #_"NodeEventListener" (NodeEventListener'new-0)
                    (§ override! #_"void" NodeEventListener''nodeAdded-2 [#_"NodeEventListener" this, #_"Node" node]
                        (NodeWorkList''add-2 (:workList instance), node)
                        nil
                    )

                    (§ override! #_"void" NodeEventListener''inputChanged-2 [#_"NodeEventListener" this, #_"Node" node]
                        (NodeWorkList''add-2 (:workList instance), node)
                        (when (instance? IndirectCanonicalization node)
                            (doseq [#_"Node" usage (Node''usages-1 node)]
                                (NodeWorkList''add-2 (:workList instance), usage)
                            )
                        )
                        nil
                    )

                    (§ override! #_"void" NodeEventListener''usagesDroppedToZero-2 [#_"NodeEventListener" this, #_"Node" node]
                        (NodeWorkList''add-2 (:workList instance), node)
                        nil
                    )
                )
        ]
            (try (§ with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                (doseq [#_"Node" node (:workList this)]
                    (CanonicalizerInstance''processNode-2 this, node)
                )
            )
        )
        nil
    )

    ;;;
     ; @return true if the graph was changed
     ;;
    (§ method- #_"boolean" CanonicalizerInstance''processNode-2 [#_"CanonicalizerInstance" this, #_"Node" node]
        (and (Node''isAlive-1 node)
            (or (GraphUtil'tryKillUnused-1 node)
                (CanonicalizerInstance''tryCanonicalize-3 this, node, (:nodeClass node))
                (and (instance? ValueNode node)
                    (let [
                        #_"boolean" improved? (CanonicalizerInstance''tryInferStamp-2 this, node)
                        #_"Constant" constant (Stamp''asConstant-1 (:stamp node))
                    ]
                        (if (and (some? constant) (not (instance? ConstantNode node)))
                            (do
                                (Node''replaceAtUsages-3 node, InputType'Value, (ConstantNode'forConstant-3 (:stamp node), constant, (:graph node)))
                                (GraphUtil'tryKillUnused-1 node)
                                true
                            )
                            (and improved?
                                ;; the improved stamp may enable additional canonicalization
                                (or (CanonicalizerInstance''tryCanonicalize-3 this, node, (:nodeClass node))
                                    (do
                                        (#_"Iterable" .forEach (Node''usages-1 node), (ß (:workList this)(§ ffun )NodeWorkList''add-2))
                                        false
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"boolean" CanonicalizerInstance''tryCanonicalize-3 [#_"CanonicalizerInstance" this, #_"Node" node, #_"NodeClass" nodeClass]
        (or
            (and (:canonicalizable? nodeClass)
                (let [
                    #_"Node" canonical
                        (let [
                            canonical (Canonicalizable''canonical-2 node, (:tool this))
                        ]
                            (when (and (= canonical node) (:commutative? nodeClass)) => canonical
                                (BinaryCommutative''maybeCommuteInputs-1 node)
                            )
                        )
                ]
                    (CanonicalizerInstance''performReplacement-3 this, node, canonical)
                )
            )
            (and (:simplifiable? nodeClass)
                (do
                    (Node''simplify-2 node, (:tool this))
                    (Node''isDeleted-1 node)
                )
            )
        )
    )

    ;; cases:                                           original node:
    ;;                                     |Floating|Fixed-unconnected|Fixed-connected|
    ;;                                     --------------------------------------------
    ;;                                  nil|   1    |        X        |       3       |
    ;;                                     --------------------------------------------
    ;;                             Floating|   2    |        X        |       4       |
    ;;   canonical node:                   --------------------------------------------
    ;;                    Fixed-unconnected|   X    |        X        |       5       |
    ;;                                     --------------------------------------------
    ;;                      Fixed-connected|   2    |        X        |       6       |
    ;;                                     --------------------------------------------
    ;;                          ControlSink|   X    |        X        |       7       |
    ;;                                     --------------------------------------------
    ;;   X: must not happen

    (§ method- #_"boolean" CanonicalizerInstance''performReplacement-3 [#_"CanonicalizerInstance" this, #_"Node" node, #_"Node" newCanonical]
        (and (not= newCanonical node)
            (let [
                #_"Graph" graph (:graph node)
                #_"Node" canonical
                    (when (and (some? newCanonical) (not (Node''isAlive-1 newCanonical))) => newCanonical
                        (Graph''addOrUniqueWithInputs-2 graph, newCanonical)
                    )
            ]
                (cond
                    (instance? FloatingNode node)
                    (do
                        (§ ass! node (Node''replaceAtUsages-2 node, canonical))
                        (GraphUtil'killWithUnusedFloatingInputs-2 node, true)
                    )
                    (instance? ControlSinkNode canonical)
                    (do
                        (Node''replaceAtPredecessor-2 node, canonical)
                        (GraphUtil'killCFG-1 node)
                    )
                    :else
                    (do
                        ;; when removing a fixed node, new canonicalization opportunities for its successor may arise
                        (Tool''addToWorkList-2 (:tool this), (:next node))
                        (cond
                            (nil? canonical)
                            (do
                                (§ ass! node (Node''replaceAtUsages-2 node, nil))
                                (GraphUtil'removeFixedWithUnusedInputs-1 node)
                            )
                            (instance? FloatingNode canonical)
                            (do
                                (§ ass! graph (Graph''replaceFixedWithFloating-3 graph, node, canonical))
                            )
                            (nil? (:predecessor canonical))
                            (do
                                (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, node, canonical))
                            )
                            :else
                            (do
                                (§ ass! node (Node''replaceAtUsages-2 node, canonical))
                                (GraphUtil'removeFixedWithUnusedInputs-1 node)
                            )
                        )
                    )
                )
                true
            )
        )
    )

    ;;;
     ; Calls ValueNode#inferStamp() on the node and, if it returns true (which means
     ; that the stamp has changed), re-queues the node's usages. If the stamp has changed then
     ; this method also checks if the stamp now describes a constant integer value, in which
     ; case the node is replaced with a constant.
     ;;
    (§ method- #_"boolean" CanonicalizerInstance''tryInferStamp-2 [#_"CanonicalizerInstance" this, #_"ValueNode" node]
        (and (Node''isAlive-1 node) (ValueNode''inferStamp-1 node)
            (do
                (doseq [#_"Node" usage (Node''usages-1 node)]
                    (NodeWorkList''add-2 (:workList this), usage)
                )
                true
            )
        )
    )
)

;;;
 ; @anno CanonicalizerPhase.CanonicalizerInstance.Tool
 ;;
(final-ns Tool (§ implements SimplifierTool)
    (§ final #_"CanonicalizerInstance" :instance nil)

    (§ defn #_"Tool" Tool'new-1 [#_"CanonicalizerInstance" instance]
        (let [
            #_"Tool" this (Object.)
            this (assoc this :instance instance)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" Tool''deleteBranch-2 [#_"Tool" this, #_"Node" branch]
        (Node''replaceFirstSuccessor-3 (:predecessor branch), branch, nil)
        (GraphUtil'killCFG-1 branch)
        nil
    )

    (§ override! #_"void" Tool''addToWorkList-2 [#_"Tool" this, #_"Node" node]
        (NodeWorkList''add-2 (:workList (:instance this)), node)
        nil
    )

    (§ override! #_"void" Tool''addToWorkList-2 [#_"Tool" this, #_"Iterable<? extends Node>" nodes]
        (NodeWorkList''addAll-2 (:workList (:instance this)), nodes)
        nil
    )

    #_unused
    (§ override! #_"void" Tool''removeIfUnused-2 [#_"Tool" this, #_"Node" node]
        (GraphUtil'tryKillUnused-1 node)
        nil
    )

    #_unused
    (§ override! #_"boolean" Tool''canonicalizeReads-1 [#_"Tool" this]
        (:canonicalizeReads (:phase (:instance this)))
    )

    #_unused
    (§ override! #_"boolean" Tool''allUsagesAvailable-1 [#_"Tool" this]
        true
    )

    #_unused
    (§ override! #_"Integer" Tool''smallestCompareWidth-1 [#_"Tool" this]
        (Lowerer'smallestCompareWidth-0)
    )
)

(final-ns ConditionalEliminationPhase (§ extends BasePhase #_"<PhaseContext>")
    (§ final #_"boolean" :fullSchedule false)

    (§ defn #_"ConditionalEliminationPhase" ConditionalEliminationPhase'new-1 [#_"boolean" fullSchedule]
        (let [
            #_"ConditionalEliminationPhase" this (BasePhase'new-0)
            this (assoc this :fullSchedule fullSchedule)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ConditionalEliminationPhase''run-3 [#_"ConditionalEliminationPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (let [
            #_"ControlFlowGraph" cfg (ControlFlowGraph'compute-5 graph, true, true, true, true)
            [#_"BlockMap<List<Node>>" blockToNodes #_"NodeMap<Block>" nodeToBlock]
                (when (:fullSchedule this) => [nil (:nodeToBlock cfg)]
                    (ControlFlowGraph''visitDominatorTree-3 cfg, (MoveGuardsUpwards'new-0), (:hasValueProxies graph))
                    (SchedulePhase'run-3 graph, SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER, cfg)
                    [(:blockToNodesMap (:lastSchedule graph)) (:nodeToBlockMap (:lastSchedule graph))]
                )
        ]
            (ControlFlowGraph''visitDominatorTree-3 cfg, (ConditionalEliminationInstance'new-4 graph, blockToNodes, nodeToBlock, context), (:hasValueProxies graph))
        )
        nil
    )
)

;;;
 ; @anno ConditionalEliminationPhase.MoveGuardsUpwards
 ;;
(final-ns MoveGuardsUpwards (§ implements RecursiveVisitor #_"<Block>")
    (§ mutable #_"Block" :anchorBlock nil)

    (§ defn #_"MoveGuardsUpwards" MoveGuardsUpwards'new-0 []
        (Object.)
    )

    #_unused
    (§ override! #_"Block" MoveGuardsUpwards''enter-2 [#_"MoveGuardsUpwards" this, #_"Block" b]
        (let [
            #_"Block" o'anchorBlock (:anchorBlock this)
        ]
            (when-not (and (some? (:dominator b)) (= (:postdominator (:dominator b)) b))
                ;; New anchor.
                (§ ass! this (assoc this :anchorBlock b))
            )

            (let [
                #_"AbstractBeginNode" begin (:beginNode b)
            ]
                (when (and (instance? AbstractMergeNode begin) (not= (:anchorBlock this) b))
                    (doseq [#_"GuardNode" guard (NodeIterable''snapshot-1 (AbstractBeginNode''guards-1 begin))]
                        (§ ass! guard (Node''replaceAndDelete-2 guard, (Graph''add-2 (:graph begin), (GuardNode'new-6 (GuardNode''getCondition-1 guard), (:beginNode (:anchorBlock this)), (:reason guard), (:action guard), (:negated? guard), (:speculation guard)))))
                    )
                )

                (let [
                    #_"FixedNode" end (:endNode b)
                ]
                    (when (instance? IfNode end)
                        (let [
                            ;; Check if we can move guards upwards.
                            #_"EconomicMap<LogicNode, GuardNode>" trueGuards (EconomicMap/create Equivalence/IDENTITY)
                            _
                                (doseq [#_"GuardNode" guard (AbstractBeginNode''guards-1 (:trueSuccessor end))]
                                    (let [
                                        #_"LogicNode" logic (GuardNode''getCondition-1 guard)
                                    ]
                                        (when (Node''hasMoreThanOneUsage-1 logic)
                                            (#_"EconomicMap" .put trueGuards, logic, guard)
                                        )
                                    )
                                )
                        ]
                            (when (seq trueGuards)
                                (loop-when-recur [#_"ISeq" s (seq (NodeIterable''snapshot-1 (AbstractBeginNode''guards-1 (:falseSuccessor end))))] (some? s) [(next s)]
                                    (let [
                                        #_"GuardNode" guard (first s)
                                        #_"GuardNode" other (get trueGuards (GuardNode''getCondition-1 guard))
                                    ]
                                        (when (and (some? other) (= (:negated? guard) (:negated? other)))
                                            (let [
                                                #_"JavaConstant" speculation
                                                    (cond
                                                        (nil? (:speculation other))                                                    (:speculation guard)
                                                        (or (nil? (:speculation guard)) (= (:speculation guard) (:speculation other))) (:speculation other)
                                                        :else
                                                            ;; Cannot optimize due to different speculations.
                                                            (§ continue )
                                                    )
                                            ]
                                                (let [
                                                    #_"GuardNode" newGuard (Graph''add-2 (:graph end), (GuardNode'new-6 (GuardNode''getCondition-1 guard), (:beginNode (:anchorBlock this)), (:reason guard), (:action guard), (:negated? guard), speculation))
                                                ]
                                                    (when (Node''isAlive-1 other)
                                                        (§ ass! other (Node''replaceAndDelete-2 other, newGuard))
                                                    )
                                                    (§ ass! guard (Node''replaceAndDelete-2 guard, newGuard))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    o'anchorBlock
                )
            )
        )
    )

    #_unused
    (§ override! #_"void" MoveGuardsUpwards''exit-3 [#_"MoveGuardsUpwards" this, #_"Block" b, #_"Block" value]
        (§ ass! this (assoc this :anchorBlock value))
        nil
    )
)

;;;
 ; @anno ConditionalEliminationPhase.PhiInfoElement
 ;;
(final-ns PhiInfoElement
    (§ mutable #_"EconomicMap<EndNode, InfoElement>" :infoElements nil)

    (§ defn #_"PhiInfoElement" PhiInfoElement'new-0 []
        (Object.)
    )

    (§ method! #_"PhiInfoElement" PhiInfoElement''set-3 [#_"PhiInfoElement" this, #_"EndNode" end, #_"InfoElement" infoElement]
        (let [
            this
                (when (nil? (:infoElements this)) => this
                    (assoc this :infoElements (EconomicMap/create Equivalence/IDENTITY))
                )
        ]
            (#_"EconomicMap" .put (:infoElements this), end, infoElement)
            this
        )
    )

    (§ method! #_"InfoElement" PhiInfoElement''get-2 [#_"PhiInfoElement" this, #_"EndNode" end]
        (when (some? (:infoElements this))
            (get (:infoElements this) end)
        )
    )
)

;;;
 ; @anno ConditionalEliminationPhase.ConditionalEliminationInstance
 ;;
(final-ns ConditionalEliminationInstance (§ implements RecursiveVisitor #_"<Integer>")
    (§ final #_"NodeMap<InfoElement>" :map nil)
    (§ final #_"BlockMap<List<Node>>" :blockToNodes nil)
    (§ final #_"NodeMap<Block>" :nodeToBlock nil)
    (§ final #_"CanonicalizerTool" :tool nil)
    (§ final #_"NodeStack" :undoOperations nil)
    (§ final #_"Graph" :graph nil)
    (§ final #_"EconomicMap<MergeNode, EconomicMap<ValuePhiNode, PhiInfoElement>>" :mergeMaps nil)

    ;;;
     ; Tests which may be eliminated because post dominating tests to prove a broader condition.
     ;;
    (§ mutable #_"Deque<DeoptimizingGuard>" :pendingTests nil)

    (§ defn #_"ConditionalEliminationInstance" ConditionalEliminationInstance'new-4 [#_"Graph" graph, #_"BlockMap<List<Node>>" blockToNodes, #_"NodeMap<Block>" nodeToBlock, #_"PhaseContext" context]
        (let [
            #_"ConditionalEliminationInstance" this (Object.)
            this (assoc this :graph graph)
            this (assoc this :blockToNodes blockToNodes)
            this (assoc this :nodeToBlock nodeToBlock)
            this (assoc this :undoOperations (NodeStack'new-0))
            this (assoc this :map (NodeMap'new-1 graph))
            this (assoc this :pendingTests (ArrayDeque.))
            this (assoc this :tool (DefaultSimplifierTool'new-1 false))
            this (assoc this :mergeMaps (EconomicMap/create))
        ]
            this
        )
    )

    (§ method! #_"void" ConditionalEliminationInstance''processConditionAnchor-2 [#_"ConditionalEliminationInstance" this, #_"ConditionAnchorNode" node]
        (ConditionalEliminationInstance''tryProveCondition-3 this, (:condition node), (ß (guard, result, guardedValueStamp, newInput) ->
            (§ fun
                (if (= result (:negated? node))
                    (let [
                        #_"ValueAnchorNode" anchor (Graph''add-2 (:graph node), (ValueAnchorNode'new-1 nil))
                    ]
                        (§ ass! node (Node''replaceAtUsages-2 node, anchor))
                        (§ ass! (:graph node) (Graph''replaceFixedWithFixed-3 (:graph node), node, anchor))
                    )
                    (do
                        (§ ass! node (Node''replaceAtUsages-2 node, guard))
                        (GraphUtil'unlinkFixedNode-1 node)
                        (GraphUtil'killWithUnusedFloatingInputs-1 node)
                    )
                )
                true
            ))
        )
        nil
    )

    (§ method! #_"void" ConditionalEliminationInstance''processGuard-2 [#_"ConditionalEliminationInstance" this, #_"GuardNode" node]
        (when-not (ConditionalEliminationInstance''tryProveGuardCondition-4 this, node, (GuardNode''getCondition-1 node), (ß (guard, result, guardedValueStamp, newInput) ->
                    (§ fun
                        (when (= result (:negated? node)) => (§ ass! node (Node''replaceAndDelete-2 node, guard))
                            (let [
                                #_"DeoptimizeNode" deopt (Graph''add-2 (:graph node), (DeoptimizeNode'new-3 (:action node), (:reason node), (:speculation node)))
                                #_"AbstractBeginNode" beginNode (FloatingAnchoredNode''getAnchor-1 node)
                                #_"FixedNode" next (:next beginNode)
                            ]
                                (§ ass! beginNode (FixedWithNextNode''setNext-2 beginNode, deopt))
                                (GraphUtil'killCFG-1 next)
                            )
                        )
                        true
                    ))
                )
            (ConditionalEliminationInstance''registerNewCondition-4 this, (GuardNode''getCondition-1 node), (:negated? node), node)
        )
        nil
    )

    (§ method! #_"void" ConditionalEliminationInstance''processFixedGuard-2 [#_"ConditionalEliminationInstance" this, #_"FixedGuardNode" node]
        (when-not (ConditionalEliminationInstance''tryProveGuardCondition-4 this, node, (AbstractFixedGuardNode''condition-1 node), (ß (guard, result, guardedValueStamp, newInput) ->
                    (§ fun
                        (if (= result (:negated? node))
                            (let [
                                #_"DeoptimizeNode" deopt (Graph''add-2 (:graph node), (DeoptimizeNode'new-3 (:action node), (:reason node), (:speculation node)))
                            ]
                                (AbstractDeoptimizeNode''setStateBefore-2 deopt, (DeoptimizingFixedWithNextNode''stateBefore-1 node))
                                (Node''replaceAtPredecessor-2 node, deopt)
                                (GraphUtil'killCFG-1 node)
                            )
                            (do
                                (§ ass! node (Node''replaceAtUsages-2 node, guard))
                                (GraphUtil'unlinkFixedNode-1 node)
                                (GraphUtil'killWithUnusedFloatingInputs-1 node)
                            )
                        )
                        true
                    ))
                )
            (ConditionalEliminationInstance''registerNewCondition-4 this, (AbstractFixedGuardNode''condition-1 node), (:negated? node), node)
        )
        nil
    )

    (§ method! #_"void" ConditionalEliminationInstance''processIf-2 [#_"ConditionalEliminationInstance" this, #_"IfNode" node]
        (ConditionalEliminationInstance''tryProveCondition-3 this, (:condition node), (ß (guard, result, guardedValueStamp, newInput) ->
            (§ fun
                (let [
                    #_"AbstractBeginNode" survivingSuccessor (IfNode''getSuccessor-2 node, result)
                ]
                    (Node''replaceAtUsages-3 survivingSuccessor, InputType'Guard, guard)
                    (Node''replaceAtPredecessor-2 survivingSuccessor, nil)
                    (Node''replaceAtPredecessor-2 node, survivingSuccessor)
                    (GraphUtil'killCFG-1 node)
                    true
                )
            ))
        )
        nil
    )

    #_unused
    (§ override! #_"Integer" ConditionalEliminationInstance''enter-2 [#_"ConditionalEliminationInstance" this, #_"Block" block]
        (let [
            #_"int" mark (:tos (:undoOperations this))
        ]
            ;; For now conservatively collect guards only within the same block.
            (#_"Deque" .clear (:pendingTests this))
            (ConditionalEliminationInstance''processNodes-2 this, block)
            mark
        )
    )

    (§ method! #_"void" ConditionalEliminationInstance''processNodes-2 [#_"ConditionalEliminationInstance" this, #_"Block" block]
        (if (some? (:blockToNodes this))
            (doseq [#_"Node" node (BlockMap''get-2 (:blockToNodes this), block)]
                (when (Node''isAlive-1 node)
                    (ConditionalEliminationInstance''processNode-2 this, node)
                )
            )
            (ConditionalEliminationInstance''processBlock-2 this, block)
        )
        nil
    )

    (§ method- #_"void" ConditionalEliminationInstance''processBlock-2 [#_"ConditionalEliminationInstance" this, #_"Block" block]
        (let [
            #_"FixedNode" end (:endNode block)
        ]
            (loop [#_"FixedNode" begin (:beginNode block)]
                (if (= begin end)
                    (when (Node''isAlive-1 end)
                        (ConditionalEliminationInstance''processNode-2 this, end)
                    )
                    (when-not (or (Node''isDeleted-1 begin) (Node''isDeleted-1 end)) ;; => this branch was deleted
                        (let [
                            #_"FixedNode" next (:next begin)
                        ]
                            (ConditionalEliminationInstance''processNode-2 this, begin)
                            (recur next)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" ConditionalEliminationInstance''processNode-2 [#_"ConditionalEliminationInstance" this, #_"Node" node]
        (when (and (instance? NodeWithState node) (not (instance? GuardingNode node)))
            (#_"Deque" .clear (:pendingTests this))
        )
        (when (instance? MergeNode node)
            (ConditionalEliminationInstance''introducePisForPhis-2 this, node)
        )
        (condp instance? node
            AbstractBeginNode
                (if (and (instance? LoopExitNode node) (:hasValueProxies (:graph this)))
                    nil ;; condition must not be used down this path
                    (ConditionalEliminationInstance''processAbstractBegin-2 this, node)
                )
            FixedGuardNode      (ConditionalEliminationInstance''processFixedGuard-2 this, node)
            GuardNode           (ConditionalEliminationInstance''processGuard-2 this, node)
            ConditionAnchorNode (ConditionalEliminationInstance''processConditionAnchor-2 this, node)
            IfNode              (ConditionalEliminationInstance''processIf-2 this, node)
            EndNode             (ConditionalEliminationInstance''processEnd-2 this, node)
            nil
        )
        nil
    )

    (§ method! #_"void" ConditionalEliminationInstance''introducePisForPhis-2 [#_"ConditionalEliminationInstance" this, #_"MergeNode" merge]
        (let [
            #_"EconomicMap<ValuePhiNode, PhiInfoElement>" mergeMap (get (:mergeMaps this) merge)
        ]
            (when (some? mergeMap)
                (let [
                    #_"MapCursor<ValuePhiNode, PhiInfoElement>" entries (#_"EconomicMap" .getEntries mergeMap)
                ]
                    (loop-when-recur [] (#_"MapCursor" .advance entries) []
                        (let [
                            #_"ValuePhiNode" phi (#_"MapCursor" .getKey entries)
                        ]
                            ;; Phi might have been killed already via a conditional elimination in another branch.
                            (when-not (Node''isDeleted-1 phi)
                                (let [
                                    #_"PhiInfoElement" phiInfoElements (#_"MapCursor" .getValue entries)
                                    #_"Stamp" bestPossibleStamp
                                        (loop-when [bestPossibleStamp nil #_"int" i 0] (< i (PhiNode''valueCount-1 phi)) => bestPossibleStamp
                                            (let [
                                                #_"ValueNode" valueAt (PhiNode''valueAt-2 phi, i)
                                                #_"InfoElement" infoElement (PhiInfoElement''get-2 phiInfoElements, (AbstractMergeNode''forwardEndAt-2 merge, i))
                                                #_"Stamp" curBestStamp
                                                    (when (some? infoElement) => (:stamp valueAt)
                                                        (Stamp''join-2 (:stamp valueAt), (:stamp infoElement))
                                                    )
                                            ]
                                                (recur (if (some? bestPossibleStamp) (Stamp''meet-2 bestPossibleStamp, curBestStamp) curBestStamp) (inc i))
                                            )
                                        )
                                ]
                                    (when (some? (Stamp''tryImproveWith-2 (:stamp phi), bestPossibleStamp))
                                        ;; Need to be careful to not run into stamp update cycles with the iterative canonicalization.
                                        (let [
                                            #_"boolean" allow?
                                                (condp instance? bestPossibleStamp
                                                    ObjectStamp
                                                        ;; Always allow object stamps.
                                                        true
                                                    IntegerStamp
                                                        (or
                                                            (not= (IntegerStamp''isPositive-1 bestPossibleStamp) (IntegerStamp''isPositive-1 (:stamp phi)))
                                                            (not= (IntegerStamp''isNegative-1 bestPossibleStamp) (IntegerStamp''isNegative-1 (:stamp phi)))
                                                            (not= (IntegerStamp''isStrictlyPositive-1 bestPossibleStamp) (IntegerStamp''isStrictlyPositive-1 (:stamp phi)))
                                                            (not= (IntegerStamp''isStrictlyNegative-1 bestPossibleStamp) (IntegerStamp''isStrictlyNegative-1 (:stamp phi)))
                                                            (some? (IntegerStamp''asConstant-1 bestPossibleStamp))
                                                            (Stamp''isUnrestricted-1 (:stamp phi))
                                                        )
                                                    #_else
                                                        (some? (Stamp''asConstant-1 bestPossibleStamp))
                                                )
                                        ]
                                            (when allow?
                                                (let [
                                                    #_"ValuePhiNode" newPhi (Graph''add-2 (:graph this), (ValuePhiNode'new-2 bestPossibleStamp, merge))
                                                ]
                                                    (dotimes [#_"int" i (PhiNode''valueCount-1 phi)]
                                                        (let [
                                                            #_"ValueNode" valueAt (PhiNode''valueAt-2 phi, i)
                                                            valueAt
                                                                (if (= (Stamp''meet-2 bestPossibleStamp, (:stamp valueAt)) bestPossibleStamp)
                                                                    valueAt ;; Pi not required here.
                                                                    (let [
                                                                        #_"InfoElement" infoElement (PhiInfoElement''get-2 phiInfoElements, (AbstractMergeNode''forwardEndAt-2 merge, i))
                                                                    ]
                                                                        (Graph''maybeAddOrUnique-2 (:graph this), (PiNode'create-3 (or (:proxifiedInput infoElement) valueAt), (:stamp infoElement), (:guard infoElement)))
                                                                    )
                                                                )
                                                        ]
                                                            (PhiNode''addInput-2 newPhi, valueAt)
                                                        )
                                                    )
                                                    (Node''replaceAtUsagesAndDelete-2 phi, newPhi)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" ConditionalEliminationInstance''processEnd-2 [#_"ConditionalEliminationInstance" this, #_"EndNode" end]
        (let [
            #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 end)
        ]
            (when (instance? MergeNode merge)
                (loop-when [#_"EconomicMap<ValuePhiNode, PhiInfoElement>" m (get (:mergeMaps this) merge) #_"ISeq" s (seq (AbstractMergeNode''valuePhis-1 merge))] (some? s)
                    (let [
                        #_"ValuePhiNode" phi (first s)
                        m
                            (loop-when [m m #_"InfoElement" infoElement (ConditionalEliminationInstance''getInfoElements-2 this, (PhiNode''valueAt-2 phi, end))] (some? infoElement) => m
                                (let [
                                    #_"Stamp" stamp (:stamp infoElement)
                                ]
                                    (when (some? (Stamp''tryImproveWith-2 (:stamp phi), stamp)) => (recur m (ConditionalEliminationInstance''nextElement-2 this, infoElement))
                                        (let [
                                            m (or m (let [m (EconomicMap/create)] (#_"EconomicMap" .put (:mergeMaps this), merge, m) m))
                                            #_"PhiInfoElement" phiInfoElement
                                                (or (get m phi)
                                                    (let [
                                                        phiInfoElement (PhiInfoElement'new-0)
                                                    ]
                                                        (#_"EconomicMap" .put m, phi, phiInfoElement)
                                                        phiInfoElement
                                                    )
                                                )
                                        ]
                                            (§ ass! phiInfoElement (PhiInfoElement''set-3 phiInfoElement, end, infoElement))
                                            m
                                        )
                                    )
                                )
                            )
                    ]
                        (recur m (next s))
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" ConditionalEliminationInstance''registerNewCondition-4 [#_"ConditionalEliminationInstance" this, #_"LogicNode" condition, #_"boolean" negated?, #_"GuardingNode" guard]
        (condp instance? condition
            UnaryOpLogicNode
                (let [
                    #_"ValueNode" value (UnaryOpLogicNode''getValue-1 condition)
                ]
                    (when (ConditionalEliminationInstance'maybeMultipleUsages-1 value)
                        ;; getSucceedingStampForValue doesn't take the (potentially a Pi Node) input stamp
                        ;; into account, so it can be safely propagated.
                        (let [
                            #_"Stamp" stamp (UnaryOpLogicNode''getSucceedingStampForValue-2 condition, negated?)
                        ]
                            (ConditionalEliminationInstance''registerNewStamp-5 this, value, stamp, guard, true)
                        )
                    )
                )
            BinaryOpLogicNode
                (let [
                    #_"ValueNode" x (:x condition)
                    #_"ValueNode" y (:y condition)
                ]
                    (when (and (not (instance? ConstantNode x)) (ConditionalEliminationInstance'maybeMultipleUsages-1 x))
                        (let [
                            #_"Stamp" newStampX (BinaryOpLogicNode''getSucceedingStampForX-4 condition, negated?, (ConditionalEliminationInstance'getSafeStamp-1 x), (ConditionalEliminationInstance'getOtherSafeStamp-1 y))
                        ]
                            (ConditionalEliminationInstance''registerNewStamp-4 this, x, newStampX, guard)
                        )
                    )

                    (when (and (not (instance? ConstantNode y)) (ConditionalEliminationInstance'maybeMultipleUsages-1 y))
                        (let [
                            #_"Stamp" newStampY (BinaryOpLogicNode''getSucceedingStampForY-4 condition, negated?, (ConditionalEliminationInstance'getOtherSafeStamp-1 x), (ConditionalEliminationInstance'getSafeStamp-1 y))
                        ]
                            (ConditionalEliminationInstance''registerNewStamp-4 this, y, newStampY, guard)
                        )
                    )

                    (when (and (instance? IntegerEqualsNode condition) (instance? DeoptimizingGuard guard) (not negated?) (instance? ConstantNode y) (instance? AndNode x) (= (:y x) y) (ConditionalEliminationInstance'maybeMultipleUsages-1 (:x x)))
                        ;; This 'and' proves something about some of the bits in and.getX().
                        ;; It's equivalent to or'ing in the mask value since those values are known to be set.
                        (let [
                            #_"IntegerStamp" newStampX (BinaryOp''foldStamp-3 (:or (ArithmeticOpTable'forStamp-1 (:stamp x))), (ConditionalEliminationInstance'getSafeStamp-1 (:x x)), (ConditionalEliminationInstance'getOtherSafeStamp-1 y))
                        ]
                            (ConditionalEliminationInstance''registerNewStamp-4 this, (:x x), newStampX, guard)
                        )
                    )
                )
            nil
        )
        (when (instance? DeoptimizingGuard guard)
            (#_"Deque" .push (:pendingTests this), guard)
        )
        (ConditionalEliminationInstance''registerCondition-4 this, condition, negated?, guard)
        nil
    )

    (§ method! #_"Pair<InfoElement, Stamp>" ConditionalEliminationInstance''recursiveFoldStamp-2 [#_"ConditionalEliminationInstance" this, #_"Node" node]
        (condp instance? node
            UnaryNode
                (loop-when [#_"InfoElement" infoElement (ConditionalEliminationInstance''getInfoElements-2 this, (UnaryNode''getValue-1 node))] (some? infoElement)
                    (let [
                        #_"Stamp" result (UnaryNode''foldStamp-2 node, (:stamp infoElement))
                    ]
                        (when (some? result) => (recur (ConditionalEliminationInstance''nextElement-2 this, infoElement))
                            (Pair/create infoElement, result)
                        )
                    )
                )
            BinaryNode
                (when (instance? ConstantNode (:y node))
                    (loop-when [#_"InfoElement" infoElement (ConditionalEliminationInstance''getInfoElements-2 this, (:x node))] (some? infoElement)
                        (let [
                            #_"Stamp" result (BinaryNode''foldStamp-3 node, (:stamp infoElement), (:stamp (:y node)))
                        ]
                            (when (some? result) => (recur (ConditionalEliminationInstance''nextElement-2 this, infoElement))
                                (Pair/create infoElement, result)
                            )
                        )
                    )
                )
            nil
        )
    )

    ;;;
     ; Get the stamp that may be used for the value for which we are registering the condition.
     ; We may directly use the stamp here without restriction, because any later lookup of the
     ; registered info elements is in the same chain of pi nodes.
     ;;
    (§ defn- #_"Stamp" ConditionalEliminationInstance'getSafeStamp-1 [#_"ValueNode" x]
        (:stamp x)
    )

    ;;;
     ; We can only use the stamp of a second value involved in the condition if we are sure that
     ; we are not implicitly creating a dependency on a pi node that is responsible for that
     ; stamp. For now, we are conservatively only using the stamps of constants. Under certain
     ; circumstances, we may also be able to use the stamp of the value after skipping pi nodes
     ; (e.g. the stamp of a parameter after inlining, or the stamp of a fixed node that can
     ; never be replaced with a pi node via canonicalization).
     ;;
    (§ defn- #_"Stamp" ConditionalEliminationInstance'getOtherSafeStamp-1 [#_"ValueNode" x]
        (if (or (instance? ConstantNode x) (:isAfterFixedReadPhase (:graph x)))
            (:stamp x)
            (Stamp''unrestricted-1 (:stamp x))
        )
    )

    ;;;
     ; Recursively try to fold stamps within this expression using information from
     ; #getInfoElements(ValueNode). It's only safe to use constants and one
     ; InfoElement, otherwise more than one guard would be required.
     ;
     ; @return the pair of the @{link InfoElement} used and the stamp produced for the whole expression
     ;;
    (§ method! #_"Pair<InfoElement, Stamp>" ConditionalEliminationInstance''recursiveFoldStampFromInfo-2 [#_"ConditionalEliminationInstance" this, #_"Node" node]
        (ConditionalEliminationInstance''recursiveFoldStamp-2 this, node)
    )

    ;;;
     ; Look for a preceding guard whose condition is implied by {@code thisGuard}. If we find
     ; one, try to move this guard just above that preceding guard so that we can fold it:
     ;
     ;     guard(C1); // preceding guard
     ;     ...
     ;     guard(C2); // thisGuard
     ;
     ; If C2 => C1, transform to:
     ;
     ;     guard(C2);
     ;     ...
     ;;
    (§ method! #_"boolean" ConditionalEliminationInstance''foldPendingTest-5 [#_"ConditionalEliminationInstance" this, #_"DeoptimizingGuard" thisGuard, #_"ValueNode" original, #_"Stamp" stamp, #_"GuardRewirer" rewireGuardFunction]
        (loop-when [#_"ISeq" s (seq (:pendingTests this))] (some? s) => false
            (let [
                #_"DeoptimizingGuard" pendingGuard (first s)
                #_"LogicNode" pendingCondition (DeoptimizingGuard''getCondition-1 pendingGuard)
                #_"TriState" result
                    (condp instance? pendingCondition
                        UnaryOpLogicNode
                            (when (= (UnaryOpLogicNode''getValue-1 pendingCondition) original) => TriState/UNKNOWN
                                (UnaryOpLogicNode''tryFold-2 pendingCondition, stamp)
                            )
                        BinaryOpLogicNode
                            (let [
                                #_"ValueNode" x (:x pendingCondition)
                                #_"ValueNode" y (:y pendingCondition)
                            ]
                                (condp = original
                                    x (BinaryOpLogicNode''tryFold-3 pendingCondition, stamp, (ConditionalEliminationInstance'getOtherSafeStamp-1 y))
                                    y (BinaryOpLogicNode''tryFold-3 pendingCondition, (ConditionalEliminationInstance'getOtherSafeStamp-1 x), stamp)
                                    (when (and (instance? IntegerEqualsNode pendingCondition) (instance? ConstantNode y) (instance? AndNode x) (= (:y x) y) (= (:x x) original)) => TriState/UNKNOWN
                                        (BinaryOpLogicNode''tryFold-3 pendingCondition, (BinaryOp''foldStamp-3 (:and (ArithmeticOpTable'forStamp-1 stamp)), stamp, (ConditionalEliminationInstance'getOtherSafeStamp-1 y)), (ConditionalEliminationInstance'getOtherSafeStamp-1 y))
                                    )
                                )
                            )
                        TriState/UNKNOWN
                    )
            ]
                ;; The test can be folded using the information available,
                ;; but it can only be moved up if we're sure there's no schedule dependence.
                (or (and (#_"TriState" .isKnown result)
                        (ConditionalEliminationInstance''canScheduleAbove-4 this, (DeoptimizingGuard''getCondition-1 thisGuard), pendingGuard, original)
                        (ConditionalEliminationInstance''foldGuard-6 this, thisGuard, pendingGuard, (#_"TriState" .toBoolean result), stamp, rewireGuardFunction)
                    )
                    (recur (next s))
                )
            )
        )
    )

    (§ method- #_"boolean" ConditionalEliminationInstance''canScheduleAbove-4 [#_"ConditionalEliminationInstance" this, #_"Node" test, #_"Node" target, #_"ValueNode" knownToBeAbove]
        (let [
            #_"Block" targetBlock (NodeMap''get-2 (:nodeToBlock this), target)
            #_"Block" testBlock (NodeMap''get-2 (:nodeToBlock this), test)
        ]
            (or
                (when (and (some? targetBlock) (some? testBlock))
                    (cond
                        (= targetBlock testBlock)
                            (loop-when [#_"ISeq" s (seq (BlockMap''get-2 (:blockToNodes this), targetBlock))] (some? s)
                                (condp = (first s)
                                    test   true
                                    target nil
                                    (recur (next s))
                                )
                            )
                        (ControlFlowGraph'dominates-2 testBlock, targetBlock)
                            true
                    )
                )
                (let [
                    #_"InputFilter" filter (InputFilter'new-1 knownToBeAbove)
                ]
                    (Node''applyInputs-2 test, filter)
                    (:ok filter)
                )
            )
        )
    )

    (§ method! #_"boolean" ConditionalEliminationInstance''foldGuard-6 [#_"ConditionalEliminationInstance" this, #_"DeoptimizingGuard" thisGuard, #_"DeoptimizingGuard" otherGuard, #_"boolean" outcome, #_"Stamp" guardedValueStamp, #_"GuardRewirer" rewireGuardFunction]
        (let [
            #_"DeoptimizationAction" action (StaticDeoptimizingNode'mergeActions-2 (:action otherGuard), (:action thisGuard))
        ]
            (and (some? action) (= (:speculation otherGuard) (:speculation thisGuard))
                (let [
                    #_"LogicNode" logic (Node''copyWithInputs-1 (DeoptimizingGuard''getCondition-1 thisGuard))
                ]
                    ;; We have ...; guard(C1); guard(C2);...
                    ;;
                    ;; Where the first guard is 'otherGuard' and the second one 'thisGuard'.
                    ;;
                    ;; Depending on 'outcome', we have C2 => C1 or C2 => !C1.
                    ;;
                    ;; - If C2 => C1, 'mustDeopt' below is false and we transform to ...; guard(C2); ...
                    ;;
                    ;; - If C2 => !C1, 'mustDeopt' is true and we transform to ..; guard(C1); deopt;

                    ;; for the second case, the action of the deopt is copied from there:
                    (DeoptimizingGuard''setAction-2 thisGuard, action)
                    (let [
                        #_"GuardRewirer" rewirer (ß (guard, result, innerGuardedValueStamp, newInput) ->
                            (§ fun
                                ;; 'result' is 'outcome', 'guard' is 'otherGuard'
                                (let [
                                    #_"boolean" mustDeopt (= result (:negated? otherGuard))
                                ]
                                    (if (GuardRewirer''rewire-5 rewireGuardFunction, guard, (= mustDeopt (:negated? thisGuard)), innerGuardedValueStamp, newInput)
                                        (do
                                            (when-not mustDeopt
                                                (DeoptimizingGuard''setCondition-3 otherGuard, logic, (:negated? thisGuard))
                                                (DeoptimizingGuard''setAction-2 otherGuard, action)
                                                (DeoptimizingGuard''setReason-2 otherGuard, (:reason thisGuard))
                                            )
                                            true
                                        )
                                        (do
                                            (Node''safeDelete-1 logic)
                                            false
                                        )
                                    )
                                )
                            )
                        )
                    ]
                        ;; move the later test up
                        (ConditionalEliminationInstance''rewireGuards-6 this, otherGuard, outcome, nil, guardedValueStamp, rewirer)
                    )
                )
            )
        )
    )

    (§ method! #_"void" ConditionalEliminationInstance''registerCondition-4 [#_"ConditionalEliminationInstance" this, #_"LogicNode" logic, #_"boolean" negated?, #_"GuardingNode" guard]
        (when (Node''hasMoreThanOneUsage-1 logic)
            (ConditionalEliminationInstance''registerNewStamp-4 this, logic, (if negated? StampFactory'booleanFalse StampFactory'booleanTrue), guard)
        )
        nil
    )

    (§ method! #_"InfoElement" ConditionalEliminationInstance''getInfoElements-2 [#_"ConditionalEliminationInstance" this, #_"ValueNode" proxiedValue]
        (let [
            #_"ValueNode" value (GraphUtil'skipPi-1 proxiedValue)
        ]
            (when (some? value)
                (NodeMap''getAndGrow-2 (:map this), value)
            )
        )
    )

    (§ method! #_"boolean" ConditionalEliminationInstance''rewireGuards-6 [#_"ConditionalEliminationInstance" this, #_"GuardingNode" guard, #_"boolean" result, #_"ValueNode" proxifiedInput, #_"Stamp" guardedValueStamp, #_"GuardRewirer" rewireGuardFunction]
        (GuardRewirer''rewire-5 rewireGuardFunction, guard, result, guardedValueStamp, proxifiedInput)
    )

    (§ method! #_"boolean" ConditionalEliminationInstance''tryProveCondition-3 [#_"ConditionalEliminationInstance" this, #_"LogicNode" node, #_"GuardRewirer" rewireGuardFunction]
        (ConditionalEliminationInstance''tryProveGuardCondition-4 this, nil, node, rewireGuardFunction)
    )

    (§ method- #_"InfoElement" ConditionalEliminationInstance''nextElement-2 [#_"ConditionalEliminationInstance" this, #_"InfoElement" current]
        (or (:parent current)
            (let [
                #_"ValueNode" proxifiedInput (:proxifiedInput current)
            ]
                (when (instance? PiNode proxifiedInput)
                    (ConditionalEliminationInstance''getInfoElements-2 this, (PiNode''getOriginalNode-1 proxifiedInput))
                )
            )
        )
    )

    (§ method! #_"boolean" ConditionalEliminationInstance''tryProveGuardCondition-4 [#_"ConditionalEliminationInstance" this, #_"DeoptimizingGuard" thisGuard, #_"LogicNode" node, #_"GuardRewirer" rewireGuardFunction]
        (loop [#_"InfoElement" infoElement (ConditionalEliminationInstance''getInfoElements-2 this, node)]
            (if (some? infoElement)
                (let [
                    #_"JavaConstant" constant (Stamp''asConstant-1 (:stamp infoElement))
                ]
                    (when (some? constant) => (recur (ConditionalEliminationInstance''nextElement-2 this, infoElement))
                        ;; No proxified input and stamp required.
                        (ConditionalEliminationInstance''rewireGuards-6 this, (:guard infoElement), (#_"JavaConstant" .asBoolean constant), nil, nil, rewireGuardFunction)
                    )
                )
                (condp instance? node
                    UnaryOpLogicNode
                        (let [
                            #_"ValueNode" value (UnaryOpLogicNode''getValue-1 node)
                        ]
                            (loop-when [#_"InfoElement" infoElement (ConditionalEliminationInstance''getInfoElements-2 this, value)] (some? infoElement)
                                (let [
                                    #_"TriState" result (UnaryOpLogicNode''tryFold-2 node, (:stamp infoElement))
                                ]
                                    (if (#_"TriState" .isKnown result)
                                        (§ return (ConditionalEliminationInstance''rewireGuards-6 this, (:guard infoElement), (#_"TriState" .toBoolean result), (:proxifiedInput infoElement), (:stamp infoElement), rewireGuardFunction))
                                        (recur (ConditionalEliminationInstance''nextElement-2 this, infoElement))
                                    )
                                )
                            )

                            (let [
                                #_"Pair<InfoElement, Stamp>" foldResult (ConditionalEliminationInstance''recursiveFoldStampFromInfo-2 this, value)
                            ]
                                (when (some? foldResult)
                                    (let [
                                        #_"TriState" result (UnaryOpLogicNode''tryFold-2 node, (#_"Pair" .getRight foldResult))
                                    ]
                                        (when (#_"TriState" .isKnown result)
                                            (§ return (ConditionalEliminationInstance''rewireGuards-6 this, (:guard (#_"Pair" .getLeft foldResult)), (#_"TriState" .toBoolean result), (:proxifiedInput (#_"Pair" .getLeft foldResult)), (#_"Pair" .getRight foldResult), rewireGuardFunction))
                                        )
                                    )
                                )
                                (and (some? thisGuard)
                                    (let [
                                        #_"Stamp" stamp (UnaryOpLogicNode''getSucceedingStampForValue-2 node, (:negated? thisGuard))
                                    ]
                                        (and (some? stamp) (ConditionalEliminationInstance''foldPendingTest-5 this, thisGuard, value, stamp, rewireGuardFunction))
                                    )
                                )
                            )
                        )
                    BinaryOpLogicNode
                        (do
                            (loop-when [#_"InfoElement" infoElement (ConditionalEliminationInstance''getInfoElements-2 this, (:x node))] (some? infoElement)
                                (let [
                                    #_"TriState" result (BinaryOpLogicNode''tryFold-3 node, (:stamp infoElement), (:stamp (:y node)))
                                ]
                                    (if (#_"TriState" .isKnown result)
                                        (§ return (ConditionalEliminationInstance''rewireGuards-6 this, (:guard infoElement), (#_"TriState" .toBoolean result), (:proxifiedInput infoElement), (:stamp infoElement), rewireGuardFunction))
                                        (recur (ConditionalEliminationInstance''nextElement-2 this, infoElement))
                                    )
                                )
                            )

                            (if (instance? ConstantNode (:y node))
                                (let [
                                    #_"Pair<InfoElement, Stamp>" foldResult (ConditionalEliminationInstance''recursiveFoldStampFromInfo-2 this, (:x node))
                                ]
                                    (when (some? foldResult)
                                        (let [
                                            #_"TriState" result (BinaryOpLogicNode''tryFold-3 node, (#_"Pair" .getRight foldResult), (:stamp (:y node)))
                                        ]
                                            (when (#_"TriState" .isKnown result)
                                                (§ return (ConditionalEliminationInstance''rewireGuards-6 this, (:guard (#_"Pair" .getLeft foldResult)), (#_"TriState" .toBoolean result), (:proxifiedInput (#_"Pair" .getLeft foldResult)), (#_"Pair" .getRight foldResult), rewireGuardFunction))
                                            )
                                        )
                                    )
                                )
                                (loop-when [#_"InfoElement" infoElement (ConditionalEliminationInstance''getInfoElements-2 this, (:y node))] (some? infoElement)
                                    (let [
                                        #_"TriState" result (BinaryOpLogicNode''tryFold-3 node, (:stamp (:x node)), (:stamp infoElement))
                                    ]
                                        (if (#_"TriState" .isKnown result)
                                            (§ return (ConditionalEliminationInstance''rewireGuards-6 this, (:guard infoElement), (#_"TriState" .toBoolean result), (:proxifiedInput infoElement), (:stamp infoElement), rewireGuardFunction))
                                            (recur (ConditionalEliminationInstance''nextElement-2 this, infoElement))
                                        )
                                    )
                                )
                            )

                            ;; For complex expressions involving constants, see if it's possible to fold the
                            ;; tests by using stamps one level up in the expression. For instance, (x + n < y)
                            ;; might fold if something is known about x and all other values are constants. The
                            ;; reason for the constant restriction is that if more than 1 real value is involved
                            ;; the code might need to adopt multiple guards to have proper dependences.
                            (when (and (instance? BinaryArithmeticNode (:x node)) (instance? ConstantNode (:y node)) (instance? ConstantNode (:y (:x node))))
                                (loop-when [#_"InfoElement" infoElement (ConditionalEliminationInstance''getInfoElements-2 this, (:x (:x node)))] (some? infoElement)
                                    (let [
                                        #_"Stamp" sx (BinaryArithmeticNode''foldStamp-3 (:x node), (:stamp infoElement), (:stamp (:y (:x node))))
                                        #_"TriState" result (BinaryOpLogicNode''tryFold-3 node, sx, (:stamp (:y node)))
                                    ]
                                        (if (#_"TriState" .isKnown result)
                                            (§ return (ConditionalEliminationInstance''rewireGuards-6 this, (:guard infoElement), (#_"TriState" .toBoolean result), (:proxifiedInput infoElement), sx, rewireGuardFunction))
                                            (recur (ConditionalEliminationInstance''nextElement-2 this, infoElement))
                                        )
                                    )
                                )
                            )

                            (when (and (some? thisGuard) (instance? IntegerEqualsNode node) (not (:negated? thisGuard)) (instance? ConstantNode (:y node)) (instance? AndNode (:x node)) (= (:y (:x node)) (:y node)))
                                ;; This 'and' proves something about some of the bits in and.getX().
                                ;; It's equivalent to or'ing in the mask value since those values are known to be set.
                                (let [
                                    #_"BinaryOp<Or>" op (:or (ArithmeticOpTable'forStamp-1 (:stamp (:x node))))
                                    #_"IntegerStamp" sx (BinaryOp''foldStamp-3 op, (ConditionalEliminationInstance'getSafeStamp-1 (:x (:x node))), (ConditionalEliminationInstance'getOtherSafeStamp-1 (:y node)))
                                ]
                                    (when (ConditionalEliminationInstance''foldPendingTest-5 this, thisGuard, (:x (:x node)), sx, rewireGuardFunction)
                                        (§ return true)
                                    )
                                )
                            )

                            (and (some? thisGuard)
                                (or
                                    (when-not (instance? ConstantNode (:x node))
                                        (let [
                                            #_"Stamp" sx (BinaryOpLogicNode''getSucceedingStampForX-4 node, (:negated? thisGuard), (ConditionalEliminationInstance'getSafeStamp-1 (:x node)), (ConditionalEliminationInstance'getOtherSafeStamp-1 (:y node)))
                                        ]
                                            (when (and (some? sx) (ConditionalEliminationInstance''foldPendingTest-5 this, thisGuard, (:x node), sx, rewireGuardFunction))
                                                true
                                            )
                                        )
                                    )
                                    (when-not (instance? ConstantNode (:y node))
                                        (let [
                                            #_"Stamp" sy (BinaryOpLogicNode''getSucceedingStampForY-4 node, (:negated? thisGuard), (ConditionalEliminationInstance'getOtherSafeStamp-1 (:x node)), (ConditionalEliminationInstance'getSafeStamp-1 (:y node)))
                                        ]
                                            (when (and (some? sy) (ConditionalEliminationInstance''foldPendingTest-5 this, thisGuard, (:y node), sy, rewireGuardFunction))
                                                true
                                            )
                                        )
                                    )
                                    false
                                )
                            )
                        )
                    ShortCircuitOrNode
                        (ConditionalEliminationInstance''tryProveCondition-3 this, (:x node), (ß (guard, result, guardedValueStamp, newInput) ->
                            (§ fun
                                (if (= result (not (:xNegated node)))
                                    (ConditionalEliminationInstance''rewireGuards-6 this, guard, true, newInput, guardedValueStamp, rewireGuardFunction)
                                    (ConditionalEliminationInstance''tryProveCondition-3 this, (:y node), (ß (innerGuard, innerResult, innerGuardedValueStamp, innerNewInput) ->
                                        (§ fun
                                            (let [
                                                #_"ValueNode" proxifiedInput
                                                    (cond
                                                        (nil? newInput)                                      innerNewInput
                                                        (or (nil? innerNewInput) (= innerNewInput newInput)) newInput
                                                        :else (§ return false) ;; Cannot canonicalize due to different proxied inputs.
                                                    )
                                            ]
                                                ;; Can only canonicalize if the guards are equal.
                                                (and (= innerGuard guard)
                                                    (ConditionalEliminationInstance''rewireGuards-6 this, guard, (§ xor innerResult (:yNegated node)), proxifiedInput, guardedValueStamp, rewireGuardFunction)
                                                )
                                            )
                                        ))
                                    )
                                )
                            ))
                        )
                    false
                )
            )
        )
    )

    (§ method! #_"void" ConditionalEliminationInstance''registerNewStamp-4 [#_"ConditionalEliminationInstance" this, #_"ValueNode" maybeProxiedValue, #_"Stamp" stamp, #_"GuardingNode" guard]
        (ConditionalEliminationInstance''registerNewStamp-5 this, maybeProxiedValue, stamp, guard, false)
        nil
    )

    (§ method! #_"void" ConditionalEliminationInstance''registerNewStamp-5 [#_"ConditionalEliminationInstance" this, #_"ValueNode" maybeProxiedValue, #_"Stamp" stamp, #_"GuardingNode" guard, #_"boolean" propagateThroughPis]
        (when (and (some? stamp) (not (Stamp''isUnrestricted-1 stamp)))
            (loop-when [#_"ValueNode" value maybeProxiedValue stamp stamp] (and (some? stamp) (some? value))
                (§ ass! (:map this) (NodeMap''setAndGrow-3 (:map this), value, (InfoElement'new-4 stamp, guard, (when (instance? PiNode value) value), (NodeMap''getAndGrow-2 (:map this), value))))
                (§ ass! (:undoOperations this) (NodeStack''push-2 (:undoOperations this), value))
                (cond
                    (and propagateThroughPis (instance? PiNode value))
                        (recur (PiNode''getOriginalNode-1 value) stamp)
                    (instance? StampInverter value)
                        (let [
                            value (StampInverter''getValue-1 value)
                        ]
                            (recur value (StampInverter''invertStamp-2 value, stamp))
                        )
                )
            )
        )
        nil
    )

    (§ method! #_"void" ConditionalEliminationInstance''processAbstractBegin-2 [#_"ConditionalEliminationInstance" this, #_"AbstractBeginNode" beginNode]
        (let [
            #_"Node" predecessor (:predecessor beginNode)
        ]
            (condp instance? predecessor
                IfNode            (ConditionalEliminationInstance''registerNewCondition-4 this, (:condition predecessor), (= (:falseSuccessor predecessor) beginNode), beginNode)
                IntegerSwitchNode (ConditionalEliminationInstance''processIntegerSwitch-3 this, beginNode, predecessor)
                nil
            )
        )
        nil
    )

    (§ defn- #_"boolean" ConditionalEliminationInstance'maybeMultipleUsages-1 [#_"ValueNode" value]
        (or (Node''hasMoreThanOneUsage-1 value) (instance? ProxyNode value) (instance? PiNode value) (instance? StampInverter value))
    )

    (§ method! #_"void" ConditionalEliminationInstance''processIntegerSwitch-3 [#_"ConditionalEliminationInstance" this, #_"AbstractBeginNode" beginNode, #_"IntegerSwitchNode" integerSwitchNode]
        (let [
            #_"ValueNode" value (SwitchNode''value-1 integerSwitchNode)
        ]
            (when (ConditionalEliminationInstance'maybeMultipleUsages-1 value)
                (let [
                    #_"Stamp" stamp (IntegerSwitchNode''getValueStampForSuccessor-2 integerSwitchNode, beginNode)
                ]
                    (when (some? stamp)
                        (ConditionalEliminationInstance''registerNewStamp-4 this, value, stamp, beginNode)
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" ConditionalEliminationInstance''exit-3 [#_"ConditionalEliminationInstance" this, #_"Block" b, #_"Integer" state]
        (let [
            #_"int" mark state
        ]
            (while (< mark (:tos (:undoOperations this)))
                (let [
                    #_"Node" node (NodeStack''pop-1 (:undoOperations this))
                ]
                    (when (Node''isAlive-1 node)
                        (NodeMap''set-3 (:map this), node, (:parent (NodeMap''get-2 (:map this), node)))
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; @anno ConditionalEliminationPhase.InfoElementProvider
 ;;
; @FunctionalInterface
(§ interface InfoElementProvider
    #_unused
    (§ abstract #_"Iterable<InfoElement>" InfoElementProvider''getInfoElements-2 [#_"InfoElementProvider" this, #_"ValueNode" value])
)

;;;
 ; Checks for safe nodes when moving pending tests up.
 ;
 ; @anno ConditionalEliminationPhase.InputFilter
 ;;
(final-ns InputFilter (§ extends EdgeVisitor)
    (§ mutable #_"boolean" :ok false)
    (§ mutable #_"ValueNode" :value nil)

    (§ defn #_"InputFilter" InputFilter'new-1 [#_"ValueNode" value]
        (let [
            #_"InputFilter" this (EdgeVisitor'new-0)
            this (assoc this :value value)
            this (assoc this :ok true)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Node" InputFilter''apply-3 [#_"InputFilter" this, #_"Node" _, #_"Node" node]
        (when (:ok this) ;; => abort the recursion
            (cond
                (not (instance? ValueNode node))                                                         (§ ass! this (assoc this :ok false))
                (or (instance? ConstantNode node) (= node (:value this)) (instance? ParameterNode node)) nil
                (or (instance? BinaryNode node) (instance? UnaryNode node))                              (Node''applyInputs-2 node, this)
                :else                                                                                    (§ ass! this (assoc this :ok false))
            )
        )
        node
    )
)

;;;
 ; @anno ConditionalEliminationPhase.GuardRewirer
 ;;
; @FunctionalInterface
(§ interface GuardRewirer
    ;;;
     ; Called if the condition could be proven to have a constant value ({@code result}) under {@code guard}.
     ;
     ; @param guard the guard whose result is proven
     ; @param result the known result of the guard
     ; @param newInput new input to pi nodes depending on the new guard
     ; @return whether the transformation could be applied
     ;;
    (§ abstract #_"boolean" GuardRewirer''rewire-5 [#_"GuardRewirer" this, #_"GuardingNode" guard, #_"boolean" result, #_"Stamp" guardedValueStamp, #_"ValueNode" newInput])
)

;;;
 ; @anno ConditionalEliminationPhase.InfoElement
 ;;
(final-ns InfoElement
    (§ final #_"Stamp" :stamp nil)
    (§ final #_"GuardingNode" :guard nil)
    (§ final #_"ValueNode" :proxifiedInput nil)
    (§ final #_"InfoElement" :parent nil)

    (§ defn #_"InfoElement" InfoElement'new-4 [#_"Stamp" stamp, #_"GuardingNode" guard, #_"ValueNode" proxifiedInput, #_"InfoElement" parent]
        (let [
            #_"InfoElement" this (Object.)
            this (assoc this :stamp stamp)
            this (assoc this :guard guard)
            this (assoc this :proxifiedInput proxifiedInput)
            this (assoc this :parent parent)
        ]
            this
        )
    )
)

;;;
 ; This phase will find branches which always end with a DeoptimizeNode and replace their
 ; ControlSplitNodes with FixedGuardNodes.
 ;
 ; This is useful because FixedGuardNodes will be lowered to GuardNodes, which can later
 ; be optimized more aggressively than control-flow constructs.
 ;
 ; This is currently only done for branches that start from a IfNode. If it encounters
 ; a branch starting at an other kind of ControlSplitNode, it will only bring the
 ; DeoptimizeNode as close to the ControlSplitNode as possible.
 ;;
(final-ns ConvertDeoptimizeToGuardPhase (§ extends BasePhase #_"<PhaseContext>")
    (§ defn #_"ConvertDeoptimizeToGuardPhase" ConvertDeoptimizeToGuardPhase'new-0 []
        (BasePhase'new-0)
    )

    (§ defn- #_"void" ConvertDeoptimizeToGuardPhase'moveAsDeoptAfter-2 [#_"FixedWithNextNode" node, #_"StaticDeoptimizingNode" deopt]
        (let [
            #_"FixedNode" next (:next node)
        ]
            (when-not (= next deopt)
                (§ ass! node (FixedWithNextNode''setNext-2 node, (Graph''add-2 (:graph node), (DeoptimizeNode'new-3 (:action deopt), (:reason deopt), (:speculation deopt)))))
                (GraphUtil'killCFG-1 next)
            )
        )
        nil
    )

    (§ method- #_"void" ConvertDeoptimizeToGuardPhase''propagateFixed-3 [#_"ConvertDeoptimizeToGuardPhase" this, #_"FixedNode" from, #_"StaticDeoptimizingNode" deopt]
        (loop-when [#_"Node" node from] (some? node)
            (let [
                #_"Node" predecessor (:predecessor node)
            ]
                (if (and GraalOptions'guardPriorities (instance? FixedGuardNode node))
                    (when (GuardPriority'isHigherPriorityThan-2 (StaticDeoptimizingNode''computePriority-1 node), (StaticDeoptimizingNode''computePriority-1 deopt)) => (recur predecessor)
                        (ConvertDeoptimizeToGuardPhase'moveAsDeoptAfter-2 node, deopt)
                    )
                    (when (instance? AbstractBeginNode node) => (recur predecessor)
                        (cond
                            (instance? AbstractMergeNode node)
                                (let [
                                    #_"FixedNode" next (:next node)
                                ]
                                    (while (Node''isAlive-1 node)
                                        (ConvertDeoptimizeToGuardPhase''propagateFixed-3 this, (first (AbstractMergeNode''forwardEnds-1 node)), deopt)
                                    )
                                    (ConvertDeoptimizeToGuardPhase''propagateFixed-3 this, next, deopt)
                                )
                            (instance? IfNode predecessor)
                                (let [
                                    ;; prioritize the source position of the IfNode
                                    #_"Graph" graph (:graph predecessor)
                                    #_"boolean" negateGuardCondition (= node (:trueSuccessor predecessor))
                                    #_"FixedGuardNode" guard (Graph''add-2 graph, (FixedGuardNode'new-5 (:condition predecessor), (:reason deopt), (:action deopt), (:speculation deopt), negateGuardCondition))
                                    #_"FixedWithNextNode" pred (:predecessor predecessor)
                                    #_"AbstractBeginNode" survivingSuccessor (if negateGuardCondition (:falseSuccessor predecessor) (:trueSuccessor predecessor))
                                ]
                                    (Graph''removeSplitPropagate-3 graph, predecessor, survivingSuccessor)
                                    (let [
                                        #_"Node" newGuard (if (instance? LoopExitNode survivingSuccessor) (ProxyNode'forGuard-3 guard, survivingSuccessor, graph) guard)
                                    ]
                                        (Node''replaceAtUsages-3 survivingSuccessor, InputType'Guard, newGuard)
                                        (let [
                                            #_"FixedNode" next (:next pred)
                                        ]
                                            (§ ass! pred (FixedWithNextNode''setNext-2 pred, guard))
                                            (§ ass! guard (FixedWithNextNode''setNext-2 guard, next))
                                            (Node''simplify-2 survivingSuccessor, (DefaultSimplifierTool'new-1 false))
                                        )
                                    )
                                )
                            :else
                                (when (or (nil? predecessor) (instance? ControlSplitNode predecessor)) => (recur predecessor)
                                    (ConvertDeoptimizeToGuardPhase'moveAsDeoptAfter-2 (§ cast #_"AbstractBeginNode" node), deopt)
                                )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" ConvertDeoptimizeToGuardPhase''processFixedGuardAndMerge-9 [#_"ConvertDeoptimizeToGuardPhase" this, #_"FixedGuardNode" fixedGuard, #_"PhaseContext" context, #_"CompareNode" compare, #_"ValueNode" x, #_"ValuePhiNode" xPhi, #_"ValueNode" y, #_"ValuePhiNode" yPhi, #_"AbstractMergeNode" merge]
        (let [
            #_"List<EndNode>" predecessors (NodeIterable''snapshot-1 (AbstractMergeNode''cfgPredecessors-1 merge))
        ]
            (loop-when [#_"int" i 0] (< i (count predecessors))
                (let [
                    #_"AbstractEndNode" pred (nth predecessors i)
                ]
                    (when (Node''isAlive-1 pred)
                        (let [
                            #_"Constant" xs (ValueNode''asConstant-1 (if (some? xPhi) (PhiNode''valueAt-2 xPhi, pred) x))
                            #_"Constant" ys (ValueNode''asConstant-1 (if (some? yPhi) (PhiNode''valueAt-2 yPhi, pred) y))
                        ]
                            (when (and (some? xs) (some? ys) (= (Condition''foldCondition-3 (CompareNode''condition-1 compare), (:condition xs), ys) (:negated? fixedGuard)))
                                (ConvertDeoptimizeToGuardPhase''propagateFixed-3 this, pred, fixedGuard)
                            )
                            (recur (inc i))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" ConvertDeoptimizeToGuardPhase''processFixedGuardAndPhis-8 [#_"ConvertDeoptimizeToGuardPhase" this, #_"FixedGuardNode" fixedGuard, #_"PhaseContext" context, #_"CompareNode" compare, #_"ValueNode" x, #_"ValuePhiNode" xPhi, #_"ValueNode" y, #_"ValuePhiNode" yPhi]
        (let [
            #_"AbstractBeginNode" pred (AbstractBeginNode'prevBegin-1 fixedGuard)
        ]
            (when (and (instance? AbstractMergeNode pred) (or (nil? xPhi) (= (PhiNode''merge-1 xPhi) pred)) (or (nil? yPhi) (= (PhiNode''merge-1 yPhi) pred)))
                (ConvertDeoptimizeToGuardPhase''processFixedGuardAndMerge-9 this, fixedGuard, context, compare, x, xPhi, y, yPhi, pred)
            )
        )
        nil
    )

    (§ method- #_"void" ConvertDeoptimizeToGuardPhase''trySplitFixedGuard-3 [#_"ConvertDeoptimizeToGuardPhase" this, #_"FixedGuardNode" fixedGuard, #_"PhaseContext" context]
        (let [
            #_"LogicNode" logic (AbstractFixedGuardNode''condition-1 fixedGuard)
        ]
            (when (instance? CompareNode logic)
                (let [
                    #_"ValueNode" x (:x logic)
                    #_"ValuePhiNode" xPhi (when (instance? ValuePhiNode x) x)
                ]
                    (when (or (instance? ConstantNode x) (some? xPhi))
                        (let [
                            #_"ValueNode" y (:y logic)
                            #_"ValuePhiNode" yPhi (when (instance? ValuePhiNode y) y)
                        ]
                            (when (or (instance? ConstantNode y) (some? yPhi))
                                (ConvertDeoptimizeToGuardPhase''processFixedGuardAndPhis-8 this, fixedGuard, context, logic, x, xPhi, y, yPhi)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" ConvertDeoptimizeToGuardPhase''run-3 [#_"ConvertDeoptimizeToGuardPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (doseq [#_"DeoptimizeNode" d (Graph''getNodes-2 graph, DeoptimizeNode'TYPE)]
            (when-not (= (:action d) DeoptimizationAction/None)
                (ConvertDeoptimizeToGuardPhase''propagateFixed-3 this, d, d)
            )
        )
        (when (some? context)
            (doseq [#_"FixedGuardNode" fixedGuard (Graph''getNodes-2 graph, FixedGuardNode'TYPE)]
                (ConvertDeoptimizeToGuardPhase''trySplitFixedGuard-3 this, fixedGuard, context)
            )
        )
        (Phase''apply-2 (DeadCodeEliminationPhase'new-1 Optionality'Optional), graph)
        nil
    )
)

(final-ns DeadCodeEliminationPhase (§ extends Phase)
    ;;;
     ; Creates a dead code elimination phase that will be run irrespective of GraalOptions#reduceDCE.
     ;;
    (§ defn #_"DeadCodeEliminationPhase" DeadCodeEliminationPhase'new-0 []
        (DeadCodeEliminationPhase'new-1 Optionality'Required)
    )

    ;;;
     ; Creates a dead code elimination phase that will be run only if it is
     ; {@linkplain Optionality#Required non-optional} or GraalOptions#reduceDCE is false.
     ;;
    (§ defn #_"DeadCodeEliminationPhase" DeadCodeEliminationPhase'new-1 [#_"Optionality" optionality]
        (let [
            #_"DeadCodeEliminationPhase" this (Phase'new-0)
            this (assoc this :optional (= optionality Optionality'Optional))
        ]
            this
        )
    )

    (§ final #_"boolean" :optional false)

    #_unused
    (§ override! #_"void" DeadCodeEliminationPhase''run-2 [#_"DeadCodeEliminationPhase" this, #_"Graph" graph]
        (when-not (and (:optional this) GraalOptions'reduceDCE)
            (let [
                #_"NodeFlood" flood (NodeFlood'new-1 graph)
                #_"int" totalNodeCount (Graph''getNodeCount-1 graph)
            ]
                (§ ass! flood (NodeFlood''add-2 flood, (:start graph)))
                (DeadCodeEliminationPhase'iterateSuccessorsAndInputs-1 flood)
                (let [
                    #_"boolean" changed?
                        (loop-when [changed? false #_"ISeq" s (seq (Graph''getNodes-2 graph, GuardNode'TYPE))] (some? s) => changed?
                            (let [
                                #_"GuardNode" guard (first s)
                                changed?
                                    (when (NodeFlood''isMarked-2 flood, (FloatingAnchoredNode''getAnchor-1 guard)) => changed?
                                        (§ ass! flood (NodeFlood''add-2 flood, guard))
                                        true
                                    )
                            ]
                                (recur changed? (next s))
                            )
                        )
                ]
                    (when changed?
                        (DeadCodeEliminationPhase'iterateSuccessorsAndInputs-1 flood)
                    )
                    (if (= totalNodeCount (:totalMarkedCount flood))
                        ;; all nodes are live => nothing more to do
                        nil
                        ;; some nodes are not marked alive and therefore dead => proceed
                        (DeadCodeEliminationPhase'deleteNodes-2 flood, graph)
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" DeadCodeEliminationPhase'iterateSuccessorsAndInputs-1 [#_"NodeFlood" flood]
        (let [
            #_"EdgeVisitor" consumer
                (§ reify #_"EdgeVisitor" (EdgeVisitor'new-0)
                    (§ override! #_"Node" EdgeVisitor''apply-3 [#_"EdgeVisitor" this, #_"Node" n, #_"Node" succOrInput]
                        (§ ass! flood (NodeFlood''add-2 flood, succOrInput))
                        succOrInput
                    )
                )
        ]
            (doseq [#_"Node" current flood]
                (if (instance? AbstractEndNode current)
                    (§ ass! flood (NodeFlood''add-2 flood, (AbstractEndNode''merge-1 current)))
                    (do
                        (Node''applySuccessors-2 current, consumer)
                        (Node''applyInputs-2 current, consumer)
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" DeadCodeEliminationPhase'deleteNodes-2 [#_"NodeFlood" flood, #_"Graph" graph]
        (let [
            #_"EdgeVisitor" consumer
                (§ reify #_"EdgeVisitor" (EdgeVisitor'new-0)
                    (§ override! #_"Node" EdgeVisitor''apply-3 [#_"EdgeVisitor" this, #_"Node" n, #_"Node" input]
                        (when (and (Node''isAlive-1 input) (NodeFlood''isMarked-2 flood, input))
                            (Node''removeUsage-2 input, n)
                        )
                        input
                    )
                )
        ]
            (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                (when-not (NodeFlood''isMarked-2 flood, node)
                    (Node''markDeleted-1 node)
                    (Node''applyInputs-2 node, consumer)
                )
            )
        )
        nil
    )
)

;;;
 ; @anno DeadCodeEliminationPhase.Optionality
 ;;
(value-ns Optionality
    (§ enum Optionality'Optional)
    (§ enum Optionality'Required)
)

;;;
 ; This phase tries to find {@link AbstractDeoptimizeNode DeoptimizeNodes} which use the same
 ; FrameState and merges them together.
 ;;
(final-ns DeoptimizationGroupingPhase (§ extends BasePhase #_"<MidTierContext>")
    (§ defn #_"DeoptimizationGroupingPhase" DeoptimizationGroupingPhase'new-0 []
        (BasePhase'new-0)
    )

    (§ defn- #_"void" DeoptimizationGroupingPhase'exitLoops-3 [#_"AbstractDeoptimizeNode" deopt, #_"EndNode" end, #_"ControlFlowGraph" cfg]
        (loop-when-recur [#_"Loop" loop (:loop (ControlFlowGraph''blockFor-2 cfg, deopt))] (some? loop) [(:parent loop)]
            (Graph''addBeforeFixed-3 (:graph end), end, (Graph''add-2 (:graph end), (LoopExitNode'new-1 (:beginNode (:header loop)))))
        )
        nil
    )

    #_unused
    (§ override! #_"void" DeoptimizationGroupingPhase''run-3 [#_"DeoptimizationGroupingPhase" this, #_"Graph" graph, #_"MidTierContext" context]
        (loop-when [#_"ControlFlowGraph" cfg nil #_"ISeq" s (seq (Graph''getNodes-2 graph, FrameState'TYPE))] (some? s)
            (let [
                #_"FrameState" fs (first s)
                [cfg #_"FixedNode" target #_"List<AbstractDeoptimizeNode>" obsoletes]
                    (loop-when [cfg cfg target nil obsoletes nil #_"ISeq" s (seq (NodeIterable''filter-2 (Node''usages-1 fs), AbstractDeoptimizeNode))] (some? s) => [cfg target obsoletes]
                        (let [
                            #_"AbstractDeoptimizeNode" deopt (first s)
                            [cfg target obsoletes]
                                (when (some? target) => [cfg deopt obsoletes]
                                    (let [
                                        cfg (or cfg (ControlFlowGraph'compute-5 graph, true, true, false, false))
                                        [target obsoletes #_"PhiNode" reasonActionPhi #_"PhiNode" speculationPhi]
                                            (when (instance? AbstractDeoptimizeNode target) => [target obsoletes nil nil]
                                                (let [
                                                    #_"AbstractMergeNode" merge (Graph''add-2 graph, (MergeNode'new-0))
                                                    #_"EndNode" firstEnd (Graph''add-2 graph, (EndNode'new-0))
                                                    #_"ValueNode" actionAndReason (AbstractDeoptimizeNode''getActionAndReason-1 target)
                                                    #_"ValueNode" speculation (AbstractDeoptimizeNode''getSpeculation-1 target)
                                                    reasonActionPhi (Graph''add-2 graph, (ValuePhiNode'new-2 (StampFactory'forKind-1 (ValueNode''getStackKind-1 actionAndReason)), merge))
                                                    speculationPhi (Graph''add-2 graph, (ValuePhiNode'new-2 (StampFactory'forKind-1 (ValueNode''getStackKind-1 speculation)), merge))
                                                ]
                                                    (AbstractMergeNode''addForwardEnd-2 merge, firstEnd)
                                                    (PhiNode''addInput-2 reasonActionPhi, actionAndReason)
                                                    (PhiNode''addInput-2 speculationPhi, speculation)
                                                    (Node''replaceAtPredecessor-2 target, firstEnd)
                                                    (DeoptimizationGroupingPhase'exitLoops-3 target, firstEnd, cfg)
                                                    (§ ass! merge (FixedWithNextNode''setNext-2 merge, (Graph''add-2 graph, (DynamicDeoptimizeNode'new-2 reasonActionPhi, speculationPhi))))
                                                    (let [
                                                        obsoletes (LinkedList.)
                                                    ]
                                                        (#_"List" .add obsoletes, target)
                                                        [merge obsoletes reasonActionPhi speculationPhi]
                                                    )
                                                )
                                            )
                                        #_"EndNode" newEnd (Graph''add-2 graph, (EndNode'new-0))
                                    ]
                                        (AbstractMergeNode''addForwardEnd-2 target, newEnd)
                                        (PhiNode''addInput-2 reasonActionPhi, (AbstractDeoptimizeNode''getActionAndReason-1 deopt))
                                        (PhiNode''addInput-2 speculationPhi, (AbstractDeoptimizeNode''getSpeculation-1 deopt))
                                        (Node''replaceAtPredecessor-2 deopt, newEnd)
                                        (DeoptimizationGroupingPhase'exitLoops-3 deopt, newEnd, cfg)
                                        (#_"List" .add obsoletes, deopt)
                                        [cfg target obsoletes]
                                    )
                                )
                        ]
                            (recur cfg target obsoletes (next s))
                        )
                    )
            ]
                (when (some? obsoletes)
                    (AbstractDeoptimizeNode''setStateBefore-2 (:next target), fs)
                    (doseq [#_"AbstractDeoptimizeNode" obsolete obsoletes]
                        (Node''safeDelete-1 obsolete)
                    )
                )
                (recur cfg (next s))
            )
        )
        nil
    )
)

(final-ns ExpandLogicPhase (§ extends Phase)
    (§ def- #_"double" ExpandLogicPhase'EPSILON 1e-6)

    (§ defn #_"ExpandLogicPhase" ExpandLogicPhase'new-0 []
        (Phase'new-0)
    )

    #_unused
    (§ override! #_"void" ExpandLogicPhase''run-2 [#_"ExpandLogicPhase" this, #_"Graph" graph]
        (doseq [#_"ShortCircuitOrNode" logic (Graph''getNodes-2 graph, ShortCircuitOrNode'TYPE)]
            (ExpandLogicPhase'processBinary-1 logic)
        )

        (doseq [#_"NormalizeCompareNode" logic (Graph''getNodes-2 graph, NormalizeCompareNode'TYPE)]
            (ExpandLogicPhase'processNormalizeCompareNode-1 logic)
        )
        (§ ass! graph (Graph''setAfterExpandLogic-1 graph))
        nil
    )

    (§ defn- #_"void" ExpandLogicPhase'processNormalizeCompareNode-1 [#_"NormalizeCompareNode" normalize]
        (let [
            #_"Graph" graph (:graph normalize)
            #_"ValueNode" x (:x normalize)
            #_"ValueNode" y (:y normalize)
            #_"LogicNode" equalComp (Graph''addOrUniqueWithInputs-2 graph, (IntegerEqualsNode'create-2 x, y))
            #_"LogicNode" lessComp (Graph''addOrUniqueWithInputs-2 graph, (IntegerLessThanNode'create-2 x, y))
            #_"Stamp" stamp (:stamp normalize)
            #_"ConditionalNode" equalValue (Graph''add-2 graph, (ConditionalNode'new-3 equalComp, (ConstantNode'forIntegerStamp-3 stamp, 0, graph), (ConstantNode'forIntegerStamp-3 stamp, 1, graph)))
            #_"ConditionalNode" value (Graph''add-2 graph, (ConditionalNode'new-3 lessComp, (ConstantNode'forIntegerStamp-3 stamp, -1, graph), equalValue))
        ]
            (Node''replaceAtUsagesAndDelete-2 normalize, value)
        )
        nil
    )

    (§ defn- #_"void" ExpandLogicPhase'processBinary-1 [#_"ShortCircuitOrNode" binary]
        (while (NodeIterable''isNotEmpty-1 (Node''usages-1 binary))
            (let [
                #_"Node" usage (NodeIterable''first-1 (Node''usages-1 binary))
            ]
                (condp instance? usage
                    ShortCircuitOrNode (ExpandLogicPhase'processBinary-1 usage)
                    IfNode             (ExpandLogicPhase'processIf-6 (:x binary), (:xNegated binary), (:y binary), (:yNegated binary), usage, (:shortCircuitProbability binary))
                    ConditionalNode    (ExpandLogicPhase'processConditional-5 (:x binary), (:xNegated binary), (:y binary), (:yNegated binary), usage)
                )
            )
        )
        (Node''safeDelete-1 binary)
        nil
    )

    (§ defn- #_"void" ExpandLogicPhase'processIf-6 [#_"LogicNode" x, #_"boolean" xNegated, #_"LogicNode" y, #_"boolean" yNegated, #_"IfNode" ifNode, #_"double" shortCircuitProbability]
        ;; This method splits an IfNode, which has a ShortCircuitOrNode as its condition,
        ;; into two separate IfNodes: if(X) and if(Y)
        ;;
        ;; For computing the probabilities P(X) and P(Y), we use two different approaches.
        ;; The first one assumes that the shortCircuitProbability and the probability on the
        ;; IfNode were created with each other in mind. If this assumption does not hold,
        ;; we fall back to another mechanism for computing the probabilities.
        (let [
            #_"AbstractBeginNode" trueTarget (:trueSuccessor ifNode)
            #_"AbstractBeginNode" falseTarget (:falseSuccessor ifNode)
            ;; 1st approach
            ;; assumption: P(originalIf.trueSuccessor) == P(X) + ((1 - P(X)) * P(Y))
            #_"double" firstIfTrueProbability shortCircuitProbability
            #_"double" secondIfTrueProbability (ExpandLogicPhase'sanitizeProbability-1 (/ (- (:trueSuccessorProbability ifNode) shortCircuitProbability) (- 1.0 shortCircuitProbability)))
        ]
            (when-not (ExpandLogicPhase'doubleEquals-2 (:trueSuccessorProbability ifNode), (+ firstIfTrueProbability (* (- 1.0 firstIfTrueProbability) secondIfTrueProbability)))
                ;; 2nd approach
                ;;
                ;; the assumption above did not hold, so we either used an artificial probability as
                ;; shortCircuitProbability or the ShortCircuitOrNode was moved to some other IfNode.
                ;;
                ;; so, we distribute the if's trueSuccessorProbability between the newly generated if
                ;; nodes according to the shortCircuitProbability. the following invariant is always
                ;; true in this case: P(originalIf.trueSuccessor) == P(X) + ((1 - P(X)) * P(Y))
                (§ ass firstIfTrueProbability (* (:trueSuccessorProbability ifNode) shortCircuitProbability))
                (§ ass secondIfTrueProbability (ExpandLogicPhase'sanitizeProbability-1 (- 1.0 (/ (IfNode''probability-2 ifNode, falseTarget) (- 1.0 firstIfTrueProbability)))))
            )

            (Node''clearSuccessors-1 ifNode)
            (let [
                #_"Graph" graph (:graph ifNode)
                #_"AbstractMergeNode" trueTargetMerge (Graph''add-2 graph, (MergeNode'new-0))
            ]
                (§ ass! trueTargetMerge (FixedWithNextNode''setNext-2 trueTargetMerge, trueTarget))
                (let [
                    #_"EndNode" firstTrueEnd (Graph''add-2 graph, (EndNode'new-0))
                    #_"EndNode" secondTrueEnd (Graph''add-2 graph, (EndNode'new-0))
                ]
                    (AbstractMergeNode''addForwardEnd-2 trueTargetMerge, firstTrueEnd)
                    (AbstractMergeNode''addForwardEnd-2 trueTargetMerge, secondTrueEnd)
                    (let [
                        #_"AbstractBeginNode" firstTrueTarget (BeginNode'begin-1 firstTrueEnd)
                        #_"AbstractBeginNode" secondTrueTarget (BeginNode'begin-1 secondTrueEnd)
                    ]
                        (when yNegated
                            (§ ass secondIfTrueProbability (- 1.0 secondIfTrueProbability))
                        )
                        (when xNegated
                            (§ ass firstIfTrueProbability (- 1.0 firstIfTrueProbability))
                        )
                        (let [
                            #_"IfNode" secondIf (IfNode'new-4 y, (if yNegated falseTarget secondTrueTarget), (if yNegated secondTrueTarget falseTarget), secondIfTrueProbability)
                            #_"AbstractBeginNode" secondIfBegin (BeginNode'begin-1 (Graph''add-2 graph, secondIf))
                            #_"IfNode" firstIf (Graph''add-2 graph, (IfNode'new-4 x, (if xNegated secondIfBegin firstTrueTarget), (if xNegated firstTrueTarget secondIfBegin), firstIfTrueProbability))
                        ]
                            (Node''replaceAtPredecessor-2 ifNode, firstIf)
                            (Node''safeDelete-1 ifNode)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"boolean" ExpandLogicPhase'doubleEquals-2 [#_"double" a, #_"double" b]
        (< (- a ExpandLogicPhase'EPSILON) b (+ a ExpandLogicPhase'EPSILON))
    )

    (§ defn- #_"double" ExpandLogicPhase'sanitizeProbability-1 [#_"double" value]
        (let [
            #_"double" newValue (min 1.0 (max 0.0 value))
        ]
            (if (Double/isNaN newValue) 0.5 newValue)
        )
    )

    (§ defn- #_"void" ExpandLogicPhase'processConditional-5 [#_"LogicNode" x, #_"boolean" xNegated, #_"LogicNode" y, #_"boolean" yNegated, #_"ConditionalNode" conditional]
        (let [
            #_"ValueNode" trueTarget (:trueValue conditional)
            #_"ValueNode" falseTarget (:falseValue conditional)
            #_"Graph" graph (:graph conditional)
            #_"ConditionalNode" secondConditional (Graph''add-2 graph, (ConditionalNode'new-3 y, (if yNegated falseTarget trueTarget), (if yNegated trueTarget falseTarget)))
            #_"ConditionalNode" firstConditional (Graph''add-2 graph, (ConditionalNode'new-3 x, (if xNegated secondConditional trueTarget), (if xNegated trueTarget secondConditional)))
        ]
            (§ ass! conditional (Node''replaceAndDelete-2 conditional, firstConditional))
        )
        nil
    )
)

;;;
 ; This phase lowers FloatingReadNodes into corresponding fixed reads.
 ;;
(final-ns FixReadsPhase (§ extends BasePhase #_"<LowTierContext>")
    (§ mutable #_"Phase" :schedulePhase nil)

    (§ defn #_"FixReadsPhase" FixReadsPhase'new-1 [#_"Phase" schedulePhase]
        (let [
            #_"FixReadsPhase" this (BasePhase'new-0)
            this (assoc this :schedulePhase schedulePhase)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" FixReadsPhase''run-3 [#_"FixReadsPhase" this, #_"Graph" graph, #_"LowTierContext" context]
        (Phase''apply-2 (:schedulePhase this), graph)
        (let [
            #_"ScheduleResult" schedule (:lastSchedule graph)
            #_"FixReadsClosure" fixReadsClosure (FixReadsClosure'new-0)
        ]
            (doseq [#_"Block" block (:reversePostOrder (:cfg schedule))]
                (ScheduledNodeIterator''processNodes-3 fixReadsClosure, block, schedule)
            )
            (when GraalOptions'rawConditionalElimination
                (ControlFlowGraph''visitDominatorTree-3 (:cfg schedule), (RawConditionalEliminationVisitor'new-2 graph, schedule), false)
            )
            (§ ass! graph (Graph''setAfterFixReadPhase-2 graph, true))
        )
        nil
    )
)

;;;
 ; @anno FixReadsPhase.FixReadsClosure
 ;;
(final-ns FixReadsClosure (§ extends ScheduledNodeIterator)
    (§ defn #_"FixReadsClosure" FixReadsClosure'new-0 []
        (ScheduledNodeIterator'new-0)
    )

    #_unused
    (§ override! #_"void" FixReadsClosure''processNode-2 [#_"FixReadsClosure" this, #_"Node" node]
        (condp instance? node
            AbstractMergeNode
                (doseq [#_"MemoryPhiNode" memoryPhi (NodeIterable''snapshot-1 (AbstractMergeNode''memoryPhis-1 node))]
                    ;; Memory phi nodes are no longer necessary at this point.
                    (§ ass! memoryPhi (Node''replaceAtUsages-2 memoryPhi, nil))
                    (Node''safeDelete-1 memoryPhi)
                )
            FloatingAccessNode
                (do
                    (FloatingGuardedNode''setLastLocationAccess-2 node, nil)
                    (§ ass! this (ScheduledNodeIterator''replaceCurrent-2 this, (FloatingAccessNode''asFixedNode-1 node)))
                )
            PiNode
                (when (Stamp''isCompatible-2 (:stamp node), (:stamp (PiNode''getOriginalNode-1 node)))
                    ;; Pi nodes are no longer necessary at this point.
                    (§ ass! node (Node''replaceAndDelete-2 node, (PiNode''getOriginalNode-1 node)))
                )
            MemoryAccess
                (MemoryAccess''setLastLocationAccess-2 node, nil)
            nil
        )
        nil
    )
)

;;;
 ; @anno FixReadsPhase.RawConditionalEliminationVisitor
 ;;
(final-ns RawConditionalEliminationVisitor (§ implements RecursiveVisitor #_"<Integer>")
    (§ final #_"NodeMap<StampElement>" :stampMap nil)
    (§ final #_"NodeStack" :undoOperations nil)
    (§ final #_"ScheduleResult" :schedule nil)
    (§ final #_"Graph" :graph nil)
    (§ final #_"BlockMap<Integer>" :blockActionStart nil)
    (§ final #_"EconomicMap<MergeNode, EconomicMap<ValueNode, Stamp>>" :endMaps nil)

    (§ defn #_"RawConditionalEliminationVisitor" RawConditionalEliminationVisitor'new-2 [#_"Graph" graph, #_"ScheduleResult" schedule]
        (let [
            #_"RawConditionalEliminationVisitor" this (Object.)
            this (assoc this :graph graph)
            this (assoc this :schedule schedule)
            this (assoc this :blockActionStart (BlockMap'new-1 (:cfg schedule)))
            this (assoc this :endMaps (EconomicMap/create))
            this (assoc this :stampMap (NodeMap'new-1 graph))
            this (assoc this :undoOperations (NodeStack'new-0))
        ]
            this
        )
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''replaceInput-4 [#_"RawConditionalEliminationVisitor" this, #_"Position" p, #_"Node" oldInput, #_"Node" newConstantInput]
        (Position''set-3 p, oldInput, newConstantInput)
        nil
    )

    (§ method! #_"int" RawConditionalEliminationVisitor''replaceConstantInputs-2 [#_"RawConditionalEliminationVisitor" this, #_"Node" node]
        ;; Check if we can replace any of the inputs with a constant.
        (loop-when [#_"int" n 0 #_"ISeq" s (seq (Node''inputPositions-1 node))] (some? s) => n
            (let [
                #_"Position" p (first s)
                #_"Node" input (Position''get-2 p, node)
                n
                    (when (and (= (Position''getInputType-1 p) InputType'Value) (instance? ValueNode input) (not (instance? ConstantNode input))) => n
                        (let [
                            #_"Stamp" bestStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, input)
                            #_"Constant" constant (Stamp''asConstant-1 bestStamp)
                        ]
                            (when (some? constant) => n
                                (RawConditionalEliminationVisitor''replaceInput-4 this, p, node, (ConstantNode'forConstant-3 bestStamp, constant, (:graph this)))
                                (inc n)
                            )
                        )
                    )
            ]
                (recur n (next s))
            )
        )
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''processNode-2 [#_"RawConditionalEliminationVisitor" this, #_"Node" node]
        (when GraalOptions'replaceInputsWithConstantsBasedOnStamps
            (RawConditionalEliminationVisitor''replaceConstantInputs-2 this, node)
        )
        (when (instance? MergeNode node)
            (RawConditionalEliminationVisitor''registerCombinedStamps-2 this, node)
        )
        (condp instance? node
            AbstractBeginNode (RawConditionalEliminationVisitor''processAbstractBegin-2 this, node)
            IfNode            (RawConditionalEliminationVisitor''processIf-2 this, node)
            IntegerSwitchNode (RawConditionalEliminationVisitor''processIntegerSwitch-2 this, node)
            BinaryNode        (RawConditionalEliminationVisitor''processBinary-2 this, node)
            ConditionalNode   (RawConditionalEliminationVisitor''processConditional-2 this, node)
            UnaryNode         (RawConditionalEliminationVisitor''processUnary-2 this, node)
            EndNode           (RawConditionalEliminationVisitor''processEnd-2 this, node)
            nil
        )
        nil
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''registerCombinedStamps-2 [#_"RawConditionalEliminationVisitor" this, #_"MergeNode" node]
        (let [
            #_"MapCursor<ValueNode, Stamp>" entries (#_"EconomicMap" .getEntries (get (:endMaps this) node))
        ]
            (while (#_"MapCursor" .advance entries)
                (let [
                    #_"ValueNode" value (#_"MapCursor" .getKey entries)
                ]
                    ;; nodes from this map can be deleted when a loop dies
                    (when-not (Node''isDeleted-1 value)
                        (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, value, (#_"MapCursor" .getValue entries))
                    )
                )
            )
        )
        nil
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''processEnd-2 [#_"RawConditionalEliminationVisitor" this, #_"EndNode" node]
        (let [
            #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 node)
        ]
            (when (instance? MergeNode merge)
                (let [
                    #_"NodeMap<Block>" blockToNodeMap (:nodeToBlockMap (:schedule this))
                    #_"Block" mergeBlock (NodeMap''get-2 blockToNodeMap, merge)
                    #_"Block" mergeBlockDominator (:dominator mergeBlock)
                    #_"EconomicMap<ValueNode, Stamp>" currentEndMap (get (:endMaps this) merge)
                ]
                    (when (or (nil? currentEndMap) (seq currentEndMap))
                        (let [
                            #_"EconomicMap<ValueNode, Stamp>" endMap (EconomicMap/create)
                        ]
                            ;; process phis
                            (doseq [#_"ValuePhiNode" phi (AbstractMergeNode''valuePhis-1 merge)]
                                (when (or (nil? currentEndMap) (contains? currentEndMap phi))
                                    (let [
                                        #_"ValueNode" valueAt (PhiNode''valueAt-2 phi, node)
                                        #_"Stamp" bestStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, valueAt)
                                        bestStamp
                                            (when (some? currentEndMap) => bestStamp
                                                (Stamp''meet-2 bestStamp, (get currentEndMap phi))
                                            )
                                    ]
                                        (when-not (= bestStamp (:stamp phi))
                                            (#_"EconomicMap" .put endMap, phi, bestStamp)
                                        )
                                    )
                                )
                            )

                            (let [
                                #_"int" lastMark (:tos (:undoOperations this))
                            ]
                                (loop-when [#_"Block" currentBlock (NodeMap''get-2 blockToNodeMap, node)] (not= currentBlock mergeBlockDominator)
                                    (let [
                                        #_"int" mark (BlockMap''get-2 (:blockActionStart this), currentBlock)
                                    ]
                                        (loop-when [#_"int" i (dec lastMark)] (<= mark i)
                                            (let [
                                                #_"ValueNode" nodeWithNewStamp (NodeStack''get-2 (:undoOperations this), i)
                                            ]
                                                (when-not (or (Node''isDeleted-1 nodeWithNewStamp) (instance? LogicNode nodeWithNewStamp) (instance? ConstantNode nodeWithNewStamp) (NodeMap''isNew-2 blockToNodeMap, nodeWithNewStamp))
                                                    (let [
                                                        #_"Block" block (RawConditionalEliminationVisitor'getBlock-2 nodeWithNewStamp, blockToNodeMap)
                                                    ]
                                                        (when (or (nil? block) (<= (:id block) (:id mergeBlockDominator)))
                                                            ;; Node with new stamp in path to the merge block dominator and that
                                                            ;; at the same time was defined at least in the merge block dominator
                                                            ;; (i.e. therefore can be used after the merge.)
                                                            (let [
                                                                #_"Stamp" bestStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, nodeWithNewStamp)
                                                                bestStamp
                                                                    (when (some? currentEndMap) => bestStamp
                                                                        (let [
                                                                            #_"Stamp" otherEndsStamp (get currentEndMap nodeWithNewStamp)
                                                                        ]
                                                                            (when (nil? otherEndsStamp)
                                                                                ;; No stamp registered in one of the previously processed ends => skip.
                                                                                (§ continue )
                                                                            )
                                                                            (Stamp''meet-2 bestStamp, otherEndsStamp)
                                                                        )
                                                                    )
                                                            ]
                                                                (when (some? (Stamp''tryImproveWith-2 (:stamp nodeWithNewStamp), bestStamp)) ;; => No point in registering the stamp.
                                                                    (#_"EconomicMap" .put endMap, nodeWithNewStamp, bestStamp)
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (recur (dec i))
                                            )
                                        )
                                        (recur (:dominator currentBlock))
                                    )
                                )

                                (#_"EconomicMap" .put (:endMaps this), merge, endMap)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"Block" RawConditionalEliminationVisitor'getBlock-2 [#_"ValueNode" node, #_"NodeMap<Block>" blockToNodeMap]
        (NodeMap''get-2 blockToNodeMap, (if (instance? PhiNode node) (PhiNode''merge-1 node) node))
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''processUnary-2 [#_"RawConditionalEliminationVisitor" this, #_"UnaryNode" node]
        (let [
            #_"Stamp" stamp (UnaryNode''foldStamp-2 node, (RawConditionalEliminationVisitor''getBestStamp-2 this, (UnaryNode''getValue-1 node)))
        ]
            (when-not (RawConditionalEliminationVisitor''checkReplaceWithConstant-3 this, stamp, node)
                (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, node, stamp)
            )
        )
        nil
    )

    (§ method! #_"boolean" RawConditionalEliminationVisitor''checkReplaceWithConstant-3 [#_"RawConditionalEliminationVisitor" this, #_"Stamp" stamp, #_"ValueNode" node]
        (let [
            #_"Constant" constant (Stamp''asConstant-1 stamp)
        ]
            (and (some? constant) (not (instance? ConstantNode node))
                (do
                    (Node''replaceAtUsages-3 node, InputType'Value, (ConstantNode'forConstant-3 stamp, constant, (:graph this)))
                    (GraphUtil'tryKillUnused-1 node)
                    true
                )
            )
        )
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''processBinary-2 [#_"RawConditionalEliminationVisitor" this, #_"BinaryNode" node]
        (let [
            #_"Stamp" xStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:x node))
            #_"Stamp" yStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:y node))
            #_"Stamp" stamp (BinaryNode''foldStamp-3 node, xStamp, yStamp)
        ]
            (when-not (RawConditionalEliminationVisitor''checkReplaceWithConstant-3 this, stamp, node)
                (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, node, stamp)
            )
        )
        nil
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''processIntegerSwitch-2 [#_"RawConditionalEliminationVisitor" this, #_"IntegerSwitchNode" node]
        (let [
            #_"Stamp" bestStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (SwitchNode''value-1 node))
        ]
            (IntegerSwitchNode''tryRemoveUnreachableKeys-3 node, nil, bestStamp)
        )
        nil
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''processIf-2 [#_"RawConditionalEliminationVisitor" this, #_"IfNode" node]
        (let [
            #_"TriState" result (RawConditionalEliminationVisitor''tryProveCondition-2 this, (:condition node))
        ]
            (when-not (= result TriState/UNKNOWN)
                (let [
                    #_"AbstractBeginNode" survivingSuccessor (IfNode''getSuccessor-2 node, (= result TriState/TRUE))
                ]
                    (§ ass! survivingSuccessor (Node''replaceAtUsages-2 survivingSuccessor, nil))
                    (Node''replaceAtPredecessor-2 survivingSuccessor, nil)
                    (Node''replaceAtPredecessor-2 node, survivingSuccessor)
                    (GraphUtil'killCFG-1 node)
                )
            )
        )
        nil
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''processConditional-2 [#_"RawConditionalEliminationVisitor" this, #_"ConditionalNode" node]
        (let [
            #_"TriState" result (RawConditionalEliminationVisitor''tryProveCondition-2 this, (:condition node))
        ]
            (if (= result TriState/UNKNOWN)
                (let [
                    #_"Stamp" trueStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:trueValue node))
                    #_"Stamp" falseStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:falseValue node))
                ]
                    (RawConditionalEliminationVisitor''registerNewStamp-3 this, node, (Stamp''meet-2 trueStamp, falseStamp))
                )
                (§ ass! node (Node''replaceAndDelete-2 node, (if (= result TriState/TRUE) (:trueValue node) (:falseValue node))))
            )
        )
        nil
    )

    (§ method! #_"TriState" RawConditionalEliminationVisitor''tryProveCondition-2 [#_"RawConditionalEliminationVisitor" this, #_"LogicNode" logic]
        (condp = (RawConditionalEliminationVisitor''getBestStamp-2 this, logic)
            StampFactory'booleanTrue  TriState/TRUE
            StampFactory'booleanFalse TriState/FALSE
            (condp instance? logic
                UnaryOpLogicNode  (UnaryOpLogicNode''tryFold-2 logic, (RawConditionalEliminationVisitor''getBestStamp-2 this, (UnaryOpLogicNode''getValue-1 logic)))
                BinaryOpLogicNode (BinaryOpLogicNode''tryFold-3 logic, (RawConditionalEliminationVisitor''getBestStamp-2 this, (:x logic)), (RawConditionalEliminationVisitor''getBestStamp-2 this, (:y logic)))
                TriState/UNKNOWN
            )
        )
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''processAbstractBegin-2 [#_"RawConditionalEliminationVisitor" this, #_"AbstractBeginNode" beginNode]
        (let [
            #_"Node" pred (:predecessor beginNode)
        ]
            (condp instance? pred
                IfNode            (RawConditionalEliminationVisitor''registerNewCondition-3 this, (:condition pred), (= (:falseSuccessor pred) beginNode))
                IntegerSwitchNode (RawConditionalEliminationVisitor''registerIntegerSwitch-3 this, beginNode, pred)
                nil
            )
        )
        nil
    )

    (§ method- #_"void" RawConditionalEliminationVisitor''registerIntegerSwitch-3 [#_"RawConditionalEliminationVisitor" this, #_"AbstractBeginNode" beginNode, #_"IntegerSwitchNode" integerSwitchNode]
        (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, (SwitchNode''value-1 integerSwitchNode), (IntegerSwitchNode''getValueStampForSuccessor-2 integerSwitchNode, beginNode))
        nil
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''registerNewCondition-3 [#_"RawConditionalEliminationVisitor" this, #_"LogicNode" condition, #_"boolean" negated?]
        (condp instance? condition
            UnaryOpLogicNode
                (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, (UnaryOpLogicNode''getValue-1 condition), (UnaryOpLogicNode''getSucceedingStampForValue-2 condition, negated?))
            BinaryOpLogicNode
                (let [
                    #_"Stamp" xStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:x condition))
                    #_"Stamp" yStamp (RawConditionalEliminationVisitor''getBestStamp-2 this, (:y condition))
                ]
                    (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, (:x condition), (BinaryOpLogicNode''getSucceedingStampForX-4 condition, negated?, xStamp, yStamp))
                    (RawConditionalEliminationVisitor''registerNewValueStamp-3 this, (:y condition), (BinaryOpLogicNode''getSucceedingStampForY-4 condition, negated?, xStamp, yStamp))
                )
            nil
        )
        (RawConditionalEliminationVisitor''registerCondition-3 this, condition, negated?)
        nil
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''registerCondition-3 [#_"RawConditionalEliminationVisitor" this, #_"LogicNode" condition, #_"boolean" negated?]
        (RawConditionalEliminationVisitor''registerNewStamp-3 this, condition, (if negated? StampFactory'booleanFalse StampFactory'booleanTrue))
        nil
    )

    (§ method! #_"boolean" RawConditionalEliminationVisitor''registerNewValueStamp-3 [#_"RawConditionalEliminationVisitor" this, #_"ValueNode" value, #_"Stamp" stamp]
        (and (some? stamp) (not (instance? ConstantNode value))
            (let [
                #_"Stamp" betterStamp (Stamp''tryImproveWith-2 (RawConditionalEliminationVisitor''getBestStamp-2 this, value), stamp)
            ]
                (and (some? betterStamp)
                    (do
                        (RawConditionalEliminationVisitor''registerNewStamp-3 this, value, betterStamp)
                        true
                    )
                )
            )
        )
    )

    (§ method! #_"void" RawConditionalEliminationVisitor''registerNewStamp-3 [#_"RawConditionalEliminationVisitor" this, #_"ValueNode" value, #_"Stamp" stamp]
        (§ ass! (:stampMap this) (NodeMap''setAndGrow-3 (:stampMap this), value, (StampElement'new-2 stamp, (NodeMap''getAndGrow-2 (:stampMap this), value))))
        (§ ass! (:undoOperations this) (NodeStack''push-2 (:undoOperations this), value))
        nil
    )

    (§ method! #_"Stamp" RawConditionalEliminationVisitor''getBestStamp-2 [#_"RawConditionalEliminationVisitor" this, #_"ValueNode" value]
        (let [
            #_"StampElement" stampElement (NodeMap''getAndGrow-2 (:stampMap this), value)
        ]
            (if (some? stampElement) (:stamp stampElement) (:stamp value))
        )
    )

    #_unused
    (§ override! #_"Integer" RawConditionalEliminationVisitor''enter-2 [#_"RawConditionalEliminationVisitor" this, #_"Block" b]
        (let [
            #_"int" mark (:tos (:undoOperations this))
        ]
            (BlockMap''put-3 (:blockActionStart this), b, mark)
            (doseq [#_"Node" n (BlockMap''get-2 (:blockToNodesMap (:schedule this)), b)]
                (when (Node''isAlive-1 n)
                    (RawConditionalEliminationVisitor''processNode-2 this, n)
                )
            )
            mark
        )
    )

    #_unused
    (§ override! #_"void" RawConditionalEliminationVisitor''exit-3 [#_"RawConditionalEliminationVisitor" this, #_"Block" b, #_"Integer" state]
        (let [
            #_"int" mark state
        ]
            (while (< mark (:tos (:undoOperations this)))
                (let [
                    #_"Node" node (NodeStack''pop-1 (:undoOperations this))
                ]
                    (when (Node''isAlive-1 node)
                        (NodeMap''set-3 (:stampMap this), node, (:parent (NodeMap''get-2 (:stampMap this), node)))
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; @anno FixReadsPhase.RawCEPhase
 ;;
(final-ns RawCEPhase (§ extends BasePhase #_"<LowTierContext>")
    #_unused
    (§ defn #_"RawCEPhase" RawCEPhase'new-0 []
        (BasePhase'new-0)
    )

    #_unused
    (§ override! #_"void" RawCEPhase''run-3 [#_"RawCEPhase" this, #_"Graph" graph, #_"LowTierContext" context]
        (when GraalOptions'rawConditionalElimination
            (Phase''apply-2 (SchedulePhase'new-2 SchedulingStrategy'LATEST, true), graph)
            (ControlFlowGraph''visitDominatorTree-3 (:cfg (:lastSchedule graph)), (RawConditionalEliminationVisitor'new-2 graph, (:lastSchedule graph)), false)
        )
        nil
    )
)

;;;
 ; @anno FixReadsPhase.StampElement
 ;;
(final-ns StampElement
    (§ final #_"Stamp" :stamp nil)
    (§ final #_"StampElement" :parent nil)

    (§ defn #_"StampElement" StampElement'new-2 [#_"Stamp" stamp, #_"StampElement" parent]
        (let [
            #_"StampElement" this (Object.)
            this (assoc this :stamp stamp)
            this (assoc this :parent parent)
        ]
            this
        )
    )
)

(final-ns FloatingReadPhase (§ extends Phase)
    (§ mutable #_"boolean" :createFloatingReads false)
    (§ mutable #_"boolean" :createMemoryMapNodes false)

    (§ defn #_"FloatingReadPhase" FloatingReadPhase'new-0 []
        (FloatingReadPhase'new-2 true, false)
    )

    ;;;
     ; @param createFloatingReads specifies whether FloatableAccessNodes like ReadNode
     ;            should be converted into floating nodes (e.g. FloatingReadNodes) where possible
     ; @param createMemoryMapNodes a MemoryMapNode will be created for each return if this is true
     ;;
    (§ defn #_"FloatingReadPhase" FloatingReadPhase'new-2 [#_"boolean" createFloatingReads, #_"boolean" createMemoryMapNodes]
        (let [
            #_"FloatingReadPhase" this (Phase'new-0)
            this (assoc this :createFloatingReads createFloatingReads)
            this (assoc this :createMemoryMapNodes createMemoryMapNodes)
        ]
            this
        )
    )

    ;;;
     ; Removes nodes from a given set that (transitively) have a usage outside the set.
     ;;
    (§ defn- #_"EconomicSet<Node>" FloatingReadPhase'removeExternallyUsedNodes-1 [#_"EconomicSet<Node>" set]
        (loop []
            (let [
                #_"boolean" changed?
                    (loop-when [changed? false #_"Iterator<Node>" it (#_"EconomicSet" .iterator set)] (#_"Iterator" .hasNext it) => changed?
                        (let [
                            changed?
                                (loop-when [changed? changed? #_"ISeq" s (seq (Node''usages-1 (#_"Iterator" .next it)))] (some? s) => changed?
                                    (when-not (contains? set (first s)) => (recur changed? (next s))
                                        (#_"Iterator" .remove it)
                                        true
                                    )
                                )
                        ]
                            (recur changed? it)
                        )
                    )
            ]
                (recur-if changed? [])
            )
        )
        set
    )

    (§ method! #_"void" FloatingReadPhase''processNode-3 [#_"FloatingReadPhase" this, #_"FixedNode" node, #_"EconomicSet<LocationIdentity>" currentState]
        (condp instance? node
            Single
                (FloatingReadPhase'processIdentity-2 currentState, (Single''getLocationIdentity-1 node))
            Multi
                (doseq [#_"LocationIdentity" identity (Multi''getLocationIdentities-1 node)]
                    (FloatingReadPhase'processIdentity-2 currentState, identity)
                )
            nil
        )
        nil
    )

    (§ defn- #_"void" FloatingReadPhase'processIdentity-2 [#_"EconomicSet<LocationIdentity>" currentState, #_"LocationIdentity" identity]
        (when (#_"LocationIdentity" .isMutable identity)
            (#_"EconomicSet" .add currentState, identity)
        )
        nil
    )

    (§ method! #_"void" FloatingReadPhase''processBlock-3 [#_"FloatingReadPhase" this, #_"Block" block, #_"EconomicSet<LocationIdentity>" currentState]
        (doseq [#_"FixedNode" node (Block''getNodes-1 block)]
            (FloatingReadPhase''processNode-3 this, node, currentState)
        )
        nil
    )

    (§ method- #_"EconomicSet<LocationIdentity>" FloatingReadPhase''processLoop-3 [#_"FloatingReadPhase" this, #_"Loop" loop, #_"EconomicMap<LoopBeginNode, EconomicSet<LocationIdentity>>" modifiedInLoops]
        (let [
            #_"LoopBeginNode" loopBegin (:beginNode (:header loop))
        ]
            (or (get modifiedInLoops loopBegin)
                (let [
                    #_"EconomicSet<LocationIdentity>" result (EconomicSet/create Equivalence/DEFAULT)
                ]
                    (doseq [#_"Loop" inner (:children loop)]
                        (#_"EconomicSet" .addAll result, (FloatingReadPhase''processLoop-3 this, inner, modifiedInLoops))
                    )
                    (doseq [#_"Block" b (:blocks loop)]
                        (when (= (:loop b) loop)
                            (FloatingReadPhase''processBlock-3 this, b, result)
                        )
                    )
                    (#_"EconomicMap" .put modifiedInLoops, loopBegin, result)
                    result
                )
            )
        )
    )

    ; @SuppressWarnings("try")
    #_unused
    (§ override! #_"void" FloatingReadPhase''run-2 [#_"FloatingReadPhase" this, #_"Graph" graph]
        (let [
            #_"EconomicMap<LoopBeginNode, EconomicSet<LocationIdentity>>" modifiedInLoops nil
        ]
            (when (Graph''hasLoops-1 graph)
                (§ ass modifiedInLoops (EconomicMap/create Equivalence/IDENTITY))
                (doseq [#_"Loop" l (:loops (ControlFlowGraph'compute-5 graph, true, true, false, false))]
                    (FloatingReadPhase''processLoop-3 this, l, modifiedInLoops)
                )
            )

            (let [
                #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-1 (EnumSet/of NodeEvent'NODE_ADDED, NodeEvent'ZERO_USAGES))
            ]
                (try (§ with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                    (ReentrantNodeIterator'apply-3 (FloatingReadClosure'new-3 modifiedInLoops, (:createFloatingReads this), (:createMemoryMapNodes this)), (:start graph), (MemoryMapImpl'new-1 (:start graph)))
                )

                (doseq [#_"Node" n (FloatingReadPhase'removeExternallyUsedNodes-1 (:nodes listener))]
                    (when (and (Node''isAlive-1 n) (instance? FloatingNode n))
                        (§ ass! n (Node''replaceAtUsages-2 n, nil))
                        (GraphUtil'killWithUnusedFloatingInputs-1 n)
                    )
                )
                (when (:createFloatingReads this)
                    (§ ass! graph (Graph''setAfterFloatingReadPhase-2 graph, true))
                )
            )
        )
        nil
    )

    (§ defn #_"MemoryMapImpl" FloatingReadPhase'mergeMemoryMaps-2 [#_"AbstractMergeNode" merge, #_"List<? extends MemoryMap>" states]
        (let [
            #_"MemoryMapImpl" newState (MemoryMapImpl'new-0)
            #_"EconomicSet<LocationIdentity>" keys (EconomicSet/create Equivalence/DEFAULT)
        ]
            (doseq [#_"MemoryMap" other states]
                (#_"EconomicSet" .addAll keys, (MemoryMap''getLocations-1 other))
            )

            (doseq [#_"LocationIdentity" key keys]
                (let [
                    #_"MemoryNode" merged
                        (loop-when [merged nil #_"boolean" isPhi false #_"int" n 0 #_"ISeq" s (seq states)] (some? s) => merged
                            (let [
                                #_"MemoryMap" state (first s)
                                #_"MemoryNode" last (MemoryMap''getLastLocationAccess-2 state, key)
                                [merged isPhi]
                                    (cond
                                        isPhi
                                            (do
                                                (PhiNode''addInput-2 merged, last)
                                                [merged isPhi]
                                            )
                                        (or (nil? merged) (= merged last))
                                            [last isPhi] ;; nothing to do
                                        :else
                                            (let [
                                                #_"MemoryPhiNode" phi (Graph''add-2 (:graph merge), (MemoryPhiNode'new-2 merge, key))
                                            ]
                                                (dotimes [_ n]
                                                    (PhiNode''addInput-2 phi, merged)
                                                )
                                                (PhiNode''addInput-2 phi, last)
                                                [phi true]
                                            )
                                    )
                            ]
                                (recur merged isPhi (inc n) (next s))
                            )
                        )
                ]
                    (#_"EconomicMap" .put (:lastMemorySnapshot newState), key, merged)
                )
            )
            newState
        )
    )
)

;;;
 ; @anno FloatingReadPhase.MemoryMapImpl
 ;;
(final-ns MemoryMapImpl (§ implements MemoryMap)
    (§ final #_"EconomicMap<LocationIdentity, MemoryNode>" :lastMemorySnapshot nil)

    (§ defn #_"MemoryMapImpl" MemoryMapImpl'new-1 [#_"MemoryMapImpl" memoryMap]
        (let [
            #_"MemoryMapImpl" this (Object.)
            this (assoc this :lastMemorySnapshot (EconomicMap/create Equivalence/DEFAULT, (:lastMemorySnapshot memoryMap)))
        ]
            this
        )
    )

    (§ defn #_"MemoryMapImpl" MemoryMapImpl'new-1 [#_"StartNode" start]
        (let [
            #_"MemoryMapImpl" this (MemoryMapImpl'new-0)
        ]
            (#_"EconomicMap" .put (:lastMemorySnapshot this), (LocationIdentity/any), start)
            this
        )
    )

    (§ defn #_"MemoryMapImpl" MemoryMapImpl'new-0 []
        (let [
            #_"MemoryMapImpl" this (Object.)
            this (assoc this :lastMemorySnapshot (EconomicMap/create Equivalence/DEFAULT))
        ]
            this
        )
    )

    (§ override! #_"MemoryNode" MemoryMapImpl''getLastLocationAccess-2 [#_"MemoryMapImpl" this, #_"LocationIdentity" locationIdentity]
        (when-not (#_"LocationIdentity" .isImmutable locationIdentity)
            (or (get (:lastMemorySnapshot this) locationIdentity)
                (get (:lastMemorySnapshot this) (LocationIdentity/any))
            )
        )
    )

    #_unused
    (§ override! #_"Iterable<LocationIdentity>" MemoryMapImpl''getLocations-1 [#_"MemoryMapImpl" this]
        (keys (:lastMemorySnapshot this))
    )
)

;;;
 ; @anno FloatingReadPhase.FloatingReadClosure
 ;;
(final-ns FloatingReadClosure (§ extends NodeIteratorClosure #_"<MemoryMapImpl>")
    (§ final #_"EconomicMap<LoopBeginNode, EconomicSet<LocationIdentity>>" :modifiedInLoops nil)
    (§ mutable #_"boolean" :createFloatingReads false)
    (§ mutable #_"boolean" :createMemoryMapNodes false)

    (§ defn #_"FloatingReadClosure" FloatingReadClosure'new-3 [#_"EconomicMap<LoopBeginNode, EconomicSet<LocationIdentity>>" modifiedInLoops, #_"boolean" createFloatingReads, #_"boolean" createMemoryMapNodes]
        (let [
            #_"FloatingReadClosure" this (NodeIteratorClosure'new-0)
            this (assoc this :modifiedInLoops modifiedInLoops)
            this (assoc this :createFloatingReads createFloatingReads)
            this (assoc this :createMemoryMapNodes createMemoryMapNodes)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"MemoryMapImpl" FloatingReadClosure''processNode-3 [#_"FloatingReadClosure" this, #_"FixedNode" node, #_"MemoryMapImpl" state]
        (if (instance? MemoryAnchorNode node)
            (do
                (FloatingReadClosure'processAnchor-2 node, state)
                state
            )
            (do
                (when (instance? MemoryAccess node)
                    (FloatingReadClosure'processAccess-2 node, state)
                )
                (cond
                    (and (:createFloatingReads this) (instance? FloatableAccessNode node))
                        (FloatingReadClosure'processFloatable-2 node, state)
                    (instance? Single node)
                        (FloatingReadClosure'processCheckpoint-2 node, state)
                    (instance? Multi node)
                        (FloatingReadClosure'processCheckpoint-2 node, state)
                )
                (when (and (:createMemoryMapNodes this) (instance? ReturnNode node))
                    (§ ass! node (ReturnNode''setMemoryMap-2 node, (Graph''add-2 (:graph node), (MemoryMapNode'new-1 (:lastMemorySnapshot state)))))
                )
                state
            )
        )
    )

    ;;;
     ; Improve the memory graph by re-wiring all usages of a MemoryAnchorNode to the real last access location.
     ;;
    (§ defn- #_"void" FloatingReadClosure'processAnchor-2 [#_"MemoryAnchorNode" anchor, #_"MemoryMapImpl" state]
        (doseq [#_"Node" node (NodeIterable''snapshot-1 (Node''usages-1 anchor))]
            (when (and (instance? MemoryAccess node) (= (:lastLocationAccess node) anchor))
                (MemoryAccess''setLastLocationAccess-2 node, (MemoryMapImpl''getLastLocationAccess-2 state, (MemoryAccess''getLocationIdentity-1 node)))
            )
        )

        (when (Node''hasNoUsages-1 anchor)
            (Graph''removeFixed-2 (:graph anchor), anchor)
        )
        nil
    )

    (§ defn- #_"void" FloatingReadClosure'processAccess-2 [#_"MemoryAccess" access, #_"MemoryMapImpl" state]
        (let [
            #_"LocationIdentity" locationIdentity (MemoryAccess''getLocationIdentity-1 access)
        ]
            (when-not (= locationIdentity (LocationIdentity/any))
                (MemoryAccess''setLastLocationAccess-2 access, (MemoryMapImpl''getLastLocationAccess-2 state, locationIdentity))
            )
        )
        nil
    )

    (§ defn- #_"void" FloatingReadClosure'processCheckpoint-2 [#_"Single" checkpoint, #_"MemoryMapImpl" state]
        (FloatingReadClosure'processIdentity-3 (Single''getLocationIdentity-1 checkpoint), checkpoint, state)
        nil
    )

    (§ defn- #_"void" FloatingReadClosure'processCheckpoint-2 [#_"Multi" checkpoint, #_"MemoryMapImpl" state]
        (doseq [#_"LocationIdentity" identity (Multi''getLocationIdentities-1 checkpoint)]
            (FloatingReadClosure'processIdentity-3 identity, checkpoint, state)
        )
        nil
    )

    (§ defn- #_"void" FloatingReadClosure'processIdentity-3 [#_"LocationIdentity" identity, #_"MemoryCheckpoint" checkpoint, #_"MemoryMapImpl" state]
        (when (#_"LocationIdentity" .isAny identity)
            (#_"EconomicMap" .clear (:lastMemorySnapshot state))
        )
        (when (#_"LocationIdentity" .isMutable identity)
            (#_"EconomicMap" .put (:lastMemorySnapshot state), identity, checkpoint)
        )
        nil
    )

    (§ defn- #_"void" FloatingReadClosure'processFloatable-2 [#_"FloatableAccessNode" accessNode, #_"MemoryMapImpl" state]
        (let [
            #_"LocationIdentity" locationIdentity (FixedAccessNode''getLocationIdentity-1 accessNode)
        ]
            (when (FloatableAccessNode''canFloat-1 accessNode)
                (let [
                    #_"FloatingAccessNode" floatingNode (FloatableAccessNode''asFloatingNode-2 accessNode, (MemoryMapImpl''getLastLocationAccess-2 state, locationIdentity))
                ]
                    (§ ass! (:graph accessNode) (Graph''replaceFixedWithFloating-3 (:graph accessNode), accessNode, floatingNode))
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"MemoryMapImpl" FloatingReadClosure''merge-3 [#_"FloatingReadClosure" this, #_"AbstractMergeNode" merge, #_"List<MemoryMapImpl>" states]
        (FloatingReadPhase'mergeMemoryMaps-2 merge, states)
    )

    #_unused
    (§ override! #_"MemoryMapImpl" FloatingReadClosure''afterSplit-3 [#_"FloatingReadClosure" this, #_"AbstractBeginNode" node, #_"MemoryMapImpl" oldState]
        (MemoryMapImpl'new-1 oldState)
    )

    #_unused
    (§ override! #_"EconomicMap<LoopExitNode, MemoryMapImpl>" FloatingReadClosure''processLoop-3 [#_"FloatingReadClosure" this, #_"LoopBeginNode" loop, #_"MemoryMapImpl" initialState]
        (let [
            #_"EconomicSet<LocationIdentity>" modifiedLocations (get (:modifiedInLoops this) loop)
            #_"EconomicMap<LocationIdentity, MemoryPhiNode>" phis (EconomicMap/create Equivalence/DEFAULT)
        ]
            (when (contains? modifiedLocations (LocationIdentity/any))
                ;; create phis for all locations if ANY is modified in the loop
                (§ ass modifiedLocations (EconomicSet/create Equivalence/DEFAULT, modifiedLocations))
                (#_"EconomicSet" .addAll modifiedLocations, (keys (:lastMemorySnapshot initialState)))
            )

            (doseq [#_"LocationIdentity" location modifiedLocations]
                (FloatingReadClosure'createMemoryPhi-4 loop, initialState, phis, location)
            )
            (#_"EconomicMap" .putAll (:lastMemorySnapshot initialState), phis)

            (let [
                #_"NodeLoopInfo<MemoryMapImpl>" loopInfo (ReentrantNodeIterator'processLoop-3 this, loop, initialState)
                #_"UnmodifiableMapCursor<LoopEndNode, MemoryMapImpl>" endStateCursor (#_"EconomicMap" .getEntries (:endStates loopInfo))
            ]
                (while (#_"UnmodifiableMapCursor" .advance endStateCursor)
                    (let [
                        #_"int" endIndex (LoopBeginNode''phiPredecessorIndex-2 loop, (#_"UnmodifiableMapCursor" .getKey endStateCursor))
                        #_"UnmodifiableMapCursor<LocationIdentity, MemoryPhiNode>" phiCursor (#_"EconomicMap" .getEntries phis)
                    ]
                        (while (#_"UnmodifiableMapCursor" .advance phiCursor)
                            (let [
                                #_"LocationIdentity" key (#_"UnmodifiableMapCursor" .getKey phiCursor)
                                #_"PhiNode" phi (#_"UnmodifiableMapCursor" .getValue phiCursor)
                            ]
                                (PhiNode''initializeValueAt-3 phi, endIndex, (MemoryMapImpl''getLastLocationAccess-2 (#_"UnmodifiableMapCursor" .getValue endStateCursor), key))
                            )
                        )
                    )
                )
                (:exitStates loopInfo)
            )
        )
    )

    (§ defn- #_"void" FloatingReadClosure'createMemoryPhi-4 [#_"LoopBeginNode" loop, #_"MemoryMapImpl" initialState, #_"EconomicMap<LocationIdentity, MemoryPhiNode>" phis, #_"LocationIdentity" location]
        (let [
            #_"MemoryPhiNode" phi (Graph''add-2 (:graph loop), (MemoryPhiNode'new-2 loop, location))
        ]
            (PhiNode''addInput-2 phi, (MemoryMapImpl''getLastLocationAccess-2 initialState, location))
            (#_"EconomicMap" .put phis, location, phi)
        )
        nil
    )
)

;;;
 ; This phase transfers FrameState nodes from StateSplit nodes to DeoptimizingNodes.
 ;
 ; This allow to enter the {@link GuardsStage#AFTER_FSA AFTER_FSA} stage of the graph where
 ; no new node that may cause deoptimization can be introduced anymore.
 ;
 ; This Phase processes the graph in post order, assigning the FrameState from the last
 ; StateSplit node to DeoptimizingNodes.
 ;;
(final-ns FrameStateAssignmentPhase (§ extends Phase)
    (§ defn #_"FrameStateAssignmentPhase" FrameStateAssignmentPhase'new-0 []
        (Phase'new-0)
    )

    #_unused
    (§ override! #_"void" FrameStateAssignmentPhase''run-2 [#_"FrameStateAssignmentPhase" this, #_"Graph" graph]
        (when (GuardsStage'areFrameStatesAtSideEffects-1 (:guardsStage graph))
            (ReentrantNodeIterator'apply-3 (FrameStateAssignmentClosure'new-0), (:start graph), nil)
            (§ ass! graph (Graph''setGuardsStage-2 graph, GuardsStage'AFTER_FSA))
            (#_"Iterable" .forEach (NodeIterable''filter-2 (Graph''getNodes-2 graph, FrameState'TYPE), (ß state -> (§ fun (Node''hasNoUsages-1 state)))), GraphUtil'killWithUnusedFloatingInputs)
        )
        nil
    )

    #_unused
    (§ defn- #_"boolean" FrameStateAssignmentPhase'hasFloatingDeopts-1 [#_"Graph" graph]
        (loop-when [#_"ISeq" s (seq (Graph''getNodes-1 graph))] (some? s) => false
            (let [
                #_"Node" node (first s)
            ]
                (or (and (instance? DeoptimizingNode node) (GraphUtil'isFloatingNode-1 node) (DeoptimizingNode''canDeoptimize-1 node))
                    (recur (next s))
                )
            )
        )
    )

    (§ defn- #_"FrameState" FrameStateAssignmentPhase'singleFrameState-1 [#_"List<FrameState>" states]
        (let [
            #_"FrameState" singleState (nth states 0)
        ]
            (loop [#_"int" i 1]
                (if (< i (count states))
                    (when (= (nth states i) singleState)
                        (recur (inc i))
                    )
                    (when (and (some? singleState) (not= (:bci singleState) BytecodeFrame/INVALID_FRAMESTATE_BCI))
                        singleState
                    )
                )
            )
        )
    )
)

;;;
 ; @anno FrameStateAssignmentPhase.FrameStateAssignmentClosure
 ;;
(final-ns FrameStateAssignmentClosure (§ extends NodeIteratorClosure #_"<FrameState>")
    (§ defn #_"FrameStateAssignmentClosure" FrameStateAssignmentClosure'new-0 []
        (NodeIteratorClosure'new-0)
    )

    #_unused
    (§ override! #_"FrameState" FrameStateAssignmentClosure''processNode-3 [#_"FrameStateAssignmentClosure" this, #_"FixedNode" node, #_"FrameState" state]
        (when (and (instance? DeoptBefore node) (DeoptBefore''canDeoptimize-1 node) (nil? (DeoptBefore''stateBefore-1 node)))
            (when (some? state) => (throw! (str "no FrameState at DeoptimizingNode " node))
                (DeoptBefore''setStateBefore-2 node, state)
            )
        )
        (let [
            state
                (when (instance? StateSplit node) => state
                    (let [
                        #_"FrameState" stateAfter (StateSplit''stateAfter-1 node)
                    ]
                        (when (some? stateAfter) => state
                            (let [
                                state
                                    (when-not (= (:bci stateAfter) BytecodeFrame/INVALID_FRAMESTATE_BCI)
                                        stateAfter
                                    )
                            ]
                                (StateSplit''setStateAfter-2 node, nil)
                                state
                            )
                        )
                    )
                )
        ]
            (when (and (instance? DeoptDuring node) (DeoptDuring''canDeoptimize-1 node))
                (when (some? state) => (throw! (str "no FrameState at DeoptimizingNode " node))
                    (DeoptDuring''computeStateDuring-2 node, state)
                )
            )
            (when (and (instance? DeoptAfter node) (DeoptAfter''canDeoptimize-1 node) (nil? (DeoptAfter''stateAfter-1 node)))
                (when (some? state) => (throw! (str "no FrameState at DeoptimizingNode " node))
                    (DeoptAfter''setStateAfter-2 node, state)
                )
            )
            state
        )
    )

    #_unused
    (§ override! #_"FrameState" FrameStateAssignmentClosure''merge-3 [#_"FrameStateAssignmentClosure" this, #_"AbstractMergeNode" merge, #_"List<FrameState>" states]
        (or (FrameStateAssignmentPhase'singleFrameState-1 states) (BeginStateSplitNode''stateAfter-1 merge))
    )

    #_unused
    (§ override! #_"FrameState" FrameStateAssignmentClosure''afterSplit-3 [#_"FrameStateAssignmentClosure" this, #_"AbstractBeginNode" node, #_"FrameState" oldState]
        oldState
    )

    #_unused
    (§ override! #_"EconomicMap<LoopExitNode, FrameState>" FrameStateAssignmentClosure''processLoop-3 [#_"FrameStateAssignmentClosure" this, #_"LoopBeginNode" loop, #_"FrameState" initialState]
        (:exitStates (ReentrantNodeIterator'processLoop-3 this, loop, initialState))
    )
)

;;;
 ; This phase lowers GuardNodes into corresponding control-flow structure and DeoptimizeNodes.
 ;
 ; This allow to enter the {@link GuardsStage#FIXED_DEOPTS FIXED_DEOPTS} stage of the graph
 ; where all node that may cause deoptimization are fixed.
 ;
 ; It first makes a schedule in order to know where the control flow should be placed. Then,
 ; for each block, it applies two passes. The first one tries to replace nil-check guards with
 ; implicit nil-checks performed by access to the objects that need to be nil-checked.
 ; The second phase does the actual control-flow expansion of the remaining GuardNodes.
 ;;
(final-ns GuardLoweringPhase (§ extends BasePhase #_"<MidTierContext>")
    (§ defn #_"GuardLoweringPhase" GuardLoweringPhase'new-0 []
        (BasePhase'new-0)
    )

    #_unused
    (§ override! #_"void" GuardLoweringPhase''run-3 [#_"GuardLoweringPhase" this, #_"Graph" graph, #_"MidTierContext" context]
        (when (GuardsStage'allowsFloatingGuards-1 (:guardsStage graph))
            (Phase''apply-2 (SchedulePhase'new-1 SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER), graph)
            (doseq [#_"Block" block (:reversePostOrder (:cfg (:lastSchedule graph)))]
                (ScheduledNodeIterator''processNodes-3 (LowerGuards'new-1 block), block, (:lastSchedule graph))
            )
            (§ ass! graph (Graph''setGuardsStage-2 graph, GuardsStage'FIXED_DEOPTS))
        )
        nil
    )
)

;;;
 ; @anno GuardLoweringPhase.LowerGuards
 ;;
(final-ns LowerGuards (§ extends ScheduledNodeIterator)
    (§ final #_"Block" :block nil)

    (§ defn #_"LowerGuards" LowerGuards'new-1 [#_"Block" block]
        (let [
            #_"LowerGuards" this (ScheduledNodeIterator'new-0)
            this (assoc this :block block)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" LowerGuards''processNode-2 [#_"LowerGuards" this, #_"Node" node]
        (when (instance? GuardNode node)
            (let [
                #_"FixedWithNextNode" lowered (GuardNode''lowerGuard-1 node)
            ]
                (if (some? lowered)
                    (§ ass! this (ScheduledNodeIterator''replaceCurrent-2 this, lowered))
                    (LowerGuards''lowerToIf-2 this, node)
                )
            )
        )
        nil
    )

    (§ method- #_"void" LowerGuards''lowerToIf-2 [#_"LowerGuards" this, #_"GuardNode" guard]
        (let [
            #_"Graph" graph (:graph guard)
            #_"AbstractBeginNode" fastPath (Graph''add-2 graph, (BeginNode'new-0))
            #_"DeoptimizeNode" deopt (Graph''add-2 graph, (DeoptimizeNode'new-5 (:action guard), (:reason guard), DeoptimizeNode'DEFAULT_DEBUG_ID, (:speculation guard), nil))
            #_"AbstractBeginNode" deoptBranch (BeginNode'begin-1 deopt)
        ]
            (LowerGuards''insertLoopExits-2 this, deopt)
            (let [
                [#_"AbstractBeginNode" trueSuccessor #_"AbstractBeginNode" falseSuccessor] (if (:negated? guard) [deoptBranch fastPath] [fastPath deoptBranch])
                #_"IfNode" ifNode (Graph''add-2 graph, (IfNode'new-4 (GuardNode''getCondition-1 guard), trueSuccessor, falseSuccessor, (if (= trueSuccessor fastPath) 1 0)))
            ]
                (§ ass! guard (Node''replaceAndDelete-2 guard, fastPath))
                (§ ass! this (ScheduledNodeIterator''insert-3 this, ifNode, fastPath))
            )
        )
        nil
    )

    (§ method- #_"void" LowerGuards''insertLoopExits-2 [#_"LowerGuards" this, #_"DeoptimizeNode" deopt]
        (let [
            #_"Graph" graph (:graph deopt)
        ]
            (loop-when-recur [#_"Loop" loop (:loop (:block this))] (some? loop) [(:parent loop)]
                (Graph''addBeforeFixed-3 graph, deopt, (Graph''add-2 graph, (LoopExitNode'new-1 (:beginNode (:header loop)))))
            )
        )
        nil
    )
)

;;;
 ; A phase suite that applies canonicalization to a graph after all
 ; phases in the suite have been applied if any of the phases changed the graph.
 ;;
(final-ns IncrementalCanonicalizerPhase #_"<C extends PhaseContext>" (§ extends PhaseSuite #_"<C>")
    (§ final #_"CanonicalizerPhase" :canonicalizer nil)

    (§ defn #_"IncrementalCanonicalizerPhase" IncrementalCanonicalizerPhase'new-1 [#_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"IncrementalCanonicalizerPhase" this (PhaseSuite'new-0)
            this (assoc this :canonicalizer canonicalizer)
        ]
            this
        )
    )

    (§ defn #_"IncrementalCanonicalizerPhase" IncrementalCanonicalizerPhase'new-2 [#_"CanonicalizerPhase" canonicalizer, #_"BasePhase<? super C>" phase]
        (let [
            #_"IncrementalCanonicalizerPhase" this (PhaseSuite'new-0)
            this (assoc this :canonicalizer canonicalizer)
        ]
            (PhaseSuite''appendPhase-2 this, phase)
            this
        )
    )

    ; @SuppressWarnings("try")
    #_unused
    (§ override! #_"void" IncrementalCanonicalizerPhase''run-3 [#_"IncrementalCanonicalizerPhase<C extends PhaseContext>" this, #_"Graph" graph, #_"C" context]
        (let [
            #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-0)
        ]
            (try (§ with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                (PhaseSuite''run-3 (§ super ), graph, context)
            )

            (when (seq (:nodes listener))
                (CanonicalizerPhase''applyIncremental-5 (:canonicalizer this), graph, context, (:nodes listener), nil)
            )
        )
        nil
    )
)

(class-ns AbstractInlineInfo (§ implements InlineInfo)
    (§ final #_"InvokeNode" :invoke nil)

    (§ defn #_"AbstractInlineInfo" AbstractInlineInfo'new-1 [#_"InvokeNode" invoke]
        (let [
            #_"AbstractInlineInfo" this (Object.)
            this (assoc this :invoke invoke)
        ]
            this
        )
    )

    #_unused
    (§ override #_"Graph" AbstractInlineInfo''graph-1 [#_"AbstractInlineInfo" this]
        (:graph (:invoke this))
    )

    #_unused
    (§ override #_"InvokeNode" AbstractInlineInfo''invoke-1 [#_"AbstractInlineInfo" this]
        (:invoke this)
    )

    (§ defn #_"EconomicSet<Node>" AbstractInlineInfo'inline-4 [#_"InvokeNode" invoke, #_"ResolvedJavaMethod" concrete, #_"Inlineable" inlineable, #_"boolean" receiverNullCheck]
        (InliningUtil'inlineForCanonicalization-4 invoke, (:graph inlineable), receiverNullCheck, concrete)
    )

    #_unused
    (§ override! #_"void" AbstractInlineInfo''populateInlinableElements-4 [#_"AbstractInlineInfo" this, #_"HighTierContext" context, #_"Graph" caller, #_"CanonicalizerPhase" canonicalizer]
        (dotimes [#_"int" i (InlineInfo''numberOfMethods-1 this)]
            (InlineInfo''setInlinableElement-3 this, i, (Inlineable'getInlineableElement-4 (InlineInfo''methodAt-2 this, i), (:invoke this), context, canonicalizer))
        )
        nil
    )

    #_unused
    (§ override! #_"int" AbstractInlineInfo''determineNodeCount-1 [#_"AbstractInlineInfo" this]
        (loop-when [#_"int" n 0 #_"int" i 0] (< i (InlineInfo''numberOfMethods-1 this)) => n
            (let [
                #_"Inlineable" elem (InlineInfo''inlineableElementAt-2 this, i)
            ]
                (recur (if (some? elem) (+ n (Inlineable''getNodeCount-1 elem)) n) (inc i))
            )
        )
    )
)

(§ interface Inlineable
    (§ defn #_"Inlineable" Inlineable'getInlineableElement-4 [#_"ResolvedJavaMethod" method, #_"InvokeNode" invoke, #_"HighTierContext" context, #_"CanonicalizerPhase" canonicalizer]
        (InlineableGraph'new-4 method, invoke, context, canonicalizer)
    )

    (§ abstract #_"int" Inlineable''getNodeCount-1 [#_"Inlineable" this])

    (§ abstract #_"Iterable<InvokeNode>" Inlineable''getInvokes-1 [#_"Inlineable" this])

    (§ abstract #_"double" Inlineable''getProbability-2 [#_"Inlineable" this, #_"InvokeNode" invoke])
)

;;;
 ; Represents a feasible concrete target for inlining, whose graph has been copied already and thus
 ; can be modified without affecting the original (usually cached) version.
 ;
 ; Instances of this class don't make sense in isolation but as part of an InlineInfo.
 ;;
(final-ns InlineableGraph (§ implements Inlineable)
    (§ final #_"Graph" :graph nil)

    (§ mutable #_"FixedNodeProbabilityCache" :probabilites (FixedNodeProbabilityCache'new-0))

    ;;;
     ; This method builds the IR nodes for the given {@code method} and canonicalizes them.
     ; Provided profiling info is mature, the resulting graph is cached. The caller is responsible
     ; for cloning before modification.
     ;;
    (§ defn- #_"Graph" InlineableGraph'parseBytecodes-3 [#_"ResolvedJavaMethod" method, #_"HighTierContext" context, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"Graph" graph (Graph'new-1 method)
        ]
            (BasePhase''apply-3 HotSpot'graphBuilderSuite, graph, context)
            (Phase''apply-2 (DeadCodeEliminationPhase'new-1 Optionality'Optional), graph)
            (BasePhase''apply-3 canonicalizer, graph, context)

            graph
        )
    )

    (§ defn #_"InlineableGraph" InlineableGraph'new-4 [#_"ResolvedJavaMethod" method, #_"InvokeNode" invoke, #_"HighTierContext" context, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"InlineableGraph" this (Object.)
            ;; TODO copying the graph is only necessary if it is modified or if it contains any invokes
            this (assoc this :graph (Graph''copy-1 (InlineableGraph'parseBytecodes-3 method, context, canonicalizer)))
        ]
            (InlineableGraph''specializeGraphToArguments-4 this, invoke, context, canonicalizer)
            this
        )
    )

    ;;;
     ; @return true iff one or more parameters {@code newGraph} were specialized to account for
     ;         a constant argument, or an argument with a more specific stamp.
     ;;
    (§ method- #_"boolean" InlineableGraph''specializeGraphToArguments-4 [#_"InlineableGraph" this, #_"InvokeNode" invoke, #_"HighTierContext" context, #_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"ArrayList<Node>" parameterUsages (InlineableGraph''replaceParamsWithMoreInformativeArguments-3 this, invoke, context)
        ]
            (if (some? parameterUsages)
                (do
                    (CanonicalizerPhase''applyIncremental-4 canonicalizer, (:graph this), context, parameterUsages)
                    true
                )
                (do
                    ;; TODO if args are not more concrete, inlining should be avoided in most cases or we
                    ;; could at least use the previous graph size + invoke probability to check the inlining
                    false
                )
            )
        )
    )

    #_unused
    (§ defn- #_"boolean" InlineableGraph'isArgMoreInformativeThanParam-2 [#_"ValueNode" arg, #_"ParameterNode" param]
        (or (instance? ConstantNode arg) (InlineableGraph'canStampBeImproved-2 arg, param))
    )

    (§ defn- #_"boolean" InlineableGraph'canStampBeImproved-2 [#_"ValueNode" arg, #_"ParameterNode" param]
        (some? (InlineableGraph'improvedStamp-2 arg, param))
    )

    (§ defn- #_"Stamp" InlineableGraph'improvedStamp-2 [#_"ValueNode" arg, #_"ParameterNode" param]
        (let [
            #_"Stamp" joinedStamp (Stamp''join-2 (:stamp param), (:stamp arg))
        ]
            (when (and (some? joinedStamp) (not= joinedStamp (:stamp param)))
                joinedStamp
            )
        )
    )

    ;;;
     ; This method detects:
     ;
     ; (1) constants among the arguments to the {@code invoke}
     ; (2) arguments with more precise type than that declared by the corresponding parameter
     ;
     ; The corresponding parameters are updated to reflect the above information. Before doing so,
     ; their usages are added to {@code parameterUsages} for later incremental canonicalization.
     ;
     ; @return nil if no incremental canonicalization is need, otherwise a list of nodes for such canonicalization
     ;;
    (§ method- #_"ArrayList<Node>" InlineableGraph''replaceParamsWithMoreInformativeArguments-3 [#_"InlineableGraph" this, #_"InvokeNode" invoke, #_"HighTierContext" context]
        (let [
            #_"NodeInputList<ValueNode>" args (CallTargetNode''arguments-1 (:callTarget invoke))
        ]
            ;; param-nodes that aren't used (e.g. as a result of canonicalization) don't occur in 'params'.
            ;; Thus, in general, the sizes of 'params' and 'args' don't always match. Still, it's always possible
            ;; to pair a param-node with its corresponding arg-node using param.index() as index into 'args'.
            (loop-when [#_"ArrayList<Node>" usages nil #_"ISeq" s (seq (NodeIterable''snapshot-1 (Graph''getNodes-2 (:graph this), ParameterNode'TYPE)))] (some? s) => usages
                (let [
                    #_"ParameterNode" param (first s)
                    usages
                        (when (NodeIterable''isNotEmpty-1 (Node''usages-1 param)) => usages
                            (let [
                                #_"ValueNode" arg (nth args (AbstractLocalNode''index-1 param))
                            ]
                                (if (instance? ConstantNode arg)
                                    (let [
                                        usages (InlineableGraph'trackParameterUsages-2 param, usages)
                                    ]
                                        ;; collect param usages before replacing the param
                                        (Node''replaceAtUsagesAndDelete-2 param, (Graph''add-2 (:graph this), (ConstantNode'forConstant-4 (:stamp arg), (:value arg), (:stableDimension arg), (:isDefaultStable arg))))
                                        ;; param-node gone, leaving a gap in the sequence given by param.index()
                                        usages
                                    )
                                    (let [
                                        #_"Stamp" improved (InlineableGraph'improvedStamp-2 arg, param)
                                    ]
                                        (when (some? improved) => usages
                                            (§ ass! param (ValueNode''setStamp-2 param, improved))
                                            (InlineableGraph'trackParameterUsages-2 param, usages)
                                        )
                                    )
                                )
                            )
                        )
                ]
                    (recur usages (next s))
                )
            )
        )
    )

    (§ defn- #_"ArrayList<Node>" InlineableGraph'trackParameterUsages-2 [#_"ParameterNode" param, #_"ArrayList<Node>" parameterUsages]
        (let [
            #_"ArrayList<Node>" result (or parameterUsages (ArrayList.))
        ]
            (NodeIterable''snapshotTo-2 (Node''usages-1 param), result)
            result
        )
    )

    #_unused
    (§ override! #_"int" InlineableGraph''getNodeCount-1 [#_"InlineableGraph" this]
        (Graph''getNodeCount-1 (:graph this))
    )

    #_unused
    (§ override! #_"Iterable<InvokeNode>" InlineableGraph''getInvokes-1 [#_"InlineableGraph" this]
        (Graph''getInvokes-1 (:graph this))
    )

    #_unused
    (§ override! #_"double" InlineableGraph''getProbability-2 [#_"InlineableGraph" this, #_"InvokeNode" invoke]
        (FixedNodeProbabilityCache''applyAsDouble-2 (:probabilites this), invoke)
    )
)

;;;
 ; Represents an inlining opportunity where the compiler can statically determine a monomorphic
 ; target method and therefore is able to determine the called method exactly.
 ;;
(final-ns ExactInlineInfo (§ extends AbstractInlineInfo)
    (§ final #_"ResolvedJavaMethod" :concrete nil)
    (§ mutable #_"Inlineable" :inlineableElement nil)
    (§ mutable #_"boolean" :suppressNullCheck false)

    (§ defn #_"ExactInlineInfo" ExactInlineInfo'new-2 [#_"InvokeNode" invoke, #_"ResolvedJavaMethod" concrete]
        (let [
            #_"ExactInlineInfo" this (AbstractInlineInfo'new-1 invoke)
            this (assoc this :concrete concrete)
        ]
            this
        )
    )

    #_unused
    (§ method! #_"ExactInlineInfo" ExactInlineInfo''suppressNullCheck-1 [#_"ExactInlineInfo" this]
        (assoc this :suppressNullCheck true)
    )

    #_unused
    (§ override! #_"EconomicSet<Node>" ExactInlineInfo''inline-1 [#_"ExactInlineInfo" this]
        (AbstractInlineInfo'inline-4 (:invoke this), (:concrete this), (:inlineableElement this), (not (:suppressNullCheck this)))
    )

    #_unused
    (§ override! #_"void" ExactInlineInfo''tryToDevirtualizeInvoke-1 [#_"ExactInlineInfo" this]
        ;; nothing todo, can already be bound statically
        nil
    )

    #_unused
    (§ override! #_"int" ExactInlineInfo''numberOfMethods-1 [#_"ExactInlineInfo" this]
        1
    )

    #_unused
    (§ override! #_"ResolvedJavaMethod" ExactInlineInfo''methodAt-2 [#_"ExactInlineInfo" this, #_"int" index]
        (:concrete this)
    )

    #_unused
    (§ override! #_"double" ExactInlineInfo''probabilityAt-2 [#_"ExactInlineInfo" this, #_"int" index]
        1.0
    )

    #_unused
    (§ override! #_"double" ExactInlineInfo''relevanceAt-2 [#_"ExactInlineInfo" this, #_"int" index]
        1.0
    )

    #_unused
    (§ override! #_"Inlineable" ExactInlineInfo''inlineableElementAt-2 [#_"ExactInlineInfo" this, #_"int" index]
        (:inlineableElement this)
    )

    #_unused
    (§ override! #_"void" ExactInlineInfo''setInlinableElement-3 [#_"ExactInlineInfo" this, #_"int" index, #_"Inlineable" inlineableElement]
        (§ ass! this (assoc this :inlineableElement inlineableElement))
        nil
    )

    #_unused
    (§ override! #_"boolean" ExactInlineInfo''shouldInline-1 [#_"ExactInlineInfo" this]
        (#_"ResolvedJavaMethod" .shouldBeInlined (:concrete this))
    )
)

;;;
 ; Represents an opportunity for inlining at a given invoke, with the given weight and level. The
 ; weight is the amortized weight of the additional code - so smaller is better. The level is the
 ; number of nested inlinings that lead to this invoke.
 ;;
(§ interface InlineInfo
    ;;;
     ; The graph containing the {@link #invoke() invocation} that may be inlined.
     ;;
    #_unused
    (§ abstract #_"Graph" InlineInfo''graph-1 [#_"InlineInfo" this])

    ;;;
     ; The invocation that may be inlined.
     ;;
    (§ abstract #_"InvokeNode" InlineInfo''invoke-1 [#_"InlineInfo" this])

    ;;;
     ; Returns the number of methods that may be inlined by the {@link #invoke() invocation}.
     ;;
    (§ abstract #_"int" InlineInfo''numberOfMethods-1 [#_"InlineInfo" this])

    (§ abstract #_"ResolvedJavaMethod" InlineInfo''methodAt-2 [#_"InlineInfo" this, #_"int" index])

    (§ abstract #_"Inlineable" InlineInfo''inlineableElementAt-2 [#_"InlineInfo" this, #_"int" index])

    (§ abstract #_"double" InlineInfo''probabilityAt-2 [#_"InlineInfo" this, #_"int" index])

    (§ abstract #_"double" InlineInfo''relevanceAt-2 [#_"InlineInfo" this, #_"int" index])

    (§ abstract #_"void" InlineInfo''setInlinableElement-3 [#_"InlineInfo" this, #_"int" index, #_"Inlineable" inlineableElement])

    ;;;
     ; Performs the inlining described by this object and returns the node that represents the return value
     ; of the inlined method (or nil for void methods and methods that have no non-exceptional exit).
     ;
     ; @return a collection of nodes that need to be canonicalized after the inlining
     ;;
    (§ abstract #_"EconomicSet<Node>" InlineInfo''inline-1 [#_"InlineInfo" this])

    ;;;
     ; Try to make the call static bindable to avoid interface and virtual method calls.
     ;;
    (§ abstract #_"void" InlineInfo''tryToDevirtualizeInvoke-1 [#_"InlineInfo" this])

    (§ abstract #_"boolean" InlineInfo''shouldInline-1 [#_"InlineInfo" this])

    (§ abstract #_"void" InlineInfo''populateInlinableElements-4 [#_"InlineInfo" this, #_"HighTierContext" context, #_"Graph" caller, #_"CanonicalizerPhase" canonicalizer])

    (§ abstract #_"int" InlineInfo''determineNodeCount-1 [#_"InlineInfo" this])
)

(final-ns InliningPhase (§ extends AbstractInliningPhase)
    (§ final #_"CanonicalizerPhase" :canonicalizer nil)

    (§ defn #_"InliningPhase" InliningPhase'new-1 [#_"CanonicalizerPhase" canonicalizer]
        (let [
            #_"InliningPhase" this (AbstractInliningPhase'new-0)
            this (assoc this :canonicalizer canonicalizer)
        ]
            this
        )
    )

    ;;;
     ; This method sets in motion the inlining machinery.
     ;;
    #_unused
    (§ override! #_"void" InliningPhase''run-3 [#_"InliningPhase" this, #_"Graph" graph, #_"HighTierContext" context]
        (let [
            #_"InliningData" data (InliningData'new-5 graph, context, (:canonicalizer this), (GreedyInliningPolicy'new-0), nil)
        ]
            (loop-when [#_"int" n 1] (InliningData''hasUnprocessedGraphs-1 data)
                (when (or (InliningData''moveForward-1 data) (< n GraalOptions'methodInlineBailoutLimit))
                    (recur (inc n))
                )
            )
        )
        nil
    )
)

(value-ns InliningUtil
    ;;;
     ; @return nil iff the check succeeds, otherwise a (non-nil) descriptive message
     ;;
    (§ defn #_"String" InliningUtil'checkInvokeConditions-1 [#_"InvokeNode" invoke]
        (cond
            (or (nil? (:predecessor invoke)) (not (Node''isAlive-1 invoke)))
                "the invoke is dead code"
            (not (instance? MethodCallTargetNode (:callTarget invoke)))
                "the invoke has already been lowered, or has been created as a low-level node"
            :else
                (let [
                    #_"MethodCallTargetNode" callTarget (:callTarget invoke)
                ]
                    (cond
                        (nil? (CallTargetNode''targetMethod-1 callTarget))
                            "target method is nil"
                        (not (:useForInlining invoke))
                            "the invoke is marked to be not used for inlining"
                        :else
                            (let [
                                #_"ValueNode" receiver (MethodCallTargetNode''receiver-1 callTarget)
                            ]
                                (when (and (some? receiver) (instance? ConstantNode receiver) (ValueNode''isNullConstant-1 receiver))
                                    "receiver is nil"
                                )
                            )
                    )
                )
        )
    )

    ;;;
     ; Performs an actual inlining, thereby replacing the given invoke with the given {@code inlineGraph}.
     ;
     ; @param invoke the invoke that will be replaced
     ; @param inlineGraph the graph that the invoke will be replaced with
     ; @param receiverNullCheck true if a nil-check needs to be generated for non-static inlinings,
     ;            false if no such check is required
     ; @param inlineeMethod the actual method being inlined. Maybe be nil for snippets.
     ;;
    (§ defn #_"UnmodifiableEconomicMap<Node, Node>" InliningUtil'inline-4 [#_"InvokeNode" invoke, #_"Graph" inlineGraph, #_"boolean" receiverNullCheck, #_"ResolvedJavaMethod" inlineeMethod]
        (let [
            #_"FixedNode" invokeNode invoke
            #_"Graph" graph (:graph invokeNode)
            #_"NodeInputList<ValueNode>" parameters (CallTargetNode''arguments-1 (:callTarget invoke))
        ]
            (when (and receiverNullCheck (not (MethodCallTargetNode''isStatic-1 (:callTarget invoke))))
                (InliningUtil'nonNullReceiver-1 invoke)
            )

            (let [
                #_"ArrayList<Node>" nodes (ArrayList.)
                #_"ArrayList<ReturnNode>" returnNodes (ArrayList.)
                #_"ArrayList<InvokeNode>" partialIntrinsicExits (ArrayList.)
                #_"StartNode" entryPointNode (:start inlineGraph)
                #_"FixedNode" firstCFGNode (:next entryPointNode)
            ]
                (when (some? firstCFGNode) => (throw (IllegalStateException. (str "Inlined graph is in invalid state: " inlineGraph)))
                    (doseq [#_"Node" node (Graph''getNodes-1 inlineGraph)]
                        (when-not (or (= node entryPointNode) (and (= node (BeginStateSplitNode''stateAfter-1 entryPointNode)) (= (NodeIterable''count-1 (Node''usages-1 node)) 1)) (instance? ParameterNode node))
                            (#_"ArrayList" .add nodes, node)
                            (condp instance? node
                                ReturnNode
                                    (#_"ArrayList" .add returnNodes, node)
                                InvokeNode
                                    (when (= (:bci node) BytecodeFrame/UNKNOWN_BCI)
                                        (#_"ArrayList" .add partialIntrinsicExits, node)
                                    )
                                nil
                            )
                        )
                    )

                    (let [
                        #_"AbstractBeginNode" prevBegin (AbstractBeginNode'prevBegin-1 invokeNode)
                        #_"DuplicationReplacement" localReplacement
                            (§ reify #_"DuplicationReplacement" (DuplicationReplacement'reify-0)
                                (§ override! #_"Node" DuplicationReplacement''replacement-2 [#_"DuplicationReplacement" this, #_"Node" node]
                                    (cond
                                        (instance? ParameterNode node) (nth parameters (AbstractLocalNode''index-1 node))
                                        (= node entryPointNode)        prevBegin
                                        :else                          node
                                    )
                                )
                            )
                        #_"NodeMark" mark (NodeMark'new-1 graph)
                        ;; Instead, attach the inlining log of the child graph to the current inlining log.
                        #_"EconomicMap<Node, Node>" duplicates (Graph''addDuplicates-5 graph, nodes, inlineGraph, (Graph''getNodeCount-1 inlineGraph), localReplacement)
                        #_"FrameState" stateAfter (AbstractStateSplit''stateAfter-1 invoke)
                    ]
                        (when (some? stateAfter)
                            (InliningUtil'processFrameStates-4 invoke, inlineGraph, duplicates, (< 1 (count returnNodes)))
                            (when-not (zero? (FrameState''nestedLockDepth-1 stateAfter))
                                (doseq [#_"MonitorIdNode" original (Graph''getNodes-2 inlineGraph, MonitorIdNode'TYPE)]
                                    (InliningUtil'processMonitorId-2 (AbstractStateSplit''stateAfter-1 invoke), (get duplicates original))
                                )
                            )
                        )

                        (let [
                            firstCFGNode (get duplicates firstCFGNode)
                        ]
                            (dotimes [#_"int" i (count returnNodes)]
                                (#_"ArrayList" .set returnNodes, i, (get duplicates (nth returnNodes i)))
                            )
                            (doseq [#_"InvokeNode" exit partialIntrinsicExits]
                                ;; A partial intrinsic exit must be replaced with a call to the intrinsified method.
                                (InvokeNode''intrinsify-2 (get duplicates exit), (Graph''add-2 graph, (InvokeNode'new-2 (:callTarget invoke), (:bci invoke))))
                            )
                            (InliningUtil'finishInlining-5 invoke, graph, firstCFGNode, returnNodes, inlineGraph)
                            (GraphUtil'killCFG-1 invokeNode)

                            duplicates
                        )
                    )
                )
            )
        )
    )

    ; @SuppressWarnings("try")
    (§ defn- #_"EconomicSet<Node>" InliningUtil'inlineForCanonicalization-5 [#_"InvokeNode" invoke, #_"Graph" inlineGraph, #_"boolean" receiverNullCheck, #_"ResolvedJavaMethod" inlineeMethod, #_"Consumer<UnmodifiableEconomicMap<Node, Node>>" duplicatesConsumer]
        (let [
            #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-0)
        ]
            ;; This code assumes that Graph.addDuplicates doesn't trigger the NodeEventListener to track
            ;; only nodes which were modified into the process of inlining the graph into the current graph.
            (try (§ with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 (:graph invoke), listener)])
                (let [
                    #_"UnmodifiableEconomicMap<Node, Node>" duplicates (InliningUtil'inline-4 invoke, inlineGraph, receiverNullCheck, inlineeMethod)
                ]
                    (when (some? duplicatesConsumer)
                        (#_"Consumer" .accept duplicatesConsumer, duplicates)
                    )
                )
            )
            (:nodes listener)
        )
    )

    ;;;
     ; Inline {@code inlineGraph} into the current replacing the InvokeNode and return the set of
     ; nodes which should be canonicalized. The set should only contain nodes which modified by the
     ; inlining since the current graph and {@code inlineGraph} are expected to already be canonical.
     ;
     ; @return the set of nodes to canonicalize
     ;;
    (§ defn #_"EconomicSet<Node>" InliningUtil'inlineForCanonicalization-4 [#_"InvokeNode" invoke, #_"Graph" inlineGraph, #_"boolean" receiverNullCheck, #_"ResolvedJavaMethod" inlineeMethod]
        (InliningUtil'inlineForCanonicalization-5 invoke, inlineGraph, receiverNullCheck, inlineeMethod, nil)
    )

    (§ defn- #_"void" InliningUtil'fixFrameStates-3 [#_"Graph" graph, #_"MergeNode" originalMerge, #_"PhiNode" returnPhi]
        ;; It is possible that some of the frame states that came from AFTER_BCI reference a Phi node
        ;; that was created to merge multiple returns. This can create cycles (see GR-3949 and GR-3957).
        ;; To detect this, we follow the control paths starting from the merge node,
        ;; split the Phi node inputs at merges and assign the proper input to each frame state.
        (let [
            #_"NodeMap<Node>" seen (NodeMap'new-1 graph)
            #_"ArrayDeque<Node>" workList (ArrayDeque.)
            #_"ArrayDeque<ValueNode>" valueList (ArrayDeque.)
        ]
            (#_"ArrayDeque" .push workList, originalMerge)
            (#_"ArrayDeque" .push valueList, returnPhi)
            (loop-when-recur [] (not (#_"ArrayDeque" .isEmpty workList)) []
                (let [
                    #_"Node" node (#_"ArrayDeque" .pop workList)
                    #_"ValueNode" currentValue (#_"ArrayDeque" .pop valueList)
                ]
                    (when-not (NodeMap''containsKey-2 seen, node)
                        (NodeMap''put-3 seen, node, node)
                        (when (and (instance? StateSplit node) (not= node originalMerge))
                            (let [
                                #_"FrameState" state (StateSplit''stateAfter-1 node)
                            ]
                                (when (and (some? state) (NodeList''contains-2 (:values state), returnPhi))
                                    (let [
                                        #_"FrameState" duplicate (FrameState''duplicate-1 state)
                                    ]
                                        (loop-when-recur [#_"int" i 0 #_"ISeq" s (seq (:values state))] (some? s) [(inc i) (next s)]
                                            (when (= (first s) returnPhi)
                                                (NodeList''set-3 (:values duplicate), i, currentValue)
                                            )
                                        )
                                        (StateSplit''setStateAfter-2 node, duplicate)
                                        (GraphUtil'tryKillUnused-1 state)
                                    )
                                )
                            )
                        )
                        (cond
                            (instance? AbstractMergeNode node)
                                (doseq [#_"EndNode" pred (AbstractMergeNode''cfgPredecessors-1 node)]
                                    (let [
                                        #_"ValueNode" newValue
                                            (when (AbstractMergeNode''isPhiAtMerge-2 node, currentValue) => currentValue
                                                (PhiNode''valueAt-2 currentValue, pred)
                                            )
                                    ]
                                        (#_"ArrayDeque" .push workList, pred)
                                        (#_"ArrayDeque" .push valueList, newValue)
                                    )
                                )
                            (some? (:predecessor node))
                                (do
                                    (#_"ArrayDeque" .push workList, (:predecessor node))
                                    (#_"ArrayDeque" .push valueList, currentValue)
                                )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"ValueNode" InliningUtil'finishInlining-5 [#_"InvokeNode" invoke, #_"Graph" graph, #_"FixedNode" firstNode, #_"List<ReturnNode>" returnNodes, #_"Graph" inlineGraph]
        (let [
            #_"FixedNode" invokeNode invoke
            #_"FrameState" stateAfter (AbstractStateSplit''stateAfter-1 invoke)
        ]
            (Node''replaceAtPredecessor-2 invokeNode, firstNode)

            (if (empty? returnNodes)
                (do
                    (§ ass! invokeNode (Node''replaceAtUsages-2 invokeNode, nil))
                    (GraphUtil'killCFG-1 (:next invoke))
                    nil
                )
                (let [
                    #_"FixedNode" n (:next invoke)
                ]
                    (§ ass! invoke (FixedWithNextNode''setNext-2 invoke, nil))
                    (if (= (count returnNodes) 1)
                        (let [
                            #_"ReturnNode" returnNode (nth returnNodes 0)
                            returnValue (:result returnNode)
                        ]
                            (§ ass! invokeNode (Node''replaceAtUsages-2 invokeNode, returnValue))
                            (§ ass! returnNode (Node''replaceAndDelete-2 returnNode, n))
                            returnValue
                        )
                        (let [
                            #_"MergeNode" merge (Graph''add-2 graph, (MergeNode'new-0))
                        ]
                            (BeginStateSplitNode''setStateAfter-2 merge, stateAfter)
                            (let [
                                returnValue (ValueMergeUtil'mergeReturns-2 merge, returnNodes)
                            ]
                                (§ ass! invokeNode (Node''replaceAtUsages-2 invokeNode, returnValue))
                                (when (AbstractMergeNode''isPhiAtMerge-2 merge, returnValue)
                                    (InliningUtil'fixFrameStates-3 graph, merge, (§ cast #_"PhiNode" returnValue))
                                )
                                (§ ass! merge (FixedWithNextNode''setNext-2 merge, n))
                                returnValue
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" InliningUtil'processMonitorId-2 [#_"FrameState" stateAfter, #_"MonitorIdNode" monitorIdNode]
        (when (some? stateAfter)
            (§ ass! monitorIdNode (MonitorIdNode''setLockDepth-2 monitorIdNode, (+ (:lockDepth monitorIdNode) (FrameState''nestedLockDepth-1 stateAfter))))
        )
        nil
    )

    (§ defn #_"void" InliningUtil'processFrameStates-4 [#_"InvokeNode" invoke, #_"Graph" inlineGraph, #_"EconomicMap<Node, Node>" duplicates, #_"boolean" alwaysDuplicateStateAfter]
        (let [
            #_"FrameState" stateAtReturn (AbstractStateSplit''stateAfter-1 invoke)
            #_"JavaKind" invokeReturnKind (ValueNode''getStackKind-1 invoke)
            #_"EconomicMap<Node, Node>" replacements (EconomicMap/create)
            #_"FrameState" outerFrameState
                (loop-when [outerFrameState nil #_"ISeq" s (seq (Graph''getNodes-2 inlineGraph, FrameState'TYPE))] (some? s) => outerFrameState
                    (let [
                        #_"FrameState" frameState (get duplicates (first s))
                        outerFrameState
                            (when (and (some? frameState) (Node''isAlive-1 frameState)) => outerFrameState
                                (let [
                                    outerFrameState
                                        (or outerFrameState
                                            (FrameState''duplicateModifiedDuringCall-3 stateAtReturn, (:bci invoke), invokeReturnKind)
                                        )
                                ]
                                    (InliningUtil'processFrameState-8 frameState, invoke, replacements, (:rootMethod inlineGraph), outerFrameState, alwaysDuplicateStateAfter, (CallTargetNode''targetMethod-1 (:callTarget invoke)), (CallTargetNode''arguments-1 (:callTarget invoke)))
                                    outerFrameState
                                )
                            )
                    ]
                        (recur outerFrameState (next s))
                    )
                )
        ]
            ;; If processing the frame states replaced any nodes, update the duplicates map.
            (#_"EconomicMap" .replaceAll duplicates, (ß (key, value) -> (§ fun (if (contains? replacements value) (get replacements value) value))))
        )
        nil
    )

    (§ defn- #_"FrameState" InliningUtil'handleAfterBciFrameState-3 [#_"FrameState" frameState, #_"InvokeNode" invoke, #_"boolean" alwaysDuplicateStateAfter]
        (let [
            #_"FrameState" stateAtReturn (AbstractStateSplit''stateAfter-1 invoke)
            #_"JavaKind" invokeReturnKind (ValueNode''getStackKind-1 invoke)
            #_"FrameState" stateAfterReturn stateAtReturn
        ]
            (when (nil? (:code frameState))
                ;; this is a frame state for a side effect within an intrinsic that was parsed for post-parse intrinsification
                (doseq [#_"Node" usage (Node''usages-1 frameState)]
                    (when (instance? ForeignCallNode usage)
                        ;; a foreign call inside an intrinsic needs to have the BCI of the invoke being intrinsified
                        (§ ass! usage (ForeignCallNode''setBci-2 usage, (:bci invoke)))
                    )
                )
            )
            ;; pop return kind from invoke's stateAfter and replace with this frameState's return value (top of stack)
            (let [
                stateAfterReturn
                    (if (and (pos? (:stackSize frameState)) (or alwaysDuplicateStateAfter (not= (FrameState''stackAt-2 stateAfterReturn, 0) (FrameState''stackAt-2 frameState, 0))))
                        ;; a non-void return value
                        (FrameState''duplicateModified-4 stateAtReturn, invokeReturnKind, invokeReturnKind, (FrameState''stackAt-2 frameState, 0))
                        ;; a void return value
                        (FrameState''duplicate-1 stateAtReturn)
                    )
            ]
                ;; return value does no longer need to be limited by the monitor exit
                (doseq [#_"MonitorExitNode" n (NodeIterable''filter-2 (Node''usages-1 frameState), MonitorExitNode)]
                    (§ ass! n (MonitorExitNode''clearEscapedReturnValue-1 n))
                )
                (§ ass! frameState (Node''replaceAndDelete-2 frameState, stateAfterReturn))
                stateAfterReturn
            )
        )
    )

    (§ defn #_"FrameState" InliningUtil'processFrameState-8 [#_"FrameState" frameState, #_"InvokeNode" invoke, #_"EconomicMap<Node, Node>" replacements, #_"ResolvedJavaMethod" inlinedMethod, #_"FrameState" outerFrameState, #_"boolean" alwaysDuplicateStateAfter, #_"ResolvedJavaMethod" invokeTargetMethod, #_"List<ValueNode>" invokeArgsList]
        (let [
            #_"FrameState" stateAtReturn (AbstractStateSplit''stateAfter-1 invoke)
            #_"JavaKind" invokeReturnKind (ValueNode''getStackKind-1 invoke)
        ]
            (condp = (:bci frameState)
                BytecodeFrame/AFTER_BCI
                    (InliningUtil'handleAfterBciFrameState-3 frameState, invoke, alwaysDuplicateStateAfter)
                BytecodeFrame/BEFORE_BCI
                    ;; This is an intrinsic. Deoptimizing within an intrinsic must re-execute the intrinsified invocation.
                    (let [
                        #_"ValueNode[]" invokeArgs (if (empty? invokeArgsList) (make-array ValueNode 0) (#_"List" .toArray invokeArgsList, (make-array ValueNode (count invokeArgsList))))
                        #_"FrameState" stateBeforeCall (FrameState''duplicateModifiedBeforeCall-5 stateAtReturn, (:bci invoke), invokeReturnKind, (#_"Signature" .toParameterKinds (#_"ResolvedJavaMethod" .getSignature invokeTargetMethod), (not (#_"ResolvedJavaMethod" .isStatic invokeTargetMethod))), invokeArgs)
                    ]
                        (§ ass! frameState (Node''replaceAndDelete-2 frameState, stateBeforeCall))
                        stateBeforeCall
                    )
                (do
                    ;; only handle the outermost frame states
                    (when (nil? (:outerFrameState frameState))
                        (§ ass! frameState (FrameState''setOuterFrameState-2 frameState, outerFrameState))
                    )
                    frameState
                )
            )
        )
    )

    ;;;
     ; Gets the receiver for an invoke, adding a guard if necessary to ensure it is non-nil,
     ; and ensuring that the resulting type is compatible with the method being invoked.
     ;;
    (§ defn #_"ValueNode" InliningUtil'nonNullReceiver-1 [#_"InvokeNode" invoke]
        (let [
            #_"MethodCallTargetNode" callTarget (:callTarget invoke)
            #_"Graph" graph (:graph callTarget)
            #_"ValueNode" oldReceiver (nth (CallTargetNode''arguments-1 callTarget) 0)
            #_"ValueNode" newReceiver oldReceiver
        ]
            (when (= (ValueNode''getStackKind-1 newReceiver) JavaKind/Object)
                (when (= (InvokeNode''getInvokeKind-1 invoke) InvokeKind'Special)
                    (let [
                        #_"Stamp" paramStamp (:stamp newReceiver)
                        #_"Stamp" stamp (Stamp''join-2 paramStamp, (StampFactory'object-1 (TypeReference'create-1 (#_"ResolvedJavaMethod" .getDeclaringClass (CallTargetNode''targetMethod-1 callTarget)))))
                    ]
                        (when-not (= stamp paramStamp)
                            ;; The verifier and previous optimizations guarantee unconditionally that the
                            ;; receiver is at least of the type of the method holder for a special invoke.
                            (§ ass newReceiver (Graph''add-2 graph, (PiNode'new-2 newReceiver, stamp)))
                        )
                    )
                )

                (when-not (StampTool'isPointerNeverNull-1 (:stamp newReceiver))
                    (let [
                        #_"LogicNode" condition (Graph''add-2 graph, (IsNullNode'create-1 newReceiver))
                        #_"FixedGuardNode" fixedGuard (Graph''add-2 graph, (FixedGuardNode'new-4 condition, DeoptimizationReason/NullCheckException, DeoptimizationAction/InvalidateReprofile, true))
                        #_"PiNode" nonNullReceiver (Graph''add-2 graph, (PiNode'new-3 newReceiver, StampFactory'objectNonNullStamp, fixedGuard))
                    ]
                        (Graph''addBeforeFixed-3 graph, invoke, fixedGuard)
                        (§ ass newReceiver nonNullReceiver)
                    )
                )
            )

            (when-not (= newReceiver oldReceiver)
                (Node''replaceFirstInput-3 callTarget, oldReceiver, newReceiver)
            )
            newReceiver
        )
    )
)

(class-ns AbstractInliningPolicy (§ implements InliningPolicy)
    (def #_"float" AbstractInliningPolicy'RelevanceCapForInlining 1.0 #_"f")
    (def #_"float" AbstractInliningPolicy'CapInheritedRelevance 1.0 #_"f")

    (§ defn #_"AbstractInliningPolicy" AbstractInliningPolicy'new-0 []
        (Object.)
    )

    (§ method! #_"double" AbstractInliningPolicy''computeMaximumSize-3 [#_"AbstractInliningPolicy" this, #_"double" relevance, #_"int" configuredMaximum]
        (* configuredMaximum (min AbstractInliningPolicy'RelevanceCapForInlining relevance))
    )

    (§ defn #_"double" AbstractInliningPolicy'determineInvokeProbability-1 [#_"InlineInfo" info]
        (loop-when [#_"double" invokeProbability 0 #_"int" i 0] (< i (InlineInfo''numberOfMethods-1 info)) => invokeProbability
            (let [
                #_"Inlineable" callee (InlineInfo''inlineableElementAt-2 info, i)
                invokeProbability
                    (loop-when-recur [invokeProbability invokeProbability #_"ISeq" s (seq (Inlineable''getInvokes-1 callee))]
                                     (some? s)
                                     [(+ invokeProbability (Inlineable''getProbability-2 callee, (first s))) (next s)]
                                  => invokeProbability
                    )
            ]
                (recur invokeProbability (inc i))
            )
        )
    )
)

(final-ns GreedyInliningPolicy (§ extends AbstractInliningPolicy)
    (§ defn #_"GreedyInliningPolicy" GreedyInliningPolicy'new-0 []
        (AbstractInliningPolicy'new-0)
    )

    #_unused
    (§ override! #_"boolean" GreedyInliningPolicy''continueInlining-2 [#_"GreedyInliningPolicy" this, #_"Graph" currentGraph]
        (< (Graph''getNodeCount-1 currentGraph) GraalOptions'maximumDesiredSize)
    )

    #_unused
    (§ override! #_"Decision" GreedyInliningPolicy''isWorthInlining-5 [#_"GreedyInliningPolicy" this, #_"Replacements" replacements, #_"MethodInvocation" invocation, #_"int" inliningDepth, #_"boolean" fullyProcessed]
        (cond
            GraalOptions'inlineEverything                     Decision'YES
            (InlineInfo''shouldInline-1 (:callee invocation)) Decision'YES
            :else
                (let [
                    #_"int" nodes (InlineInfo''determineNodeCount-1 (:callee invocation))
                ]
                    (cond
                        (< nodes GraalOptions'trivialInliningSize)
                            Decision'YES
                        ;; TODO invoked methods that are on important paths but not yet compiled -> will be compiled anyways
                        ;; and it is likely that we are the only caller... might be useful to inline those methods but increases
                        ;; bootstrap time (maybe those methods are also getting queued in the compilation queue concurrently)
                        (and (pos? GraalOptions'limitInlinedInvokes) fullyProcessed
                            (< GraalOptions'limitInlinedInvokes (AbstractInliningPolicy'determineInvokeProbability-1 (:callee invocation)))
                        )
                            Decision'NO
                        (<= nodes (AbstractInliningPolicy''computeMaximumSize-3 this, (:relevance invocation), GraalOptions'maximumInliningSize))
                            Decision'YES
                        :else
                            Decision'NO
                    )
                )
        )
    )
)

(§ interface InliningPolicy
    (§ abstract #_"boolean" InliningPolicy''continueInlining-2 [#_"InliningPolicy" this, #_"Graph" graph])

    (§ abstract #_"Decision" InliningPolicy''isWorthInlining-5 [#_"InliningPolicy" this, #_"Replacements" replacements, #_"MethodInvocation" invocation, #_"int" inliningDepth, #_"boolean" fullyProcessed])
)

;;;
 ; @anno InliningPolicy.Decision
 ;;
(final-ns Decision
    (§ def #_"Decision" Decision'YES (Decision'new-2 true, "(unknown reason)"))
    (§ def #_"Decision" Decision'NO (Decision'new-2 false, "(unknown reason)"))

    (§ final #_"boolean" :shouldInline false)
    (§ final #_"String" :reason nil)

    (§ defn- #_"Decision" Decision'new-2 [#_"boolean" shouldInline, #_"String" reason]
        (let [
            #_"Decision" this (Object.)
            this (assoc this :shouldInline shouldInline)
            this (assoc this :reason reason)
        ]
            this
        )
    )
)

;;;
 ; Information about a graph that will potentially be inlined. This includes tracking the
 ; invocations in graph that will subject to inlining themselves.
 ;;
(class-ns CallsiteHolder
    (§ defn #_"CallsiteHolder" CallsiteHolder'new-0 []
        (Object.)
    )

    ;;;
     ; Gets the method associated with the {@linkplain #graph() graph} represented by this object.
     ;;
    (§ abstract #_"ResolvedJavaMethod" CallsiteHolder''method-1 [#_"CallsiteHolder" this])

    ;;;
     ; The stack realized by InliningData grows upon InliningData#moveForward()
     ; deciding to explore (depth-first) a callsite of the graph associated to this
     ; CallsiteHolder. The list of not-yet-considered callsites is managed by
     ; CallsiteHolderExplorable, and this method reports whether any such candidates remain.
     ;;
    (§ abstract #_"boolean" CallsiteHolder''hasRemainingInvokes-1 [#_"CallsiteHolder" this])

    ;;;
     ; The graph about which this object contains inlining information.
     ;;
    (§ abstract #_"Graph" CallsiteHolder''graph-1 [#_"CallsiteHolder" this])
)

;;;
 ; A CallsiteHolder whose graph has been copied already and thus can be modified without affecting
 ; the original (usually cached) version.
 ;
 ; An instance of this class is derived from an InlineableGraph and contains a subset of the information
 ; there: just the InvokeNodes from it. Such nodes are candidates for depth-first search of further
 ; inlining opportunities (thus the adjective "explorable" given to this class).
 ;;
(final-ns CallsiteHolderExplorable (§ extends CallsiteHolder)
    ;;;
     ; Graph in which inlining may be performed at one or more of the callsites containined in #remainingInvokes.
     ;;
    (§ final #_"Graph" :graph nil)

    (§ final #_"LinkedList<InvokeNode>" :remainingInvokes nil)
    (§ final #_"double" :probability 0.0)
    (§ final #_"double" :relevance 0.0)

    ;;;
     ; Parameters for which the callsite targeting #graph() provides "fixed" arguments. That
     ; callsite isn't referenced by this instance. Instead, it belongs to the graph of the caller of
     ; this CallsiteHolderExplorable.
     ;
     ; Constant arguments don't contribute to fixed-params: those params have been removed already,
     ; see InlineableGraph.
     ;
     ; Instead, fixed-params are those receiving freshly instantiated arguments (possibly
     ; instantiated several levels up in the call-hierarchy).
     ;;
    (§ final #_"EconomicSet<ParameterNode>" :fixedParams nil)

    (§ final #_"ToDoubleFunction<FixedNode>" :probabilities nil)
    (§ final #_"ComputeInliningRelevance" :computeInliningRelevance nil)

    (§ defn #_"CallsiteHolderExplorable" CallsiteHolderExplorable'new-5 [#_"Graph" graph, #_"double" probability, #_"double" relevance, #_"BitSet" freshlyInstantiatedArguments, #_"LinkedList<InvokeNode>" invokes]
        (let [
            #_"CallsiteHolderExplorable" this (CallsiteHolder'new-0)
            this (assoc this :graph graph)
            this (assoc this :probability probability)
            this (assoc this :relevance relevance)
            this (assoc this :fixedParams (CallsiteHolderExplorable''fixedParamsAt-2 this, freshlyInstantiatedArguments))
            this (assoc this :remainingInvokes (or invokes (InliningIterator''apply-1 (InliningIterator'new-1 graph))))
        ]
            (if (empty? (:remainingInvokes this))
                (do
                    (§ ass this (assoc this :probabilities nil))
                    (§ ass this (assoc this :computeInliningRelevance nil))
                )
                (do
                    (§ ass this (assoc this :probabilities (FixedNodeProbabilityCache'new-0)))
                    (§ ass this (assoc this :computeInliningRelevance (ComputeInliningRelevance'new-2 graph, (:probabilities this))))
                    (CallsiteHolderExplorable''computeProbabilities-1 this)
                )
            )
            this
        )
    )

    (§ method- #_"EconomicSet<ParameterNode>" CallsiteHolderExplorable''fixedParamsAt-2 [#_"CallsiteHolderExplorable" this, #_"BitSet" freshlyInstantiatedArguments]
        (let [
            #_"EconomicSet<ParameterNode>" params (EconomicSet/create Equivalence/IDENTITY)
        ]
            (when (and (some? freshlyInstantiatedArguments) (not (#_"BitSet" .isEmpty freshlyInstantiatedArguments))) => params
                (doseq [#_"ParameterNode" param (Graph''getNodes-2 (:graph this), ParameterNode'TYPE)]
                    (when (#_"BitSet" .get freshlyInstantiatedArguments, (AbstractLocalNode''index-1 param))
                        (#_"EconomicSet" .add params, param)
                    )
                )
                params
            )
        )
    )

    #_unused
    (§ override! #_"ResolvedJavaMethod" CallsiteHolderExplorable''method-1 [#_"CallsiteHolderExplorable" this]
        (when (some? (:graph this)) (:rootMethod (:graph this)))
    )

    #_unused
    (§ override! #_"boolean" CallsiteHolderExplorable''hasRemainingInvokes-1 [#_"CallsiteHolderExplorable" this]
        (seq (:remainingInvokes this))
    )

    (§ override! #_"Graph" CallsiteHolderExplorable''graph-1 [#_"CallsiteHolderExplorable" this]
        (:graph this)
    )

    (§ method! #_"InvokeNode" CallsiteHolderExplorable''popInvoke-1 [#_"CallsiteHolderExplorable" this]
        (#_"LinkedList" .removeFirst (:remainingInvokes this))
    )

    (§ method! #_"void" CallsiteHolderExplorable''pushInvoke-2 [#_"CallsiteHolderExplorable" this, #_"InvokeNode" invoke]
        (#_"LinkedList" .push (:remainingInvokes this), invoke)
        nil
    )

    #_unused
    (§ defn #_"boolean" CallsiteHolderExplorable'allArgsNonNull-1 [#_"InvokeNode" invoke]
        (loop-when [#_"ISeq" s (seq (CallTargetNode''arguments-1 (:callTarget invoke)))] (some? s) => true
            (and (some? (first s))
                (recur (next s))
            )
        )
    )

    #_unused
    (§ method! #_"boolean" CallsiteHolderExplorable''containsInvoke-2 [#_"CallsiteHolderExplorable" this, #_"InvokeNode" invoke]
        (loop-when [#_"ISeq" s (seq (Graph''getInvokes-1 (CallsiteHolderExplorable''graph-1 this)))] (some? s) => false
            (or (= (first s) invoke)
                (recur (next s))
            )
        )
    )

    #_unused
    (§ method! #_"boolean" CallsiteHolderExplorable''containsParam-2 [#_"CallsiteHolderExplorable" this, #_"ParameterNode" param]
        (loop-when [#_"ISeq" s (seq (Graph''getNodes-2 (:graph this), ParameterNode'TYPE))] (some? s) => false
            (or (= (first s) param)
                (recur (next s))
            )
        )
    )

    (§ method! #_"void" CallsiteHolderExplorable''computeProbabilities-1 [#_"CallsiteHolderExplorable" this]
        (§ ass! (:computeInliningRelevance this) (ComputeInliningRelevance''compute-1 (:computeInliningRelevance this)))
        nil
    )

    (§ method! #_"double" CallsiteHolderExplorable''invokeProbability-2 [#_"CallsiteHolderExplorable" this, #_"InvokeNode" invoke]
        (* (:probability this) (#_"ToDoubleFunction" .applyAsDouble (:probabilities this), invoke))
    )

    (§ method! #_"double" CallsiteHolderExplorable''invokeRelevance-2 [#_"CallsiteHolderExplorable" this, #_"InvokeNode" invoke]
        (* (min AbstractInliningPolicy'CapInheritedRelevance (:relevance this)) (ComputeInliningRelevance''getRelevance-2 (:computeInliningRelevance this), invoke))
    )
)

(final-ns ComputeInliningRelevance
    (§ def- #_"double" ComputeInliningRelevance'EPSILON (/ 1.0 Integer/MAX_VALUE))
    (def- #_"double" ComputeInliningRelevance'UNINITIALIZED -1.0)

    (def- #_"int" ComputeInliningRelevance'EXPECTED_MIN_INVOKE_COUNT 3)
    (def- #_"int" ComputeInliningRelevance'EXPECTED_INVOKE_RATIO 20)
    (def- #_"int" ComputeInliningRelevance'EXPECTED_LOOP_COUNT 3)

    (§ final #_"Graph" :graph nil)
    (§ final #_"ToDoubleFunction<FixedNode>" :nodeProbabilities nil)

    ;;;
     ; Node relevances are pre-computed for all invokes if the graph contains loops. If there are no
     ; loops, the computation happens lazily based on #rootScope.
     ;;
    (§ mutable #_"EconomicMap<FixedNode, Double>" :nodeRelevances nil)
    ;;;
     ; This scope is non-nil if (and only if) there are no loops in the graph. In this case, the
     ; root scope is used to compute invoke relevances on the fly.
     ;;
    (§ mutable #_"Scope" :rootScope nil)

    (§ defn #_"ComputeInliningRelevance" ComputeInliningRelevance'new-2 [#_"Graph" graph, #_"ToDoubleFunction<FixedNode>" nodeProbabilities]
        (let [
            #_"ComputeInliningRelevance" this (Object.)
            this (assoc this :graph graph)
            this (assoc this :nodeProbabilities nodeProbabilities)
        ]
            this
        )
    )

    ;;;
     ; Initializes or updates the relevance computation. If there are no loops within the graph,
     ; most computation happens lazily.
     ;;
    (§ method! #_"ComputeInliningRelevance" ComputeInliningRelevance''compute-1 [#_"ComputeInliningRelevance" this]
        (when (Graph''hasLoops-1 (:graph this)) => (assoc this :rootScope (Scope'new-3 this, (:start (:graph this)), nil))
            (let [
                this (assoc this :rootScope nil)
                this
                    (when (nil? (:nodeRelevances this)) => this
                        (assoc this :nodeRelevances (EconomicMap/create Equivalence/IDENTITY, (+ ComputeInliningRelevance'EXPECTED_MIN_INVOKE_COUNT (quot (Graph''getNodeCount-1 (:graph this)) ComputeInliningRelevance'EXPECTED_INVOKE_RATIO))))
                    )
                #_"NodeWorkList" workList (SingletonNodeWorkList'new-1 (:graph this))
                #_"EconomicMap<LoopBeginNode, Scope>" loops (EconomicMap/create Equivalence/IDENTITY, ComputeInliningRelevance'EXPECTED_LOOP_COUNT)
                #_"Scope" topScope (Scope'new-3 this, (:start (:graph this)), nil)
            ]
                (doseq [#_"LoopBeginNode" loopBegin (Graph''getNodes-2 (:graph this), LoopBeginNode'TYPE)]
                    (ComputeInliningRelevance''createLoopScope-4 this, loopBegin, loops, topScope)
                )
                (Scope''process-2 topScope, workList)
                (doseq [#_"Scope" scope (vals loops)]
                    (Scope''process-2 scope, workList)
                )
                this
            )
        )
    )

    (§ method! #_"double" ComputeInliningRelevance''getRelevance-2 [#_"ComputeInliningRelevance" this, #_"InvokeNode" invoke]
        (if (some? (:rootScope this))
            (Scope''computeInvokeRelevance-2 (:rootScope this), invoke)
            (get (:nodeRelevances this) invoke)
        )
    )

    ;;;
     ; Determines the parent of the given loop and creates a Scope object for each one.
     ; This method will call itself recursively if no Scope for the parent loop exists.
     ;;
    (§ method- #_"Scope" ComputeInliningRelevance''createLoopScope-4 [#_"ComputeInliningRelevance" this, #_"LoopBeginNode" loopBegin, #_"EconomicMap<LoopBeginNode, Scope>" loops, #_"Scope" topScope]
        (or (get loops loopBegin)
            ;; look for the parent scope
            (let [
                #_"Scope" parent
                    (loop [#_"FixedNode" node (LoopBeginNode''forwardEnd-1 loopBegin)]
                        (cond
                            (nil? (:predecessor node))
                                (condp instance? node
                                    LoopBeginNode
                                        ;; if we reach a LoopBeginNode then we're within this loop
                                        (ComputeInliningRelevance''createLoopScope-4 this, node, loops, topScope)
                                    StartNode
                                        ;; we're within the outermost scope
                                        topScope
                                    ;; follow any path upwards - it doesn't matter which one
                                    (recur (AbstractMergeNode''forwardEndAt-2 node, 0))
                                )
                            (instance? LoopExitNode node)
                                ;; if we reach a loop exit then we follow this loop and have the same parent
                                (:parent (ComputeInliningRelevance''createLoopScope-4 this, (:loopBegin node), loops, topScope))
                            :else
                                (recur (:predecessor node))
                        )
                    )
                #_"Scope" scope (Scope'new-3 this, loopBegin, parent)
            ]
                (#_"EconomicMap" .put loops, loopBegin, scope)
                scope
            )
        )
    )

    ;;;
     ; Computes the minimum probability along the most probable path within the scope.
     ; During iteration, the method returns immediately once a loop exit is discovered.
     ;;
    (§ method- #_"double" ComputeInliningRelevance''computeFastPathMinProbability-2 [#_"ComputeInliningRelevance" this, #_"FixedNode" scopeStart]
        (let [
            #_"ArrayList<FixedNode>" pathBeginNodes (ArrayList.)
            _ (#_"ArrayList" .add pathBeginNodes, scopeStart)
        ]
            (loop [#_"double" minPathProbability (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities this), scopeStart)]
                (let [
                    minPathProbability
                        (loop [#_"Node" node (#_"ArrayList" .remove pathBeginNodes, (dec (count pathBeginNodes))) minPathProbability minPathProbability]
                            (let [
                                [node minPathProbability]
                                    (cond
                                        (and (instance? LoopBeginNode scopeStart) (instance? LoopExitNode node) (NodeIterable''contains-2 (LoopBeginNode''loopExits-1 scopeStart), node))
                                            (§ return minPathProbability)
                                        (and (instance? LoopBeginNode node) (not= node scopeStart))
                                            (let [
                                                node (ComputeInliningRelevance''getMaxProbabilityLoopExit-3 this, node, pathBeginNodes)
                                            ]
                                                [node (ComputeInliningRelevance''getMinPathProbability-3 this, node, minPathProbability)]
                                            )
                                        (instance? ControlSplitNode node)
                                            (let [
                                                node (ComputeInliningRelevance'getMaxProbabilitySux-2 node, pathBeginNodes)
                                            ]
                                                [node (ComputeInliningRelevance''getMinPathProbability-3 this, node, minPathProbability)]
                                            )
                                        :else
                                            [(NodeIterable''first-1 (Node''successors-1 node)) minPathProbability]
                                    )
                            ]
                                (recur-if (some? node) [node minPathProbability] => minPathProbability)
                            )
                        )
                ]
                    (recur-if (seq pathBeginNodes) [minPathProbability] => minPathProbability)
                )
            )
        )
    )

    (§ method- #_"double" ComputeInliningRelevance''getMinPathProbability-3 [#_"ComputeInliningRelevance" this, #_"FixedNode" node, #_"double" minPathProbability]
        (if (some? node) (min minPathProbability (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities this), node)) minPathProbability)
    )

    ;;;
     ; Returns the most probable successor. If multiple successors share the maximum probability,
     ; one is returned and the others are enqueued in pathBeginNodes.
     ;;
    (§ defn- #_"Node" ComputeInliningRelevance'getMaxProbabilitySux-2 [#_"ControlSplitNode" controlSplit, #_"ArrayList<FixedNode>" pathBeginNodes]
        (let [
            #_"int" pathBeginCount (count pathBeginNodes)
        ]
            (loop-when [#_"Node" maxSux nil #_"double" maxProbability 0.0 #_"ISeq" s (seq (Node''successors-1 controlSplit))] (some? s) => maxSux
                (let [
                    #_"Node" sux (first s)
                    #_"double" probability (ControlSplitNode''probability-2 controlSplit, (§ cast #_"AbstractBeginNode" sux))
                    [maxSux maxProbability]
                        (if (< maxProbability probability)
                            (do
                                (ComputeInliningRelevance'truncate-2 pathBeginNodes, pathBeginCount)
                                [sux probability]
                            )
                            (do
                                (when (= probability maxProbability)
                                    (#_"ArrayList" .add pathBeginNodes, sux)
                                )
                                [maxSux maxProbability]
                            )
                        )
                ]
                    (recur maxSux maxProbability (next s))
                )
            )
        )
    )

    ;;;
     ; Returns the most probable loop exit. If multiple successors share the maximum probability,
     ; one is returned and the others are enqueued in pathBeginNodes.
     ;;
    (§ method- #_"Node" ComputeInliningRelevance''getMaxProbabilityLoopExit-3 [#_"ComputeInliningRelevance" this, #_"LoopBeginNode" loopBegin, #_"ArrayList<FixedNode>" pathBeginNodes]
        (let [
            #_"int" pathBeginCount (count pathBeginNodes)
        ]
            (loop-when [#_"Node" maxSux nil #_"double" maxProbability 0.0 #_"ISeq" s (seq (LoopBeginNode''loopExits-1 loopBegin))] (some? s) => maxSux
                (let [
                    #_"LoopExitNode" sux (first s)
                    #_"double" probability (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities this), sux)
                    [maxSux maxProbability]
                        (if (< maxProbability probability)
                            (do
                                (ComputeInliningRelevance'truncate-2 pathBeginNodes, pathBeginCount)
                                [sux probability]
                            )
                            (do
                                (when (= probability maxProbability)
                                    (#_"ArrayList" .add pathBeginNodes, sux)
                                )
                                [maxSux maxProbability]
                            )
                        )
                ]
                    (recur maxSux maxProbability (next s))
                )
            )
        )
    )

    (§ defn- #_"void" ComputeInliningRelevance'truncate-2 [#_"ArrayList<FixedNode>" pathBeginNodes, #_"int" pathBeginCount]
        (loop-when-recur [#_"int" i (- (count pathBeginNodes) pathBeginCount)] (pos? i) [(dec i)]
            (#_"ArrayList" .remove pathBeginNodes, (dec (count pathBeginNodes)))
        )
        nil
    )
)

;;;
 ; A scope holds information for the contents of one loop or of the root of the method.
 ;
 ; It does not include child loops, i.e. the iteration in #process(NodeWorkList)
 ; explicitly excludes the nodes of child loops.
 ;
 ; @anno ComputeInliningRelevance.Scope
 ;;
(final-ns Scope
    (§ final #_"ComputeInliningRelevance" :relevance nil)

    (§ final #_"FixedNode" :start nil)
    (§ final #_"Scope" :parent nil) ;; can be nil for the outermost scope

    ;;;
     ; The minimum probability along the most probable path in this scope. Computed lazily.
     ;;
    (§ mutable #_"double" :fastPathMinProbability ComputeInliningRelevance'UNINITIALIZED)
    ;;;
     ; A measure of how important this scope is within its parent scope. Computed lazily.
     ;;
    (§ mutable #_"double" :scopeRelevanceWithinParent ComputeInliningRelevance'UNINITIALIZED)

    (§ defn #_"Scope" Scope'new-3 [#_"ComputeInliningRelevance" relevance, #_"FixedNode" start, #_"Scope" parent]
        (let [
            #_"Scope" this (Object.)
            this (assoc this :relevance relevance)
            this (assoc this :start start)
            this (assoc this :parent parent)
        ]
            this
        )
    )

    (§ method! #_"double" Scope''getFastPathMinProbability-1 [#_"Scope" this]
        (when (= (:fastPathMinProbability this) ComputeInliningRelevance'UNINITIALIZED)
            (§ ass! this (assoc this :fastPathMinProbability (max ComputeInliningRelevance'EPSILON (ComputeInliningRelevance''computeFastPathMinProbability-2 (:relevance this), (:start this)))))
        )
        (:fastPathMinProbability this)
    )

    ;;;
     ; Computes the ratio between the probabilities of the current scope's entry point and the
     ; parent scope's fastPathMinProbability.
     ;;
    (§ method! #_"double" Scope''getScopeRelevanceWithinParent-1 [#_"Scope" this]
        (when (= (:scopeRelevanceWithinParent this) ComputeInliningRelevance'UNINITIALIZED)
            (§ ass! this (assoc this :scopeRelevanceWithinParent (if (instance? LoopBeginNode (:start this)) (/ (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities (:relevance this)), (LoopBeginNode''forwardEnd-1 (:start this))) (Scope''getFastPathMinProbability-1 (:parent this))) 1.0)))
        )
        (:scopeRelevanceWithinParent this)
    )

    ;;;
     ; Processes all invokes in this scope by starting at the scope's start node and iterating
     ; all fixed nodes. Child loops are skipped by going from loop entries directly to the loop
     ; exits. Processing stops at loop exits of the current loop.
     ;;
    (§ method! #_"void" Scope''process-2 [#_"Scope" this, #_"NodeWorkList" workList]
        (NodeWorkList''addAll-2 workList, (Node''successors-1 (:start this)))

        (doseq [#_"Node" node workList]
            (condp instance? node
                InvokeNode
                (do
                    ;; process the invoke and queue its successors
                    (#_"EconomicMap" .put (:nodeRelevances (:relevance this)), node, (Scope''computeInvokeRelevance-2 this, node))
                    (NodeWorkList''addAll-2 workList, (Node''successors-1 node))
                )
                LoopBeginNode
                    ;; skip child loops by advancing over the loop exits
                    (#_"Iterable" .forEach (LoopBeginNode''loopExits-1 node), (ß exit -> (§ fun (NodeWorkList''add-2 workList, (:next exit)))))
                LoopEndNode       nil ;; nothing to do
                LoopExitNode      nil ;; nothing to do
                FixedWithNextNode (NodeWorkList''add-2 workList, (:next node))
                EndNode           (NodeWorkList''add-2 workList, (AbstractEndNode''merge-1 node))
                ControlSinkNode   nil ;; nothing to do
                ControlSplitNode  (NodeWorkList''addAll-2 workList, (Node''successors-1 node))
                nil
            )
        )
        nil
    )

    ;;;
     ; The relevance of an invoke is the ratio between the invoke's probability and the current
     ; scope's fastPathMinProbability, adjusted by scopeRelevanceWithinParent.
     ;;
    (§ method! #_"double" Scope''computeInvokeRelevance-2 [#_"Scope" this, #_"InvokeNode" invoke]
        (* (/ (#_"ToDoubleFunction" .applyAsDouble (:nodeProbabilities (:relevance this)), invoke) (Scope''getFastPathMinProbability-1 this)) (min (Scope''getScopeRelevanceWithinParent-1 this) 1.0))
    )
)

;;;
 ; The space of inlining decisions is explored depth-first with the help of a stack realized by
 ; InliningData. At any point in time, the topmost element of that stack consists of:
 ;
 ; (1) the callsite under consideration is tracked as a MethodInvocation.
 ; (2) one or more CallsiteHolders, all of them associated to the callsite above. Why more
 ; than one? Depending on the type-profile for the receiver more than one concrete method may be
 ; feasible target.
 ;
 ; The bottom element in the stack consists of:
 ;
 ; (1) a single MethodInvocation (the {@link MethodInvocation#isRoot root} one, i.e.
 ; the unknown caller of the root graph)
 ; (2) a single CallsiteHolder (the root one, for the method on which inlining was called)
 ;;
(final-ns InliningData
    ;;;
     ; Call hierarchy from outer most call (i.e. compilation unit) to inner most callee.
     ;;
    (§ final #_"ArrayDeque<CallsiteHolder>" :graphQueue (ArrayDeque.))
    (§ final #_"ArrayDeque<MethodInvocation>" :invocationQueue (ArrayDeque.))

    (§ final #_"HighTierContext" :context nil)
    (§ final #_"CanonicalizerPhase" :canonicalizer nil)
    (§ final #_"InliningPolicy" :inliningPolicy nil)
    (§ final #_"Graph" :rootGraph nil)

    (§ mutable #_"int" :maxGraphs 0)

    (§ defn #_"InliningData" InliningData'new-5 [#_"Graph" rootGraph, #_"HighTierContext" context, #_"CanonicalizerPhase" canonicalizer, #_"InliningPolicy" inliningPolicy, #_"LinkedList<InvokeNode>" rootInvokes]
        (let [
            #_"InliningData" this (Object.)
            this (assoc this :context context)
            this (assoc this :canonicalizer canonicalizer)
            this (assoc this :inliningPolicy inliningPolicy)
            this (assoc this :maxGraphs 1)
            this (assoc this :rootGraph rootGraph)
        ]
            (#_"ArrayDeque" .push (:invocationQueue this), (MethodInvocation'new-4 nil, 1.0, 1.0, nil))
            (#_"ArrayDeque" .push (:graphQueue this), (CallsiteHolderExplorable'new-5 rootGraph, 1.0, 1.0, nil, rootInvokes))
            this
        )
    )

    (§ defn #_"boolean" InliningData'isFreshInstantiation-1 [#_"ValueNode" arg]
        (or (instance? AbstractNewObjectNode arg) (instance? AllocatedObjectNode arg) (instance? VirtualObjectNode arg))
    )

    (§ method- #_"String" InliningData''checkTargetConditionsHelper-2 [#_"InliningData" this, #_"ResolvedJavaMethod" method]
        (cond
            (nil? method)
                "the method is not resolved"
            (#_"ResolvedJavaMethod" .isNative method)
                "it is a non-intrinsic native method"
            (#_"ResolvedJavaMethod" .isAbstract method)
                "it is an abstract method"
            (not (#_"ResolvedJavaType" .isInitialized (#_"ResolvedJavaMethod" .getDeclaringClass method)))
                "the method's class is not initialized"
            (not (#_"ResolvedJavaMethod" .canBeInlined method))
                "it is marked non-inlinable"
            (< GraalOptions'maximumRecursiveInlining (InliningData''countRecursiveInlining-2 this, method))
                "it exceeds the maximum recursive inlining depth"
            (OptimisticOptimizations''lessOptimisticThan-2 OptimisticOptimizations'ALL, (:optimisticOpts (:context this)))
                "the callee uses less optimistic optimizations than caller"
        )
    )

    (§ method- #_"boolean" InliningData''checkTargetConditions-2 [#_"InliningData" this, #_"ResolvedJavaMethod" method]
        (nil? (InliningData''checkTargetConditionsHelper-2 this, method))
    )

    ;;;
     ; Determines if inlining is possible at the given invoke node.
     ;
     ; @param invoke the invoke that should be inlined
     ; @return an instance of InlineInfo, or nil if no inlining is possible at the given invoke
     ;;
    (§ method- #_"InlineInfo" InliningData''getInlineInfo-2 [#_"InliningData" this, #_"InvokeNode" invoke]
        (when (nil? (InliningUtil'checkInvokeConditions-1 invoke))
            (let [
                #_"MethodCallTargetNode" callTarget (:callTarget invoke)
                #_"ResolvedJavaMethod" targetMethod (CallTargetNode''targetMethod-1 callTarget)
            ]
                (cond
                    (or (= (CallTargetNode''invokeKind-1 callTarget) InvokeKind'Special) (#_"ResolvedJavaMethod" .canBeStaticallyBound targetMethod))
                        (InliningData''getExactInlineInfo-3 this, invoke, targetMethod)
                    (instance? ObjectStamp (:stamp (MethodCallTargetNode''receiver-1 callTarget)))
                        (let [
                            #_"ObjectStamp" receiverStamp (:stamp (MethodCallTargetNode''receiver-1 callTarget))
                        ]
                            (when-not (:always-nil? receiverStamp) ;; => don't inline if receiver is known to be nil
                                (let [
                                    #_"ResolvedJavaType" contextType (InvokeNode''getContextType-1 invoke)
                                    #_"ResolvedJavaType" holder (#_"ResolvedJavaMethod" .getDeclaringClass targetMethod)
                                    holder
                                        (when (some? (AbstractObjectStamp''type-1 receiverStamp)) => holder
                                            ;; the invoke target might be more specific than the holder (happens after inlining:
                                            ;; parameters lose their declared type...)
                                            (let [
                                                #_"ResolvedJavaType" receiverType (AbstractObjectStamp''type-1 receiverStamp)
                                            ]
                                                (when (and (some? receiverType) (#_"ResolvedJavaType" .isAssignableFrom holder, receiverType)) => holder
                                                    (let [
                                                        holder receiverType
                                                    ]
                                                        (when (AbstractObjectStamp''isExactType-1 receiverStamp)
                                                            (let [
                                                                #_"ResolvedJavaMethod" resolvedMethod (#_"ResolvedJavaType" .resolveConcreteMethod holder, targetMethod, contextType)
                                                            ]
                                                                (when (some? resolvedMethod)
                                                                    (§ return (InliningData''getExactInlineInfo-3 this, invoke, resolvedMethod))
                                                                )
                                                            )
                                                        )
                                                        holder
                                                    )
                                                )
                                            )
                                        )
                                ]
                                    (when (#_"ResolvedJavaType" .isArray holder)
                                        ;; arrays can be treated as objects
                                        (let [
                                            #_"ResolvedJavaMethod" resolvedMethod (#_"ResolvedJavaType" .resolveConcreteMethod holder, targetMethod, contextType)
                                        ]
                                            (when (some? resolvedMethod)
                                                (InliningData''getExactInlineInfo-3 this, invoke, resolvedMethod)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                )
            )
        )
    )

    (§ method- #_"InlineInfo" InliningData''getExactInlineInfo-3 [#_"InliningData" this, #_"InvokeNode" invoke, #_"ResolvedJavaMethod" targetMethod]
        (when (InliningData''checkTargetConditions-2 this, targetMethod)
            (ExactInlineInfo'new-2 invoke, targetMethod)
        )
    )

    (§ method- #_"void" InliningData''doInline-3 [#_"InliningData" this, #_"CallsiteHolderExplorable" callerCallsiteHolder, #_"MethodInvocation" calleeInvocation]
        (let [
            #_"Graph" callerGraph (CallsiteHolderExplorable''graph-1 callerCallsiteHolder)
            #_"InlineInfo" calleeInfo (:callee calleeInvocation)
        ]
            (let [
                #_"EconomicSet<Node>" canonicalizedNodes (EconomicSet/create Equivalence/IDENTITY)
            ]
                (#_"EconomicSet" .addAll canonicalizedNodes, (Node''usages-1 (InlineInfo''invoke-1 calleeInfo)))
                (let [
                    #_"EconomicSet<Node>" parameterUsages (InlineInfo''inline-1 calleeInfo)
                ]
                    (#_"EconomicSet" .addAll canonicalizedNodes, parameterUsages)

                    (let [
                        #_"NodeMark" markBeforeCanonicalization (NodeMark'new-1 callerGraph)
                    ]
                        (CanonicalizerPhase''applyIncremental-4 (:canonicalizer this), callerGraph, (:context this), canonicalizedNodes)

                        ;; process invokes that are possibly created during canonicalization
                        (doseq [#_"Node" newNode (Graph''getNewNodes-2 callerGraph, markBeforeCanonicalization)]
                            (when (instance? InvokeNode newNode)
                                (CallsiteHolderExplorable''pushInvoke-2 callerCallsiteHolder, newNode)
                            )
                        )

                        (CallsiteHolderExplorable''computeProbabilities-1 callerCallsiteHolder)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; This method attempts:
     ;
     ; (1) to inline at the callsite given by {@code calleeInvocation}, where that callsite belongs
     ; to the CallsiteHolderExplorable at the top of the #graphQueue maintained in this class
     ; (2) otherwise, to devirtualize the callsite in question
     ;
     ; @return true iff inlining was actually performed
     ;;
    (§ method- #_"boolean" InliningData''tryToInline-3 [#_"InliningData" this, #_"MethodInvocation" calleeInvocation, #_"int" inliningDepth]
        (let [
            #_"CallsiteHolderExplorable" callerCallsiteHolder (InliningData''currentGraph-1 this)
            #_"InlineInfo" calleeInfo (:callee calleeInvocation)
            #_"Decision" decision (InliningPolicy''isWorthInlining-5 (:inliningPolicy this), HotSpot'replacements, calleeInvocation, inliningDepth, true)
        ]
            (if (:shouldInline decision)
                (do
                    (InliningData''doInline-3 this, callerCallsiteHolder, calleeInvocation)
                    true
                )
                (do
                    (when (OptimisticOptimizations''devirtualizeInvokes-1 (:optimisticOpts (:context this)))
                        (InlineInfo''tryToDevirtualizeInvoke-1 calleeInfo)
                    )
                    false
                )
            )
        )
    )

    ;;;
     ; This method picks one of the callsites belonging to the current CallsiteHolderExplorable.
     ; Provided the callsite qualifies to be analyzed for inlining, this method prepares a new
     ; stack top in InliningData for such callsite, which comprises:
     ;
     ; - preparing a summary of feasible targets, i.e. preparing an InlineInfo
     ; - based on it, preparing the stack top proper which consists of:
     ;
     ; -- one MethodInvocation
     ; -- a CallsiteHolder for each feasible target
     ;
     ; The thus prepared "stack top" is needed by #moveForward() to explore the space of
     ; inlining decisions (each decision one of: backtracking, delving, inlining).
     ;
     ; The InlineInfo used to get things rolling is kept around in the MethodInvocation,
     ; it will be needed in case of inlining.
     ;;
    (§ method- #_"InliningData" InliningData''processNextInvoke-1 [#_"InliningData" this]
        (let [
            #_"CallsiteHolderExplorable" callsiteHolder (InliningData''currentGraph-1 this)
            #_"InvokeNode" invoke (CallsiteHolderExplorable''popInvoke-1 callsiteHolder)
            #_"InlineInfo" info (InliningData''getInlineInfo-2 this, invoke)
        ]
            (when (some? info) => this
                (InlineInfo''populateInlinableElements-4 info, (:context this), (CallsiteHolder''graph-1 (InliningData''currentGraph-1 this)), (:canonicalizer this))
                (let [
                    #_"double" invokeProbability (CallsiteHolderExplorable''invokeProbability-2 callsiteHolder, invoke)
                    #_"double" invokeRelevance (CallsiteHolderExplorable''invokeRelevance-2 callsiteHolder, invoke)
                ]
                    (InliningData''pushInvocationAndGraphs-2 this, (MethodInvocation'new-4 info, invokeProbability, invokeRelevance, (InliningData'freshlyInstantiatedArguments-2 invoke, (:fixedParams callsiteHolder))))
                )
            )
        )
    )

    ;;;
     ; Gets the freshly instantiated arguments.
     ;
     ; A freshly instantiated argument is either:
     ;
     ; (1) an InliningData#isFreshInstantiation(ValueNode)
     ; (2) a fixed-param, i.e. a ParameterNode receiving a freshly instantiated argument
     ;
     ; @return the positions of freshly instantiated arguments in the argument list of the
     ;         {@code invoke}, or nil if no such positions exist.
     ;;
    (§ defn #_"BitSet" InliningData'freshlyInstantiatedArguments-2 [#_"InvokeNode" invoke, #_"EconomicSet<ParameterNode>" fixedParams]
        (loop-when [#_"BitSet" bits nil #_"int" i 0 #_"ISeq" s (seq (CallTargetNode''arguments-1 (:callTarget invoke)))] (some? s) => bits
            (let [
                #_"ValueNode" arg (first s)
                bits
                    (when (or (InliningData'isFreshInstantiation-1 arg) (and (instance? ParameterNode arg) (contains? fixedParams arg))) => bits
                        (let [
                            bits (or bits (BitSet.))
                        ]
                            (#_"BitSet" .set bits, i)
                            bits
                        )
                    )
            ]
                (recur bits (inc i) (next s))
            )
        )
    )

    #_unused
    (§ defn- #_"boolean" InliningData'paramsAndInvokeAreInSameGraph-2 [#_"InvokeNode" invoke, #_"EconomicSet<ParameterNode>" fixedParams]
        (loop-when [#_"ISeq" s (seq fixedParams)] (some? s) => true
            (and (= (:graph (first s)) (:graph invoke))
                (recur (next s))
            )
        )
    )

    #_unused
    (§ method! #_"int" InliningData''graphCount-1 [#_"InliningData" this]
        (#_"ArrayDeque" .size (:graphQueue this))
    )

    (§ method! #_"boolean" InliningData''hasUnprocessedGraphs-1 [#_"InliningData" this]
        (not (#_"ArrayDeque" .isEmpty (:graphQueue this)))
    )

    (§ method- #_"CallsiteHolder" InliningData''currentGraph-1 [#_"InliningData" this]
        (#_"ArrayDeque" .peek (:graphQueue this))
    )

    (§ method- #_"void" InliningData''popGraph-1 [#_"InliningData" this]
        (#_"ArrayDeque" .pop (:graphQueue this))
        nil
    )

    (§ method- #_"void" InliningData''popGraphs-2 [#_"InliningData" this, #_"int" n]
        (dotimes [#_"int" i n]
            (#_"ArrayDeque" .pop (:graphQueue this))
        )
        nil
    )

    (§ method- #_"MethodInvocation" InliningData''currentInvocation-1 [#_"InliningData" this]
        (#_"ArrayDeque" .peekFirst (:invocationQueue this))
    )

    (§ method- #_"InliningData" InliningData''pushInvocationAndGraphs-2 [#_"InliningData" this, #_"MethodInvocation" methodInvocation]
        (#_"ArrayDeque" .addFirst (:invocationQueue this), methodInvocation)
        (let [
            #_"int" n (InlineInfo''numberOfMethods-1 (:callee methodInvocation))
            this (assoc this :maxGraphs (+ (:maxGraphs this) n))
        ]
            (dotimes [#_"int" i n]
                (#_"ArrayDeque" .push (:graphQueue this), (MethodInvocation''buildCallsiteHolderForElement-2 methodInvocation, i))
            )
            this
        )
    )

    (§ method- #_"InliningData" InliningData''popInvocation-1 [#_"InliningData" this]
        (let [
            this (assoc this :maxGraphs (- (:maxGraphs this) (InlineInfo''numberOfMethods-1 (:callee (#_"ArrayDeque" .peekFirst (:invocationQueue this))))))
        ]
            (#_"ArrayDeque" .removeFirst (:invocationQueue this))
            this
        )
    )

    (§ method! #_"int" InliningData''countRecursiveInlining-2 [#_"InliningData" this, #_"ResolvedJavaMethod" method]
        (loop-when-recur [#_"int" n 0 #_"ISeq" s (seq (:graphQueue this))]
                         (some? s)
                         [(if (= method (CallsiteHolder''method-1 (first s))) (inc n) n) (next s)]
                      => n
        )
    )

    (§ method! #_"int" InliningData''inliningDepth-1 [#_"InliningData" this]
        (dec (#_"ArrayDeque" .size (:invocationQueue this)))
    )

    #_unused
    (§ method- #_"boolean" InliningData''contains-2 [#_"InliningData" this, #_"Graph" graph]
        (loop [#_"ISeq" s (seq (:graphQueue this))] (and (some? s) (or (= (CallsiteHolder''graph-1 (first s)) graph) (recur (next s)))))
    )

    ;;;
     ; The stack realized by InliningData grows and shrinks as choices are made among the
     ; alternatives below:
     ;
     ; (1) not worth inlining: pop stack top, which comprises:
     ;
     ; - pop any remaining graphs not yet delved into
     ; - pop the current invocation
     ;
     ; (2) {@link #processNextInvoke() delve} into one of the callsites hosted in the current graph,
     ; such callsite is explored next by #moveForward()
     ;
     ; (3) {@link #tryToInline(MethodInvocation, int) try to inline}: move past the current graph
     ; (remove it from the topmost element)
     ;
     ; - if that was the last one then {@link #tryToInline(MethodInvocation, int) try to inline}
     ; the callsite under consideration (i.e. the "current invocation")
     ; - whether inlining occurs or not, that callsite is removed from the top of InliningData
     ;
     ; Some facts about the alternatives above:
     ;
     ; - the first step amounts to backtracking, the 2nd one to depth-search, and the 3rd one also
     ; involves backtracking (however possibly after inlining)
     ; - the choice of abandon-and-backtrack or delve-into depends on
     ; InliningPolicy#isWorthInlining and InliningPolicy#continueInlining
     ; - the 3rd choice is picked whenever none of the previous choices are made
     ;
     ; @return true iff inlining was actually performed
     ;;
    (§ method! #_"boolean" InliningData''moveForward-1 [#_"InliningData" this]
        (let [
            #_"MethodInvocation" currentInvocation (InliningData''currentInvocation-1 this)
        ]
            (cond
                (and (not (MethodInvocation''isRoot-1 currentInvocation)) (not (:shouldInline (InliningPolicy''isWorthInlining-5 (:inliningPolicy this), HotSpot'replacements, currentInvocation, (InliningData''inliningDepth-1 this), false))))
                    (do
                        (InliningData''popGraphs-2 this, (- (MethodInvocation''totalGraphs-1 currentInvocation) (:processedGraphs currentInvocation)))
                        (§ ass! this (InliningData''popInvocation-1 this))
                        false
                    )
                (and (CallsiteHolder''hasRemainingInvokes-1 (InliningData''currentGraph-1 this)) (InliningPolicy''continueInlining-2 (:inliningPolicy this), (CallsiteHolder''graph-1 (InliningData''currentGraph-1 this))))
                    (do
                        (§ ass! this (InliningData''processNextInvoke-1 this))
                        false
                    )
                :else
                    (do
                        (InliningData''popGraph-1 this)
                        (and (not (MethodInvocation''isRoot-1 currentInvocation))
                            (do
                                ;; try to inline
                                (§ ass! currentInvocation (MethodInvocation''incrementProcessedGraphs-1 currentInvocation))
                                (and (= (:processedGraphs currentInvocation) (MethodInvocation''totalGraphs-1 currentInvocation))
                                    (do
                                        ;; "all of currentInvocation's graphs processed" amounts to
                                        ;; "all concrete methods that come into question already had the callees they contain analyzed for inlining"
                                        (§ ass! this (InliningData''popInvocation-1 this))
                                        (and (InliningData''tryToInline-3 this, currentInvocation, (inc (InliningData''inliningDepth-1 this)))
                                            ;; report real progress only if we inline into the root graph
                                            (= (CallsiteHolder''graph-1 (InliningData''currentGraph-1 this)) (:rootGraph this))
                                        )
                                    )
                                )
                            )
                        )
                    )
            )
        )
    )
)

;;;
 ; Given a graph, visit all fixed nodes in dominator-based order, collecting in the process
 ; the InvokeNodes with MethodCallTargetNode. Such list of callsites is returned by #apply().
 ;;
(final-ns InliningIterator
    (§ final #_"StartNode" :start nil)
    (§ final #_"Deque<FixedNode>" :nodeQueue nil)
    (§ final #_"NodeBitMap" :queuedNodes nil)

    (§ defn #_"InliningIterator" InliningIterator'new-1 [#_"Graph" graph]
        (let [
            #_"InliningIterator" this (Object.)
            this (assoc this :start (:start graph))
            this (assoc this :nodeQueue (ArrayDeque.))
            this (assoc this :queuedNodes (NodeBitMap'new-1 graph))
        ]
            this
        )
    )

    (§ method! #_"LinkedList<InvokeNode>" InliningIterator''apply-1 [#_"InliningIterator" this]
        (let [
            #_"LinkedList<InvokeNode>" invokes (LinkedList.)
        ]
            (InliningIterator''forcedQueue-2 this, (:start this))

            (loop-when-recur [#_"FixedNode" node (InliningIterator''nextQueuedNode-1 this)] (some? node) [(InliningIterator''nextQueuedNode-1 this)]
                (if (and (instance? InvokeNode node) (instance? MethodCallTargetNode (:callTarget node)))
                    (do
                        (when-not (= node (:start this))
                            (#_"LinkedList" .addLast invokes, node)
                        )
                        (InliningIterator''queueSuccessors-2 this, node)
                    )
                    (condp instance? node
                        LoopBeginNode     (InliningIterator''queueSuccessors-2 this, node)
                        LoopEndNode       nil ;; nothing to do
                        AbstractMergeNode (InliningIterator''queueSuccessors-2 this, node)
                        FixedWithNextNode (InliningIterator''queueSuccessors-2 this, node)
                        EndNode           (InliningIterator''queueMerge-2 this, node)
                        ControlSinkNode   nil ;; nothing to do
                        ControlSplitNode  (InliningIterator''queueSuccessors-2 this, node)
                        nil
                    )
                )
            )

            invokes
        )
    )

    (§ method- #_"void" InliningIterator''queueSuccessors-2 [#_"InliningIterator" this, #_"FixedNode" x]
        (doseq [#_"Node" node (Node''successors-1 x)]
            (InliningIterator''queue-2 this, node)
        )
        nil
    )

    (§ method- #_"void" InliningIterator''queue-2 [#_"InliningIterator" this, #_"Node" node]
        (when (and (some? node) (not (NodeBitMap''isMarked-2 (:queuedNodes this), node)))
            (InliningIterator''forcedQueue-2 this, node)
        )
        nil
    )

    (§ method- #_"void" InliningIterator''forcedQueue-2 [#_"InliningIterator" this, #_"Node" node]
        (NodeBitMap''mark-2 (:queuedNodes this), node)
        (#_"Deque" .addFirst (:nodeQueue this), node)
        nil
    )

    (§ method- #_"FixedNode" InliningIterator''nextQueuedNode-1 [#_"InliningIterator" this]
        (when (seq (:nodeQueue this))
            (#_"Deque" .removeFirst (:nodeQueue this))
        )
    )

    (§ method- #_"void" InliningIterator''queueMerge-2 [#_"InliningIterator" this, #_"AbstractEndNode" end]
        (let [
            #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 end)
        ]
            (when (and (not (NodeBitMap''isMarked-2 (:queuedNodes this), merge)) (InliningIterator''visitedAllEnds-2 this, merge))
                (NodeBitMap''mark-2 (:queuedNodes this), merge)
                (#_"Deque" .add (:nodeQueue this), merge)
            )
        )
        nil
    )

    (§ method- #_"boolean" InliningIterator''visitedAllEnds-2 [#_"InliningIterator" this, #_"AbstractMergeNode" merge]
        (loop-when [#_"int" i 0] (< i (AbstractMergeNode''forwardEndCount-1 merge)) => true
            (and (NodeBitMap''isMarked-2 (:queuedNodes this), (AbstractMergeNode''forwardEndAt-2 merge, i))
                (recur (inc i))
            )
        )
    )

    #_unused
    (§ defn- #_"int" InliningIterator'count-1 [#_"Iterable<InvokeNode>" invokes]
        (let [
            #_"Iterator<InvokeNode>" it (#_"Iterable" .iterator invokes)
        ]
            (loop-when-recur [#_"int" n 0] (#_"Iterator" .hasNext it) [(inc n)] => n
                (#_"Iterator" .next it)
            )
        )
    )
)

;;;
 ; An instance of this class denotes a callsite being analyzed for inlining.
 ;
 ; Each element of the InliningData stack contains one such instance, the accompanying
 ; CallsiteHolders in that element represent feasible targets for the callsite in question.
 ;;
(final-ns MethodInvocation
    (§ final #_"InlineInfo" :callee nil)
    (§ final #_"double" :probability 0.0)
    (§ final #_"double" :relevance 0.0)

    (§ mutable #_"int" :processedGraphs 0)

    ;;;
     ; The immutable positions of freshly instantiated arguments (i.e. positions in {@code callee.invoke.callTarget.arguments}).
     ;
     ; A freshly instantiated argument is either:
     ;
     ; (1) an InliningData#isFreshInstantiation(ValueNode)
     ; (2) a fixed-param of the graph containing the callsite (i.e. of {@code callee.graph()} that contains {@code callee.invoke})
     ;
     ; Given those positions, the CallsiteHolderExplorable instantiated in #buildCallsiteHolderForElement(int) can determine
     ; which of <i>its</i> parameters are fixed.
     ;;
    (§ final #_"BitSet" :freshlyInstantiatedArguments nil)

    (§ final #_"int" :sizeFreshArgs 0)

    (§ defn #_"MethodInvocation" MethodInvocation'new-4 [#_"InlineInfo" info, #_"double" probability, #_"double" relevance, #_"BitSet" freshlyInstantiatedArguments]
        (let [
            #_"MethodInvocation" this (Object.)
            this (assoc this :callee info)
            this (assoc this :probability probability)
            this (assoc this :relevance relevance)
            this (assoc this :freshlyInstantiatedArguments freshlyInstantiatedArguments)
            this (assoc this :sizeFreshArgs (if (some? freshlyInstantiatedArguments) (#_"BitSet" .cardinality freshlyInstantiatedArguments) 0))
        ]
            this
        )
    )

    (§ method! #_"MethodInvocation" MethodInvocation''incrementProcessedGraphs-1 [#_"MethodInvocation" this]
        (update this :processedGraphs inc)
    )

    (§ method! #_"int" MethodInvocation''totalGraphs-1 [#_"MethodInvocation" this]
        (InlineInfo''numberOfMethods-1 (:callee this))
    )

    (§ method! #_"boolean" MethodInvocation''isRoot-1 [#_"MethodInvocation" this]
        (nil? (:callee this))
    )

    (§ method! #_"CallsiteHolder" MethodInvocation''buildCallsiteHolderForElement-2 [#_"MethodInvocation" this, #_"int" index]
        (let [
            #_"Inlineable" elem (InlineInfo''inlineableElementAt-2 (:callee this), index)
            #_"double" invokeProbability (* (:probability this) (InlineInfo''probabilityAt-2 (:callee this), index))
            #_"double" invokeRelevance (* (:relevance this) (InlineInfo''relevanceAt-2 (:callee this), index))
        ]
            (CallsiteHolderExplorable'new-5 (:graph elem), invokeProbability, invokeRelevance, (:freshlyInstantiatedArguments this), nil)
        )
    )
)

(final-ns IterativeConditionalEliminationPhase (§ extends BasePhase #_"<PhaseContext>")
    (def- #_"int" IterativeConditionalEliminationPhase'MAX_ITERATIONS 256)

    (§ final #_"CanonicalizerPhase" :canonicalizer nil)
    (§ final #_"boolean" :fullSchedule false)

    (§ defn #_"IterativeConditionalEliminationPhase" IterativeConditionalEliminationPhase'new-2 [#_"CanonicalizerPhase" canonicalizer, #_"boolean" fullSchedule]
        (let [
            #_"IterativeConditionalEliminationPhase" this (BasePhase'new-0)
            this (assoc this :canonicalizer canonicalizer)
            this (assoc this :fullSchedule fullSchedule)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" IterativeConditionalEliminationPhase''run-3 [#_"IterativeConditionalEliminationPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (let [
            #_"HashSetNodeEventListener" listener (HashSetNodeEventListener''exclude-2 (HashSetNodeEventListener'new-0), NodeEvent'NODE_ADDED)
        ]
            (loop [#_"int" iteration 0]
                (try (§ with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                    (BasePhase''apply-3 (ConditionalEliminationPhase'new-1 (:fullSchedule this)), graph, context)
                )
                (when (seq (:nodes listener))
                    (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                        (when (instance? Simplifiable node)
                            (#_"EconomicSet" .add (:nodes listener), node)
                        )
                    )
                    (CanonicalizerPhase''applyIncremental-4 (:canonicalizer this), graph, context, (:nodes listener))
                    (#_"EconomicSet" .clear (:nodes listener))
                    (let [
                        iteration (inc iteration)
                    ]
                        (when (< IterativeConditionalEliminationPhase'MAX_ITERATIONS iteration)
                            (throw! (str "number of iterations in ConditionalEliminationPhase phase exceeds " IterativeConditionalEliminationPhase'MAX_ITERATIONS))
                        )
                        (recur iteration)
                    )
                )
            )
        )
        nil
    )
)

(final-ns LockEliminationPhase (§ extends Phase)
    (§ defn #_"LockEliminationPhase" LockEliminationPhase'new-0 []
        (Phase'new-0)
    )

    #_unused
    (§ override! #_"void" LockEliminationPhase''run-2 [#_"LockEliminationPhase" this, #_"Graph" graph]
        (doseq [#_"MonitorExitNode" monitorExitNode (Graph''getNodes-2 graph, MonitorExitNode'TYPE)]
            (let [
                #_"FixedNode" next (:next monitorExitNode)
            ]
                (when (or (instance? MonitorEnterNode next) (instance? RawMonitorEnterNode next))
                    ;; should never happen, osr monitor enters are always direct successors of the graph start
                    (let [
                        #_"AccessMonitorNode" monitorEnterNode next
                    ]
                        (when (= (GraphUtil'unproxify-1 (:object monitorEnterNode)) (GraphUtil'unproxify-1 (:object monitorExitNode)))
                            ;; We've coarsened the lock so use the same monitor id for the whole region,
                            ;; otherwise the monitor operations appear to be unrelated.
                            (let [
                                #_"MonitorIdNode" enterId (:monitorId monitorEnterNode)
                                #_"MonitorIdNode" exitId (:monitorId monitorExitNode)
                            ]
                                (when-not (= enterId exitId)
                                    (§ ass! enterId (Node''replaceAndDelete-2 enterId, exitId))
                                )
                                (GraphUtil'removeFixedWithUnusedInputs-1 monitorEnterNode)
                                (GraphUtil'removeFixedWithUnusedInputs-1 monitorExitNode)
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; Adds safepoints to loops.
 ;;
(final-ns LoopSafepointInsertionPhase (§ extends Phase)
    (§ defn #_"LoopSafepointInsertionPhase" LoopSafepointInsertionPhase'new-0 []
        (Phase'new-0)
    )

    #_unused
    (§ override! #_"void" LoopSafepointInsertionPhase''run-2 [#_"LoopSafepointInsertionPhase" this, #_"Graph" graph]
        (when GraalOptions'genLoopSafepoints
            (doseq [#_"LoopBeginNode" loopBeginNode (Graph''getNodes-2 graph, LoopBeginNode'TYPE)]
                (doseq [#_"LoopEndNode" loopEndNode (LoopBeginNode''loopEnds-1 loopBeginNode)]
                    (when (:canSafepoint loopEndNode)
                        (Graph''addBeforeFixed-3 graph, loopEndNode, (Graph''add-2 graph, (SafepointNode'new-0)))
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; Processes all Lowerable nodes to do their lowering.
 ;;
(final-ns LoweringPhase (§ extends BasePhase #_"<PhaseContext>")
    (§ final #_"CanonicalizerPhase" :canonicalizer nil)
    (§ final #_"LoweringStage" :loweringStage nil)

    (§ defn #_"LoweringPhase" LoweringPhase'new-2 [#_"CanonicalizerPhase" canonicalizer, #_"LoweringStage" loweringStage]
        (let [
            #_"LoweringPhase" this (BasePhase'new-0)
            this (assoc this :canonicalizer canonicalizer)
            this (assoc this :loweringStage loweringStage)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" LoweringPhase''run-3 [#_"LoweringPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (let [
            #_"IncrementalCanonicalizerPhase<PhaseContext>" incrementalCanonicalizer (IncrementalCanonicalizerPhase'new-1 (:canonicalizer this))
        ]
            (PhaseSuite''appendPhase-2 incrementalCanonicalizer, (LoweringRound'new-2 this, context))
            (BasePhase''apply-3 incrementalCanonicalizer, graph, context)
        )
        nil
    )

    ;;;
     ; This state-machine resembles the following recursion:
     ;
     ; void processBlock(Block block) {
     ;     preprocess();
     ;     // Process always reached block first.
     ;     Block alwaysReachedBlock = block.getPostdominator();
     ;     if (alwaysReachedBlock != null && alwaysReachedBlock.getDominator() == block) {
     ;         processBlock(alwaysReachedBlock);
     ;     }
     ;
     ;     // Now go for the other dominators.
     ;     for (Block dominated : block.getDominated()) {
     ;         if (dominated != alwaysReachedBlock) {
     ;             assert dominated.getDominator() == block;
     ;             processBlock(dominated);
     ;         }
     ;     }
     ;     postprocess();
     ; }
     ;
     ; This is necessary, as the recursive implementation quickly exceed the stack depth on SPARC.
     ;
     ; @param rootFrame contains the starting block.
     ;;
    (§ defn #_"void" LoweringPhase'processBlock-1 [#_"ProcessFrame" rootFrame]
        (loop-when [#_"ProcessBlockState" state ProcessBlockState'ST_PROCESS #_"ProcessFrame" frame rootFrame] (some? frame)
            (let [
                [state frame]
                    (condp = state
                        ProcessBlockState'ST_PROCESS
                            (do
                                (§ ass! frame (ProcessFrame''preprocess-1 frame))
                                [ProcessBlockState'ST_ENTER_ALWAYS_REACHED frame]
                            )
                        ProcessBlockState'ST_PROCESS_ALWAYS_REACHED
                            (do
                                (§ ass! frame (ProcessFrame''preprocess-1 frame))
                                [ProcessBlockState'ST_ENTER frame]
                            )
                        ProcessBlockState'ST_ENTER_ALWAYS_REACHED
                            (if (and (some? (:alwaysReachedBlock frame)) (= (:dominator (:alwaysReachedBlock frame)) (:block frame)))
                                [ProcessBlockState'ST_PROCESS (ProcessFrame''enterAlwaysReached-2 frame, (:alwaysReachedBlock frame))]
                                [ProcessBlockState'ST_ENTER frame]
                            )
                        ProcessBlockState'ST_ENTER
                            (let [
                                #_"Block" block (:dominated frame)
                            ]
                                (when (some? block) => [ProcessBlockState'ST_LEAVE frame]
                                    (§ ass! frame (assoc frame :dominated (:dominatedSibling block)))
                                    (let [
                                        block
                                            (when (= block (:alwaysReachedBlock frame)) => block
                                                (let [
                                                    block (:dominated frame)
                                                ]
                                                    (when (some? block)
                                                        (§ ass! frame (assoc frame :dominated (:dominatedSibling block)))
                                                        block
                                                    )
                                                )
                                            )
                                    ]
                                        (when (some? block) => [ProcessBlockState'ST_LEAVE frame]
                                            [ProcessBlockState'ST_PROCESS (ProcessFrame''enter-2 frame, block)]
                                        )
                                    )
                                )
                            )
                        ProcessBlockState'ST_LEAVE
                            (do
                                (ProcessFrame''postprocess-1 frame)
                                [ProcessBlockState'ST_ENTER (:parent frame)]
                            )
                    )
            ]
                (recur state frame)
            )
        )
        nil
    )

    #_unused
    (§ defn #_"void" LoweringPhase'processBlockBounded-1 [#_"ProcessFrame" rootFrame]
        (loop-when [#_"ProcessBlockState" state ProcessBlockState'ST_PROCESS #_"ProcessFrame" frame rootFrame] (some? frame)
            (let [
                [state frame]
                    (condp = state
                        ProcessBlockState'ST_PROCESS
                            (do
                                (§ ass! frame (ProcessFrame''preprocess-1 frame))
                                [ProcessBlockState'ST_ENTER_ALWAYS_REACHED frame]
                            )
                        ProcessBlockState'ST_PROCESS_ALWAYS_REACHED
                            (do
                                (§ ass! frame (ProcessFrame''preprocess-1 frame))
                                [ProcessBlockState'ST_ENTER frame]
                            )
                        ProcessBlockState'ST_ENTER_ALWAYS_REACHED
                            (when (and (some? (:alwaysReachedBlock frame)) (= (:dominator (:alwaysReachedBlock frame)) (:block frame))) => [ProcessBlockState'ST_ENTER frame]
                                (let [
                                    #_"ProcessFrame" continueRecur (ProcessFrame''enterAlwaysReached-2 frame, (:alwaysReachedBlock frame))
                                ]
                                    (when (nil? continueRecur) => [ProcessBlockState'ST_PROCESS continueRecur]
                                        ;; stop recursion here
                                        (ProcessFrame''postprocess-1 frame)
                                        [ProcessBlockState'ST_ENTER (:parent frame)]
                                    )
                                )
                            )
                        ProcessBlockState'ST_ENTER
                            (let [
                                #_"Block" block (:dominated frame)
                            ]
                                (when (some? block) => [ProcessBlockState'ST_LEAVE frame]
                                    (§ ass! frame (assoc frame :dominated (:dominatedSibling block)))
                                    (let [
                                        block
                                            (when (= block (:alwaysReachedBlock frame)) => block
                                                (let [
                                                    block (:dominated frame)
                                                ]
                                                    (when (some? block)
                                                        (§ ass! frame (assoc frame :dominated (:dominatedSibling block)))
                                                        block
                                                    )
                                                )
                                            )
                                    ]
                                        (when (some? block) => [ProcessBlockState'ST_LEAVE frame]
                                            (let [
                                                #_"ProcessFrame" continueRecur (ProcessFrame''enter-2 frame, block)
                                            ]
                                                (when (nil? continueRecur) => [ProcessBlockState'ST_PROCESS continueRecur]
                                                    ;; stop recursion here
                                                    (ProcessFrame''postprocess-1 frame)
                                                    [ProcessBlockState'ST_ENTER (:parent frame)]
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        ProcessBlockState'ST_LEAVE
                            (do
                                (ProcessFrame''postprocess-1 frame)
                                [ProcessBlockState'ST_ENTER (:parent frame)]
                            )
                    )
            ]
                (recur state frame)
            )
        )
        nil
    )
)

;;;
 ; @anno LoweringPhase.DummyGuardHandle
 ;;
(final-ns DummyGuardHandle (§ extends ValueNode) (§ implements GuardedNode)
    (§ def #_"NodeClass<DummyGuardHandle>" DummyGuardHandle'TYPE (NodeClass'create-1 DummyGuardHandle))

    ; @Input(InputType'Guard)
    (§ mutable #_"GuardingNode" :guard nil)

    (§ defn #_"DummyGuardHandle" DummyGuardHandle'new-1 [#_"GuardingNode" guard]
        (let [
            #_"DummyGuardHandle" this (ValueNode'new-2 DummyGuardHandle'TYPE, (StampFactory'forVoid-0))
            this (assoc this :guard guard)
        ]
            this
        )
    )

    (§ override! #_"GuardingNode" DummyGuardHandle''getGuard-1 [#_"DummyGuardHandle" this]
        (:guard this)
    )

    #_unused
    (§ override! #_"void" DummyGuardHandle''setGuard-2 [#_"DummyGuardHandle" this, #_"GuardingNode" guard]
        (Node''updateUsages-3 this, (:guard this), guard)
        (§ ass! this (assoc this :guard guard))
        nil
    )
)

(final-ns LoweringTool
    (§ final #_"LoweringPhase" :phase nil)

    (§ final #_"PhaseContext" :context nil)
    (§ final #_"NodeBitMap" :activeGuards nil)
    (§ mutable #_"AnchoringNode" :guardAnchor nil)
    (§ mutable #_"FixedWithNextNode" :lastFixedNode nil)

    (§ defn #_"LoweringTool" LoweringTool'new-5 [#_"LoweringPhase" phase, #_"PhaseContext" context, #_"AnchoringNode" guardAnchor, #_"NodeBitMap" activeGuards, #_"FixedWithNextNode" lastFixedNode]
        (let [
            #_"LoweringTool" this (Object.)
            this (assoc this :phase phase)
            this (assoc this :context context)
            this (assoc this :guardAnchor guardAnchor)
            this (assoc this :activeGuards activeGuards)
            this (assoc this :lastFixedNode lastFixedNode)
        ]
            this
        )
    )

    (§ method! #_"GuardingNode" LoweringTool''createGuard-5 [#_"LoweringTool" this, #_"FixedNode" before, #_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action]
        (LoweringTool''createGuard-7 this, before, logic, reason, action, JavaConstant/NULL_POINTER, false)
    )

    (§ method! #_"GuardingNode" LoweringTool''createGuard-7 [#_"LoweringTool" this, #_"FixedNode" before, #_"LogicNode" logic, #_"DeoptimizationReason" reason, #_"DeoptimizationAction" action, #_"JavaConstant" speculation, #_"boolean" negated?]
        (let [
            #_"Graph" graph (:graph before)
        ]
            (when GraalOptions'optEliminateGuards
                (loop-when [#_"ISeq" s (seq (Node''usages-1 logic))] (some? s)
                    (let [
                        #_"Node" usage (first s)
                    ]
                        (if (and (not (NodeBitMap''isNew-2 (:activeGuards this), usage)) (NodeBitMap''isMarked-2 (:activeGuards this), usage) (= (:negated? usage) negated?))
                            (§ return usage)
                            (recur (next s))
                        )
                    )
                )
            )
            (if (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph logic)))
                (let [
                    #_"GuardNode" newGuard (Graph''add-2 graph, (GuardNode'new-6 logic, (:guardAnchor this), reason, action, negated?, speculation))
                ]
                    (when GraalOptions'optEliminateGuards
                        (§ ass! (:activeGuards this) (NodeBitMap''markAndGrow-2 (:activeGuards this), newGuard))
                    )
                    newGuard
                )
                (let [
                    #_"FixedGuardNode" fixedGuard (Graph''add-2 graph, (FixedGuardNode'new-5 logic, reason, action, speculation, negated?))
                ]
                    (Graph''addBeforeFixed-3 graph, before, fixedGuard)
                    (let [
                        #_"DummyGuardHandle" handle (Graph''add-2 graph, (DummyGuardHandle'new-1 fixedGuard))
                    ]
                        (FixedGuardNode''lower-2 fixedGuard, this)
                        (let [
                            #_"GuardingNode" result (DummyGuardHandle''getGuard-1 handle)
                        ]
                            (Node''safeDelete-1 handle)
                            result
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Sets the closest fixed node preceding the node currently being lowered.
     ;;
    (§ method #_"void" LoweringTool''setLastFixedNode-2 [#_"LoweringTool" this, #_"FixedWithNextNode" n]
        (§ ass! this (assoc this :lastFixedNode n))
        nil
    )
)

;;;
 ; @anno LoweringPhase.LoweringRound
 ;;
(final-ns LoweringRound (§ extends Phase)
    (§ final #_"LoweringPhase" :phase nil)
    (§ final #_"PhaseContext" :context nil)

    (§ final #_"SchedulePhase" :schedulePhase (SchedulePhase'new-0))
    (§ mutable #_"ScheduleResult" :schedule nil)

    (§ defn- #_"LoweringRound" LoweringRound'new-2 [#_"LoweringPhase" phase, #_"PhaseContext" context]
        (let [
            #_"LoweringRound" this (Phase'new-0)
            this (assoc this :phase phase)
            this (assoc this :context context)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" LoweringRound''run-2 [#_"LoweringRound" this, #_"Graph" graph]
        (Phase''apply-2 (:schedulePhase this), graph)
        (§ ass! this (assoc this :schedule (:lastSchedule graph)))
        (ControlFlowGraph''computePostdominators-1 (:cfg (:schedule this)))
        (let [
            #_"Block" startBlock (ControlFlowGraph''getStartBlock-1 (:cfg (:schedule this)))
        ]
            (LoweringPhase'processBlock-1 (ProcessFrame'new-5 nil, this, startBlock, (NodeBitMap'new-1 graph), (:beginNode startBlock)))
        )
        nil
    )

    (§ method- #_"AnchoringNode" LoweringRound''process-4 [#_"LoweringRound" this, #_"Block" block, #_"NodeBitMap" activeGuards, #_"AnchoringNode" startAnchor]
        ;; Lower the instructions of this block.
        (let [
            #_"LoweringTool" lowerer
                (loop-when [lowerer (LoweringTool'new-5 (:phase this), (:context this), startAnchor, activeGuards, (:beginNode block)) #_"ISeq" s (seq (ScheduleResult''nodesFor-2 (:schedule this), block))] (some? s) => lowerer
                    (let [
                        #_"Node" node (first s)
                    ]
                        ;; => can happen when previous lowerings have deleted nodes
                        (when-not (Node''isDeleted-1 node) => (recur lowerer (next s))
                            ;; Cache the next node to be able to reconstruct the previous of the next node after lowering.
                            (let [
                                #_"FixedNode" nextNode (:next (if (instance? FixedWithNextNode node) node (:lastFixedNode lowerer)))
                            ]
                                (when (instance? Lowerable node)
                                    (Lowerable''lower-2 node, lowerer)
                                    (when (Node''isDeleted-1 (:guardAnchor lowerer))
                                        ;; TODO nextNode could be deleted but this is not currently supported
                                        (§ ass! lowerer (assoc lowerer :guardAnchor (AbstractBeginNode'prevBegin-1 nextNode)))
                                    )
                                )

                                ;; => can happen when the rest of the block is killed by lowering (e.g. by an unconditional deopt)
                                (when (Node''isAlive-1 nextNode) => lowerer
                                    (let [
                                        #_"Node" predecessor (:predecessor nextNode)
                                        predecessor
                                            (when-not (instance? FixedWithNextNode predecessor) => predecessor
                                                ;; Insert begin node, to have a valid last fixed for next lowerable node.
                                                ;; This is about lowering a FixedWithNextNode to a control split while this
                                                ;; FixedWithNextNode is followed by some kind of BeginNode.
                                                ;; For example the when a FixedGuard followed by a loop exit is lowered to
                                                ;; a control-split + deopt.
                                                (let [
                                                    #_"AbstractBeginNode" begin (Graph''add-2 (:graph node), (BeginNode'new-0))
                                                ]
                                                    (Node''replaceFirstSuccessor-3 predecessor, nextNode, begin)
                                                    (§ ass! begin (FixedWithNextNode''setNext-2 begin, nextNode))
                                                    begin
                                                )
                                            )
                                    ]
                                        (LoweringTool''setLastFixedNode-2 lowerer, predecessor)
                                        (recur lowerer (next s))
                                    )
                                )
                            )
                        )
                    )
                )
        ]
            (:guardAnchor lowerer)
        )
    )

    ;;;
     ; Gets all usages of a floating, lowerable node that are unscheduled.
     ;
     ; Given that the lowering of such nodes may introduce fixed nodes, they must be lowered in
     ; the context of a usage that dominates all other usages. The fixed nodes resulting from
     ; lowering are attached to the fixed node context of the dominating usage. This ensures the
     ; post-lowering graph still has a valid schedule.
     ;
     ; @param node a Lowerable node
     ;;
    #_unused
    (§ method- #_"Collection<Node>" LoweringRound''getUnscheduledUsages-2 [#_"LoweringRound" this, #_"Node" node]
        (let [
            #_"List<Node>" unscheduledUsages (ArrayList.)
        ]
            (when (instance? FloatingNode node)
                (doseq [#_"Node" usage (Node''usages-1 node)]
                    (when (and (instance? ValueNode usage) (not (instance? PhiNode usage)) (not (instance? ProxyNode usage)))
                        (when (or (NodeMap''isNew-2 (:nodeToBlock (:cfg (:schedule this))), usage) (nil? (ControlFlowGraph''blockFor-2 (:cfg (:schedule this)), usage)))
                            (#_"List" .add unscheduledUsages, usage)
                        )
                    )
                )
            )
            unscheduledUsages
        )
    )
)

;;;
 ; @anno LoweringPhase.ProcessBlockState
 ;;
(value-ns ProcessBlockState
    (§ enum ProcessBlockState'ST_ENTER)
    (§ enum ProcessBlockState'ST_PROCESS)
    (§ enum ProcessBlockState'ST_ENTER_ALWAYS_REACHED)
    (§ enum ProcessBlockState'ST_LEAVE)
    (§ enum ProcessBlockState'ST_PROCESS_ALWAYS_REACHED)
)

;;;
 ; @anno LoweringPhase.LoweringRound.ProcessFrame
 ;;
(final-ns ProcessFrame
    (§ final #_"ProcessFrame" :parent nil)
    (§ final #_"Block" :block nil)
    (§ mutable #_"Block" :dominated nil)
    (§ final #_"Block" :alwaysReachedBlock nil)

    (§ final #_"LoweringRound" :round nil)

    (§ final #_"NodeBitMap" :activeGuards nil)
    (§ mutable #_"AnchoringNode" :anchor nil)

    (§ defn #_"ProcessFrame" ProcessFrame'new-5 [#_"ProcessFrame" parent, #_"LoweringRound" round, #_"Block" block, #_"NodeBitMap" activeGuards, #_"AnchoringNode" anchor]
        (let [
            #_"ProcessFrame" this (Object.)
            this (assoc this :parent parent)
            this (assoc this :block block)
            this (assoc this :alwaysReachedBlock (:postdominator block))
            this (assoc this :dominated (:firstDominated block))
            this (assoc this :round round)
            this (assoc this :activeGuards activeGuards)
            this (assoc this :anchor anchor)
        ]
            this
        )
    )

    (§ method! #_"ProcessFrame" ProcessFrame''preprocess-1 [#_"ProcessFrame" this]
        (assoc this :anchor (LoweringRound''process-4 (:round this), (:block this), (:activeGuards this), (:anchor this)))
    )

    (§ method! #_"ProcessFrame" ProcessFrame''enter-2 [#_"ProcessFrame" this, #_"Block" block]
        (ProcessFrame'new-5 this, (:round this), block, (:activeGuards this), (:beginNode block))
    )

    (§ method! #_"ProcessFrame" ProcessFrame''enterAlwaysReached-2 [#_"ProcessFrame" this, #_"Block" block]
        (let [
            #_"AnchoringNode" anchor
                (when (and (some? (:parent this)) (not= (:loop block) (:loop (:block (:parent this)))) (not (Block''isLoopHeader-1 block))) => (:anchor this)
                    ;; We are exiting a loop => cannot reuse the anchor without inserting loop proxies.
                    (:beginNode block)
                )
        ]
            (ProcessFrame'new-5 this, (:round this), block, (:activeGuards this), anchor)
        )
    )

    (§ method! #_"void" ProcessFrame''postprocess-1 [#_"ProcessFrame" this]
        (when (and (= (:anchor this) (:beginNode (:block this))) GraalOptions'optEliminateGuards)
            (doseq [#_"GuardNode" guard (NodeIterable''filter-2 (Node''usages-1 (:anchor this)), GuardNode)]
                (when (NodeBitMap''isMarkedAndGrow-2 (:activeGuards this), guard)
                    (NodeBitMap''clear-2 (:activeGuards this), guard)
                )
            )
        )
        nil
    )
)

;;;
 ; This phase will make sure that the branch leading towards this deopt has 0.0 probability.
 ;;
(final-ns PropagateDeoptimizeProbabilityPhase (§ extends BasePhase #_"<PhaseContext>")
    (§ defn #_"PropagateDeoptimizeProbabilityPhase" PropagateDeoptimizeProbabilityPhase'new-0 []
        (BasePhase'new-0)
    )

    #_unused
    (§ override! #_"void" PropagateDeoptimizeProbabilityPhase''run-3 [#_"PropagateDeoptimizeProbabilityPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (when (Graph''hasNode-2 graph, AbstractDeoptimizeNode'TYPE)
            (let [
                #_"NodeStack" stack (NodeStack'new-0)
                #_"EconomicMap<ControlSplitNode, EconomicSet<AbstractBeginNode>>" reachableSplits (EconomicMap/create)
            ]
                ;; Mark all control flow nodes that are post-dominated by a deoptimization.
                (doseq [#_"AbstractDeoptimizeNode" d (Graph''getNodes-2 graph, AbstractDeoptimizeNode'TYPE)]
                    (§ ass! stack (NodeStack''push-2 stack, (AbstractBeginNode'prevBegin-1 d)))
                    (while (not (NodeStack''isEmpty-1 stack))
                        (let [
                            #_"AbstractBeginNode" beginNode (NodeStack''pop-1 stack)
                            #_"FixedNode" fixedNode (:predecessor beginNode)
                        ]
                            (cond
                                (nil? fixedNode)
                                    nil ;; Can happen for start node.
                                (instance? AbstractMergeNode fixedNode)
                                    (doseq [#_"AbstractEndNode" end (AbstractMergeNode''forwardEnds-1 fixedNode)]
                                        (§ ass! stack (NodeStack''push-2 stack, (AbstractBeginNode'prevBegin-1 end)))
                                    )
                                (instance? ControlSplitNode fixedNode)
                                    (let [
                                        #_"EconomicSet<AbstractBeginNode>" reachableSuccessors (get reachableSplits fixedNode)
                                    ]
                                        (when (nil? reachableSuccessors)
                                            (§ ass reachableSuccessors (EconomicSet/create))
                                            (#_"EconomicMap" .put reachableSplits, fixedNode, reachableSuccessors)
                                        )

                                        (if (= (ControlSplitNode''getSuccessorCount-1 fixedNode) (dec (count reachableSuccessors)))
                                            (do
                                                ;; All successors of this split lead to deopt, propagate reachability further upwards.
                                                (#_"EconomicMap" .removeKey reachableSplits, fixedNode)
                                                (§ ass! stack (NodeStack''push-2 stack, (AbstractBeginNode'prevBegin-1 (:predecessor fixedNode))))
                                            )
                                            (#_"EconomicSet" .add reachableSuccessors, beginNode)
                                        )
                                    )
                                :else
                                    (§ ass! stack (NodeStack''push-2 stack, (AbstractBeginNode'prevBegin-1 fixedNode)))
                            )
                        )
                    )
                )

                ;; Make sure the probability on the path towards the deoptimization is 0.0.
                (let [
                    #_"MapCursor<ControlSplitNode, EconomicSet<AbstractBeginNode>>" entries (#_"EconomicMap" .getEntries reachableSplits)
                ]
                    (while (#_"MapCursor" .advance entries)
                        (let [
                            #_"ControlSplitNode" controlSplitNode (#_"MapCursor" .getKey entries)
                            #_"EconomicSet<AbstractBeginNode>" value (#_"MapCursor" .getValue entries)
                        ]
                            (doseq [#_"AbstractBeginNode" begin value]
                                (when-not (= (ControlSplitNode''probability-2 controlSplitNode, begin) 0.0)
                                    (ControlSplitNode''setProbability-3 controlSplitNode, begin, 0.0)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )
)

(final-ns RemoveValueProxyPhase (§ extends Phase)
    (§ defn #_"RemoveValueProxyPhase" RemoveValueProxyPhase'new-0 []
        (Phase'new-0)
    )

    #_unused
    (§ override! #_"void" RemoveValueProxyPhase''run-2 [#_"RemoveValueProxyPhase" this, #_"Graph" graph]
        (doseq [#_"LoopExitNode" exit (Graph''getNodes-2 graph, LoopExitNode'TYPE)]
            (doseq [#_"ProxyNode" vpn (NodeIterable''snapshot-1 (LoopExitNode''proxies-1 exit))]
                (Node''replaceAtUsagesAndDelete-2 vpn, (ProxyNode''value-1 vpn))
            )
            (let [
                #_"FrameState" stateAfter (BeginStateSplitNode''stateAfter-1 exit)
            ]
                (when (some? stateAfter)
                    (BeginStateSplitNode''setStateAfter-2 exit, nil)
                    (when (Node''hasNoUsages-1 stateAfter)
                        (GraphUtil'killWithUnusedFloatingInputs-1 stateAfter)
                    )
                )
            )
        )
        (§ ass! graph (Graph''setHasValueProxies-2 graph, false))
        nil
    )
)

(final-ns UseTrappingNullChecksPhase (§ extends BasePhase #_"<LowTierContext>")
    (§ defn #_"UseTrappingNullChecksPhase" UseTrappingNullChecksPhase'new-0 []
        (BasePhase'new-0)
    )

    (§ defn- #_"void" UseTrappingNullChecksPhase'replaceWithTrappingNullCheck-5 [#_"AbstractDeoptimizeNode" deopt, #_"IfNode" ifNode, #_"LogicNode" logic, #_"DeoptimizationReason" deoptimizationReason, #_"long" implicitNullCheckLimit]
        (let [
            #_"AbstractBeginNode" nonTrappingContinuation (:falseSuccessor ifNode)
            #_"AbstractBeginNode" trappingContinuation (:trueSuccessor ifNode)
            #_"FixedNode" nextNonTrapping (:next nonTrappingContinuation)
            #_"ValueNode" value (UnaryOpLogicNode''getValue-1 logic)
            #_"DeoptimizingFixedWithNextNode" trappingNullCheck
                (when (and GraalOptions'optImplicitNullChecks (pos? implicitNullCheckLimit) (instance? FixedAccessNode nextNonTrapping) (DeoptimizingFixedWithNextNode''canNullCheck-1 nextNonTrapping))
                    (let [
                        #_"AddressNode" address (FixedAccessNode''getAddress-1 nextNonTrapping)
                        #_"ValueNode" base (AddressNode''getBase-1 address)
                        #_"ValueNode" index (AddressNode''getIndex-1 address)
                        ;; allow for architectures which cannot fold an intervening uncompress out of the address chain
                        base (if (and (some? base) (instance? CompressionNode base)) (UnaryNode''getValue-1 base) base)
                        index (if (and (some? index) (instance? CompressionNode index)) (UnaryNode''getValue-1 index) index)
                    ]
                        (when (and (or (and (= base value) (nil? index)) (and (nil? base) (= index value))) (< (AddressNode''getMaxConstantDisplacement-1 address) implicitNullCheckLimit))
                            ;; Opportunity for implicit nil-check as part of an existing read found!
                            (DeoptimizingFixedWithNextNode''setStateBefore-2 nextNonTrapping, (AbstractDeoptimizeNode''stateBefore-1 deopt))
                            (§ ass! nextNonTrapping (FixedAccessNode''setNullCheck-2 nextNonTrapping, true))
                            (Graph''removeSplit-3 (:graph deopt), ifNode, nonTrappingContinuation)
                            nextNonTrapping
                        )
                    )
                )
            trappingNullCheck
                (or trappingNullCheck
                    ;; Need to add a nil-check node.
                    (let [
                        trappingNullCheck (Graph''add-2 (:graph deopt), (NullCheckNode'new-1 value))
                    ]
                        (Graph''replaceSplit-4 (:graph deopt), ifNode, trappingNullCheck, nonTrappingContinuation)
                        trappingNullCheck
                    )
                )
        ]
            (DeoptimizingFixedWithNextNode''setStateBefore-2 trappingNullCheck, (AbstractDeoptimizeNode''stateBefore-1 deopt))

            ;; We now have the pattern NullCheck/BeginNode/... It's possible some node is using the
            ;; BeginNode as a guard input, so replace guard users of the Begin with the NullCheck and
            ;; then remove the Begin from the graph.
            (Node''replaceAtUsages-3 nonTrappingContinuation, InputType'Guard, trappingNullCheck)

            (when (instance? BeginNode nonTrappingContinuation)
                (GraphUtil'unlinkFixedNode-1 nonTrappingContinuation)
                (Node''safeDelete-1 nonTrappingContinuation)
            )

            (GraphUtil'killCFG-1 trappingContinuation)
            (GraphUtil'tryKillUnused-1 logic)
        )
        nil
    )

    (§ defn- #_"void" UseTrappingNullChecksPhase'checkPredecessor-4 [#_"AbstractDeoptimizeNode" deopt, #_"Node" predecessor, #_"DeoptimizationReason" deoptimizationReason, #_"long" implicitNullCheckLimit]
        (let [
            [#_"Node" node #_"AbstractBeginNode" branch]
                (loop-when [node predecessor branch nil] (instance? AbstractBeginNode node) => [node branch]
                    (if (NodeIterable''isNotEmpty-1 (AbstractBeginNode''anchored-1 node))
                        nil ;; some input of the deopt framestate is anchored to this branch
                        (recur (:predecessor node) node)
                    )
                )
        ]
            (when (and (instance? IfNode node) (= branch (:trueSuccessor node)) (instance? IsNullNode (:condition node)))
                (UseTrappingNullChecksPhase'replaceWithTrappingNullCheck-5 deopt, node, (:condition node), deoptimizationReason, implicitNullCheckLimit)
            )
        )
        nil
    )

    (§ defn- #_"void" UseTrappingNullChecksPhase'tryUseTrappingNullCheck-5 [#_"AbstractDeoptimizeNode" deopt, #_"Node" predecessor, #_"DeoptimizationReason" deoptimizationReason, #_"JavaConstant" speculation, #_"long" implicitNullCheckLimit]
        (when (and (any = deoptimizationReason DeoptimizationReason/NullCheckException DeoptimizationReason/UnreachedCode)
                   (or (nil? speculation) (= speculation JavaConstant/NULL_POINTER))
              )
            (condp instance? predecessor
                AbstractMergeNode
                    (when (NodeIterable''isEmpty-1 (AbstractMergeNode''phis-1 predecessor))
                        (doseq [#_"AbstractEndNode" end (NodeIterable''snapshot-1 (AbstractMergeNode''cfgPredecessors-1 predecessor))]
                            (UseTrappingNullChecksPhase'checkPredecessor-4 deopt, (:predecessor end), deoptimizationReason, implicitNullCheckLimit)
                        )
                    )
                AbstractBeginNode
                    (UseTrappingNullChecksPhase'checkPredecessor-4 deopt, predecessor, deoptimizationReason, implicitNullCheckLimit)
                nil
            )
        )
        nil
    )

    (§ defn- #_"void" UseTrappingNullChecksPhase'tryUseTrappingNullCheck-2 [#_"DynamicDeoptimizeNode" deopt, #_"long" implicitNullCheckLimit]
        (let [
            #_"Node" predecessor (:predecessor deopt)
        ]
            (when (instance? AbstractMergeNode predecessor)
                (let [
                    #_"AbstractMergeNode" merge predecessor
                    ;; Process each predecessor at the merge, unpacking the reasons and speculations as needed.
                    #_"ValueNode" reason (:actionAndReason deopt)
                    [#_"List<ValueNode>" reasons #_"int" expectedPhis]
                        (condp instance? reason
                            ValuePhiNode
                                (if (= (PhiNode''merge-1 reason) merge)
                                    [(NodeList''snapshot-1 (ValuePhiNode''values-1 reason)) 1]
                                    (§ return )
                                )
                            ConstantNode
                                [nil 0]
                            (§ return )
                        )
                ]
                    (let [
                        #_"ValueNode" speculation (:speculation deopt)
                        [#_"List<ValueNode>" speculations expectedPhis]
                            (when (instance? ValuePhiNode speculation) => [nil expectedPhis]
                                (if-not (= (PhiNode''merge-1 speculation) merge)
                                    (§ return )
                                    [(NodeList''snapshot-1 (ValuePhiNode''values-1 speculation)) (inc expectedPhis)]
                                )
                            )
                    ]
                        (when (= (NodeIterable''count-1 (AbstractMergeNode''phis-1 merge)) expectedPhis)
                            (loop-when [#_"int" i 0 #_"ISeq" s (seq (NodeIterable''snapshot-1 (AbstractMergeNode''cfgPredecessors-1 merge)))] (some? s)
                                (let [
                                    #_"AbstractEndNode" end (first s)
                                    #_"ValueNode" thisReason (if (some? reasons) (nth reasons i) reason)
                                    #_"ValueNode" thisSpeculation (if (some? speculations) (nth speculations i) speculation)
                                    i (if (some? speculations) (inc i) i)
                                ]
                                    (when (and (instance? ConstantNode thisReason) (instance? ConstantNode thisSpeculation) (= (:value thisSpeculation) JavaConstant/NULL_POINTER))
                                        (UseTrappingNullChecksPhase'tryUseTrappingNullCheck-5 deopt, (:predecessor end), (#_"MetaAccessProvider" .decodeDeoptReason HotSpot'metaAccess, (ValueNode''asJavaConstant-1 thisReason)), nil, implicitNullCheckLimit)
                                    )
                                    (recur i (next s))
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" UseTrappingNullChecksPhase''run-3 [#_"UseTrappingNullChecksPhase" this, #_"Graph" graph, #_"LowTierContext" context]
        (when-not (or (not GraalOptions'useTrappingNullChecks) (<= (.implicitNullCheckLimit HotSpot'target) 0))
            (let [
                #_"long" implicitNullCheckLimit (.implicitNullCheckLimit HotSpot'target)
            ]
                (doseq [#_"DeoptimizeNode" deopt (Graph''getNodes-2 graph, DeoptimizeNode'TYPE)]
                    (UseTrappingNullChecksPhase'tryUseTrappingNullCheck-5 deopt, (:predecessor deopt), (:reason deopt), (:speculation deopt), implicitNullCheckLimit)
                )
                (doseq [#_"DynamicDeoptimizeNode" deopt (Graph''getNodes-2 graph, DynamicDeoptimizeNode'TYPE)]
                    (UseTrappingNullChecksPhase'tryUseTrappingNullCheck-2 deopt, implicitNullCheckLimit)
                )
            )
        )
        nil
    )
)

;;;
 ; A simple NodeEventListener implementation that accumulates event nodes in a HashSet.
 ;;
(final-ns HashSetNodeEventListener (§ extends NodeEventListener)
    ;;;
     ; The set being used to accumulate the nodes communicated to this listener.
     ;;
    (§ final #_"EconomicSet<Node>" :nodes nil)
    (§ final #_"Set<NodeEvent>" :filter nil)

    ;;;
     ; Creates a NodeEventListener that collects nodes from all events.
     ;;
    (§ defn #_"HashSetNodeEventListener" HashSetNodeEventListener'new-0 []
        (let [
            #_"HashSetNodeEventListener" this (NodeEventListener'new-0)
            this (assoc this :nodes (EconomicSet/create Equivalence/IDENTITY))
            this (assoc this :filter (EnumSet/allOf NodeEvent))
        ]
            this
        )
    )

    ;;;
     ; Creates a NodeEventListener that collects nodes from all events that match a given filter.
     ;;
    (§ defn #_"HashSetNodeEventListener" HashSetNodeEventListener'new-1 [#_"Set<NodeEvent>" filter]
        (let [
            #_"HashSetNodeEventListener" this (NodeEventListener'new-0)
            this (assoc this :nodes (EconomicSet/create Equivalence/IDENTITY))
            this (assoc this :filter filter)
        ]
            this
        )
    )

    ;;;
     ; Excludes a given event from those for which nodes are collected.
     ;;
    (§ method! #_"HashSetNodeEventListener" HashSetNodeEventListener''exclude-2 [#_"HashSetNodeEventListener" this, #_"NodeEvent" e]
        (#_"Set" .remove (:filter this), e)
        this
    )

    #_unused
    (§ override! #_"void" HashSetNodeEventListener''changed-3 [#_"HashSetNodeEventListener" this, #_"NodeEvent" e, #_"Node" node]
        (when (contains? (:filter this) e)
            (#_"EconomicSet" .add (:nodes this), node)
            (when (instance? IndirectCanonicalization node)
                (doseq [#_"Node" usage (Node''usages-1 node)]
                    (#_"EconomicSet" .add (:nodes this), usage)
                )
            )
        )
        nil
    )
)

;;;
 ; Compute probabilities for fixed nodes on the fly and cache them at AbstractBeginNodes.
 ;;
(final-ns FixedNodeProbabilityCache (§ implements ToDoubleFunction #_"<FixedNode>")
    (§ defn #_"FixedNodeProbabilityCache" FixedNodeProbabilityCache'new-0 []
        (Object.)
    )

    (§ final #_"EconomicMap<FixedNode, Double>" :cache (EconomicMap/create Equivalence/IDENTITY))

    ;;;
     ; Given a FixedNode this method finds the most immediate AbstractBeginNode preceding it that either:
     ;
     ; - has no predecessor (i.e. the begin-node is a merge, in particular a loop-begin, or the start-node)
     ; - has a control-split predecessor
     ;
     ; The thus found AbstractBeginNode is equi-probable with the FixedNode it was obtained from.
     ; When computed for the first time (afterwards a cache lookup returns it) that probability
     ; is computed as follows, again depending on the begin-node's predecessor:
     ;
     ; - No predecessor. In this case the begin-node is either:
     ; -- a merge-node, whose probability adds up those of its forward-ends
     ; -- a loop-begin, with probability as above multiplied by the loop-frequency
     ; - Control-split predecessor: probability of the branch times that of the control-split
     ;
     ; As an exception to all the above, a probability of 1 is assumed for a FixedNode that
     ; appears to be dead-code (i.e. lacks a predecessor).
     ;;
    (§ override! #_"double" FixedNodeProbabilityCache''applyAsDouble-2 [#_"FixedNodeProbabilityCache" this, #_"FixedNode" node]
        (let [
            node (FixedNodeProbabilityCache'findBegin-1 node)
        ]
            (when (some? node) => 1.0 ;; this should only appear for dead code
                (or (get (:cache this) node)
                    (let [
                        #_"Node" predecessor (:predecessor node)
                        #_"double" probability
                            (if (some? predecessor)
                                (ControlFlowGraph'multiplyProbabilities-2 (ControlSplitNode''probability-2 predecessor, node), (FixedNodeProbabilityCache''applyAsDouble-2 this, predecessor))
                                (if (instance? AbstractMergeNode node)
                                    (FixedNodeProbabilityCache''handleMerge-3 this, node, 0.0)
                                    1.0
                                )
                            )
                    ]
                        (#_"EconomicMap" .put (:cache this), node, probability)
                        probability
                    )
                )
            )
        )
    )

    (§ method- #_"double" FixedNodeProbabilityCache''handleMerge-3 [#_"FixedNodeProbabilityCache" this, #_"FixedNode" node, #_"double" probability]
        ;; Use simple iteration instead of streams, since the stream infrastructure adds many frames
        ;; which causes the recursion to overflow the stack earlier than it would otherwise.
        (let [
            probability
                (loop-when-recur [probability probability #_"ISeq" s (seq (AbstractMergeNode''forwardEnds-1 node))]
                                 (some? s)
                                 [(+ probability (FixedNodeProbabilityCache''applyAsDouble-2 this, (first s))) (next s)]
                              => probability
                )
        ]
            (when (instance? LoopBeginNode node) => probability
                (ControlFlowGraph'multiplyProbabilities-2 probability, (:loopFrequency node))
            )
        )
    )

    (§ defn- #_"FixedNode" FixedNodeProbabilityCache'findBegin-1 [#_"FixedNode" node]
        (loop [node node]
            (let [
                #_"Node" predecessor (:predecessor node)
            ]
                (if (instance? AbstractBeginNode node)
                    (when (and (some? predecessor) (= (NodeIterable''count-1 (Node''successors-1 predecessor)) 1)) => node
                        (recur predecessor)
                    )
                    (when (some? predecessor)
                        (recur predecessor)
                    )
                )
            )
        )
    )
)

(value-ns InferStamps
    ;;;
     ; Infer the stamps for all Object nodes in the graph, to make the stamps as precise as
     ; possible. For example, this propagates the word-type through phi functions. To handle phi
     ; functions at loop headers, the stamp inference is called until a fix point is reached.
     ;
     ; This method can be used when it is needed that stamps are inferred before the first run of
     ; the canonicalizer. For example, word type rewriting must run before the first run of the
     ; canonicalizer because many nodes are not prepared to see the word type during canonicalization.
     ;;
    #_unused
    (§ defn #_"void" InferStamps'inferStamps-1 [#_"Graph" graph]
        ;; We want to make the stamps more precise. For cyclic phi functions, this means we have to
        ;; ignore the initial stamp because the imprecise stamp would always propagate around the
        ;; cycle. We therefore set the stamp to an illegal stamp, which is automatically ignored
        ;; when the phi function performs the "meet" operator on its input stamps.
        (doseq [#_"Node" node (Graph''getNodes-1 graph)]
            (when (and (instance? ValuePhiNode node) (instance? ObjectStamp (:stamp node)))
                (§ ass! node (ValueNode''setStamp-2 node, (Stamp''empty-1 (:stamp node))))
            )
        )

        ;; The algorithm is not guaranteed to reach a stable state.
        (loop [#_"int" iteration 0]
            (let [
                #_"boolean" changed?
                    (loop-when [changed? false #_"ISeq" s (seq (Graph''getNodes-1 graph))] (some? s) => changed?
                        (let [
                            #_"Node" node (first s)
                            changed?
                                (when (and (instance? ValueNode node) (instance? ObjectStamp (:stamp node))) => changed?
                                    (or changed? (ValueNode''inferStamp-1 node))
                                )
                        ]
                            (recur changed? (next s))
                        )
                    )
            ]
                (recur-if (and changed? (< iteration 10000)) [(inc iteration)])
            )
        )
        nil
    )
)

(value-ns ReentrantBlockIterator
    (§ defn- #_"<StateT> boolean" ReentrantBlockIterator'allEndsVisited-3 [#_"EconomicMap<FixedNode, StateT>" states, #_"Block" current, #_"AbstractMergeNode" merge]
        (loop-when [#_"ISeq" s (seq (AbstractMergeNode''forwardEnds-1 merge))] (some? s) => true
            (let [
                #_"AbstractEndNode" forwardEnd (first s)
            ]
                (and (or (= forwardEnd (:endNode current)) (contains? states forwardEnd))
                    (recur (next s))
                )
            )
        )
    )

    (§ defn- #_"<StateT> Block" ReentrantBlockIterator'processMultipleSuccessors-5 [#_"BlockIteratorClosure<StateT>" closure, #_"Deque<Block>" blockQueue, #_"EconomicMap<FixedNode, StateT>" states, #_"StateT" state, #_"Block[]" successors]
        (loop-when-recur [#_"int" i 1] (< i (count successors)) [(inc i)]
            (let [
                #_"Block" successor (nth successors i)
            ]
                (#_"Deque" .addFirst blockQueue, successor)
                (#_"EconomicMap" .put states, (:beginNode successor), (BlockIteratorClosure''cloneState-2 closure, state))
            )
        )
        (nth successors 0)
    )

    (§ defn- #_"<StateT> ArrayList<StateT>" ReentrantBlockIterator'mergeStates-5 [#_"EconomicMap<FixedNode, StateT>" states, #_"StateT" state, #_"Block" current, #_"Block" successor, #_"AbstractMergeNode" merge]
        (let [
            #_"ArrayList<StateT>" mergedStates (ArrayList.)
        ]
            (doseq [#_"Block" predecessor (:predecessors successor)]
                (#_"ArrayList" .add mergedStates, (if (= predecessor current) state (#_"EconomicMap" .removeKey states, (:endNode predecessor))))
            )
            mergedStates
        )
    )

    (§ defn- #_"<StateT> void" ReentrantBlockIterator'recurseIntoLoop-5 [#_"BlockIteratorClosure<StateT>" closure, #_"Deque<Block>" blockQueue, #_"EconomicMap<FixedNode, StateT>" states, #_"StateT" state, #_"Block" successor]
        ;; recurse into the loop
        (let [
            #_"Loop" loop (:loop successor)
            #_"List<StateT>" exitStates (BlockIteratorClosure''processLoop-3 closure, loop, state)
        ]
            (loop-when [#_"int" i 0 #_"ISeq" s (seq (:exits loop))] (some? s)
                (let [
                    #_"Block" exit (first s)
                ]
                    (#_"EconomicMap" .put states, (:beginNode exit), (nth exitStates i))
                    (#_"Deque" .addFirst blockQueue, exit)
                    (recur (inc i) (next s))
                )
            )
        )
        nil
    )

    (§ defn #_"<StateT> EconomicMap<FixedNode, StateT>" ReentrantBlockIterator'apply-4 [#_"BlockIteratorClosure<StateT>" closure, #_"Block" start, #_"StateT" initialState, #_"Predicate<Block>" stopAtBlock]
        (let [
            #_"Deque<Block>" blockQueue (ArrayDeque.)
            ;; States are stored on EndNodes before merges, and on BeginNodes after ControlSplitNodes.
            #_"EconomicMap<FixedNode, StateT>" states (EconomicMap/create Equivalence/IDENTITY)
            #_"Graph" graph (:graph (:beginNode start))
        ]
            (loop [#_"Block" block start #_"StateT" state initialState]
                (let [
                    [block state]
                        (if (and (some? stopAtBlock) (#_"Predicate" .test stopAtBlock, block))
                            (do
                                (#_"EconomicMap" .put states, (:beginNode block), state)
                                [nil state]
                            )
                            (let [
                                state (BlockIteratorClosure''processBlock-3 closure, block, state)
                                #_"Block[]" successors (:successors block)
                            ]
                                (case (count successors)
                                    0
                                        [nil state] ;; nothing to do...
                                    1
                                        (let [
                                            #_"Block" successor (nth successors 0)
                                        ]
                                            (cond
                                                (Block''isLoopHeader-1 successor)
                                                    (do
                                                        (if (Block''isLoopEnd-1 block)
                                                            ;; nothing to do... loop ends only lead to loop begins we've already visited
                                                            (#_"EconomicMap" .put states, (:endNode block), state)
                                                            (ReentrantBlockIterator'recurseIntoLoop-5 closure, blockQueue, states, state, successor)
                                                        )
                                                        [nil state]
                                                    )
                                                (instance? AbstractEndNode (:endNode block))
                                                    (let [
                                                        #_"AbstractEndNode" end (:endNode block)
                                                        ;; add the end node and see if the merge is ready for processing
                                                        #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 end)
                                                    ]
                                                        (if (ReentrantBlockIterator'allEndsVisited-3 states, block, merge)
                                                            [successor (BlockIteratorClosure''merge-3 closure, successor, (ReentrantBlockIterator'mergeStates-5 states, state, block, successor, merge))]
                                                            (do
                                                                (#_"EconomicMap" .put states, end, state)
                                                                [nil state]
                                                            )
                                                        )
                                                    )
                                                :else
                                                    [successor state]
                                            )
                                        )
                                    [(ReentrantBlockIterator'processMultipleSuccessors-5 closure, blockQueue, states, state, successors) state]
                                )
                            )
                        )
                ]
                    ;; get next queued block
                    (cond
                        (some? block)
                            (recur block state)
                        (empty? blockQueue)
                            states
                        :else
                            (let [
                                block (#_"Deque" .removeFirst blockQueue)
                            ]
                                (recur block (#_"EconomicMap" .removeKey states, (:beginNode block)))
                            )
                    )
                )
            )
        )
    )

    (§ defn #_"<StateT> void" ReentrantBlockIterator'apply-2 [#_"BlockIteratorClosure<StateT>" closure, #_"Block" start]
        (ReentrantBlockIterator'apply-4 closure, start, (BlockIteratorClosure''getInitialState-1 closure), nil)
        nil
    )

    (§ defn #_"<StateT> BlockLoopInfo<StateT>" ReentrantBlockIterator'processLoop-3 [#_"BlockIteratorClosure<StateT>" closure, #_"Loop" loop, #_"StateT" initialState]
        (let [
            #_"EconomicMap<FixedNode, StateT>" blockEndStates (ReentrantBlockIterator'apply-4 closure, (:header loop), initialState, (ß block -> (§ fun (not (or (= (:loop block) loop) (Block''isLoopHeader-1 block))))))
            #_"Block[]" predecessors (:predecessors (:header loop))
            #_"BlockLoopInfo<StateT>" info (BlockLoopInfo'new-2 (dec (count predecessors)), (count (:exits loop)))
        ]
            (loop-when-recur [#_"int" i 1] (< i (count predecessors)) [(inc i)]
                (let [
                    #_"StateT" endState (get blockEndStates (:endNode (nth predecessors i)))
                ]
                    ;; make sure all end states are unique objects
                    (#_"List" .add (:endStates info), (BlockIteratorClosure''cloneState-2 closure, endState))
                )
            )
            (doseq [#_"Block" loopExit (:exits loop)]
                (let [
                    #_"StateT" exitState (get blockEndStates (:beginNode loopExit))
                ]
                    ;; make sure all exit states are unique objects
                    (#_"List" .add (:exitStates info), (BlockIteratorClosure''cloneState-2 closure, exitState))
                )
            )
            info
        )
    )
)

;;;
 ; @anno ReentrantBlockIterator.BlockLoopInfo
 ;;
(final-ns BlockLoopInfo #_"<StateT>"
    (§ final #_"List<StateT>" :endStates nil)
    (§ final #_"List<StateT>" :exitStates nil)

    (§ defn #_"BlockLoopInfo" BlockLoopInfo'new-2 [#_"int" endCount, #_"int" exitCount]
        (let [
            #_"BlockLoopInfo" this (Object.)
            this (assoc this :endStates (ArrayList.))
            this (assoc this :exitStates (ArrayList.))
        ]
            this
        )
    )
)

;;;
 ; @anno ReentrantBlockIterator.BlockIteratorClosure
 ;;
(class-ns BlockIteratorClosure #_"<StateT>"
    (§ defn #_"BlockIteratorClosure" BlockIteratorClosure'new-0 []
        (Object.)
    )

    (§ abstract #_"StateT" BlockIteratorClosure''getInitialState-1 [#_"BlockIteratorClosure<StateT>" this])

    (§ abstract #_"StateT" BlockIteratorClosure''processBlock-3 [#_"BlockIteratorClosure<StateT>" this, #_"Block" block, #_"StateT" currentState])

    (§ abstract #_"StateT" BlockIteratorClosure''merge-3 [#_"BlockIteratorClosure<StateT>" this, #_"Block" merge, #_"List<StateT>" states])

    (§ abstract #_"StateT" BlockIteratorClosure''cloneState-2 [#_"BlockIteratorClosure<StateT>" this, #_"StateT" oldState])

    (§ abstract #_"List<StateT>" BlockIteratorClosure''processLoop-3 [#_"BlockIteratorClosure<StateT>" this, #_"Loop" loop, #_"StateT" initialState])
)

(value-ns ReentrantNodeIterator
    (§ defn- #_"<StateT> EconomicMap<FixedNode, StateT>" ReentrantNodeIterator'apply-4 [#_"NodeIteratorClosure<StateT>" closure, #_"FixedNode" start, #_"StateT" initialState, #_"LoopBeginNode" boundary]
        (let [
            #_"Deque<AbstractBeginNode>" nodeQueue (ArrayDeque.)
            #_"EconomicMap<FixedNode, StateT>" blockEndStates (EconomicMap/create Equivalence/IDENTITY)
        ]
            (loop [#_"StateT" state initialState #_"FixedNode" node start]
                (let [
                    [state node]
                        (loop-when [state state node node] (instance? FixedWithNextNode node) => [state node]
                            (if (and (some? boundary) (instance? LoopExitNode node) (= (:loopBegin node) boundary))
                                (do
                                    (#_"EconomicMap" .put blockEndStates, node, state)
                                    (recur state nil)
                                )
                                (let [
                                    state (NodeIteratorClosure''processNode-3 closure, node, state)
                                ]
                                    (recur state (when true (:next node)))
                                )
                            )
                        )
                ]
                    (when (some? node)
                        (let [
                            state (NodeIteratorClosure''processNode-3 closure, node, state)
                        ]
                            (when true
                                (let [
                                    #_"Iterator<Node>" successors (#_"Iterable" .iterator (Node''successors-1 node))
                                ]
                                    (if (not (#_"Iterator" .hasNext successors))
                                        (condp instance? node
                                            LoopEndNode
                                                (#_"EconomicMap" .put blockEndStates, node, state)
                                            EndNode
                                                ;; add the end node and see if the merge is ready for processing
                                                (let [
                                                    #_"AbstractMergeNode" merge (AbstractEndNode''merge-1 node)
                                                ]
                                                    (if (instance? LoopBeginNode merge)
                                                        (let [
                                                            #_"EconomicMap<LoopExitNode, StateT>" loopExitState (NodeIteratorClosure''processLoop-3 closure, merge, state)
                                                            #_"MapCursor<LoopExitNode, StateT>" entry (#_"EconomicMap" .getEntries loopExitState)
                                                        ]
                                                            (while (#_"MapCursor" .advance entry)
                                                                (#_"EconomicMap" .put blockEndStates, (#_"MapCursor" .getKey entry), (#_"MapCursor" .getValue entry))
                                                                (#_"Deque" .add nodeQueue, (#_"MapCursor" .getKey entry))
                                                            )
                                                        )
                                                        (let [
                                                            #_"boolean" endsVisited
                                                                (loop-when [#_"ISeq" s (seq (AbstractMergeNode''forwardEnds-1 merge))] (some? s) => true
                                                                    (let [
                                                                        #_"AbstractEndNode" forwardEnd (first s)
                                                                    ]
                                                                        (and (or (= forwardEnd node) (contains? blockEndStates forwardEnd))
                                                                            (recur (next s))
                                                                        )
                                                                    )
                                                                )
                                                        ]
                                                            (if endsVisited
                                                                (let [
                                                                    #_"ArrayList<StateT>" states (ArrayList.)
                                                                ]
                                                                    (dotimes [#_"int" i (AbstractMergeNode''forwardEndCount-1 merge)]
                                                                        (let [
                                                                            #_"AbstractEndNode" forwardEnd (AbstractMergeNode''forwardEndAt-2 merge, i)
                                                                        ]
                                                                            (#_"ArrayList" .add states, (if (= forwardEnd node) state (#_"EconomicMap" .removeKey blockEndStates, forwardEnd)))
                                                                        )
                                                                    )
                                                                    (§ ass state (NodeIteratorClosure''merge-3 closure, merge, states))
                                                                    (§ ass node (when true merge))
                                                                    (§ continue )
                                                                )
                                                                (#_"EconomicMap" .put blockEndStates, node, state)
                                                            )
                                                        )
                                                    )
                                                )
                                            nil
                                        )
                                        (let [
                                            #_"FixedNode" firstSuccessor (#_"Iterator" .next successors)
                                        ]
                                            (if (not (#_"Iterator" .hasNext successors))
                                                (do
                                                    (§ ass node firstSuccessor)
                                                    (§ continue )
                                                )
                                                (do
                                                    (loop []
                                                        (let [
                                                            #_"AbstractBeginNode" successor (#_"Iterator" .next successors)
                                                            #_"StateT" successorState (NodeIteratorClosure''afterSplit-3 closure, successor, state)
                                                        ]
                                                            (when true
                                                                (#_"EconomicMap" .put blockEndStates, successor, successorState)
                                                                (#_"Deque" .add nodeQueue, successor)
                                                            )
                                                            (recur-if (#_"Iterator" .hasNext successors) [])
                                                        )
                                                    )

                                                    (§ ass state (NodeIteratorClosure''afterSplit-3 closure, (§ cast #_"AbstractBeginNode" firstSuccessor), state))
                                                    (§ ass node (when true firstSuccessor))
                                                    (§ continue )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (seq nodeQueue) => blockEndStates
                        (let [
                            node (#_"Deque" .removeFirst nodeQueue)
                        ]
                            (recur (#_"EconomicMap" .removeKey blockEndStates, node) node)
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"<StateT> void" ReentrantNodeIterator'apply-3 [#_"NodeIteratorClosure<StateT>" closure, #_"FixedNode" start, #_"StateT" initialState]
        (ReentrantNodeIterator'apply-4 closure, start, initialState, nil)
        nil
    )

    (§ defn #_"<StateT> NodeLoopInfo<StateT>" ReentrantNodeIterator'processLoop-3 [#_"NodeIteratorClosure<StateT>" closure, #_"LoopBeginNode" loop, #_"StateT" initialState]
        (let [
            #_"EconomicMap<FixedNode, StateT>" blockEndStates (ReentrantNodeIterator'apply-4 closure, loop, initialState, loop)
            #_"NodeLoopInfo<StateT>" info (NodeLoopInfo'new-2 (NodeIterable''count-1 (LoopBeginNode''loopEnds-1 loop)), (NodeIterable''count-1 (LoopBeginNode''loopExits-1 loop)))
        ]
            (doseq [#_"LoopEndNode" end (LoopBeginNode''loopEnds-1 loop)]
                (when (contains? blockEndStates end)
                    (#_"EconomicMap" .put (:endStates info), end, (get blockEndStates end))
                )
            )
            (doseq [#_"LoopExitNode" exit (LoopBeginNode''loopExits-1 loop)]
                (when (contains? blockEndStates exit)
                    (#_"EconomicMap" .put (:exitStates info), exit, (get blockEndStates exit))
                )
            )
            info
        )
    )
)

;;;
 ; @anno ReentrantNodeIterator.NodeLoopInfo
 ;;
(final-ns NodeLoopInfo #_"<StateT>"
    (§ final #_"EconomicMap<LoopEndNode, StateT>" :endStates nil)
    (§ final #_"EconomicMap<LoopExitNode, StateT>" :exitStates nil)

    (§ defn #_"NodeLoopInfo" NodeLoopInfo'new-2 [#_"int" endCount, #_"int" exitCount]
        (let [
            #_"NodeLoopInfo" this (Object.)
            this (assoc this :endStates (EconomicMap/create Equivalence/IDENTITY, endCount))
            this (assoc this :exitStates (EconomicMap/create Equivalence/IDENTITY, exitCount))
        ]
            this
        )
    )
)

;;;
 ; @anno ReentrantNodeIterator.NodeIteratorClosure
 ;;
(class-ns NodeIteratorClosure #_"<StateT>"
    (§ defn #_"NodeIteratorClosure" NodeIteratorClosure'new-0 []
        (Object.)
    )

    (§ abstract #_"StateT" NodeIteratorClosure''processNode-3 [#_"NodeIteratorClosure<StateT>" this, #_"FixedNode" node, #_"StateT" currentState])

    (§ abstract #_"StateT" NodeIteratorClosure''merge-3 [#_"NodeIteratorClosure<StateT>" this, #_"AbstractMergeNode" merge, #_"List<StateT>" states])

    (§ abstract #_"StateT" NodeIteratorClosure''afterSplit-3 [#_"NodeIteratorClosure<StateT>" this, #_"AbstractBeginNode" node, #_"StateT" oldState])

    (§ abstract #_"EconomicMap<LoopExitNode, StateT>" NodeIteratorClosure''processLoop-3 [#_"NodeIteratorClosure<StateT>" this, #_"LoopBeginNode" loop, #_"StateT" initialState])
)

;;;
 ; Iterates over a list of nodes, which usually comes from ScheduleResult#getBlockToNodesMap().
 ;
 ; While iterating, it is possible to {@link #insert(FixedNode, FixedWithNextNode) insert} and
 ; {@link #replaceCurrent(FixedWithNextNode) replace} nodes.
 ;;
(class-ns ScheduledNodeIterator
    (§ defn #_"ScheduledNodeIterator" ScheduledNodeIterator'new-0 []
        (Object.)
    )

    (§ mutable #_"FixedWithNextNode" :lastFixed nil)
    (§ mutable #_"FixedWithNextNode" :reconnect nil)
    (§ mutable #_"ListIterator<Node>" :iterator nil)

    (§ method #_"void" ScheduledNodeIterator''processNodes-3 [#_"ScheduledNodeIterator" this, #_"Block" block, #_"ScheduleResult" schedule]
        (§ ass! this (assoc this :lastFixed (:beginNode block)))
        (§ ass! this (assoc this :reconnect nil))
        (§ ass! this (assoc this :iterator (#_"List" .listIterator (ScheduleResult''nodesFor-2 schedule, block))))

        (loop-when-recur [] (#_"ListIterator" .hasNext (:iterator this)) []
            (let [
                #_"Node" node (#_"ListIterator" .next (:iterator this))
            ]
                (when (Node''isAlive-1 node)
                    (when (and (some? (:reconnect this)) (instance? FixedNode node))
                        (§ ass! (:reconnect this) (FixedWithNextNode''setNext-2 (:reconnect this), node))
                        (§ ass! this (assoc this :reconnect nil))
                    )
                    (when (instance? FixedWithNextNode node)
                        (§ ass! this (assoc this :lastFixed node))
                    )
                    (ScheduledNodeIterator''processNode-2 this, node)
                )
            )
        )
        (when (some? (:reconnect this))
            (§ ass! (:reconnect this) (FixedWithNextNode''setNext-2 (:reconnect this), (:beginNode (Block''getFirstSuccessor-1 block))))
        )
        nil
    )

    (§ method! #_"ScheduledNodeIterator" ScheduledNodeIterator''insert-3 [#_"ScheduledNodeIterator" this, #_"FixedNode" start, #_"FixedWithNextNode" end]
        (let [
            _ (§ ass! (:lastFixed this) (FixedWithNextNode''setNext-2 (:lastFixed this), start))
            this (assoc this :lastFixed end)
            this (assoc this :reconnect end)
        ]
            this
        )
    )

    (§ method! #_"ScheduledNodeIterator" ScheduledNodeIterator''replaceCurrent-2 [#_"ScheduledNodeIterator" this, #_"FixedWithNextNode" newNode]
        (let [
            #_"Node" current (#_"ListIterator" .previous (:iterator this))
        ]
            (#_"ListIterator" .next (:iterator this)) ;; needed because of the previous() call
            (let [
                _ (§ ass! current (Node''replaceAndDelete-2 current, newNode))
                this (ScheduledNodeIterator''insert-3 this, newNode, newNode)
            ]
                (#_"ListIterator" .set (:iterator this), newNode)
                this
            )
        )
    )

    (§ abstract #_"void" ScheduledNodeIterator''processNode-2 [#_"ScheduledNodeIterator" this, #_"Node" node])
)

;;;
 ; @anno OptimisticOptimizations.Optimization
 ;;
(value-ns Optimization
    (§ enum Optimization'RemoveNeverExecutedCode)
    (§ enum Optimization'UseTypeCheckedInlining)
    (§ enum Optimization'UseLoopLimitChecks)
)

(final-ns OptimisticOptimizations
    (§ final #_"Set<Optimization>" :enabledOpts nil)

    (§ defn #_"OptimisticOptimizations" OptimisticOptimizations'new-1 [#_"Set<Optimization>" enabledOpts]
        (let [
            #_"OptimisticOptimizations" this (Object.)
            this (assoc this :enabledOpts enabledOpts)
        ]
            this
        )
    )

    (§ def #_"OptimisticOptimizations" OptimisticOptimizations'ALL (OptimisticOptimizations'new-1 (EnumSet/allOf Optimization)))
    (§ def #_"OptimisticOptimizations" OptimisticOptimizations'NONE (OptimisticOptimizations'new-1 (EnumSet/noneOf Optimization)))

    (§ method! #_"boolean" OptimisticOptimizations''removeNeverExecutedCode-1 [#_"OptimisticOptimizations" this]
        (and GraalOptions'removeNeverExecutedCode (contains? (:enabledOpts this) Optimization'RemoveNeverExecutedCode))
    )

    (§ method! #_"boolean" OptimisticOptimizations''devirtualizeInvokes-1 [#_"OptimisticOptimizations" this]
        (and GraalOptions'optDevirtualizeInvokesOptimistically (contains? (:enabledOpts this) Optimization'UseTypeCheckedInlining))
    )

    (§ method! #_"boolean" OptimisticOptimizations''useLoopLimitChecks-1 [#_"OptimisticOptimizations" this]
        (and GraalOptions'useLoopLimitChecks (contains? (:enabledOpts this) Optimization'UseLoopLimitChecks))
    )

    (§ method! #_"boolean" OptimisticOptimizations''lessOptimisticThan-2 [#_"OptimisticOptimizations" this, #_"OptimisticOptimizations" other]
        (loop [#_"ISeq" s (seq (Optimization'values-0))]
            (and (some? s)
                (let [
                    #_"Optimization" opt (first s)
                ]
                    (or (and (not (contains? (:enabledOpts this) opt)) (contains? (:enabledOpts other) opt))
                        (recur (next s))
                    )
                )
            )
        )
    )
)

;;;
 ; Base class for compiler phases that don't need a context object.
 ;;
(class-ns Phase (§ extends BasePhase #_"<Object>")
    (§ defn #_"Phase" Phase'new-0 []
        (BasePhase'new-0)
    )

    (§ method! #_"void" Phase''apply-2 [#_"Phase" this, #_"Graph" graph]
        (BasePhase''apply-3 this, graph, nil)
        nil
    )

    (§ abstract #_"void" Phase''run-2 [#_"Phase" this, #_"Graph" graph])

    #_unused
    (§ override! #_"void" Phase''run-3 [#_"Phase" this, #_"Graph" graph, #_"Object" context]
        (Phase''run-2 this, graph)
        nil
    )
)

;;;
 ; A compiler phase that can apply an ordered collection of phases to a graph.
 ;;
(class-ns PhaseSuite #_"<C>" (§ extends BasePhase #_"<C>")
    (§ mutable #_"List<BasePhase<? super C>>" :phases nil)

    (§ defn #_"PhaseSuite" PhaseSuite'new-0 []
        (let [
            #_"PhaseSuite" this (BasePhase'new-0)
            this (assoc this :phases (ArrayList.))
        ]
            this
        )
    )

    ;;;
     ; Add a new phase at the beginning of this suite.
     ;;
    #_unused
    (§ method! #_"void" PhaseSuite''prependPhase-2 [#_"PhaseSuite<C>" this, #_"BasePhase<? super C>" phase]
        (#_"List" .add (:phases this), 0, phase)
        nil
    )

    ;;;
     ; Add a new phase at the end of this suite.
     ;;
    (§ method! #_"void" PhaseSuite''appendPhase-2 [#_"PhaseSuite<C>" this, #_"BasePhase<? super C>" phase]
        (#_"List" .add (:phases this), phase)
        nil
    )

    ;;;
     ; Inserts a phase before the last phase in the suite. If the suite contains no phases the new
     ; phase will be inserted as the first phase.
     ;;
    #_unused
    (§ method! #_"void" PhaseSuite''addBeforeLast-2 [#_"PhaseSuite<C>" this, #_"BasePhase<? super C>" phase]
        (let [
            #_"ListIterator<BasePhase<? super C>>" last (PhaseSuite''findLastPhase-1 this)
        ]
            (when (#_"ListIterator" .hasPrevious last)
                (#_"ListIterator" .previous last)
            )
            (#_"ListIterator" .add last, phase)
        )
        nil
    )

    ;;;
     ; Returns a ListIterator at the position of the last phase in the suite. If the suite
     ; has no phases then it will return an empty iterator.
     ;;
    (§ method- #_"ListIterator<BasePhase<? super C>>" PhaseSuite''findLastPhase-1 [#_"PhaseSuite<C>" this]
        (let [
            #_"ListIterator<BasePhase<? super C>>" it (#_"List" .listIterator (:phases this))
        ]
            (while (#_"ListIterator" .hasNext it)
                (#_"ListIterator" .next it)
            )
            it
        )
    )

    ;;;
     ; Gets an unmodifiable view on the phases in this suite.
     ;;
    #_unused
    (§ method #_"List<BasePhase<? super C>>" PhaseSuite''getPhases-1 [#_"PhaseSuite<C>" this]
        (Collections/unmodifiableList (:phases this))
    )

    ;;;
     ; Returns a ListIterator at the position of the first phase which is an instance of {@code phaseClass}
     ; or nil if no such phase can be found.
     ;
     ; Calling ListIterator#previous() would return the phase that was found.
     ;
     ; @param phaseClass the type of phase to look for.
     ;;
    (§ method! #_"ListIterator<BasePhase<? super C>>" PhaseSuite''findPhase-2 [#_"PhaseSuite<C>" this, #_"Class<? extends BasePhase<? super C>>" phaseClass]
        (PhaseSuite''findPhase-3 this, phaseClass, false)
    )

    ;;;
     ; Returns a ListIterator at the position of the first phase which is an instance of {@code phaseClass} or,
     ; if {@code recursive} is true, is a PhaseSuite containing a phase which is an instance of {@code phaseClass}.
     ; This method returns nil if no such phase can be found.
     ;
     ; Calling ListIterator#previous() would return the phase or phase suite that was found.
     ;
     ; @param phaseClass the type of phase to look for
     ; @param recursive whether to recursively look into phase suites.
     ;;
    (§ method! #_"ListIterator<BasePhase<? super C>>" PhaseSuite''findPhase-3 [#_"PhaseSuite<C>" this, #_"Class<? extends BasePhase<? super C>>" phaseClass, #_"boolean" recursive?]
        (let [
            #_"ListIterator<BasePhase<? super C>>" it (#_"List" .listIterator (:phases this))
        ]
            (when (PhaseSuite'findNextPhase-3 it, phaseClass, recursive?) it)
        )
    )

    #_unused
    (§ defn #_"<C> boolean" PhaseSuite'findNextPhase-2 [#_"ListIterator<BasePhase<? super C>>" it, #_"Class<? extends BasePhase<? super C>>" phaseClass]
        (PhaseSuite'findNextPhase-3 it, phaseClass, false)
    )

    (§ defn #_"<C> boolean" PhaseSuite'findNextPhase-3 [#_"ListIterator<BasePhase<? super C>>" it, #_"Class<? extends BasePhase<? super C>>" phaseClass, #_"boolean" recursive?]
        (loop []
            (and (#_"ListIterator" .hasNext it)
                (let [
                    #_"BasePhase<? super C>" phase (#_"ListIterator" .next it)
                ]
                    (cond
                        (#_"Class" .isInstance phaseClass, phase)       true
                        (and recursive? (instance? PhaseSuite phase)) (or (some? (PhaseSuite''findPhase-3 phase, phaseClass, true)) (recur))
                        :else                                         (recur)
                    )
                )
            )
        )
    )

    ;;;
     ; Removes the first instance of the given phase class, looking recursively into inner phase suites.
     ;;
    (§ method! #_"boolean" PhaseSuite''removePhase-2 [#_"PhaseSuite<C>" this, #_"Class<? extends BasePhase<? super C>>" phaseClass]
        (let [
            #_"ListIterator<BasePhase<? super C>>" it (#_"List" .listIterator (:phases this))
        ]
            (loop []
                (and (#_"ListIterator" .hasNext it)
                    (let [
                        #_"BasePhase<? super C>" phase (#_"ListIterator" .next it)
                    ]
                        (if (#_"Class" .isInstance phaseClass, phase)
                            (do
                                (#_"ListIterator" .remove it)
                                true
                            )
                            (when (and (instance? PhaseSuite phase) (PhaseSuite''removePhase-2 phase, phaseClass)) => (recur)
                                (when (empty? (:phases phase))
                                    (#_"ListIterator" .remove it)
                                )
                                true
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Removes the first instance of the given phase class, looking recursively into inner phase suites.
     ;;
    #_unused
    (§ method! #_"boolean" PhaseSuite''replacePhase-3 [#_"PhaseSuite<C>" this, #_"Class<? extends BasePhase<? super C>>" phaseClass, #_"BasePhase<? super C>" newPhase]
        (let [
            #_"ListIterator<BasePhase<? super C>>" it (#_"List" .listIterator (:phases this))
        ]
            (loop []
                (and (#_"ListIterator" .hasNext it)
                    (let [
                        #_"BasePhase<? super C>" phase (#_"ListIterator" .next it)
                    ]
                        (if (#_"Class" .isInstance phaseClass, phase)
                            (do
                                (#_"ListIterator" .set it, newPhase)
                                true
                            )
                            (when (and (instance? PhaseSuite phase) (PhaseSuite''removePhase-2 phase, phaseClass)) => (recur)
                                (when (empty? (:phases phase))
                                    (#_"ListIterator" .set it, newPhase)
                                )
                                true
                            )
                        )
                    )
                )
            )
        )
    )

    (§ override #_"void" PhaseSuite''run-3 [#_"PhaseSuite<C>" this, #_"Graph" graph, #_"C" context]
        (doseq [#_"BasePhase<? super C>" phase (:phases this)]
            (BasePhase''apply-3 phase, graph, context)
        )
        nil
    )
)

(final-ns SchedulePhase (§ extends Phase)
    (§ final #_"SchedulingStrategy" :selectedStrategy nil)

    (§ final #_"boolean" :immutableGraph false)

    (§ defn #_"SchedulePhase" SchedulePhase'new-0 []
        (SchedulePhase'new-1 false)
    )

    (§ defn #_"SchedulePhase" SchedulePhase'new-1 [#_"boolean" immutableGraph]
        (SchedulePhase'new-2 (if GraalOptions'optScheduleOutOfLoops SchedulingStrategy'LATEST_OUT_OF_LOOPS SchedulingStrategy'LATEST), immutableGraph)
    )

    (§ defn #_"SchedulePhase" SchedulePhase'new-1 [#_"SchedulingStrategy" strategy]
        (SchedulePhase'new-2 strategy, false)
    )

    (§ defn #_"SchedulePhase" SchedulePhase'new-2 [#_"SchedulingStrategy" strategy, #_"boolean" immutableGraph]
        (let [
            #_"SchedulePhase" this (Phase'new-0)
            this (assoc this :selectedStrategy strategy)
            this (assoc this :immutableGraph immutableGraph)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" SchedulePhase''run-2 [#_"SchedulePhase" this, #_"Graph" graph]
        (§ ass! (ScheduleInstance'new-0) (ScheduleInstance''run-4 (ScheduleInstance'new-0), graph, (:selectedStrategy this), (:immutableGraph this)))
        nil
    )

    (§ defn #_"void" SchedulePhase'run-3 [#_"Graph" graph, #_"SchedulingStrategy" strategy, #_"ControlFlowGraph" cfg]
        (§ ass! (ScheduleInstance'new-1 cfg) (ScheduleInstance''run-4 (ScheduleInstance'new-1 cfg), graph, strategy, false))
        nil
    )
)

;;;
 ; @anno SchedulePhase.SchedulingStrategy
 ;;
(value-ns SchedulingStrategy
    (§ enum SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER)
    (§ enum SchedulingStrategy'EARLIEST)
    (§ enum SchedulingStrategy'LATEST)
    (§ enum SchedulingStrategy'LATEST_OUT_OF_LOOPS)
    (§ enum SchedulingStrategy'FINAL_SCHEDULE)

    (§ defn #_"boolean" SchedulingStrategy'isEarliest-1 [#_"SchedulingStrategy" self]
        (any = self SchedulingStrategy'EARLIEST SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER)
    )

    #_unused
    (§ defn #_"boolean" SchedulingStrategy'isLatest-1 [#_"SchedulingStrategy" self]
        (not (SchedulingStrategy'isEarliest-1 self))
    )
)

;;;
 ; @anno SchedulePhase.ScheduleInstance
 ;;
(final-ns ScheduleInstance
    (def- #_"double" ScheduleInstance'IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR 2)
    ;;;
     ; Map from blocks to the nodes in each block.
     ;;
    (§ mutable #_"ControlFlowGraph" :cfg nil)
    (§ mutable #_"BlockMap<List<Node>>" :blockToNodesMap nil)
    (§ mutable #_"NodeMap<Block>" :nodeToBlockMap nil)

    (§ defn #_"ScheduleInstance" ScheduleInstance'new-0 []
        (ScheduleInstance'new-1 nil)
    )

    (§ defn #_"ScheduleInstance" ScheduleInstance'new-1 [#_"ControlFlowGraph" cfg]
        (let [
            #_"ScheduleInstance" this (Object.)
            this (assoc this :cfg cfg)
        ]
            this
        )
    )

    (§ method! #_"ScheduleInstance" ScheduleInstance''run-4 [#_"ScheduleInstance" this, #_"Graph" graph, #_"SchedulingStrategy" selectedStrategy, #_"boolean" immutableGraph]
        (let [
            this
                (when (nil? (:cfg this)) => this
                    (assoc this :cfg (ControlFlowGraph'compute-5 graph, true, true, true, false))
                )
            #_"NodeMap<Block>" currentNodeMap (NodeMap'new-1 graph)
            #_"NodeBitMap" visited (NodeBitMap'new-1 graph)
            #_"BlockMap<List<Node>>" earliestBlockToNodesMap (BlockMap'new-1 (:cfg this))
            this (assoc this :nodeToBlockMap currentNodeMap)
            this (assoc this :blockToNodesMap earliestBlockToNodesMap)
        ]
            (ScheduleInstance''scheduleEarliestIterative-7 this, earliestBlockToNodesMap, currentNodeMap, visited, graph, immutableGraph, (= selectedStrategy SchedulingStrategy'EARLIEST_WITH_GUARD_ORDER))

            (let [
                this
                    (when-not (SchedulingStrategy'isEarliest-1 selectedStrategy) => this
                        ;; For non-earliest schedules, we need to do a second pass.
                        (let [
                            #_"BlockMap<List<Node>>" latestBlockToNodesMap (BlockMap'new-1 (:cfg this))
                            _
                                (doseq [#_"Block" b (:reversePostOrder (:cfg this))]
                                    (BlockMap''put-3 latestBlockToNodesMap, b, (ArrayList.))
                                )
                            #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap (ScheduleInstance''calcLatestBlocks-7 this, selectedStrategy, currentNodeMap, earliestBlockToNodesMap, visited, latestBlockToNodesMap, immutableGraph)
                        ]
                            (ScheduleInstance'sortNodesLatestWithinBlock-6 (:cfg this), earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited)

                            (assoc this :blockToNodesMap latestBlockToNodesMap)
                        )
                    )
                _ (§ ass! (:cfg this) (ControlFlowGraph''setNodeToBlock-2 (:cfg this), currentNodeMap))
                _ (§ ass! graph (Graph''setLastSchedule-2 graph, (ScheduleResult'new-3 (:cfg this), (:nodeToBlockMap this), (:blockToNodesMap this))))
            ]
                this
            )
        )
    )

    (§ method- #_"BlockMap<ArrayList<FloatingReadNode>>" ScheduleInstance''calcLatestBlocks-7 [#_"ScheduleInstance" this, #_"SchedulingStrategy" strategy, #_"NodeMap<Block>" currentNodeMap, #_"BlockMap<List<Node>>" earliestBlockToNodesMap, #_"NodeBitMap" visited, #_"BlockMap<List<Node>>" latestBlockToNodesMap, #_"boolean" immutableGraph]
        (let [
            #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap (BlockMap'new-1 (:cfg this))
            #_"Block[]" reversePostOrder (:reversePostOrder (:cfg this))
        ]
            (loop-when-recur [#_"int" j (dec (count reversePostOrder))] (<= 0 j) [(dec j)]
                (let [
                    #_"Block" block (nth reversePostOrder j)
                    #_"List<Node>" blockToNodes (BlockMap''get-2 earliestBlockToNodesMap, block)
                ]
                    (loop-when [#_"LocationSet" killed nil #_"int" i' (count blockToNodes) #_"int" i (dec i')] (<= 0 i)
                        (let [
                            #_"Node" node (nth blockToNodes i)
                            [killed i']
                                (when-not (instance? FixedNode node) => [killed i'] ;; For these nodes, the earliest is at the same time the latest block.
                                    (let [
                                        [killed i' #_"LocationIdentity" constrainingLocation #_"Block" latestBlock]
                                            (when (instance? FloatingReadNode node) => [killed i' nil nil]
                                                ;; We are scheduling a floating read node => check memory anti-dependencies.
                                                (let [
                                                    #_"LocationIdentity" location (FloatingAccessNode''getLocationIdentity-1 node)
                                                ]
                                                    (when (#_"LocationIdentity" .isMutable location) => [killed i' nil nil]
                                                        ;; Location can be killed.
                                                        (let [
                                                            constrainingLocation location
                                                            [killed i' latestBlock]
                                                                (when (Block''canKill-2 block, location) => [killed i' nil]
                                                                    (let [
                                                                        killed (or killed (LocationSet'new-0))
                                                                    ]
                                                                        (ScheduleInstance'fillKillSet-2 killed, (#_"List" .subList blockToNodes, (inc i), i'))
                                                                        ;; Earliest block kills location => we need to stay within earliest block.
                                                                        [killed i (when (LocationSet''contains-2 killed, location) block)]
                                                                    )
                                                                )
                                                        ]
                                                            [killed i' constrainingLocation latestBlock]
                                                        )
                                                    )
                                                )
                                            )
                                    ]
                                        (if (nil? latestBlock)
                                            ;; We are not constraint within earliest block => calculate optimized schedule.
                                            (ScheduleInstance''calcLatestBlock-10 this, block, strategy, node, currentNodeMap, constrainingLocation, watchListMap, latestBlockToNodesMap, visited, immutableGraph)
                                            (ScheduleInstance'selectLatestBlock-7 node, block, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap)
                                        )
                                        [killed i']
                                    )
                                )
                        ]
                            (recur killed i' (dec i))
                        )
                    )
                )
            )
            watchListMap
        )
    )

    (§ defn #_"void" ScheduleInstance'selectLatestBlock-7 [#_"Node" currentNode, #_"Block" currentBlock, #_"Block" latestBlock, #_"NodeMap<Block>" currentNodeMap, #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap, #_"LocationIdentity" constrainingLocation, #_"BlockMap<List<Node>>" latestBlockToNodesMap]
        (when-not (= currentBlock latestBlock)
            (§ ass! currentNodeMap (NodeMap''setAndGrow-3 currentNodeMap, currentNode, latestBlock))

            (when (and (some? constrainingLocation) (Block''canKill-2 latestBlock, constrainingLocation))
                (when (nil? (BlockMap''get-2 watchListMap, latestBlock))
                    (BlockMap''put-3 watchListMap, latestBlock, (ArrayList.))
                )
                (#_"ArrayList" .add (BlockMap''get-2 watchListMap, latestBlock), (§ cast #_"FloatingReadNode" currentNode))
            )
        )

        (#_"List" .add (BlockMap''get-2 latestBlockToNodesMap, latestBlock), currentNode)
        nil
    )

    (§ defn #_"Block" ScheduleInstance'checkKillsBetween-3 [#_"Block" earliest, #_"Block" latest, #_"LocationIdentity" location]
        (let [
            ;; Collect dominator chain that needs checking.
            #_"List<Block>" dominators (ArrayList.)
        ]
            (#_"List" .add dominators, latest)
            (loop-when-recur [#_"Block" block (:dominator latest)] (not= block earliest) [(:dominator block)]
                ;; Current is an intermediate dominator between earliest and latest.
                (when (Block''canKill-2 block, location)
                    (#_"List" .clear dominators)
                )
                (#_"List" .add dominators, block)
            )
            ;; The first element of dominators now contains the latest possible block.
            (let [
                #_"Block" last
                    (loop-when [last earliest #_"int" i (dec (count dominators))] (<= 0 i) => last
                        (let [
                            #_"Block" block (nth dominators i)
                            ;; We are entering a loop boundary. The new loops must not kill the location for the crossing to be safe.
                            ? (or (and (< (Block''getLoopDepth-1 last) (Block''getLoopDepth-1 block)) (some? (:loop block)) (Loop''canKill-2 (:loop block), location)) (Block''canKillBetweenThisAndDominator-2 block, location))
                        ]
                            (if ? last (recur block (dec i)))
                        )
                    )
            ]
                (when (instance? KillingBeginNode (:beginNode last)) => last
                    (let [
                        #_"LocationIdentity" identity (KillingBeginNode''getLocationIdentity-1 (:beginNode last))
                    ]
                        (when (and (or (#_"LocationIdentity" .isAny identity) (= identity location)) (not= last earliest)) => last
                            ;; The begin of this block kills the location, so we *have* to schedule the node in the dominating block.
                            (:dominator last)
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"void" ScheduleInstance'fillKillSet-2 [#_"LocationSet" killed, #_"List<Node>" nodes]
        (when-not (LocationSet''isAny-1 killed)
            (loop-when [#_"ISeq" s (seq nodes)] (some? s)
                (let [
                    #_"Node" node (first s)
                ]
                    (or
                        ;; Check if this node kills a node in the watch list.
                        (condp instance? node
                            Single
                                (do
                                    (§ ass! killed (LocationSet''add-2 killed, (Single''getLocationIdentity-1 node)))
                                    (when (LocationSet''isAny-1 killed)
                                        :done
                                    )
                                )
                            Multi
                                (loop-when [#_"ISeq" s (seq (Multi''getLocationIdentities-1 node))] (some? s)
                                    (§ ass! killed (LocationSet''add-2 killed, (first s)))
                                    (when (LocationSet''isAny-1 killed) => (recur (next s))
                                        :done
                                    )
                                )
                            nil
                        )
                        (recur (next s))
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" ScheduleInstance'sortNodesLatestWithinBlock-6 [#_"ControlFlowGraph" cfg, #_"BlockMap<List<Node>>" earliestBlockToNodesMap, #_"BlockMap<List<Node>>" latestBlockToNodesMap, #_"NodeMap<Block>" currentNodeMap, #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap, #_"NodeBitMap" visited]
        (doseq [#_"Block" block (:reversePostOrder cfg)]
            (ScheduleInstance'sortNodesLatestWithinBlock-6 block, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited)
        )
        nil
    )

    (§ defn- #_"void" ScheduleInstance'sortNodesLatestWithinBlock-6 [#_"Block" block, #_"BlockMap<List<Node>>" earliestBlockToNodesMap, #_"BlockMap<List<Node>>" latestBlockToNodesMap, #_"NodeMap<Block>" nodeMap, #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap, #_"NodeBitMap" unprocessed]
        (let [
            #_"List<Node>" earliestSorting (BlockMap''get-2 earliestBlockToNodesMap, block)
            #_"ArrayList<Node>" result (ArrayList.)
            #_"ArrayList<FloatingReadNode>" watchList (when (some? watchListMap) (BlockMap''get-2 watchListMap, block))
            #_"AbstractBeginNode" beginNode (:beginNode block)
        ]
            (when (instance? LoopExitNode beginNode)
                (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 beginNode)]
                    (NodeBitMap''clear-2 unprocessed, proxy)
                    (let [
                        #_"ValueNode" value (ProxyNode''value-1 proxy)
                    ]
                        ;; if multiple proxies reference the same value, schedule the value of a proxy once
                        (when (and (some? value) (= (NodeMap''get-2 nodeMap, value) block) (NodeBitMap''isMarked-2 unprocessed, value))
                            (ScheduleInstance'sortIntoList-6 value, block, result, nodeMap, unprocessed, nil)
                        )
                    )
                )
            )
            (let [
                #_"FixedNode" endNode (:endNode block)
                ;; Only if the end node is either a control split or an end node,
                ;; we need to force it to be the last node in the schedule.
                #_"FixedNode" fixedEndNode (when (ScheduleInstance'isFixedEnd-1 endNode) endNode)
            ]
                (loop-when [watchList watchList #_"ISeq" s (seq earliestSorting)] (some? s)
                    (let [
                        #_"Node" node (first s)
                        watchList
                            (when-not (= node fixedEndNode) => watchList
                                (cond
                                    (instance? FixedNode node)
                                        (do
                                            (ScheduleInstance'checkWatchList-6 block, nodeMap, unprocessed, result, watchList, node)
                                            (ScheduleInstance'sortIntoList-6 node, block, result, nodeMap, unprocessed, nil)
                                            watchList
                                        )
                                    (and (= (NodeMap''get-2 nodeMap, node) block) (instance? FloatingReadNode node))
                                        (if (ScheduleInstance'isImplicitNullOpportunity-2 node, block)
                                            (do
                                                ;; Schedule at the beginning of the block.
                                                (ScheduleInstance'sortIntoList-6 node, block, result, nodeMap, unprocessed, nil)
                                                watchList
                                            )
                                            (when (Block''canKill-2 block, (FloatingAccessNode''getLocationIdentity-1 node)) => watchList
                                                ;; This read can be killed in this block, add to watch list.
                                                (let [
                                                    watchList (or watchList (ArrayList.))
                                                ]
                                                    (#_"ArrayList" .add watchList, node)
                                                    watchList
                                                )
                                            )
                                        )
                                    :else
                                        watchList
                                )
                            )
                    ]
                        (recur watchList (next s))
                    )
                )
                (doseq [#_"Node" node (BlockMap''get-2 latestBlockToNodesMap, block)]
                    (when (NodeBitMap''isMarked-2 unprocessed, node)
                        (ScheduleInstance'sortIntoList-6 node, block, result, nodeMap, unprocessed, fixedEndNode)
                    )
                )
                (when (and (some? endNode) (NodeBitMap''isMarked-2 unprocessed, endNode))
                    (ScheduleInstance'sortIntoList-6 endNode, block, result, nodeMap, unprocessed, nil)
                )
                (BlockMap''put-3 latestBlockToNodesMap, block, result)
            )
        )
        nil
    )

    (§ defn- #_"void" ScheduleInstance'checkWatchList-6 [#_"Block" block, #_"NodeMap<Block>" nodeMap, #_"NodeBitMap" unprocessed, #_"ArrayList<Node>" result, #_"ArrayList<FloatingReadNode>" watchList, #_"Node" node]
        (when (seq watchList)
            ;; Check if this node kills a node in the watch list.
            (condp instance? node
                Single
                    (let [
                        #_"LocationIdentity" identity (Single''getLocationIdentity-1 node)
                    ]
                        (ScheduleInstance'checkWatchList-6 watchList, identity, block, result, nodeMap, unprocessed)
                    )
                Multi
                    (doseq [#_"LocationIdentity" identity (Multi''getLocationIdentities-1 node)]
                        (ScheduleInstance'checkWatchList-6 watchList, identity, block, result, nodeMap, unprocessed)
                    )
                nil
            )
        )
        nil
    )

    (§ defn- #_"void" ScheduleInstance'checkWatchList-6 [#_"ArrayList<FloatingReadNode>" watchList, #_"LocationIdentity" identity, #_"Block" b, #_"ArrayList<Node>" result, #_"NodeMap<Block>" nodeMap, #_"NodeBitMap" unprocessed]
        (cond
            (#_"LocationIdentity" .isImmutable identity)
                nil ;; Nothing to do. This can happen for an initialization write.
            (#_"LocationIdentity" .isAny identity)
                (do
                    (doseq [#_"FloatingReadNode" r watchList]
                        (when (NodeBitMap''isMarked-2 unprocessed, r)
                            (ScheduleInstance'sortIntoList-6 r, b, result, nodeMap, unprocessed, nil)
                        )
                    )
                    (#_"ArrayList" .clear watchList)
                )
            :else
                (loop-when [#_"int" i 0] (< i (count watchList))
                    (let [
                        #_"FloatingReadNode" r (nth watchList i)
                    ]
                        (when (NodeBitMap''isMarked-2 unprocessed, r)
                            (if (#_"LocationIdentity" .overlaps identity, (FloatingAccessNode''getLocationIdentity-1 r))
                                (ScheduleInstance'sortIntoList-6 r, b, result, nodeMap, unprocessed, nil)
                                (§ continue (inc i))
                            )
                        )
                        (let [
                            #_"int" end (dec (count watchList))
                        ]
                            (#_"ArrayList" .set watchList, i, (nth watchList end))
                            (#_"ArrayList" .remove watchList, end)
                            (recur i)
                        )
                    )
                )
        )
        nil
    )

    (§ defn- #_"void" ScheduleInstance'sortIntoList-6 [#_"Node" node, #_"Block" block, #_"ArrayList<Node>" result, #_"NodeMap<Block>" nodeMap, #_"NodeBitMap" unprocessed, #_"Node" excludeNode]
        (when-not (instance? PhiNode node)
            (NodeBitMap''clear-2 unprocessed, node)
            (doseq [#_"Node" input (Node''inputs-1 node)]
                (when (and (= (NodeMap''get-2 nodeMap, input) block) (NodeBitMap''isMarked-2 unprocessed, input) (not= input excludeNode))
                    (ScheduleInstance'sortIntoList-6 input, block, result, nodeMap, unprocessed, excludeNode)
                )
            )
            (when-not (instance? ProxyNode node) ;; skip proxy nodes
                (#_"ArrayList" .add result, node)
            )
        )
        nil
    )

    (§ method! #_"void" ScheduleInstance''calcLatestBlock-10 [#_"ScheduleInstance" this, #_"Block" earliest, #_"SchedulingStrategy" strategy, #_"Node" node, #_"NodeMap<Block>" nodeMap, #_"LocationIdentity" constrainingLocation, #_"BlockMap<ArrayList<FloatingReadNode>>" watchListMap, #_"BlockMap<List<Node>>" latestBlockToNodesMap, #_"NodeBitMap" visited, #_"boolean" immutable?]
        (let [
            #_"Block" latest
                (when (Node''hasUsages-1 node) => earliest
                    (let [
                        latest
                            (loop-when [latest nil #_"ISeq" s (seq (Node''usages-1 node))] (some? s) => latest
                                (let [
                                    #_"Node" usage (first s)
                                    ;; Normally, dead nodes are deleted by the scheduler before we reach this point.
                                    ;; Only when the scheduler is asked to not modify a graph, we can see dead nodes here.
                                    latest
                                        (when-not (and immutable? (not (NodeBitMap''contains-2 visited, usage))) => latest
                                            (ScheduleInstance'calcBlockForUsage-4 node, usage, latest, nodeMap)
                                        )
                                ]
                                    (recur latest (next s))
                                )
                            )
                        latest
                            (when (any = strategy SchedulingStrategy'FINAL_SCHEDULE SchedulingStrategy'LATEST_OUT_OF_LOOPS) => latest
                                (loop-when [latest latest #_"Block" block latest] (and (< (Block''getLoopDepth-1 earliest) (Block''getLoopDepth-1 block)) (not= block (:dominator earliest))) => latest
                                    (let [
                                        #_"Block" prior block
                                        block (:dominator block)
                                        ;; Only assign new latest block if frequency is actually lower or
                                        ;; if loop proxies would be required otherwise.
                                        ? (and (Block''isLoopHeader-1 prior) (or (< (:probability block) (:probability latest)) (:hasValueProxies (:graph node))))
                                    ]
                                        (recur (if ? block latest) block)
                                    )
                                )
                            )
                    ]
                        (when (and (not= latest earliest) (not= latest (:dominator earliest)) (some? constrainingLocation)) => latest
                            (ScheduleInstance'checkKillsBetween-3 earliest, latest, constrainingLocation)
                        )
                    )
                )
            ? (and (not= latest earliest) (instance? FloatingReadNode node) (ScheduleInstance'isImplicitNullOpportunity-2 node, earliest) (< (:probability earliest) (* (:probability latest) ScheduleInstance'IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR)))
        ]
            (ScheduleInstance'selectLatestBlock-7 node, earliest, (if ? earliest latest), nodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap)
        )
        nil
    )

    (§ defn- #_"boolean" ScheduleInstance'isImplicitNullOpportunity-2 [#_"FloatingReadNode" floatingReadNode, #_"Block" block]
        (let [
            #_"Node" pred (:predecessor (:beginNode block))
        ]
            (and (instance? IfNode pred) (instance? IsNullNode (:condition pred))
                (= (ScheduleInstance'getUnproxifiedUncompressed-1 (AddressNode''getBase-1 (FloatingAccessNode''getAddress-1 floatingReadNode)))
                   (ScheduleInstance'getUnproxifiedUncompressed-1 (UnaryOpLogicNode''getValue-1 (:condition pred)))
                )
            )
        )
    )

    (§ defn- #_"Node" ScheduleInstance'getUnproxifiedUncompressed-1 [#_"Node" node]
        (loop [node node]
            (condp instance? node
                ValueProxy
                    (recur (Proxy''getOriginalNode-1 node))
                ConvertNode
                    (when (ConvertNode''mayNullCheckSkipConversion-1 node) => node
                        (recur (ConvertNode''getValue-1 node))
                    )
                node
            )
        )
    )

    (§ defn- #_"Block" ScheduleInstance'calcBlockForUsage-4 [#_"Node" node, #_"Node" usage, #_"Block" block, #_"NodeMap<Block>" currentNodeMap]
        (condp instance? usage
            PhiNode
                ;; An input to a PhiNode is used at the end of the predecessor block that
                ;; corresponds to the PhiNode input. One PhiNode can use an input multiple times.
                (let [
                    #_"Block" mergeBlock (NodeMap''get-2 currentNodeMap, (PhiNode''merge-1 usage))
                ]
                    (loop-when-recur [block block #_"int" i 0]
                                     (< i (PhiNode''valueCount-1 usage))
                                     [(if (= (PhiNode''valueAt-2 usage, i) node) (ControlFlowGraph'commonDominator-2 block, (nth (:predecessors mergeBlock) i)) block) (inc i)]
                                  => block
                    )
                )
            AbstractBeginNode
                (let [
                    #_"Block" otherBlock (NodeMap''get-2 currentNodeMap, usage)
                ]
                    (ControlFlowGraph'commonDominator-2 block, (if (instance? StartNode usage) otherBlock (:dominator otherBlock)))
                )
            #_else
                ;; All other types of usages: Put the input into the same block as the usage.
                (let [
                    #_"Block" otherBlock (NodeMap''get-2 currentNodeMap, (if (instance? ProxyNode usage) (:loopExit usage) usage))
                ]
                    (ControlFlowGraph'commonDominator-2 block, otherBlock)
                )
        )
    )

    (§ method- #_"void" ScheduleInstance''scheduleEarliestIterative-7 [#_"ScheduleInstance" this, #_"BlockMap<List<Node>>" blockToNodes, #_"NodeMap<Block>" nodeToBlock, #_"NodeBitMap" visited, #_"Graph" graph, #_"boolean" immutableGraph, #_"boolean" withGuardOrder]
        (let [
            #_"NodeMap<MicroBlock>" entries (NodeMap'new-1 graph)
            #_"NodeStack" stack (NodeStack'new-0)
            ;; Initialize with fixed nodes.
            [#_"MicroBlock" startBlock #_"int" nextId]
                (loop-when [startBlock nil nextId 1 #_"ISeq" s (seq (:reversePostOrder (:cfg this)))] (some? s) => [startBlock nextId]
                    (let [
                        #_"Block" block (first s)
                        [startBlock nextId]
                            (loop-when [startBlock startBlock nextId nextId #_"ISeq" s (seq (AbstractBeginNode''getBlockNodes-1 (:beginNode block)))] (some? s) => [startBlock nextId]
                                (let [
                                    #_"FixedNode" node (first s)
                                    #_"MicroBlock" microBlock (MicroBlock'new-1 nextId)
                                ]
                                    (NodeMap''set-3 entries, node, microBlock)
                                    (NodeBitMap''checkAndMarkInc-2 visited, node)
                                    (recur (or startBlock microBlock) (inc nextId) (next s))
                                )
                            )
                    ]
                        (recur startBlock nextId (next s))
                    )
                )
        ]
            (when (and (GuardsStage'allowsFloatingGuards-1 (:guardsStage graph)) (NodeIterable''isNotEmpty-1 (Graph''getNodes-2 graph, GuardNode'TYPE)))
                ;; Now process guards.
                (if (and GraalOptions'guardPriorities withGuardOrder)
                    (let [
                        #_"EnumMap<GuardPriority, List<GuardNode>>" guardsByPriority (EnumMap. GuardPriority)
                    ]
                        (doseq [#_"GuardNode" guard (Graph''getNodes-2 graph, GuardNode'TYPE)]
                            (#_"List" .add (#_"EnumMap" .computeIfAbsent guardsByPriority, (FloatingAnchoredNode''computePriority-1 guard), (ß p -> (§ fun (ArrayList.)))), guard)
                        )
                        ;; 'EnumMap.values' returns values in "natural" key order.
                        (doseq [#_"List<GuardNode>" guards (#_"EnumMap" .values guardsByPriority)]
                            (ScheduleInstance'processNodes-5 visited, entries, stack, startBlock, guards)
                        )
                        (GuardOrder'resortGuards-3 graph, entries, stack)
                    )
                    (ScheduleInstance'processNodes-5 visited, entries, stack, startBlock, (Graph''getNodes-2 graph, GuardNode'TYPE))
                )
            )
            ;; Now process inputs of fixed nodes.
            (doseq [#_"Block" b (:reversePostOrder (:cfg this))]
                (doseq [#_"FixedNode" current (AbstractBeginNode''getBlockNodes-1 (:beginNode b))]
                    (ScheduleInstance'processNodes-5 visited, entries, stack, startBlock, (Node''inputs-1 current))
                )
            )
            (when (< (:counter visited) (Graph''getNodeCount-1 graph))
                ;; Visit back input edges of loop phis.
                (loop []
                    (let [
                        [#_"boolean" unmarked? #_"boolean" changed?]
                            (loop-when [unmarked? false changed? false #_"ISeq" s (seq (Graph''getNodes-2 graph, LoopBeginNode'TYPE))] (some? s) => [unmarked? changed?]
                                (let [
                                    #_"LoopBeginNode" loopBegin (first s)
                                    [unmarked? changed?]
                                        (loop-when [unmarked? unmarked? changed? changed? #_"ISeq" s (seq (AbstractMergeNode''phis-1 loopBegin))] (some? s) => [unmarked? changed?]
                                            (let [
                                                #_"PhiNode" phi (first s)
                                                [unmarked? changed?]
                                                    (when (NodeBitMap''isMarked-2 visited, phi) => [true changed?]
                                                        (loop-when [unmarked? unmarked? changed? changed? #_"int" i 0] (< i (:nextEndIndex loopBegin)) => [unmarked? changed?]
                                                            (let [
                                                                #_"Node" node (PhiNode''valueAt-2 phi, (+ i (AbstractMergeNode''forwardEndCount-1 loopBegin)))
                                                                changed?
                                                                    (when (and (some? node) (nil? (NodeMap''get-2 entries, node))) => changed?
                                                                        (ScheduleInstance'processStack-5 node, startBlock, entries, visited, stack)
                                                                        true
                                                                    )
                                                            ]
                                                                (recur unmarked? changed? (inc i))
                                                            )
                                                        )
                                                    )
                                            ]
                                                (recur unmarked? changed? (next s))
                                            )
                                        )
                                ]
                                    (recur unmarked? changed? (next s))
                                )
                            )
                    ]
                        ;; The processing of one loop phi could have marked a previously checked loop phi, therefore this needs to be iterative.
                        (recur-if (and unmarked? changed?) [])
                    )
                )
            )
            ;; Check for dead nodes.
            (when (and (not immutableGraph) (< (:counter visited) (Graph''getNodeCount-1 graph)))
                (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                    (when-not (NodeBitMap''isMarked-2 visited, node)
                        (Node''clearInputs-1 node)
                        (Node''markDeleted-1 node)
                    )
                )
            )
            (doseq [#_"Block" block (:reversePostOrder (:cfg this))]
                (let [
                    #_"FixedNode" fixedNode (:endNode block)
                ]
                    (when (instance? ControlSplitNode fixedNode)
                        (let [
                            #_"AbstractBeginNode" primarySuccessor (ControlSplitNode''getPrimarySuccessor-1 fixedNode)
                        ]
                            (when (some? primarySuccessor)
                                (§ ass! (NodeMap''get-2 entries, fixedNode) (MicroBlock''prependChildrenTo-2 (NodeMap''get-2 entries, fixedNode), (NodeMap''get-2 entries, primarySuccessor)))
                            )
                        )
                    )
                )
            )
            (doseq [#_"Block" block (:reversePostOrder (:cfg this))]
                (let [
                    #_"ArrayList<Node>" nodes (ArrayList.)
                ]
                    (doseq [#_"FixedNode" node (AbstractBeginNode''getBlockNodes-1 (:beginNode block))]
                        (NodeMap''set-3 nodeToBlock, node, block)
                        (#_"ArrayList" .add nodes, node)
                        (loop-when-recur [#_"NodeEntry" next (:head (NodeMap''get-2 entries, node))] (some? next) [(:next next)]
                            (NodeMap''set-3 nodeToBlock, (:node next), block)
                            (#_"ArrayList" .add nodes, (:node next))
                        )
                    )
                    (BlockMap''put-3 blockToNodes, block, nodes)
                )
            )
        )
        nil
    )

    (§ defn- #_"void" ScheduleInstance'processNodes-5 [#_"NodeBitMap" visited, #_"NodeMap<MicroBlock>" entries, #_"NodeStack" stack, #_"MicroBlock" startBlock, #_"Iterable<? extends Node>" nodes]
        (doseq [#_"Node" node nodes]
            (when (nil? (NodeMap''get-2 entries, node))
                (ScheduleInstance'processStack-5 node, startBlock, entries, visited, stack)
            )
        )
        nil
    )

    (§ defn- #_"void" ScheduleInstance'processStackPhi-4 [#_"NodeStack" stack, #_"PhiNode" phiNode, #_"NodeMap<MicroBlock>" nodeToBlock, #_"NodeBitMap" visited]
        (NodeStack''pop-1 stack)
        (when (NodeBitMap''checkAndMarkInc-2 visited, phiNode)
            (let [
                #_"MicroBlock" mergeBlock (NodeMap''get-2 nodeToBlock, (PhiNode''merge-1 phiNode))
            ]
                (NodeMap''set-3 nodeToBlock, phiNode, mergeBlock)
                (let [
                    #_"AbstractMergeNode" merge (PhiNode''merge-1 phiNode)
                ]
                    (dotimes [#_"int" i (AbstractMergeNode''forwardEndCount-1 merge)]
                        (let [
                            #_"Node" input (PhiNode''valueAt-2 phiNode, i)
                        ]
                            (when (and (some? input) (nil? (NodeMap''get-2 nodeToBlock, input)))
                                (§ ass! stack (NodeStack''push-2 stack, input))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" ScheduleInstance'processStackProxy-4 [#_"NodeStack" stack, #_"ProxyNode" proxyNode, #_"NodeMap<MicroBlock>" nodeToBlock, #_"NodeBitMap" visited]
        (NodeStack''pop-1 stack)
        (when (NodeBitMap''checkAndMarkInc-2 visited, proxyNode)
            (NodeMap''set-3 nodeToBlock, proxyNode, (NodeMap''get-2 nodeToBlock, (:loopExit proxyNode)))
            (let [
                #_"Node" input (ProxyNode''value-1 proxyNode)
            ]
                (when (and (some? input) (nil? (NodeMap''get-2 nodeToBlock, input)))
                    (§ ass! stack (NodeStack''push-2 stack, input))
                )
            )
        )
        nil
    )

    (§ defn- #_"void" ScheduleInstance'processStack-5 [#_"Node" first, #_"MicroBlock" startBlock, #_"NodeMap<MicroBlock>" nodeToMicroBlock, #_"NodeBitMap" visited, #_"NodeStack" stack]
        (§ ass! stack (NodeStack''push-2 stack, first))
        (loop [#_"Node" node first]
            (condp instance? node
                PhiNode   (ScheduleInstance'processStackPhi-4 stack, node, nodeToMicroBlock, visited)
                ProxyNode (ScheduleInstance'processStackProxy-4 stack, node, nodeToMicroBlock, visited)
                (if (some? (NodeMap''get-2 nodeToMicroBlock, node))
                    (NodeStack''pop-1 stack)
                    (let [
                        #_"MicroBlock" earliestBlock (ScheduleInstance'processInputs-4 nodeToMicroBlock, stack, startBlock, node)
                    ]
                        (if (nil? earliestBlock)
                            nil ;; We need to delay until inputs are processed.
                            (do
                                ;; Can immediately process and pop.
                                (NodeStack''pop-1 stack)
                                (NodeBitMap''checkAndMarkInc-2 visited, node)
                                (NodeMap''set-3 nodeToMicroBlock, node, earliestBlock)
                                (§ ass! earliestBlock (MicroBlock''add-2 earliestBlock, node))
                            )
                        )
                    )
                )
            )
            (when-not (NodeStack''isEmpty-1 stack)
                (recur (NodeStack''peek-1 stack))
            )
        )
        nil
    )

    ;;;
     ; Processes the inputs of given block. Pushes unprocessed inputs onto the stack. Returns
     ; nil if there were still unprocessed inputs, otherwise returns the earliest block given
     ; node can be scheduled in.
     ;;
    (§ defn- #_"MicroBlock" ScheduleInstance'processInputs-4 [#_"NodeMap<MicroBlock>" nodeToBlock, #_"NodeStack" stack, #_"MicroBlock" startBlock, #_"Node" current]
        (when-not (:isLeafNode (:nodeClass current)) => startBlock
            (loop-when [#_"MicroBlock" earliestBlock startBlock #_"ISeq" s (seq (Node''inputs-1 current))] (some? s) => earliestBlock
                (let [
                    #_"Node" input (first s)
                    #_"MicroBlock" inputBlock (NodeMap''get-2 nodeToBlock, input)
                    earliestBlock
                        (when (nil? inputBlock) => (if (and (some? earliestBlock) (< (:id earliestBlock) (:id inputBlock))) inputBlock earliestBlock)
                            (§ ass! stack (NodeStack''push-2 stack, input))
                            nil
                        )
                ]
                    (recur earliestBlock (next s))
                )
            )
        )
    )

    (§ defn- #_"boolean" ScheduleInstance'isFixedEnd-1 [#_"FixedNode" endNode]
        (or (instance? ControlSplitNode endNode) (instance? ControlSinkNode endNode) (instance? AbstractEndNode endNode))
    )

    ;;;
     ; Gets the nodes in a given block.
     ;;
    #_unused
    (§ method! #_"List<Node>" ScheduleInstance''nodesFor-2 [#_"ScheduleInstance" this, #_"Block" block]
        (BlockMap''get-2 (:blockToNodesMap this), block)
    )
)

;;;
 ; Micro block that is allocated for each fixed node and captures all floating nodes that
 ; need to be scheduled immediately after the corresponding fixed node.
 ;
 ; @anno SchedulePhase.ScheduleInstance.MicroBlock
 ;;
(final-ns MicroBlock
    ;;;
     ; The id of the micro block, with a block always associated with a lower id than its successors.
     ;;
    (§ final #_"int" :id 0)
    ;;;
     ; Number of nodes in this micro block.
     ;;
    (§ mutable #_"int" :nodeCount 0)
    ;;;
     ; First node of the linked list of nodes of this micro block.
     ;;
    (§ mutable #_"NodeEntry" :head nil)
    (§ mutable #_"NodeEntry" :tail nil)

    (§ defn #_"MicroBlock" MicroBlock'new-1 [#_"int" id]
        (let [
            #_"MicroBlock" this (Object.)
            this (assoc this :id id)
        ]
            this
        )
    )

    ;;;
     ; Adds a new floating node into the micro block.
     ;;
    (§ method! #_"MicroBlock" MicroBlock''add-2 [#_"MicroBlock" this, #_"Node" node]
        (let [
            #_"NodeEntry" tail (NodeEntry'new-1 node)
            this
                (if (nil? (:tail this))
                    (let [
                        this (assoc this :head tail)
                        this (assoc this :tail tail)
                    ]
                        this
                    )
                    (let [
                        _ (§ ass! (:next (:tail this)) tail)
                        this (assoc this :tail tail)
                    ]
                        this
                    )
                )
            this (update this :nodeCount inc)
        ]
            this
        )
    )

    ;;;
     ; Takes all nodes in this micro blocks and prepends them to the nodes of the given parameter.
     ;
     ; @param block the new block for the nodes
     ;;
    (§ method! #_"MicroBlock" MicroBlock''prependChildrenTo-2 [#_"MicroBlock" this, #_"MicroBlock" block]
        (when (some? (:tail this)) => this
            (let [
                _ (§ ass! (:next (:tail this)) (:head block))
                _ (§ ass! block (assoc block :head (:head this)))
                this (assoc this :tail nil)
                this (assoc this :head nil)
                _ (§ ass! block (assoc block :nodeCount (+ (:nodeCount block) (:nodeCount this))))
                this (assoc this :nodeCount 0)
            ]
                this
            )
        )
    )
)

;;;
 ; Entry in the linked list of nodes.
 ;
 ; @anno SchedulePhase.ScheduleInstance.NodeEntry
 ;;
(final-ns NodeEntry
    (§ final #_"Node" :node nil)
    (§ mutable #_"NodeEntry" :next nil)

    (§ defn #_"NodeEntry" NodeEntry'new-1 [#_"Node" node]
        (let [
            #_"NodeEntry" this (Object.)
            this (assoc this :node node)
            this (assoc this :next nil)
        ]
            this
        )
    )
)

;;;
 ; @anno SchedulePhase.ScheduleInstance.GuardOrder
 ;;
(value-ns GuardOrder
    ;;;
     ; After an earliest schedule, this will re-sort guards to honor their
     ; {@linkplain StaticDeoptimizingNode#computePriority() priority}.
     ;
     ; Note that this only changes the order of nodes within
     ; {@linkplain MicroBlock micro-blocks},
     ; nodes will not be moved from one micro-block to another.
     ;;
    (§ defn- #_"void" GuardOrder'resortGuards-3 [#_"Graph" graph, #_"NodeMap<MicroBlock>" entries, #_"NodeStack" stack]
        (let [
            #_"EconomicSet<MicroBlock>" blocksWithGuards (EconomicSet/create Equivalence/IDENTITY)
        ]
            (doseq [#_"GuardNode" guard (Graph''getNodes-2 graph, GuardNode'TYPE)]
                (#_"EconomicSet" .add blocksWithGuards, (NodeMap''get-2 entries, guard))
            )
            (let [
                #_"NodeMap<GuardPriority>" priorities (NodeMap'new-1 graph)
                #_"NodeBitMap" blockNodes (NodeBitMap'new-1 graph)
            ]
                (loop-when-recur [#_"ISeq" s (seq blocksWithGuards)] (some? s) [(next s)]
                    (let [
                        #_"MicroBlock" block (first s)
                        #_"MicroBlock" newBlock (GuardOrder'resortGuards-4 block, stack, blockNodes, priorities)
                    ]
                        (when (some? newBlock)
                            (§ ass! block (assoc block :head (:head newBlock)))
                            (§ ass! block (assoc block :tail (:tail newBlock)))
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; This resorts guards within one micro-block.
     ;
     ; {@code stack}, {@code blockNodes} and {@code priorities} are just temporary
     ; data-structures which are allocated once by the callers of this method. They should
     ; be in their "initial"/"empty" state when calling this method and when it returns.
     ;;
    (§ defn- #_"MicroBlock" GuardOrder'resortGuards-4 [#_"MicroBlock" block, #_"NodeStack" stack, #_"NodeBitMap" blockNodes, #_"NodeMap<GuardPriority>" priorities]
        (when (GuardOrder'propagatePriority-4 block, stack, priorities, blockNodes)
            (let [
                #_"Function<GuardNode, GuardPriority>" transitiveGuardPriorityGetter (ß priorities(§ ffun )NodeMap''get-2)
                #_"Comparator<GuardNode>" globalGuardPriorityComparator (#_"Comparator" .thenComparingInt (#_"Comparator" .thenComparing (Comparator/comparing transitiveGuardPriorityGetter), (ß GuardNode(§ ffun )StaticDeoptimizingNode''computePriority-1)), (§ ffun #_"Object" .hashCode))
                #_"SortedSet<GuardNode>" availableGuards (TreeSet. globalGuardPriorityComparator)
                #_"MicroBlock" newBlock (MicroBlock'new-1 (:id block))
                #_"NodeBitMap" sorted blockNodes
            ]
                (NodeBitMap''invert-1 sorted)

                (loop-when-recur [#_"NodeEntry" e (:head block)] (some? e) [(:next e)]
                    (GuardOrder'checkIfAvailable-6 (:node e), stack, sorted, newBlock, availableGuards, false)
                )
                (loop []
                    (while (not (NodeStack''isEmpty-1 stack))
                        (GuardOrder'checkIfAvailable-6 (NodeStack''pop-1 stack), stack, sorted, newBlock, availableGuards, true)
                    )
                    (let [
                        #_"Iterator<GuardNode>" it (#_"SortedSet" .iterator availableGuards)
                    ]
                        (when (#_"Iterator" .hasNext it)
                            (GuardOrder'addNodeToResort-5 (#_"Iterator" .next it), stack, sorted, newBlock, true)
                            (#_"Iterator" .remove it)
                        )
                        (recur-if (or (not (NodeStack''isEmpty-1 stack)) (seq availableGuards)) [])
                    )
                )

                (NodeBitMap''clearAll-1 blockNodes)
                newBlock
            )
        )
    )

    ;;;
     ; This checks if {@code node} can be scheduled, if it is the case, it schedules it now
     ; by calling #addNodeToResort(Node, NodeStack, NodeBitMap, MicroBlock, boolean).
     ;;
    (§ defn- #_"void" GuardOrder'checkIfAvailable-6 [#_"Node" node, #_"NodeStack" stack, #_"NodeBitMap" sorted, #_"MicroBlock" newBlock, #_"SortedSet<GuardNode>" availableGuardNodes, #_"boolean" pushUsages]
        (when-not (NodeBitMap''isMarked-2 sorted, node)
            (loop [#_"ISeq" s (seq (Node''inputs-1 node))]
                (if (some? s)
                    (when (NodeBitMap''isMarked-2 sorted, (first s))
                        (recur (next s))
                    )
                    (if (instance? GuardNode node)
                        (#_"SortedSet" .add availableGuardNodes, node)
                        (GuardOrder'addNodeToResort-5 node, stack, sorted, newBlock, pushUsages)
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Add a node to the re-sorted micro-block. This also pushes nodes that need to be
     ; (re-)examined on the stack.
     ;;
    (§ defn- #_"void" GuardOrder'addNodeToResort-5 [#_"Node" node, #_"NodeStack" stack, #_"NodeBitMap" sorted, #_"MicroBlock" newBlock, #_"boolean" pushUsages]
        (NodeBitMap''mark-2 sorted, node)
        (§ ass! newBlock (MicroBlock''add-2 newBlock, node))
        (when pushUsages
            (doseq [#_"Node" usage (Node''usages-1 node)]
                (when-not (NodeBitMap''isMarked-2 sorted, usage)
                    (§ ass! stack (NodeStack''push-2 stack, usage))
                )
            )
        )
        nil
    )

    ;;;
     ; This fills in a map of transitive priorities ({@code priorities}). It also marks the
     ; nodes from this micro-block in {@code blockNodes}.
     ;
     ; The transitive priority of a guard is the highest of its priority and the priority of
     ; the guards that depend on it (transitively).
     ;
     ; This method returns false if no re-ordering is necessary in this micro-block.
     ;;
    (§ defn- #_"boolean" GuardOrder'propagatePriority-4 [#_"MicroBlock" block, #_"NodeStack" stack, #_"NodeMap<GuardPriority>" priorities, #_"NodeBitMap" blockNodes]
        (let [
            #_"GuardPriority" lowestPriority
                (loop-when [lowestPriority (GuardPriority'highest-0) #_"NodeEntry" e (:head block)] (some? e) => lowestPriority
                    (NodeBitMap''mark-2 blockNodes, (:node e))
                    (let [
                        lowestPriority
                            (when (instance? GuardNode (:node e)) => lowestPriority
                                (let [
                                    #_"GuardNode" guard (:node e)
                                    #_"GuardPriority" priority (FloatingAnchoredNode''computePriority-1 guard)
                                    lowestPriority
                                        (when (some? lowestPriority)
                                            (cond
                                                (GuardPriority'isLowerPriorityThan-2 priority, lowestPriority)  priority
                                                (GuardPriority'isHigherPriorityThan-2 priority, lowestPriority) nil
                                                :else                                                           lowestPriority
                                            )
                                        )
                                ]
                                    (§ ass! stack (NodeStack''push-2 stack, guard))
                                    (NodeMap''set-3 priorities, guard, priority)
                                    lowestPriority
                                )
                            )
                    ]
                        (recur lowestPriority (:next e))
                    )
                )
        ]
            (if (some? lowestPriority)
                (do
                    (§ ass! stack (NodeStack''clear-1 stack))
                    (NodeBitMap''clearAll-1 blockNodes)
                    false
                )
                (loop []
                    (let [
                        #_"Node" node (NodeStack''pop-1 stack)
                        #_"GuardPriority" priority (NodeMap''get-2 priorities, node)
                    ]
                        (loop-when-recur [#_"ISeq" s (seq (Node''inputs-1 node))] (some? s) [(next s)]
                            (let [
                                #_"Node" input (first s)
                            ]
                                (when (NodeBitMap''isMarked-2 blockNodes, input)
                                    (let [
                                        #_"GuardPriority" inputPriority (NodeMap''get-2 priorities, input)
                                    ]
                                        (when (or (nil? inputPriority) (GuardPriority'isLowerPriorityThan-2 inputPriority, priority))
                                            (NodeMap''set-3 priorities, input, priority)
                                            (§ ass! stack (NodeStack''push-2 stack, input))
                                        )
                                    )
                                )
                            )
                        )
                        (recur-if (not (NodeStack''isEmpty-1 stack)) [] => true)
                    )
                )
            )
        )
    )
)

(final-ns HighTierContext (§ extends PhaseContext)
    (§ final #_"OptimisticOptimizations" :optimisticOpts nil)

    (§ defn #_"HighTierContext" HighTierContext'new-1 [#_"OptimisticOptimizations" optimisticOpts]
        (let [
            #_"HighTierContext" this (PhaseContext'new-0)
            this (assoc this :optimisticOpts optimisticOpts)
        ]
            this
        )
    )
)

(final-ns LowTierContext (§ extends PhaseContext)
    (§ defn #_"LowTierContext" LowTierContext'new-0 []
        (PhaseContext'new-0)
    )
)

(final-ns MidTierContext (§ extends PhaseContext)
    (§ final #_"OptimisticOptimizations" :optimisticOpts nil)

    (§ defn #_"MidTierContext" MidTierContext'new-1 [#_"OptimisticOptimizations" optimisticOpts]
        (let [
            #_"MidTierContext" this (PhaseContext'new-0)
            this (assoc this :optimisticOpts optimisticOpts)
        ]
            this
        )
    )
)

(class-ns PhaseContext
    (§ defn #_"PhaseContext" PhaseContext'new-0 []
        (Object.)
    )
)

(value-ns ValueMergeUtil
    (§ defn #_"<T> ValueNode" ValueMergeUtil'mergeValueProducers-4 [#_"AbstractMergeNode" merge, #_"List<? extends T>" valueProducers, #_"Function<T, FixedWithNextNode>" lastInstrFunction, #_"Function<T, ValueNode>" valueFunction]
        (let [
            [#_"ValueNode" singleResult #_"PhiNode" phiResult]
                (loop-when [singleResult nil phiResult nil #_"ISeq" s (seq valueProducers)] (some? s) => [singleResult phiResult]
                    (let [
                        #_"T" valueProducer (first s)
                        #_"ValueNode" result (#_"Function" .apply valueFunction, valueProducer)
                        [singleResult phiResult]
                            (when (some? result) => [singleResult phiResult]
                                (cond
                                    (and (nil? phiResult) (or (nil? singleResult) (= singleResult result)))
                                        (do
                                            ;; Only one result value, so no need yet for a phi node.
                                            [result phiResult]
                                        )
                                    (nil? phiResult)
                                        ;; Found a second result value, so create phi node.
                                        (let [
                                            phiResult (Graph''add-2 (:graph merge), (ValuePhiNode'new-2 (Stamp''unrestricted-1 (:stamp result)), merge))
                                        ]
                                            (dotimes [#_"int" i (AbstractMergeNode''forwardEndCount-1 merge)]
                                                (PhiNode''addInput-2 phiResult, singleResult)
                                            )
                                            (PhiNode''addInput-2 phiResult, result)
                                            [singleResult phiResult]
                                        )
                                    :else
                                        (do
                                            ;; Multiple return values, just add to existing phi node.
                                            (PhiNode''addInput-2 phiResult, result)
                                            [singleResult phiResult]
                                        )
                                )
                            )
                        ;; create and wire up a new EndNode
                        #_"EndNode" endNode (Graph''add-2 (:graph merge), (EndNode'new-0))
                    ]
                        (AbstractMergeNode''addForwardEnd-2 merge, endNode)
                        (if (some? lastInstrFunction)
                            (§ ass! (#_"Function" .apply lastInstrFunction, valueProducer) (FixedWithNextNode''setNext-2 (#_"Function" .apply lastInstrFunction, valueProducer), endNode))
                            (§ ass! valueProducer (Node''replaceAndDelete-2 valueProducer, endNode))
                        )
                        (recur singleResult phiResult (next s))
                    )
                )
        ]
            (when (some? phiResult) => singleResult
                (ValueNode''inferStamp-1 phiResult)
                phiResult
            )
        )
    )

    (§ defn #_"ValueNode" ValueMergeUtil'mergeReturns-2 [#_"AbstractMergeNode" merge, #_"List<? extends ReturnNode>" returnNodes]
        (ValueMergeUtil'mergeValueProducers-4 merge, returnNodes, nil, (ß returnNode -> (§ fun (:result returnNode))))
    )
)

;;;
 ; Count the number of leading zeros using the {@code lzcntq} or {@code lzcntl} instructions.
 ;;
(final-ns AMD64CountLeadingZerosNode (§ extends UnaryNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<AMD64CountLeadingZerosNode>" AMD64CountLeadingZerosNode'TYPE (NodeClass'create-1 AMD64CountLeadingZerosNode))

    #_unused
    (§ defn #_"AMD64CountLeadingZerosNode" AMD64CountLeadingZerosNode'new-1 [#_"ValueNode" value]
        (UnaryNode'new-3 AMD64CountLeadingZerosNode'TYPE, (AMD64CountLeadingZerosNode'computeStamp-2 (:stamp value), value), value)
    )

    #_unused
    (§ override! #_"Stamp" AMD64CountLeadingZerosNode''foldStamp-2 [#_"AMD64CountLeadingZerosNode" this, #_"Stamp" stamp]
        (AMD64CountLeadingZerosNode'computeStamp-2 stamp, (UnaryNode''getValue-1 this))
    )

    (§ defn- #_"Stamp" AMD64CountLeadingZerosNode'computeStamp-2 [#_"Stamp" stamp, #_"ValueNode" value]
        (StampTool'stampForLeadingZeros-1 stamp)
    )

    (§ defn #_"ValueNode" AMD64CountLeadingZerosNode'tryFold-1 [#_"ValueNode" value]
        (when (instance? ConstantNode value)
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 value)
            ]
                (if (= (ValueNode''getStackKind-1 value) JavaKind/Int)
                    (ConstantNode'forInt-1 (Integer/numberOfLeadingZeros (#_"JavaConstant" .asInt constant)))
                    (ConstantNode'forInt-1 (Long/numberOfLeadingZeros (#_"JavaConstant" .asLong constant)))
                )
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" AMD64CountLeadingZerosNode''canonical-3 [#_"AMD64CountLeadingZerosNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (or (AMD64CountLeadingZerosNode'tryFold-1 value)
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64CountLeadingZerosNode''generate-2 [#_"AMD64CountLeadingZerosNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitCountLeadingZeros-2 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this))))
        nil
    )
)

;;;
 ; Count the number of trailing zeros using the {@code tzcntq} or {@code tzcntl} instructions.
 ;;
(final-ns AMD64CountTrailingZerosNode (§ extends UnaryNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<AMD64CountTrailingZerosNode>" AMD64CountTrailingZerosNode'TYPE (NodeClass'create-1 AMD64CountTrailingZerosNode))

    #_unused
    (§ defn #_"AMD64CountTrailingZerosNode" AMD64CountTrailingZerosNode'new-1 [#_"ValueNode" value]
        (UnaryNode'new-3 AMD64CountTrailingZerosNode'TYPE, (AMD64CountTrailingZerosNode'computeStamp-2 (:stamp value), value), value)
    )

    #_unused
    (§ override! #_"Stamp" AMD64CountTrailingZerosNode''foldStamp-2 [#_"AMD64CountTrailingZerosNode" this, #_"Stamp" stamp]
        (AMD64CountTrailingZerosNode'computeStamp-2 stamp, (UnaryNode''getValue-1 this))
    )

    (§ defn #_"Stamp" AMD64CountTrailingZerosNode'computeStamp-2 [#_"Stamp" stamp, #_"ValueNode" value]
        (StampTool'stampForTrailingZeros-1 stamp)
    )

    (§ defn #_"ValueNode" AMD64CountTrailingZerosNode'tryFold-1 [#_"ValueNode" value]
        (when (instance? ConstantNode value)
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 value)
            ]
                (if (= (ValueNode''getStackKind-1 value) JavaKind/Int)
                    (ConstantNode'forInt-1 (Integer/numberOfTrailingZeros (#_"JavaConstant" .asInt constant)))
                    (ConstantNode'forInt-1 (Long/numberOfTrailingZeros (#_"JavaConstant" .asLong constant)))
                )
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" AMD64CountTrailingZerosNode''canonical-3 [#_"AMD64CountTrailingZerosNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (or (AMD64CountTrailingZerosNode'tryFold-1 value)
            this
        )
    )

    #_unused
    (§ override! #_"void" AMD64CountTrailingZerosNode''generate-2 [#_"AMD64CountTrailingZerosNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitCountTrailingZeros-2 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this))))
        nil
    )
)

(value-ns BoxingSnippets (§ implements Snippets)
    ; @Snippet
    #_unused
    (§ defn #_"Object" BoxingSnippets'booleanValueOf-1 [#_"boolean" value]
        (PiNode'piCastToSnippetReplaceeStamp-1 (Boolean/valueOf value))
    )

    ; @Snippet
    #_unused
    (§ defn #_"Object" BoxingSnippets'byteValueOf-1 [#_"byte" value]
        (PiNode'piCastToSnippetReplaceeStamp-1 (Byte/valueOf value))
    )

    ; @Snippet
    #_unused
    (§ defn #_"Object" BoxingSnippets'charValueOf-1 [#_"char" value]
        (PiNode'piCastToSnippetReplaceeStamp-1 (Character/valueOf value))
    )

    ; @Snippet
    #_unused
    (§ defn #_"Object" BoxingSnippets'intValueOf-1 [#_"int" value]
        (PiNode'piCastToSnippetReplaceeStamp-1 (Integer/valueOf value))
    )

    ; @Snippet
    #_unused
    (§ defn #_"Object" BoxingSnippets'longValueOf-1 [#_"long" value]
        (PiNode'piCastToSnippetReplaceeStamp-1 (Long/valueOf value))
    )

    ; @Snippet
    #_unused
    (§ defn #_"Object" BoxingSnippets'shortValueOf-1 [#_"short" value]
        (PiNode'piCastToSnippetReplaceeStamp-1 (Short/valueOf value))
    )

    ; @Snippet
    #_unused
    (§ defn #_"boolean" BoxingSnippets'booleanValue-1 [#_"Boolean" value]
        (#_"Boolean" .booleanValue value)
    )

    ; @Snippet
    #_unused
    (§ defn #_"byte" BoxingSnippets'byteValue-1 [#_"Byte" value]
        (#_"Byte" .byteValue value)
    )

    ; @Snippet
    #_unused
    (§ defn #_"char" BoxingSnippets'charValue-1 [#_"Character" value]
        (#_"Character" .charValue value)
    )

    ; @Snippet
    #_unused
    (§ defn #_"int" BoxingSnippets'intValue-1 [#_"Integer" value]
        (#_"Integer" .intValue value)
    )

    ; @Snippet
    #_unused
    (§ defn #_"long" BoxingSnippets'longValue-1 [#_"Long" value]
        (#_"Long" .longValue value)
    )

    ; @Snippet
    #_unused
    (§ defn #_"short" BoxingSnippets'shortValue-1 [#_"Short" value]
        (#_"Short" .shortValue value)
    )

    (§ defn #_"FloatingNode" BoxingSnippets'canonicalizeBoxing-1 [#_"BoxNode" box]
        (let [
            #_"ValueNode" value (BoxNode''getValue-1 box)
        ]
            (when (instance? ConstantNode value)
                (let [
                    #_"JavaConstant" sourceConstant (ValueNode''asJavaConstant-1 value)
                    sourceConstant
                        (when (and (not= (#_"JavaConstant" .getJavaKind sourceConstant) (:boxingKind box)) (#_"JavaKind" .isNumericInteger (#_"JavaConstant" .getJavaKind sourceConstant))) => sourceConstant
                            (condp = (:boxingKind box)
                                JavaKind/Boolean (JavaConstant/forBoolean (not (zero? (#_"JavaConstant" .asLong sourceConstant))))
                                JavaKind/Byte    (JavaConstant/forByte          (byte (#_"JavaConstant" .asLong sourceConstant)))
                                JavaKind/Char    (JavaConstant/forChar          (char (#_"JavaConstant" .asLong sourceConstant)))
                                JavaKind/Short   (JavaConstant/forShort        (short (#_"JavaConstant" .asLong sourceConstant)))
                                                 sourceConstant
                            )
                        )
                    #_"JavaConstant" boxedConstant (#_"ConstantReflectionProvider" .boxPrimitive HotSpot'constantReflection, sourceConstant)
                ]
                    (when (and (some? boxedConstant) (= (#_"JavaConstant" .getJavaKind sourceConstant) (:boxingKind box)))
                        (ConstantNode'forConstant-2 boxedConstant, (:graph box))
                    )
                )
            )
        )
    )
)

;;;
 ; @anno BoxingSnippets.BoxingTemplates
 ;;
(final-ns BoxingTemplates (§ extends AbstractTemplates)
    (§ final #_"EnumMap<JavaKind, SnippetInfo>" :boxSnippets (EnumMap. JavaKind))
    (§ final #_"EnumMap<JavaKind, SnippetInfo>" :unboxSnippets (EnumMap. JavaKind))

    (§ defn #_"BoxingTemplates" BoxingTemplates'new-0 []
        (let [
            #_"BoxingTemplates" this (AbstractTemplates'new-0)
        ]
            (doseq [#_"JavaKind" kind (into-array JavaKind [ JavaKind/Boolean, JavaKind/Byte, JavaKind/Char, JavaKind/Int, JavaKind/Long, JavaKind/Short ])]
                (#_"EnumMap" .put (:boxSnippets this), kind, (AbstractTemplates''snippet-4* this, BoxingSnippets, (str (#_"JavaKind" .getJavaName kind) "ValueOf")))
                (#_"EnumMap" .put (:unboxSnippets this), kind, (AbstractTemplates''snippet-4* this, BoxingSnippets, (str (#_"JavaKind" .getJavaName kind) "Value")))
            )
            this
        )
    )

    (§ method! #_"void" BoxingTemplates''lower-3 [#_"BoxingTemplates" this, #_"BoxNode" box, #_"LoweringTool" lowerer]
        (let [
            #_"FloatingNode" canonical (BoxingSnippets'canonicalizeBoxing-1 box)
        ]
            ;; if in AOT mode, we don't want to embed boxed constants.
            (if (some? canonical)
                (§ ass! (:graph box) (Graph''replaceFixedWithFloating-3 (:graph box), box, canonical))
                (let [
                    #_"Arguments" args (Arguments'new-3 (get (:boxSnippets this) (:boxingKind box)), (:guardsStage (:graph box)), (:loweringStage (:phase lowerer)))
                ]
                    (Arguments''add-3 args, "value", (BoxNode''getValue-1 box))
                    (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, box), box, SnippetTemplate'DEFAULT_REPLACER, args)
                )
            )
        )
        nil
    )

    (§ method! #_"void" BoxingTemplates''lower-3 [#_"BoxingTemplates" this, #_"UnboxNode" unbox, #_"LoweringTool" lowerer]
        (let [
            #_"Arguments" args (Arguments'new-3 (get (:unboxSnippets this) (:boxingKind unbox)), (:guardsStage (:graph unbox)), (:loweringStage (:phase lowerer)))
        ]
            (Arguments''add-3 args, "value", (UnboxNode''getValue-1 unbox))
            (SnippetTemplate''instantiate-4 (SnippetTemplate'new-2 args, unbox), unbox, SnippetTemplate'DEFAULT_REPLACER, args)
        )
        nil
    )
)

;;;
 ; Container for objects representing the Code attributes parsed from a class file.
 ;;
(final-ns Classfile
    (def- #_"int" Classfile'MAGIC 0xcafebabe)
    (def- #_"int" Classfile'MAJOR_VERSION_JAVA_MIN 51) ;; JDK7
    (def- #_"int" Classfile'MAJOR_VERSION_JAVA_MAX 55) ;; JDK11

    (§ final #_"ResolvedJavaType" :type nil)
    (§ final #_"List<ClassfileBytecode>" :codeAttributes nil)

    ;;;
     ; Creates a Classfile by parsing the class file bytes for {@code type} loadable from {@code context}.
     ;
     ; @throws NoClassDefFoundError if there is an IO error while parsing the class file
     ;;
    (§ defn #_"Classfile" Classfile'new-3 [#_"ResolvedJavaType" type, #_"DataInputStream" stream, #_"ClassfileBytecodeProvider" context]
        (let [
            #_"Classfile" this (Object.)
            this (assoc this :type type)
            #_"int" magic (#_"DataInputStream" .readInt stream)
            #_"int" minor (#_"DataInputStream" .readUnsignedShort stream)
            #_"int" major (#_"DataInputStream" .readUnsignedShort stream)
            _
                (when-not (<= Classfile'MAJOR_VERSION_JAVA_MIN major Classfile'MAJOR_VERSION_JAVA_MAX)
                    (throw (UnsupportedClassVersionError. (str "unsupported class file version: " major "." minor)))
                )
            #_"ClassfileConstantPool" cp (ClassfileConstantPool'new-2 stream, context)
            _ (Classfile'skipFully-2 stream, 6)                                                   ;; access_flags, this_class, super_class
            _ (Classfile'skipFully-2 stream, (* (#_"DataInputStream" .readUnsignedShort stream) 2)) ;; interfaces
            _ (Classfile'skipFields-1 stream)                                                     ;; fields
            this (assoc this :codeAttributes (Classfile''readMethods-3 this, stream, cp))         ;; methods
            _ (Classfile'skipAttributes-1 stream)                                                 ;; attributes
        ]
            this
        )
    )

    (§ method! #_"ClassfileBytecode" Classfile''getCode-3 [#_"Classfile" this, #_"String" name, #_"String" descriptor]
        (loop-when [#_"ISeq" s (seq (:codeAttributes this))] (some? s) => (throw (NoSuchMethodError. (str (#_"ResolvedJavaType" .toJavaName (:type this)) "." name descriptor)))
            (let [
                #_"ClassfileBytecode" code (first s)
                #_"ResolvedJavaMethod" method (ClassfileBytecode''getMethod-1 code)
            ]
                (when (and (= (#_"ResolvedJavaMethod" .getName method) name) (= (#_"Signature" .toMethodDescriptor (#_"ResolvedJavaMethod" .getSignature method)) descriptor)) => (recur (next s))
                    code
                )
            )
        )
    )

    (§ defn- #_"void" Classfile'skipAttributes-1 [#_"DataInputStream" stream]
        (dotimes [_ (#_"DataInputStream" .readUnsignedShort stream)]
            (Classfile'skipFully-2 stream, 2) ;; name_index
            (Classfile'skipFully-2 stream, (#_"DataInputStream" .readInt stream))
        )
        nil
    )

    (§ defn #_"void" Classfile'skipFully-2 [#_"DataInputStream" stream, #_"int" n]
        (loop [#_"long" i 0]
            (let [
                #_"long" skipped (#_"DataInputStream" .skip stream, (- n i))
                i (+ i skipped)
                i
                    (when (and (zero? skipped) (< i n)) => i
                        ;; check for EOF (i.e. truncated class file)
                        (when (= (#_"DataInputStream" .read stream) -1)
                            (throw (IOException. "truncated stream"))
                        )
                        (inc i)
                    )
            ]
                (recur-if (< i n) [i])
            )
        )
        nil
    )

    (§ method- #_"ClassfileBytecode" Classfile''findCodeAttribute-6 [#_"Classfile" this, #_"DataInputStream" stream, #_"ClassfileConstantPool" cp, #_"String" name, #_"String" descriptor, #_"boolean" static?]
        (let [
            #_"int" attributesCount (#_"DataInputStream" .readUnsignedShort stream)
        ]
            (loop-when [#_"ClassfileBytecode" code nil #_"int" i 0] (< i attributesCount) => code
                (let [
                    #_"String" attributeName (:value (ClassfileConstantPool''get-3 cp, Utf8, (#_"DataInputStream" .readUnsignedShort stream)))
                    #_"int" attributeLength (#_"DataInputStream" .readInt stream)
                    code
                        (if (and (nil? code) (= attributeName "Code"))
                            (let [
                                #_"ResolvedJavaMethod" method (ClassfileBytecodeProvider''findMethod-5 (:context cp), (:type this), name, descriptor, static?)
                                ;; Even if we will discard the Code attribute (see below), we still
                                ;; need to parse it to reach the following class file content.
                                code (ClassfileBytecode'new-3 method, stream, cp)
                            ]
                                (when (some? method) ;; => this is a method hidden from reflection (see sun.reflect.Reflection.filterMethods)
                                    code
                                )
                            )
                            (do
                                (Classfile'skipFully-2 stream, attributeLength)
                                code
                            )
                        )
                ]
                    (recur code (inc i))
                )
            )
        )
    )

    (§ defn- #_"void" Classfile'skipFields-1 [#_"DataInputStream" stream]
        (let [
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
        ]
            (dotimes [#_"int" i n]
                (Classfile'skipFully-2 stream, 6) ;; access_flags, name_index, descriptor_index
                (Classfile'skipAttributes-1 stream)
            )
        )
        nil
    )

    (§ method- #_"List<ClassfileBytecode>" Classfile''readMethods-3 [#_"Classfile" this, #_"DataInputStream" stream, #_"ClassfileConstantPool" cp]
        (let [
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
            #_"List<ClassfileBytecode>" result (ArrayList.)
        ]
            (dotimes [#_"int" i n]
                (let [
                    #_"int" accessFlags (#_"DataInputStream" .readUnsignedShort stream)
                    #_"boolean" static? (Modifier/isStatic accessFlags)
                    #_"String" name (:value (ClassfileConstantPool''get-3 cp, Utf8, (#_"DataInputStream" .readUnsignedShort stream)))
                    #_"String" descriptor (:value (ClassfileConstantPool''get-3 cp, Utf8, (#_"DataInputStream" .readUnsignedShort stream)))
                    #_"ClassfileBytecode" code (Classfile''findCodeAttribute-6 this, stream, cp, name, descriptor, static?)
                ]
                    (when (some? code)
                        (#_"List" .add result, code)
                    )
                )
            )
            result
        )
    )
)

;;;
 ; The bytecode properties of a method as parsed directly from a class file without any
 ; instrumentation or other rewriting performed on the bytecode.
 ;;
(final-ns ClassfileBytecode (§ implements Bytecode)
    (def- #_"int" ClassfileBytecode'EXCEPTION_HANDLER_TABLE_SIZE_IN_BYTES 8)

    (§ final #_"ResolvedJavaMethod" :method nil)

    (§ final #_"ClassfileConstantPool" :constantPool nil)

    (§ mutable #_"byte[]" :code nil)
    (§ mutable #_"int" :maxLocals 0)
    (§ mutable #_"int" :maxStack 0)

    (§ defn #_"ClassfileBytecode" ClassfileBytecode'new-3 [#_"ResolvedJavaMethod" method, #_"DataInputStream" stream, #_"ClassfileConstantPool" constantPool]
        (let [
            #_"ClassfileBytecode" this (Object.)
            this (assoc this :method method)
            this (assoc this :constantPool constantPool)
            this (assoc this :maxStack (#_"DataInputStream" .readUnsignedShort stream))
            this (assoc this :maxLocals (#_"DataInputStream" .readUnsignedShort stream))
            #_"int" codeLength (#_"DataInputStream" .readInt stream)
            this (assoc this :code (byte-array codeLength))
            _ (#_"DataInputStream" .readFully stream, (:code this))
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
            _ (Classfile'skipFully-2 stream, (* n ClassfileBytecode'EXCEPTION_HANDLER_TABLE_SIZE_IN_BYTES))
            _ (ClassfileBytecode''skipCodeAttributes-2 this, stream)
        ]
            this
        )
    )

    (§ method- #_"void" ClassfileBytecode''skipCodeAttributes-2 [#_"ClassfileBytecode" this, #_"DataInputStream" stream]
        (let [
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
        ]
            (dotimes [#_"int" i n]
                (#_"DataInputStream" .readUnsignedShort stream)
                (Classfile'skipFully-2 stream, (#_"DataInputStream" .readInt stream))
            )
        )
        nil
    )

    #_unused
    (§ override! #_"byte[]" ClassfileBytecode''getCode-1 [#_"ClassfileBytecode" this]
        (:code this)
    )

    #_unused
    (§ override! #_"int" ClassfileBytecode''getCodeSize-1 [#_"ClassfileBytecode" this]
        (count (:code this))
    )

    #_unused
    (§ override! #_"int" ClassfileBytecode''getMaxLocals-1 [#_"ClassfileBytecode" this]
        (:maxLocals this)
    )

    #_unused
    (§ override! #_"int" ClassfileBytecode''getMaxStackSize-1 [#_"ClassfileBytecode" this]
        (:maxStack this)
    )

    #_unused
    (§ override! #_"ConstantPool" ClassfileBytecode''getConstantPool-1 [#_"ClassfileBytecode" this]
        (:constantPool this)
    )

    (§ override! #_"ResolvedJavaMethod" ClassfileBytecode''getMethod-1 [#_"ClassfileBytecode" this]
        (:method this)
    )
)

;;;
 ; A BytecodeProvider that provides bytecode properties of a ResolvedJavaMethod as parsed from a class file.
 ; This avoids all {@linkplain java.lang.instrument.Instrumentation instrumentation} and any bytecode
 ; rewriting performed by the VM.
 ;
 ; This mechanism retrieves class files based on the name and ClassLoader of existing Class instances.
 ; It bypasses all VM parsing and verification of the class file and assumes the class files are well formed.
 ; As such, it should only be used for classes from a trusted source such as the boot class (or module) path.
 ;
 ; A combination of Class#forName(String) and an existing MetaAccessProvider is used to resolve
 ; constant pool references. This opens up the opportunity for linkage errors if the referee is structurally
 ; changed through redefinition (e.g. a referred to method is renamed or deleted). This will result in an
 ; appropriate LinkageError being thrown. The only way to avoid this is to have a completely isolated
 ; {@code jdk.vm.ci.meta} implementation for parsing snippet/intrinsic bytecodes.
 ;;
(final-ns ClassfileBytecodeProvider (§ implements BytecodeProvider)
    (§ final #_"ClassLoader" :loader nil)
    (§ final #_"EconomicMap<Class, Classfile>" :classfiles (EconomicMap/create Equivalence/IDENTITY))
    (§ final #_"EconomicMap<String, Class>" :classes (EconomicMap/create))
    (§ final #_"EconomicMap<ResolvedJavaType, FieldsCache>" :fields (EconomicMap/create))
    (§ final #_"EconomicMap<ResolvedJavaType, MethodsCache>" :methods (EconomicMap/create))

    (§ defn #_"ClassfileBytecodeProvider" ClassfileBytecodeProvider'new-0 []
        (let [
            #_"ClassfileBytecodeProvider" this (Object.)
            this (assoc this :loader (or (#_"Class" .getClassLoader (#_"Object" .getClass this)) (ClassLoader/getSystemClassLoader)))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Bytecode" ClassfileBytecodeProvider''getBytecode-2 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaMethod" method]
        (let [
            #_"Classfile" classfile (ClassfileBytecodeProvider''getClassfile-2 this, (ClassfileBytecodeProvider''resolveToClass-2 this, (#_"ResolvedJavaType" .getName (#_"ResolvedJavaMethod" .getDeclaringClass method))))
        ]
            (Classfile''getCode-3 classfile, (#_"ResolvedJavaMethod" .getName method), (#_"Signature" .toMethodDescriptor (#_"ResolvedJavaMethod" .getSignature method)))
        )
    )

    #_unused
    (§ override! #_"boolean" ClassfileBytecodeProvider''supportsInvokedynamic-1 [#_"ClassfileBytecodeProvider" this]
        false
    )

    ;;;
     ; Gets the class file bytes for {@code c}.
     ;;
    (§ defn- #_"InputStream" ClassfileBytecodeProvider'getClassfileAsStream-1 [#_"Class" c]
        (#_"Module" .getResourceAsStream (#_"Class" .getModule c), (str (#_"String" .replace (#_"Class" .getName c), (§ char "."), (§ char "/")) ".class"))
    )

    ;;;
     ; Gets a Classfile created by parsing the class file bytes for {@code c}.
     ;
     ; @throws NoClassDefFoundError if the class file cannot be found
     ;;
    (§ method- #_"Classfile" ClassfileBytecodeProvider''getClassfile-2 [#_"ClassfileBytecodeProvider" this, #_"Class" c]
        (locking this
            (or (get (:classfiles this) c)
                (let [
                    #_"ResolvedJavaType" type (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, c)
                    #_"InputStream" in (ClassfileBytecodeProvider'getClassfileAsStream-1 c)
                ]
                    (when (some? in) => (throw (NoClassDefFoundError. (#_"Class" .getName c)))
                        (let [
                            #_"Classfile" classfile (Classfile'new-3 type, (DataInputStream. in), this)
                        ]
                            (#_"EconomicMap" .put (:classfiles this), c, classfile)
                            classfile
                        )
                    )
                )
            )
        )
    )

    (§ method! #_"Class" ClassfileBytecodeProvider''resolveToClass-2 [#_"ClassfileBytecodeProvider" this, #_"String" descriptor]
        (locking this
            (or (get (:classes this) descriptor)
                (if (= (count descriptor) 1)
                    (#_"JavaKind" .toJavaClass (JavaKind/fromPrimitiveOrVoidTypeChar (nth descriptor 0)))
                    (let [
                        #_"int" dims (loop-when-recur [dims 0] (= (nth descriptor dims) (§ char "[")) [(inc dims)] => dims)
                        #_"String" name
                            (if (and (zero? dims) (#_"String" .startsWith descriptor, "L") (#_"String" .endsWith descriptor, ";"))
                                (#_"String" .replace (#_"String" .substring descriptor, 1, (dec (count descriptor))), (§ char "/"), (§ char "."))
                                (#_"String" .replace                        descriptor,                               (§ char "/"), (§ char "."))
                            )
                        #_"Class" c (Class/forName name, true, (:loader this))
                    ]
                        (#_"EconomicMap" .put (:classes this), descriptor, c)
                        c
                    )
                )
            )
        )
    )

    ;;;
     ; Gets the methods cache for {@code type}.
     ;
     ; Synchronized since the cache is lazily created.
     ;;
    (§ method- #_"MethodsCache" ClassfileBytecodeProvider''getMethods-2 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaType" type]
        (locking this
            (let [
                #_"MethodsCache" methodsCache (get (:methods this) type)
            ]
                (when (nil? methodsCache)
                    (§ ass methodsCache (MethodsCache'new-0))
                    (#_"EconomicMap" .put (:methods this), type, methodsCache)
                )
                methodsCache
            )
        )
    )

    ;;;
     ; Gets the fields cache for {@code type}.
     ;
     ; Synchronized since the cache is lazily created.
     ;;
    (§ method- #_"FieldsCache" ClassfileBytecodeProvider''getFields-2 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaType" type]
        (locking this
            (let [
                #_"FieldsCache" fieldsCache (get (:fields this) type)
            ]
                (when (nil? fieldsCache)
                    (§ ass fieldsCache (FieldsCache'new-0))
                    (#_"EconomicMap" .put (:fields this), type, fieldsCache)
                )
                fieldsCache
            )
        )
    )

    (§ method! #_"ResolvedJavaField" ClassfileBytecodeProvider''findField-5 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaType" type, #_"String" name, #_"String" fieldType, #_"boolean" static?]
        (FieldsCache''lookup-5 (ClassfileBytecodeProvider''getFields-2 this, type), type, name, fieldType, static?)
    )

    (§ method! #_"ResolvedJavaMethod" ClassfileBytecodeProvider''findMethod-5 [#_"ClassfileBytecodeProvider" this, #_"ResolvedJavaType" type, #_"String" name, #_"String" descriptor, #_"boolean" static?]
        (let [
            #_"ResolvedJavaMethod" method (MethodsCache''lookup-4 (ClassfileBytecodeProvider''getMethods-2 this, type), type, name, descriptor)
        ]
            (when (and (some? method) (= (#_"ResolvedJavaMethod" .isStatic method) static?))
                method
            )
        )
    )
)

;;;
 ; Name and type of a field.
 ;
 ; @anno ClassfileBytecodeProvider.FieldKey
 ;;
(final-ns FieldKey
    (§ final #_"String" :name nil)
    (§ final #_"String" :type nil)

    (§ defn #_"FieldKey" FieldKey'new-2 [#_"String" name, #_"String" type]
        (let [
            #_"FieldKey" this (Object.)
            this (assoc this :name name)
            this (assoc this :type type)
        ]
            this
        )
    )
)

;;;
 ; Name and descriptor of a method.
 ;
 ; @anno ClassfileBytecodeProvider.MethodKey
 ;;
(final-ns MethodKey
    (§ final #_"String" :name nil)
    (§ final #_"String" :descriptor nil)

    (§ defn #_"MethodKey" MethodKey'new-2 [#_"String" name, #_"String" descriptor]
        (let [
            #_"MethodKey" this (Object.)
            this (assoc this :name name)
            this (assoc this :descriptor descriptor)
        ]
            this
        )
    )
)

;;;
 ; Method cache for a ResolvedJavaType.
 ;
 ; @anno ClassfileBytecodeProvider.MethodsCache
 ;;
(final-ns MethodsCache
    (§ defn #_"MethodsCache" MethodsCache'new-0 []
        (Object.)
    )

    (§ volatile #_"EconomicMap<MethodKey, ResolvedJavaMethod>" :constructors nil)
    (§ volatile #_"EconomicMap<MethodKey, ResolvedJavaMethod>" :methods nil)

    (§ method! #_"ResolvedJavaMethod" MethodsCache''lookup-4 [#_"MethodsCache" this, #_"ResolvedJavaType" type, #_"String" name, #_"String" descriptor]
        (let [
            #_"MethodKey" key (MethodKey'new-2 name, descriptor)
        ]
            (case name
                "<clinit>"
                    ;; no need to cache <clinit> as it will be looked up at most once
                    (#_"ResolvedJavaType" .getClassInitializer type)
                "<init>"
                    (do
                        (when (nil? (:constructors this))
                            ;; racy initialization is safe since instanceFields is volatile
                            (§ ass! this (assoc this :constructors (MethodsCache'createMethodMap-1 (#_"ResolvedJavaType" .getDeclaredConstructors type))))
                        )
                        (get (:constructors this) key)
                    )
                (do
                    (when (nil? (:methods this))
                        ;; racy initialization is safe since 'methods' is volatile
                        (§ ass! this (assoc this :methods (MethodsCache'createMethodMap-1 (#_"ResolvedJavaType" .getDeclaredMethods type))))
                    )
                    (get (:methods this) key)
                )
            )
        )
    )

    (§ defn- #_"EconomicMap<MethodKey, ResolvedJavaMethod>" MethodsCache'createMethodMap-1 [#_"ResolvedJavaMethod[]" methods]
        (let [
            #_"EconomicMap<MethodKey, ResolvedJavaMethod>" map (EconomicMap/create)
        ]
            (doseq [#_"ResolvedJavaMethod" method methods]
                (#_"EconomicMap" .put map, (MethodKey'new-2 (#_"ResolvedJavaMethod" .getName method), (#_"Signature" .toMethodDescriptor (#_"ResolvedJavaMethod" .getSignature method))), method)
            )
            map
        )
    )
)

;;;
 ; Field cache for a ResolvedJavaType.
 ;
 ; @anno ClassfileBytecodeProvider.FieldsCache
 ;;
(final-ns FieldsCache
    (§ defn #_"FieldsCache" FieldsCache'new-0 []
        (Object.)
    )

    (§ volatile #_"EconomicMap<FieldKey, ResolvedJavaField>" :instanceFields nil)
    (§ volatile #_"EconomicMap<FieldKey, ResolvedJavaField>" :staticFields nil)

    (§ method! #_"ResolvedJavaField" FieldsCache''lookup-5 [#_"FieldsCache" this, #_"ResolvedJavaType" type, #_"String" name, #_"String" fieldType, #_"boolean" static?]
        (let [
            #_"FieldKey" key (FieldKey'new-2 name, fieldType)
        ]
            (if static?
                (do
                    (when (nil? (:staticFields this))
                        ;; racy initialization is safe since staticFields is volatile
                        (§ ass! this (assoc this :staticFields (FieldsCache'createFieldMap-1 (#_"ResolvedJavaType" .getStaticFields type))))
                    )
                    (get (:staticFields this) key)
                )
                (do
                    (when (nil? (:instanceFields this))
                        ;; racy initialization is safe since instanceFields is volatile
                        (§ ass! this (assoc this :instanceFields (FieldsCache'createFieldMap-1 (#_"ResolvedJavaType" .getInstanceFields type, false))))
                    )
                    (get (:instanceFields this) key)
                )
            )
        )
    )

    (§ defn- #_"EconomicMap<FieldKey, ResolvedJavaField>" FieldsCache'createFieldMap-1 [#_"ResolvedJavaField[]" fieldArray]
        (let [
            #_"EconomicMap<FieldKey, ResolvedJavaField>" map (EconomicMap/create)
        ]
            (doseq [#_"ResolvedJavaField" f fieldArray]
                (#_"EconomicMap" .put map, (FieldKey'new-2 (#_"ResolvedJavaField" .getName f), (#_"JavaType" .getName (#_"ResolvedJavaField" .getType f))), f)
            )
            map
        )
    )
)

(class-ns ClassfileConstant
    (def #_"byte" ClassfileConstant'CONSTANT_Utf8               1)
    (def #_"byte" ClassfileConstant'CONSTANT_Integer            3)
    (def #_"byte" ClassfileConstant'CONSTANT_Float              4)
    (def #_"byte" ClassfileConstant'CONSTANT_Long               5)
    (def #_"byte" ClassfileConstant'CONSTANT_Double             6)
    (def #_"byte" ClassfileConstant'CONSTANT_Class              7)
    (def #_"byte" ClassfileConstant'CONSTANT_Fieldref           9)
    (def #_"byte" ClassfileConstant'CONSTANT_String             8)
    (def #_"byte" ClassfileConstant'CONSTANT_Methodref          10)
    (def #_"byte" ClassfileConstant'CONSTANT_InterfaceMethodref 11)
    (def #_"byte" ClassfileConstant'CONSTANT_NameAndType        12)
    (def #_"byte" ClassfileConstant'CONSTANT_MethodHandle       15)
    (def #_"byte" ClassfileConstant'CONSTANT_MethodType         16)
    (def #_"byte" ClassfileConstant'CONSTANT_Dynamic            17)
    (def #_"byte" ClassfileConstant'CONSTANT_InvokeDynamic      18)

    (§ final #_"byte" :tag 0)

    (§ defn #_"ClassfileConstant" ClassfileConstant'new-1 [#_"byte" tag]
        (let [
            #_"ClassfileConstant" this (Object.)
            this (assoc this :tag tag)
        ]
            this
        )
    )

    ;;;
     ; Loads the type, if any, referenced at a specified entry.
     ;;
    (§ method #_"void" ClassfileConstant''loadReferencedType-4 [#_"ClassfileConstant" this, #_"ClassfileConstantPool" cp, #_"int" index, #_"int" opcode]
        nil
    )

    (§ defn #_"ResolvedJavaMethod" ClassfileConstant'resolveMethod-5 [#_"ClassfileBytecodeProvider" context, #_"ResolvedJavaType" c, #_"String" name, #_"String" descriptor, #_"boolean" static?]
        (or (ClassfileBytecodeProvider''findMethod-5 context, c, name, descriptor, static?)
            (when-not (or (#_"ResolvedJavaType" .isJavaLangObject c) (#_"ResolvedJavaType" .isInterface c))
                (ClassfileConstant'resolveMethod-5 context, (#_"ResolvedJavaType" .getSuperclass c), name, descriptor, static?)
            )
            (loop-when [#_"ISeq" s (seq (#_"ResolvedJavaType" .getInterfaces c))] (some? s)
                (or (ClassfileConstant'resolveMethod-5 context, (first s), name, descriptor, static?)
                    (recur (next s))
                )
            )
        )
    )

    (§ defn #_"ResolvedJavaField" ClassfileConstant'resolveField-5 [#_"ClassfileBytecodeProvider" context, #_"ResolvedJavaType" c, #_"String" name, #_"String" fieldType, #_"boolean" static?]
        (or (ClassfileBytecodeProvider''findField-5 context, c, name, fieldType, static?)
            (when-not (or (#_"ResolvedJavaType" .isJavaLangObject c) (#_"ResolvedJavaType" .isInterface c))
                (ClassfileConstant'resolveField-5 context, (#_"ResolvedJavaType" .getSuperclass c), name, fieldType, static?)
            )
            (loop-when [#_"ISeq" s (seq (#_"ResolvedJavaType" .getInterfaces c))] (some? s)
                (or (ClassfileConstant'resolveField-5 context, (first s), name, fieldType, static?)
                    (recur (next s))
                )
            )
        )
    )
)

;;;
 ; @anno ClassfileConstant.ClassRef
 ;;
(final-ns ClassRef (§ extends ClassfileConstant)
    (§ final #_"int" :nameIndex 0)
    (§ mutable #_"ResolvedJavaType" :type nil)

    (§ defn #_"ClassRef" ClassRef'new-1 [#_"DataInputStream" stream]
        (let [
            #_"ClassRef" this (ClassfileConstant'new-1 ClassfileConstant'CONSTANT_Class)
            this (assoc this :nameIndex (#_"DataInputStream" .readUnsignedShort stream))
        ]
            this
        )
    )

    (§ override! #_"void" ClassRef''loadReferencedType-4 [#_"ClassRef" this, #_"ClassfileConstantPool" cp, #_"int" index, #_"int" opcode]
        (ClassRef''resolve-2 this, cp)
        nil
    )

    (§ method! #_"ResolvedJavaType" ClassRef''resolve-2 [#_"ClassRef" this, #_"ClassfileConstantPool" cp]
        (when (nil? (:type this))
            (let [
                #_"String" typeDescriptor (:value (ClassfileConstantPool''get-3 cp, Utf8, (:nameIndex this)))
                #_"ClassfileBytecodeProvider" context (:context cp)
            ]
                (§ ass! this (assoc this :type (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (ClassfileBytecodeProvider''resolveToClass-2 context, typeDescriptor))))
            )
        )
        (:type this)
    )
)

;;;
 ; @anno ClassfileConstant.MemberRef
 ;;
(class-ns MemberRef (§ extends ClassfileConstant)
    (§ final #_"int" :classIndex 0)
    (§ final #_"int" :nameAndTypeIndex 0)

    (§ defn #_"MemberRef" MemberRef'new-2 [#_"byte" tag, #_"DataInputStream" stream]
        (let [
            #_"MemberRef" this (ClassfileConstant'new-1 tag)
            this (assoc this :classIndex (#_"DataInputStream" .readUnsignedShort stream))
            this (assoc this :nameAndTypeIndex (#_"DataInputStream" .readUnsignedShort stream))
        ]
            this
        )
    )

    #_unused
    (§ override #_"void" MemberRef''loadReferencedType-4 [#_"MemberRef" this, #_"ClassfileConstantPool" cp, #_"int" index, #_"int" opcode]
        (ClassRef''loadReferencedType-4 (ClassfileConstantPool''get-3 cp, ClassRef, (:classIndex this)), cp, (:classIndex this), opcode)
        nil
    )
)

;;;
 ; @anno ClassfileConstant.ExecutableRef
 ;;
(class-ns ExecutableRef (§ extends MemberRef)
    (§ mutable #_"ResolvedJavaMethod" :method nil)

    (§ defn #_"ExecutableRef" ExecutableRef'new-2 [#_"byte" tag, #_"DataInputStream" stream]
        (MemberRef'new-2 tag, stream)
    )

    (§ method #_"ResolvedJavaMethod" ExecutableRef''resolve-3 [#_"ExecutableRef" this, #_"ClassfileConstantPool" cp, #_"int" opcode]
        (when (nil? (:method this))
            (let [
                #_"ResolvedJavaType" cls (ClassRef''resolve-2 (ClassfileConstantPool''get-3 cp, ClassRef, (:classIndex this)), cp)
                #_"NameAndType" nameAndType (ClassfileConstantPool''get-3 cp, NameAndType, (:nameAndTypeIndex this))
                #_"String" name (NameAndType''getName-2 nameAndType, cp)
                #_"String" type (NameAndType''getType-2 nameAndType, cp)
            ]
                (cond
                    (= opcode Bytecodes'INVOKEINTERFACE)
                        (do
                            (§ ass! this (assoc this :method (ClassfileConstant'resolveMethod-5 (:context cp), cls, name, type, false)))
                            (when (nil? (:method this))
                                (throw (NoSuchMethodError. (str (#_"ResolvedJavaType" .toJavaName cls) "." name type)))
                            )
                            (when (or (not (#_"ResolvedJavaMethod" .isPublic (:method this))) (not (or (#_"ResolvedJavaType" .isInterface (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))) (#_"ResolvedJavaType" .isJavaLangObject (#_"ResolvedJavaMethod" .getDeclaringClass (:method this))))))
                                (throw (IncompatibleClassChangeError. (str "cannot invokeinterface " (#_"ResolvedJavaMethod" .format (:method this), "%H.\n(%P)%R"))))
                            )
                        )
                    (or (= opcode Bytecodes'INVOKEVIRTUAL) (= opcode Bytecodes'INVOKESPECIAL))
                        (do
                            (§ ass! this (assoc this :method (ClassfileConstant'resolveMethod-5 (:context cp), cls, name, type, false)))
                            (when (nil? (:method this))
                                (throw (NoSuchMethodError. (str (#_"ResolvedJavaType" .toJavaName cls) "." name type)))
                            )
                        )
                    :else
                        (do
                            (§ ass! this (assoc this :method (ClassfileConstant'resolveMethod-5 (:context cp), cls, name, type, true)))
                            (when (nil? (:method this))
                                (throw (NoSuchMethodError. (str (#_"ResolvedJavaType" .toJavaName cls) "." name type)))
                            )
                        )
                )
            )
        )
        (:method this)
    )
)

;;;
 ; @anno ClassfileConstant.MethodRef
 ;;
(final-ns MethodRef (§ extends ExecutableRef)
    (§ defn #_"MethodRef" MethodRef'new-1 [#_"DataInputStream" stream]
        (ExecutableRef'new-2 ClassfileConstant'CONSTANT_Methodref, stream)
    )
)

;;;
 ; @anno ClassfileConstant.InterfaceMethodRef
 ;;
(final-ns InterfaceMethodRef (§ extends ExecutableRef)
    (§ defn #_"InterfaceMethodRef" InterfaceMethodRef'new-1 [#_"DataInputStream" stream]
        (ExecutableRef'new-2 ClassfileConstant'CONSTANT_InterfaceMethodref, stream)
    )
)

;;;
 ; @anno ClassfileConstant.FieldRef
 ;;
(final-ns FieldRef (§ extends MemberRef)
    (§ mutable #_"ResolvedJavaField" :field nil)

    (§ defn #_"FieldRef" FieldRef'new-1 [#_"DataInputStream" stream]
        (MemberRef'new-2 ClassfileConstant'CONSTANT_Fieldref, stream)
    )

    (§ method! #_"ResolvedJavaField" FieldRef''resolve-3 [#_"FieldRef" this, #_"ClassfileConstantPool" cp, #_"int" opcode]
        (when (nil? (:field this))
            (let [
                #_"ResolvedJavaType" cls (ClassRef''resolve-2 (ClassfileConstantPool''get-3 cp, ClassRef, (:classIndex this)), cp)
                #_"NameAndType" nameAndType (ClassfileConstantPool''get-3 cp, NameAndType, (:nameAndTypeIndex this))
                #_"String" name (NameAndType''getName-2 nameAndType, cp)
                #_"String" type (NameAndType''getType-2 nameAndType, cp)
            ]
                (§ ass! this (assoc this :field (ClassfileConstant'resolveField-5 (:context cp), cls, name, type, (or (= opcode Bytecodes'GETSTATIC) (= opcode Bytecodes'PUTSTATIC)))))
                (when (nil? (:field this))
                    (throw (NoSuchFieldError. (str (#_"ResolvedJavaType" .toJavaName cls) "." name " " type)))
                )
            )
        )
        (:field this)
    )
)

;;;
 ; @anno ClassfileConstant.Primitive
 ;;
(final-ns Primitive (§ extends ClassfileConstant)
    (§ final #_"JavaConstant" :value nil)

    (§ defn #_"Primitive" Primitive'new-2 [#_"byte" tag, #_"JavaConstant" value]
        (let [
            #_"Primitive" this (ClassfileConstant'new-1 tag)
            this (assoc this :value value)
        ]
            this
        )
    )
)

;;;
 ; @anno ClassfileConstant.StringRef
 ;;
(final-ns StringRef (§ extends ClassfileConstant)
    (§ final #_"int" :stringIndex 0)
    (§ mutable #_"JavaConstant" :value nil)

    (§ defn #_"StringRef" StringRef'new-1 [#_"DataInputStream" stream]
        (let [
            #_"StringRef" this (ClassfileConstant'new-1 ClassfileConstant'CONSTANT_String)
            this (assoc this :stringIndex (#_"DataInputStream" .readUnsignedShort stream))
        ]
            this
        )
    )

    (§ method! #_"JavaConstant" StringRef''getValue-2 [#_"StringRef" this, #_"ClassfileConstantPool" pool]
        (when (nil? (:value this))
            (§ ass! this (assoc this :value (SnippetReflection'forObject-1 (ClassfileConstantPool''lookupUtf8-2 pool, (:stringIndex this)))))
        )
        (:value this)
    )
)

;;;
 ; @anno ClassfileConstant.NameAndType
 ;;
(final-ns NameAndType (§ extends ClassfileConstant)
    (§ final #_"int" :nameIndex 0)
    (§ final #_"int" :typeIndex 0)
    (§ mutable #_"String" :name nil)
    (§ mutable #_"String" :type nil)

    (§ defn #_"NameAndType" NameAndType'new-1 [#_"DataInputStream" stream]
        (let [
            #_"NameAndType" this (ClassfileConstant'new-1 ClassfileConstant'CONSTANT_NameAndType)
            this (assoc this :nameIndex (#_"DataInputStream" .readUnsignedShort stream))
            this (assoc this :typeIndex (#_"DataInputStream" .readUnsignedShort stream))
        ]
            this
        )
    )

    (§ method! #_"String" NameAndType''getName-2 [#_"NameAndType" this, #_"ClassfileConstantPool" cp]
        (when (nil? (:name this))
            (§ ass! this (assoc this :name (:value (ClassfileConstantPool''get-3 cp, Utf8, (:nameIndex this)))))
        )
        (:name this)
    )

    (§ method! #_"String" NameAndType''getType-2 [#_"NameAndType" this, #_"ClassfileConstantPool" cp]
        (when (nil? (:type this))
            (§ ass! this (assoc this :type (:value (ClassfileConstantPool''get-3 cp, Utf8, (:typeIndex this)))))
        )
        (:type this)
    )
)

;;;
 ; @anno ClassfileConstant.Utf8
 ;;
(final-ns Utf8 (§ extends ClassfileConstant)
    (§ final #_"String" :value nil)

    (§ defn #_"Utf8" Utf8'new-1 [#_"String" value]
        (let [
            #_"Utf8" this (ClassfileConstant'new-1 ClassfileConstant'CONSTANT_Utf8)
            this (assoc this :value value)
        ]
            this
        )
    )
)

;;;
 ; @anno ClassfileConstant.Unsupported
 ;;
(final-ns Unsupported (§ extends ClassfileConstant)
    (§ final #_"String" :name nil)

    (§ defn #_"Unsupported" Unsupported'new-2 [#_"byte" tag, #_"String" name]
        (let [
            #_"Unsupported" this (ClassfileConstant'new-1 tag)
            this (assoc this :name name)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" Unsupported''loadReferencedType-4 [#_"Unsupported" this, #_"ClassfileConstantPool" cp, #_"int" index, #_"int" opcode]
        (throw! (str "Resolution of " (:name this) " constant pool entries not supported by " (#_"Class" .getSimpleName ClassfileBytecodeProvider)))
    )
)

(final-ns ClassfileConstantPool (§ implements ConstantPool)
    (§ final #_"ClassfileConstant[]" :entries nil)
    (§ final #_"ClassfileBytecodeProvider" :context nil)

    (§ defn #_"ClassfileConstantPool" ClassfileConstantPool'new-2 [#_"DataInputStream" stream, #_"ClassfileBytecodeProvider" context]
        (let [
            #_"ClassfileConstantPool" this (Object.)
            this (assoc this :context context)
            #_"int" n (#_"DataInputStream" .readUnsignedShort stream)
            this (assoc this :entries (make-array ClassfileConstant n))
            _
                (loop-when-recur [#_"int" i 1] (< i n) [(if (any = (:tag (nth (:entries this) i)) ClassfileConstant'CONSTANT_Double ClassfileConstant'CONSTANT_Long) (+ i 2) (inc i))]
                    (aset (:entries this) i (ClassfileConstantPool'readConstant-1 stream))
                )
        ]
            this
        )
    )

    (§ defn #_"ClassfileConstant" ClassfileConstantPool'readConstant-1 [#_"DataInputStream" stream]
        (let [
            #_"byte" tag (#_"DataInputStream" .readByte stream)
        ]
            (condp = tag
                ClassfileConstant'CONSTANT_Class              (ClassRef'new-1 stream)
                ClassfileConstant'CONSTANT_Fieldref           (FieldRef'new-1 stream)
                ClassfileConstant'CONSTANT_Methodref          (MethodRef'new-1 stream)
                ClassfileConstant'CONSTANT_InterfaceMethodref (InterfaceMethodRef'new-1 stream)
                ClassfileConstant'CONSTANT_String             (StringRef'new-1 stream)
                ClassfileConstant'CONSTANT_Integer            (Primitive'new-2 tag, (JavaConstant/forInt (#_"DataInputStream" .readInt stream)))
                ClassfileConstant'CONSTANT_Long               (Primitive'new-2 tag, (JavaConstant/forLong (#_"DataInputStream" .readLong stream)))
                ClassfileConstant'CONSTANT_NameAndType        (NameAndType'new-1 stream)
                ClassfileConstant'CONSTANT_Utf8               (Utf8'new-1 (#_"DataInputStream" .readUTF stream))
                ClassfileConstant'CONSTANT_MethodHandle
                (do
                    (Classfile'skipFully-2 stream, 3) ;; reference_kind, reference_index
                    (Unsupported'new-2 tag, "CONSTANT_MethodHandle_info")
                )
                ClassfileConstant'CONSTANT_MethodType
                (do
                    (Classfile'skipFully-2 stream, 2) ;; descriptor_index
                    (Unsupported'new-2 tag, "CONSTANT_MethodType_info")
                )
                ClassfileConstant'CONSTANT_Dynamic
                (do
                    (Classfile'skipFully-2 stream, 4) ;; bootstrap_method_attr_index, name_and_type_index
                    (Unsupported'new-2 tag, "CONSTANT_Dynamic_info")
                )
                ClassfileConstant'CONSTANT_InvokeDynamic
                (do
                    (Classfile'skipFully-2 stream, 4) ;; bootstrap_method_attr_index, name_and_type_index
                    (Unsupported'new-2 tag, "CONSTANT_InvokeDynamic_info")
                )
            )
        )
    )

    (§ override! #_"int" #_"ConstantPool" .length [#_"ClassfileConstantPool" this]
        (count (:entries this))
    )

    (§ method! #_"<T extends ClassfileConstant> T" ClassfileConstantPool''get-3 [#_"ClassfileConstantPool" this, #_"Class<T>" c, #_"int" index]
        (#_"Class" .cast c, (nth (:entries this) index))
    )

    #_unused
    (§ override! #_"void" ClassfileConstantPool''loadReferencedType-3 [#_"ClassfileConstantPool" this, #_"int" index, #_"int" opcode]
        (when (= opcode Bytecodes'INVOKEDYNAMIC)
            (throw! (str "INVOKEDYNAMIC not supported by " (#_"Class" .getSimpleName ClassfileBytecodeProvider)))
        )
        (ClassfileConstant''loadReferencedType-4 (nth (:entries this) index), this, index, opcode)
        nil
    )

    #_unused
    (§ override! #_"JavaField" ClassfileConstantPool''lookupField-4 [#_"ClassfileConstantPool" this, #_"int" index, #_"ResolvedJavaMethod" method, #_"int" opcode]
        (FieldRef''resolve-3 (ClassfileConstantPool''get-3 this, FieldRef, index), this, opcode)
    )

    #_unused
    (§ override! #_"JavaMethod" ClassfileConstantPool''lookupMethod-3 [#_"ClassfileConstantPool" this, #_"int" index, #_"int" opcode]
        (when (= opcode Bytecodes'INVOKEDYNAMIC)
            (throw! (str "INVOKEDYNAMIC not supported by" (#_"Class" .getSimpleName ClassfileBytecodeProvider)))
        )
        (ExecutableRef''resolve-3 (ClassfileConstantPool''get-3 this, ExecutableRef, index), this, opcode)
    )

    (§ override! #_"JavaType" ClassfileConstantPool''lookupType-3 [#_"ClassfileConstantPool" this, #_"int" index, #_"int" opcode]
        (ClassRef''resolve-2 (ClassfileConstantPool''get-3 this, ClassRef, index), this)
    )

    (§ override! #_"String" ClassfileConstantPool''lookupUtf8-2 [#_"ClassfileConstantPool" this, #_"int" index]
        (:value (§ cast #_"Utf8" (nth (:entries this) index)))
    )

    #_unused
    (§ override! #_"Signature" ClassfileConstantPool''lookupSignature-2 [#_"ClassfileConstantPool" this, #_"int" index]
        (throw! "should not reach here")
    )

    #_unused
    (§ override! #_"Object" ClassfileConstantPool''lookupConstant-2 [#_"ClassfileConstantPool" this, #_"int" index]
        (let [
            #_"ClassfileConstant" c (nth (:entries this) index)
        ]
            (if (instance? Primitive c)
                (:value c)
                (condp = (:tag c)
                    ClassfileConstant'CONSTANT_Class  (ClassfileConstantPool''lookupType-3 this, index, -1)
                    ClassfileConstant'CONSTANT_String (StringRef''getValue-2 this, c)
                    (throw! (str "unexpected constant pool tag " (:tag c)))
                )
            )
        )
    )

    #_unused
    (§ override! #_"JavaConstant" ClassfileConstantPool''lookupAppendix-3 [#_"ClassfileConstantPool" this, #_"int" index, #_"int" opcode]
        (when-not (= opcode Bytecodes'INVOKEVIRTUAL)
            (throw! "should not reach here")
        )
    )
)

;;;
 ; A ParameterPlugin that binds constant values to some parameters.
 ;;
(final-ns ConstantBindingParameterPlugin (§ implements ParameterPlugin)
    (§ final #_"Object[]" :constantArgs nil)

    ;;;
     ; Creates a plugin that will create ConstantNodes for each parameter with
     ; an index equal to that of a non-nil object in {@code constantArgs} (from which
     ; the ConstantNode is created if it isn't already a ConstantNode).
     ;;
    (§ defn #_"ConstantBindingParameterPlugin" ConstantBindingParameterPlugin'new-1 [#_"Object[]" constantArgs]
        (let [
            #_"ConstantBindingParameterPlugin" this (Object.)
            this (assoc this :constantArgs constantArgs)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"FloatingNode" ConstantBindingParameterPlugin''interceptParameter-4 [#_"ConstantBindingParameterPlugin" this, #_"GraphBuilderTool" b, #_"int" index, #_"StampPair" stamp]
        (when-some [#_"Object" arg (nth (:constantArgs this) index)]
            (condp instance? arg
                ConstantNode
                    (when-not (= (:graph arg) (:graph b)) => arg
                        ;; This is a node from another graph, so copy over extra state into a new ConstantNode.
                        (ConstantNode'forConstant-4 (:trustedStamp stamp), (:value arg), (:stableDimension arg), (:isDefaultStable arg))
                    )
                Constant
                    (ConstantNode'forConstant-2 (:trustedStamp stamp), arg)
                #_else
                    (ConstantNode'forConstant-1 (SnippetReflection'forBoxed-2 (Stamp''getStackKind-1 (:trustedStamp stamp)), arg))
            )
        )
    )
)

;;;
 ; Provides a capability for replacing a higher node with one or more lower level nodes.
 ;;
(value-ns Lowerer
    (§ def #_"BoxingTemplates"        Lowerer'boxingSnippets        (BoxingTemplates'new-0))
    (§ def #_"InstanceOfTemplates"    Lowerer'instanceofSnippets    (InstanceOfTemplates'new-0))
    (§ def #_"NewObjectTemplates"     Lowerer'newObjectSnippets     (NewObjectTemplates'new-0))
    (§ def #_"MonitorTemplates"       Lowerer'monitorSnippets       (MonitorTemplates'new-1 HotSpot'useFastLocking))
    (§ def #_"WriteBarrierTemplates"  Lowerer'writeBarrierSnippets  (WriteBarrierTemplates'new-1 (when HotSpot'useCompressedOops HotSpot'oopEncoding)))
    (§ def #_"StringToBytesTemplates" Lowerer'stringToBytesSnippets (StringToBytesTemplates'new-0))
    (§ def #_"UnsafeLoadTemplates"    Lowerer'unsafeLoadSnippets    (UnsafeLoadTemplates'new-0))

    (§ defn- #_"boolean" Lowerer'addReadBarrier-1 [#_"RawLoadNode" load]
        (and HotSpot'useG1GC
            (= (:guardsStage (:graph load)) GuardsStage'FIXED_DEOPTS)
            (= (ValueNode''getStackKind-1 (:object load)) JavaKind/Object)
            (= (:accessKind load) JavaKind/Object)
            (not (StampTool'isPointerAlwaysNull-1 (:stamp (:object load))))
            (let [
                #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp (:object load)))
            ]
                (and (some? type) (not (#_"ResolvedJavaType" .isArray type)))
            )
        )
    )

    (§ defn- #_"ReadNode" Lowerer'createReadVirtualMethod-4 [#_"Graph" graph, #_"ValueNode" hub, #_"HotSpotResolvedJavaMethod" method, #_"ResolvedJavaType" receiverType]
        (Lowerer'createReadVirtualMethod-3 graph, hub, (#_"HotSpotResolvedJavaMethod" .vtableEntryOffset method, receiverType))
    )

    (§ defn- #_"ReadNode" Lowerer'createReadVirtualMethod-3 [#_"Graph" graph, #_"ValueNode" hub, #_"int" vtableEntryOffset]
        ;; We use LocationNode.ANY_LOCATION for the reads that access the vtable
        ;; entry as HotSpot does not guarantee that this is a final value.
        (let [
            #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, hub, vtableEntryOffset)
        ]
            (Graph''add-2 graph, (ReadNode'new-4 address, (LocationIdentity/any), MethodPointerStamp'METHOD_NON_NULL, BarrierType'NONE))
        )
    )

    (§ defn- #_"WriteNode" Lowerer'createWriteHub-3 [#_"Graph" graph, #_"ValueNode" object, #_"ValueNode" value]
        (let [
            #_"ValueNode" writeValue (if HotSpot'useCompressedClassPointers (HotSpotCompressionNode'compress-2 value, HotSpot'klassEncoding) value)
            #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, object, HotSpot'hubOffset)
        ]
            (Graph''add-2 graph, (WriteNode'new-4 address, HotSpotReplacementsUtil'HUB_WRITE_LOCATION, writeValue, BarrierType'NONE))
        )
    )

    (§ defn #_"AddressNode" Lowerer'createOffsetAddress-3 [#_"Graph" graph, #_"ValueNode" object, #_"long" offset]
        (Graph''add-2 graph, (OffsetAddressNode'new-2 object, (ConstantNode'forIntegerKind-3 (.wordJavaKind HotSpot'target), offset, graph)))
    )

    (§ defn #_"AddressNode" Lowerer'createFieldAddress-3 [#_"Graph" graph, #_"ValueNode" object, #_"ResolvedJavaField" field]
        (let [
            #_"int" offset (Lowerer'fieldOffset-1 field)
        ]
            (when (<= 0 offset) (Lowerer'createOffsetAddress-3 graph, object, offset))
        )
    )

    (§ defn #_"JavaKind" Lowerer'getStorageKind-1 [#_"ResolvedJavaField" field]
        (#_"ResolvedJavaField" .getJavaKind field)
    )

    ;;;
     ; Create a PiNode on the index proving that the index is positive. On some platforms this is
     ; important to allow the index to be used as an int in the address mode.
     ;;
    (§ defn #_"AddressNode" Lowerer'createArrayIndexAddress-5 [#_"Graph" graph, #_"ValueNode" array, #_"JavaKind" elementKind, #_"ValueNode" index, #_"GuardingNode" boundsCheck]
        (let [
            #_"IntegerStamp" indexStamp (StampFactory'forInteger-3 32, 0, (dec Integer/MAX_VALUE))
            #_"ValueNode" positiveIndex (Graph''maybeAddOrUnique-2 graph, (PiNode'create-3 index, indexStamp, (when (some? boundsCheck) boundsCheck)))
        ]
            (Lowerer'createArrayAddress-4 graph, array, elementKind, positiveIndex)
        )
    )

    (§ defn #_"AddressNode" Lowerer'createArrayAddress-4 [#_"Graph" graph, #_"ValueNode" array, #_"JavaKind" elementKind, #_"ValueNode" index]
        (let [
            #_"ValueNode" wordIndex
                (if (< 4 (.wordSize HotSpot'target))
                    (Graph''add-2 graph, (SignExtendNode'new-2 index, (* (.wordSize HotSpot'target) 8)))
                    index
                )
            #_"int" shift (CodeUtil/log2 (HotSpot'arrayIndexScale-1 elementKind))
            #_"ValueNode" scaledIndex (Graph''add-2 graph, (LeftShiftNode'new-2 wordIndex, (ConstantNode'forInt-2 shift, graph)))
            #_"int" base (HotSpot'arrayBaseOffset-1 elementKind)
            #_"ValueNode" offset (Graph''add-2 graph, (AddNode'new-2 scaledIndex, (ConstantNode'forIntegerKind-3 (.wordJavaKind HotSpot'target), base, graph)))
        ]
            (Graph''add-2 graph, (OffsetAddressNode'new-2 array, offset))
        )
    )

    ;;;
     ; Creates a read node that read the array length and is guarded by a nil-check.
     ;
     ; The created node is placed before {@code before} in the CFG.
     ;;
    (§ defn #_"ReadNode" Lowerer'createReadArrayLength-3 [#_"ValueNode" array, #_"FixedNode" before, #_"LoweringTool" lowerer]
        (let [
            #_"Graph" graph (:graph array)
            #_"ValueNode" canonicalArray (Lowerer'createNullCheckedValue-3 (GraphUtil'skipPiWhileNonNull-1 array), before, lowerer)
            #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, canonicalArray, HotSpot'arrayLengthOffset)
            #_"ReadNode" readArrayLength (Graph''add-2 graph, (ReadNode'new-4 address, NamedLocationIdentity'ARRAY_LENGTH_LOCATION, StampFactory'nonNegativeInt, BarrierType'NONE))
        ]
            (Graph''addBeforeFixed-3 graph, before, readArrayLength)
            readArrayLength
        )
    )

    (§ defn #_"AddressNode" Lowerer'createUnsafeAddress-3 [#_"Graph" graph, #_"ValueNode" object, #_"ValueNode" offset]
        (if (and (instance? ConstantNode object) (#_"Constant" .isDefaultForKind (:value object)))
            (Graph''addOrUniqueWithInputs-2 graph, (OffsetAddressNode'create-1 offset))
            (Graph''add-2 graph, (OffsetAddressNode'new-2 object, offset))
        )
    )

    (§ defn #_"ReadNode" Lowerer'createUnsafeRead-3 [#_"Graph" graph, #_"RawLoadNode" load, #_"GuardingNode" guard]
        (let [
            #_"boolean" compressible? (= (:accessKind load) JavaKind/Object)
            #_"JavaKind" readKind (:accessKind load)
            #_"Stamp" loadStamp (Lowerer'loadStamp-3 (:stamp load), readKind, compressible?)
            #_"AddressNode" address (Lowerer'createUnsafeAddress-3 graph, (:object load), (:offset load))
            #_"ReadNode" memoryRead (Graph''add-2 graph, (ReadNode'new-4 address, (:locationIdentity load), loadStamp, BarrierType'NONE))
        ]
            (if (some? guard)
                (FixedAccessNode''setGuard-2 memoryRead, guard)
                ;; An unsafe read must not float, otherwise it may float above a test guaranteeing the read is safe.
                (§ ass! memoryRead (FloatableAccessNode''setForceFixed-2 memoryRead, true))
            )
            (let [
                #_"ValueNode" readValue (Lowerer'performBooleanCoercionIfNecessary-2 (Lowerer'implicitLoadConvert-4 graph, readKind, memoryRead, compressible?), readKind)
            ]
                (§ ass! load (Node''replaceAtUsages-2 load, readValue))
                memoryRead
            )
        )
    )

    (§ defn- #_"ValueNode" Lowerer'performBooleanCoercionIfNecessary-2 [#_"ValueNode" readValue, #_"JavaKind" readKind]
        (when (= readKind JavaKind/Boolean) => readValue
            (let [
                #_"Graph" graph (:graph readValue)
                #_"IntegerEqualsNode" eq (Graph''add-2 graph, (IntegerEqualsNode'new-2 readValue, (ConstantNode'forInt-2 0, graph)))
            ]
                (Graph''add-2 graph, (ConditionalNode'new-3 eq, (ConstantNode'forBoolean-2 false, graph), (ConstantNode'forBoolean-2 true, graph)))
            )
        )
    )

    (§ defn #_"NewInstanceNode" Lowerer'createNewInstanceFromVirtual-1 [#_"VirtualObjectNode" virtual]
        (NewInstanceNode'new-2 (VirtualObjectNode''type-1 virtual), true)
    )

    (§ defn #_"NewArrayNode" Lowerer'createNewArrayFromVirtual-2 [#_"VirtualObjectNode" virtual, #_"ValueNode" length]
        (NewArrayNode'new-3 (:componentType virtual), length, true)
    )

    (§ defn #_"void" Lowerer'finishAllocatedObjects-3 [#_"LoweringTool" lowerer, #_"CommitAllocationNode" commit, #_"ValueNode[]" allocations]
        (let [
            #_"Graph" graph (:graph commit)
        ]
            (dotimes [#_"int" i (count (:virtualObjects commit))]
                (let [
                    #_"FixedValueAnchorNode" anchor (Graph''add-2 graph, (FixedValueAnchorNode'new-1 (nth allocations i)))
                ]
                    (aset allocations i anchor)
                    (Graph''addBeforeFixed-3 graph, commit, anchor)
                )
            )
            ;; Note that the FrameState that is assigned to these MonitorEnterNodes isn't the correct state.
            ;; It will be the state from before the allocation occurred instead of a valid state after the
            ;; locking is performed. In practice this should be fine since these are newly allocated objects.
            ;; The bytecodes themselves permit allocating an object, doing a monitorenter and then dropping
            ;; all references to the object which would produce the same state, though that would normally
            ;; produce an IllegalMonitorStateException. In HotSpot some form of fast path locking should
            ;; always occur so the FrameState should never actually be used.
            (let [
                #_"ArrayList<MonitorEnterNode>" enters
                    (loop-when [enters nil #_"int" i 0] (< i (count (:virtualObjects commit))) => enters
                        (let [
                            #_"List<MonitorIdNode>" locks (CommitAllocationNode''getLocks-2 commit, i)
                            locks
                                (when (< 1 (count locks)) => locks
                                    ;; ensure that the lock operations are performed in lock depth order
                                    (let [
                                        #_"ArrayList<MonitorIdNode>" newList (ArrayList. locks)
                                    ]
                                        (#_"ArrayList" .sort newList, (ß (a, b) -> (§ fun (Integer/compare (:lockDepth a), (:lockDepth b)))))
                                        newList
                                    )
                                )
                            enters
                                (loop-when [enters enters #_"ISeq" s (seq locks)] (some? s) => enters
                                    (let [
                                        #_"MonitorEnterNode" enter (Graph''add-2 graph, (MonitorEnterNode'new-2 (nth allocations i), (first s)))
                                    ]
                                        (Graph''addBeforeFixed-3 graph, commit, enter)
                                        (let [
                                            enters (or enters (ArrayList.))
                                        ]
                                            (#_"ArrayList" .add enters, enter)
                                            (recur enters (next s))
                                        )
                                    )
                                )
                        ]
                            (recur enters (inc i))
                        )
                    )
            ]
                (doseq [#_"Node" usage (NodeIterable''snapshot-1 (Node''usages-1 commit))]
                    (if (instance? AllocatedObjectNode usage)
                        (Node''replaceAtUsagesAndDelete-2 usage, (nth allocations (#_"List" .indexOf (:virtualObjects commit), (:virtualObject usage))))
                        (Node''replaceAtUsages-3 commit, InputType'Memory, (nth enters (dec (count enters))))
                    )
                )
                (doseq [#_"MonitorEnterNode" enter enters]
                    (MonitorEnterNode''lower-2 enter, lowerer)
                )
                (Lowerer'insertAllocationBarrier-2 commit, graph)
            )
        )
        nil
    )

    ;;;
     ; Insert the required MemoryBarriers#STORE_STORE barrier for an allocation and also
     ; include the MemoryBarriers#LOAD_STORE required for final fields if any final fields
     ; are being written, as if FinalFieldBarrierNode were emitted.
     ;;
    (§ defn- #_"void" Lowerer'insertAllocationBarrier-2 [#_"CommitAllocationNode" commit, #_"Graph" graph]
        (let [
            #_"boolean" final?
                (loop-when [#_"ISeq" s (seq (:virtualObjects commit))] (some? s) => false
                    (or
                        (loop-when [#_"ISeq" s (seq (#_"ResolvedJavaType" .getInstanceFields (VirtualObjectNode''type-1 (first s)), true))] (some? s) => false
                            (or
                                (#_"ResolvedJavaField" .isFinal (first s))
                                (recur (next s))
                            )
                        )
                        (recur (next s))
                    )
                )
            #_"int" barrier (| MemoryBarriers/STORE_STORE (if final? MemoryBarriers/LOAD_STORE 0))
        ]
            (Graph''addAfterFixed-3 graph, commit, (Graph''add-2 graph, (MembarNode'new-2 barrier, (LocationIdentity/init))))
        )
        nil
    )

    (§ defn #_"BarrierType" Lowerer'fieldLoadBarrierType-1 [#_"ResolvedJavaField" field]
        (if (and HotSpot'useG1GC (= (#_"HotSpotResolvedJavaField" .getJavaKind field) JavaKind/Object) (= (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, java.lang.ref.Reference) (#_"HotSpotResolvedJavaField" .getDeclaringClass field)) (= (#_"HotSpotResolvedJavaField" .getName field) "referent"))
            BarrierType'PRECISE
            BarrierType'NONE
        )
    )

    (§ defn #_"BarrierType" Lowerer'fieldStoreBarrierType-1 [#_"ResolvedJavaField" field]
        (if (= (#_"ResolvedJavaField" .getJavaKind field) JavaKind/Object) BarrierType'IMPRECISE BarrierType'NONE)
    )

    (§ defn #_"BarrierType" Lowerer'arrayStoreBarrierType-1 [#_"JavaKind" elementKind]
        (if (= elementKind JavaKind/Object) BarrierType'PRECISE BarrierType'NONE)
    )

    (§ defn #_"BarrierType" Lowerer'fieldInitializationBarrier-1 [#_"JavaKind" entryKind]
        (if (and (= entryKind JavaKind/Object) (not HotSpot'useDeferredInitBarriers)) BarrierType'IMPRECISE BarrierType'NONE)
    )

    (§ defn #_"BarrierType" Lowerer'arrayInitializationBarrier-1 [#_"JavaKind" entryKind]
        (if (and (= entryKind JavaKind/Object) (not HotSpot'useDeferredInitBarriers)) BarrierType'PRECISE BarrierType'NONE)
    )

    (§ defn- #_"BarrierType" Lowerer'unsafeStoreBarrierType-1 [#_"RawStoreNode" store]
        (when (:needsBarrier store) => BarrierType'NONE
            (Lowerer'storeBarrierType-2 (:object store), (:value store))
        )
    )

    (§ defn- #_"BarrierType" Lowerer'storeBarrierType-2 [#_"ValueNode" object, #_"ValueNode" value]
        (when (and (= (ValueNode''getStackKind-1 value) JavaKind/Object) (= (ValueNode''getStackKind-1 object) JavaKind/Object)) => BarrierType'NONE
            (let [
                #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp object))
            ]
                (if (and (some? type) (not (#_"ResolvedJavaType" .isArray type))) BarrierType'IMPRECISE BarrierType'PRECISE)
            )
        )
    )

    (§ defn #_"int" Lowerer'fieldOffset-1 [#_"ResolvedJavaField" field]
        (#_"HotSpotResolvedJavaField" .offset field)
    )

    (§ defn #_"FieldLocationIdentity" Lowerer'fieldLocationIdentity-1 [#_"ResolvedJavaField" field]
        (FieldLocationIdentity'new-1 field)
    )

    (§ defn #_"ValueNode" Lowerer'staticFieldBase-2 [#_"Graph" graph, #_"ResolvedJavaField" field]
        (ConstantNode'forConstant-2 (#_"HotSpotConstantReflectionProvider" .asJavaClass HotSpot'constantReflection, (#_"HotSpotResolvedJavaField" .getDeclaringClass field)), graph)
    )

    (§ defn #_"Stamp" Lowerer'loadStamp-2 [#_"Stamp" stamp, #_"JavaKind" kind]
        (Lowerer'loadStamp-3 stamp, kind, true)
    )

    (§ defn- #_"boolean" Lowerer'useCompressedOops-2 [#_"JavaKind" kind, #_"boolean" compressible?]
        (and (= kind JavaKind/Object) compressible? HotSpot'useCompressedOops)
    )

    (§ defn #_"Stamp" Lowerer'loadCompressedStamp-1 [#_"ObjectStamp" stamp]
        (HotSpotNarrowOopStamp'compressed-2 stamp, HotSpot'oopEncoding)
    )

    (§ defn #_"Stamp" Lowerer'loadStamp-3 [#_"Stamp" stamp, #_"JavaKind" kind, #_"boolean" compressible?]
        (if (Lowerer'useCompressedOops-2 kind, compressible?)
            (Lowerer'loadCompressedStamp-1 stamp)
            (condp =? kind
                [JavaKind/Boolean JavaKind/Byte] (IntegerConvertOp''foldStamp-4 (:narrow IntegerStamp'OPS), 32, 8, stamp)
                [JavaKind/Char JavaKind/Short]   (IntegerConvertOp''foldStamp-4 (:narrow IntegerStamp'OPS), 32, 16, stamp)
                                                 stamp
            )
        )
    )

    (§ defn #_"ValueNode" Lowerer'implicitLoadConvert-3 [#_"Graph" graph, #_"JavaKind" kind, #_"ValueNode" value]
        (Lowerer'implicitLoadConvert-4 graph, kind, value, true)
    )

    #_unused
    (§ defn #_"ValueNode" Lowerer'implicitLoadConvert-2 [#_"JavaKind" kind, #_"ValueNode" value]
        (Lowerer'implicitLoadConvert-3 kind, value, true)
    )

    (§ defn #_"ValueNode" Lowerer'implicitLoadConvert-4 [#_"Graph" graph, #_"JavaKind" kind, #_"ValueNode" value, #_"boolean" compressible?]
        (let [
            #_"ValueNode" ret (Lowerer'implicitLoadConvert-3 kind, value, compressible?)
        ]
            (when-not (Node''isAlive-1 ret) => ret
                (Graph''add-2 graph, ret)
            )
        )
    )

    (§ defn #_"ValueNode" Lowerer'newCompressionNode-2 [#_"CompressionOp" op, #_"ValueNode" value]
        (HotSpotCompressionNode'new-3 op, value, HotSpot'oopEncoding)
    )

    (§ defn #_"ValueNode" Lowerer'implicitLoadConvert-3 [#_"JavaKind" kind, #_"ValueNode" value, #_"boolean" compressible?]
        (if (Lowerer'useCompressedOops-2 kind, compressible?)
            (Lowerer'newCompressionNode-2 CompressionOp'Uncompress, value)
            (condp =? kind
                [JavaKind/Byte JavaKind/Short]   (SignExtendNode'new-2 value, 32)
                [JavaKind/Boolean JavaKind/Char] (ZeroExtendNode'new-2 value, 32)
                                                 value
            )
        )
    )

    (§ defn #_"ValueNode" Lowerer'implicitStoreConvert-3 [#_"Graph" graph, #_"JavaKind" kind, #_"ValueNode" value]
        (Lowerer'implicitStoreConvert-4 graph, kind, value, true)
    )

    #_unused
    (§ defn #_"ValueNode" Lowerer'implicitStoreConvert-2 [#_"JavaKind" kind, #_"ValueNode" value]
        (Lowerer'implicitStoreConvert-3 kind, value, true)
    )

    (§ defn #_"ValueNode" Lowerer'implicitStoreConvert-4 [#_"Graph" graph, #_"JavaKind" kind, #_"ValueNode" value, #_"boolean" compressible?]
        (let [
            #_"ValueNode" ret (Lowerer'implicitStoreConvert-3 kind, value, compressible?)
        ]
            (when-not (Node''isAlive-1 ret) => ret
                (Graph''add-2 graph, ret)
            )
        )
    )

    (§ defn #_"ValueNode" Lowerer'implicitStoreConvert-3 [#_"JavaKind" kind, #_"ValueNode" value, #_"boolean" compressible?]
        (if (Lowerer'useCompressedOops-2 kind, compressible?)
            (Lowerer'newCompressionNode-2 CompressionOp'Compress, value)
            (condp =? kind
                [JavaKind/Boolean JavaKind/Byte] (NarrowNode'new-2 value, 8)
                [JavaKind/Char JavaKind/Short]   (NarrowNode'new-2 value, 16)
                                                 value
            )
        )
    )

    (§ defn #_"ValueNode" Lowerer'createReadHub-3 [#_"Graph" graph, #_"ValueNode" object, #_"LoweringTool" lowerer]
        (if-not (= (:loweringStage (:phase lowerer)) LoweringStage'LOW_TIER)
            (Graph''add-2 graph, (LoadHubNode'new-1 object))
            (let [
                #_"KlassPointerStamp" hubStamp KlassPointerStamp'KLASS_NON_NULL
                hubStamp (if HotSpot'useCompressedClassPointers (KlassPointerStamp''compressed-2 hubStamp, HotSpot'klassEncoding) hubStamp)
                #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, object, HotSpot'hubOffset)
                #_"LocationIdentity" hubLocation (if HotSpot'useCompressedClassPointers HotSpotReplacementsUtil'COMPRESSED_HUB_LOCATION HotSpotReplacementsUtil'HUB_LOCATION)
                #_"FloatingReadNode" memoryRead (Graph''add-2 graph, (FloatingReadNode'new-6 address, hubLocation, nil, hubStamp, nil, BarrierType'NONE))
            ]
                (if HotSpot'useCompressedClassPointers (HotSpotCompressionNode'uncompress-2 memoryRead, HotSpot'klassEncoding) memoryRead)
            )
        )
    )

    (§ defn #_"ValueNode" Lowerer'createReadArrayComponentHub-3 [#_"Graph" graph, #_"ValueNode" arrayHub, #_"FixedNode" anchor]
        ;; Anchor the read of the element klass to the cfg, because it is only valid when arrayClass
        ;; is an object class, which might not be the case in other parts of the compiled method.
        (let [
            #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, arrayHub, HotSpot'arrayClassElementOffset)
        ]
            (Graph''add-2 graph, (FloatingReadNode'new-5 address, HotSpotReplacementsUtil'OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION, nil, KlassPointerStamp'KLASS_NON_NULL, (AbstractBeginNode'prevBegin-1 anchor)))
        )
    )

    (§ defn #_"GuardingNode" Lowerer'getBoundsCheck-3 [#_"AccessIndexedNode" node, #_"ValueNode" array, #_"LoweringTool" lowerer]
        (let [
            #_"ValueNode" arrayLength (ArrayLengthNode'readArrayLength-1 array)
            arrayLength
                (if (some? arrayLength)
                    (if (Node''isAlive-1 arrayLength) arrayLength (Graph''addOrUniqueWithInputs-2 (:graph node), arrayLength))
                    (Lowerer'createReadArrayLength-3 array, node, lowerer)
                )
            #_"LogicNode" boundsCheck (IntegerBelowNode'create-2 (AccessIndexedNode''index-1 node), arrayLength)
        ]
            (when-not (LogicNode''isTautology-1 boundsCheck)
                (LoweringTool''createGuard-5 lowerer, node, (Graph''addOrUniqueWithInputs-2 (:graph node), boundsCheck), DeoptimizationReason/BoundsCheckException, DeoptimizationAction/InvalidateReprofile)
            )
        )
    )

    (§ defn #_"GuardingNode" Lowerer'createNullCheck-3 [#_"ValueNode" object, #_"FixedNode" before, #_"LoweringTool" lowerer]
        (when-not (StampTool'isPointerNeverNull-1 (:stamp object))
            (LoweringTool''createGuard-7 lowerer, before, (Graph''add-2 (:graph before), (IsNullNode'create-1 object)), DeoptimizationReason/NullCheckException, DeoptimizationAction/InvalidateReprofile, JavaConstant/NULL_POINTER, true)
        )
    )

    (§ defn #_"ValueNode" Lowerer'createNullCheckedValue-3 [#_"ValueNode" object, #_"FixedNode" before, #_"LoweringTool" lowerer]
        (let [
            #_"GuardingNode" nullCheck (Lowerer'createNullCheck-3 object, before, lowerer)
        ]
            (when (some? nullCheck) => object
                (Graph''maybeAddOrUnique-2 (:graph before), (PiNode'create-3 object, (Stamp''join-2 (:stamp object), StampFactory'objectNonNullStamp), nullCheck))
            )
        )
    )

    ;;;
     ; Indicates the smallest width for comparing an integer value on the target platform.
     ;;
    (§ defn #_"Integer" Lowerer'smallestCompareWidth-0 []
        8
    )

    (§ defn #_"void" Lowerer'lowerInvoke-3 [#_"InvokeNode" invoke, #_"LoweringTool" lowerer, #_"Graph" graph]
        (when (instance? MethodCallTargetNode (:callTarget invoke))
            (let [
                #_"MethodCallTargetNode" callTarget (:callTarget invoke)
                #_"NodeInputList<ValueNode>" parameters (CallTargetNode''arguments-1 callTarget)
                #_"ValueNode" receiver (first parameters)
                receiver
                    (when (and (not (MethodCallTargetNode''isStatic-1 callTarget)) (instance? ObjectStamp (:stamp receiver)) (not (StampTool'isPointerNeverNull-1 (:stamp receiver)))) => receiver
                        (let [
                            receiver (Lowerer'createNullCheckedValue-3 receiver, invoke, lowerer)
                        ]
                            (NodeList''set-3 parameters, 0, receiver)
                            receiver
                        )
                    )
                #_"JavaType[]" signature (#_"Signature" .toParameterTypes (#_"ResolvedJavaMethod" .getSignature (CallTargetNode''targetMethod-1 callTarget)), (when-not (MethodCallTargetNode''isStatic-1 callTarget) (#_"ResolvedJavaMethod" .getDeclaringClass (CallTargetNode''targetMethod-1 callTarget))))
                #_"LoweredCallTargetNode" loweredCallTarget
                    (or
                        (when (and GraalOptions'inlineVTableStubs (InvokeKind''isIndirect-1 (CallTargetNode''invokeKind-1 callTarget)) GraalOptions'alwaysInlineVTableStubs)
                            (let [
                                #_"HotSpotResolvedJavaMethod" hsMethod (CallTargetNode''targetMethod-1 callTarget)
                                #_"ResolvedJavaType" receiverType (InvokeNode''getReceiverType-1 invoke)
                            ]
                                (when (#_"HotSpotResolvedJavaMethod" .isInVirtualMethodTable hsMethod, receiverType)
                                    (let [
                                        #_"JavaKind" wordKind (.wordJavaKind HotSpot'target)
                                        #_"ValueNode" hub (Lowerer'createReadHub-3 graph, receiver, lowerer)
                                        #_"ReadNode" metaspaceMethod (Lowerer'createReadVirtualMethod-4 graph, hub, hsMethod, receiverType)
                                        ;; We use LocationNode.ANY_LOCATION for the reads that access the compiled
                                        ;; code entry as HotSpot does not guarantee they are final values.
                                        #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, metaspaceMethod, HotSpot'methodCompiledEntryOffset)
                                        #_"ReadNode" compiledEntry (Graph''add-2 graph, (ReadNode'new-4 address, (LocationIdentity/any), (StampFactory'forKind-1 wordKind), BarrierType'NONE))
                                        loweredCallTarget (Graph''add-2 graph, (HotSpotIndirectCallTargetNode'new-8 metaspaceMethod, compiledEntry, (NodeList''toArray-2 parameters, (make-array ValueNode (count parameters))), (CallTargetNode''returnStamp-1 callTarget), signature, (CallTargetNode''targetMethod-1 callTarget), HotSpotCallingConventionType/JavaCall, (CallTargetNode''invokeKind-1 callTarget)))
                                    ]
                                        (Graph''addBeforeFixed-3 graph, invoke, metaspaceMethod)
                                        (Graph''addAfterFixed-3 graph, metaspaceMethod, compiledEntry)
                                        loweredCallTarget
                                    )
                                )
                            )
                        )
                        (Graph''add-2 graph, (HotSpotDirectCallTargetNode'new-6 (NodeList''toArray-2 parameters, (make-array ValueNode (count parameters))), (CallTargetNode''returnStamp-1 callTarget), signature, (CallTargetNode''targetMethod-1 callTarget), HotSpotCallingConventionType/JavaCall, (CallTargetNode''invokeKind-1 callTarget)))
                    )
            ]
                (§ ass! callTarget (Node''replaceAndDelete-2 callTarget, loweredCallTarget))
            )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerLoadMethodNode-1 [#_"LoadMethodNode" node]
        (§ ass! (:graph node) (Graph''replaceFixed-3 (:graph node), node, (Lowerer'createReadVirtualMethod-4 (:graph node), (:hub node), (:method node), (:receiverType node))))
        nil
    )

    (§ defn #_"void" Lowerer'lowerGetClassNode-3 [#_"GetClassNode" getClass, #_"LoweringTool" lowerer, #_"Graph" graph]
        (let [
            #_"LoadHubNode" hub (Graph''add-2 graph, (LoadHubNode'new-1 (:object getClass)))
            #_"HubGetClassNode" hubGetClass (Graph''add-2 graph, (HubGetClassNode'new-1 hub))
        ]
            (Node''replaceAtUsagesAndDelete-2 getClass, hubGetClass)
            (LoadHubNode''lower-2 hub, lowerer)
            (HubGetClassNode''lower-2 hubGetClass, lowerer)
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerStoreHubNode-2 [#_"StoreHubNode" storeHub, #_"Graph" graph]
        (§ ass! graph (Graph''replaceFixed-3 graph, storeHub, (Lowerer'createWriteHub-3 graph, (:object storeHub), (:value storeHub))))
        nil
    )

    (§ defn #_"void" Lowerer'lowerClassGetHubNode-2 [#_"ClassGetHubNode" node, #_"LoweringTool" lowerer]
        (when-not (= (:loweringStage (:phase lowerer)) LoweringStage'HIGH_TIER)
            (let [
                #_"Graph" graph (:graph node)
                #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, (ClassGetHubNode''getValue-1 node), HotSpot'klassOffset)
                #_"FloatingReadNode" read (Graph''add-2 graph, (FloatingReadNode'new-6 address, HotSpotReplacementsUtil'CLASS_KLASS_LOCATION, nil, (:stamp node), nil, BarrierType'NONE))
            ]
                (Node''replaceAtUsagesAndDelete-2 node, read)
            )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerHubGetClassNode-2 [#_"HubGetClassNode" node, #_"LoweringTool" lowerer]
        (when-not (= (:loweringStage (:phase lowerer)) LoweringStage'HIGH_TIER)
            (let [
                #_"Graph" graph (:graph node)
                #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, (:hub node), HotSpot'classMirrorOffset)
                #_"FloatingReadNode" read (Graph''add-2 graph, (FloatingReadNode'new-6 address, HotSpotReplacementsUtil'CLASS_MIRROR_LOCATION, nil, (StampFactory'forKind-1 (.wordJavaKind HotSpot'target)), nil, BarrierType'NONE))
                address (Lowerer'createOffsetAddress-3 graph, read, 0)
                read (Graph''add-2 graph, (FloatingReadNode'new-6 address, HotSpotReplacementsUtil'CLASS_MIRROR_HANDLE_LOCATION, nil, (:stamp node), nil, BarrierType'NONE))
            ]
                (Node''replaceAtUsagesAndDelete-2 node, read)
            )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerKlassLayoutHelperNode-2 [#_"KlassLayoutHelperNode" node, #_"LoweringTool" lowerer]
        (when-not (= (:loweringStage (:phase lowerer)) LoweringStage'HIGH_TIER)
            (let [
                #_"Graph" graph (:graph node)
                #_"AddressNode" address (Lowerer'createOffsetAddress-3 graph, (:klass node), HotSpot'klassLayoutHelperOffset)
            ]
                (Node''replaceAtUsagesAndDelete-2 node, (Graph''add-2 graph, (FloatingReadNode'new-6 address, HotSpotReplacementsUtil'KLASS_LAYOUT_HELPER_LOCATION, nil, (:stamp node), nil, BarrierType'NONE)))
            )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerComputeObjectAddressNode-1 [#_"ComputeObjectAddressNode" node]
        ;; Lower the node into a ComputeObjectAddress node and an Add,
        ;; but ensure that it's below any potential safepoints and above it's uses.
        (doseq [#_"Node" use (NodeIterable''snapshot-1 (Node''usages-1 node))]
            (when (instance? FixedNode use) => (throw! (str "unexpected floating use of ComputeObjectAddressNode " node))
                (let [
                    #_"Graph" graph (:graph node)
                    #_"GetObjectAddressNode" address (Graph''add-2 graph, (GetObjectAddressNode'new-1 (:object node)))
                ]
                    (Graph''addBeforeFixed-3 graph, use, address)
                    (Node''replaceFirstInput-3 use, node, (Graph''add-2 graph, (AddNode'new-2 address, (:offset node))))
                )
            )
        )
        (GraphUtil'unlinkFixedNode-1 node)
        (Node''safeDelete-1 node)
        nil
    )

    (§ defn #_"void" Lowerer'lowerLoadFieldNode-2 [#_"LoadFieldNode" loadField, #_"LoweringTool" lowerer]
        (let [
            #_"Graph" graph (:graph loadField)
            #_"ResolvedJavaField" field (AccessFieldNode''field-1 loadField)
            #_"ValueNode" object (if (AccessFieldNode''isStatic-1 loadField) (Lowerer'staticFieldBase-2 graph, field) (:object loadField))
            object (Lowerer'createNullCheckedValue-3 object, loadField, lowerer)
            #_"Stamp" loadStamp (Lowerer'loadStamp-2 (:stamp loadField), (Lowerer'getStorageKind-1 field))
            #_"AddressNode" address (Lowerer'createFieldAddress-3 graph, object, field)
            #_"ReadNode" memoryRead (Graph''add-2 graph, (ReadNode'new-4 address, (Lowerer'fieldLocationIdentity-1 field), loadStamp, (Lowerer'fieldLoadBarrierType-1 field)))
            #_"ValueNode" readValue (Lowerer'implicitLoadConvert-3 graph, (Lowerer'getStorageKind-1 field), memoryRead)
        ]
            (§ ass! loadField (Node''replaceAtUsages-2 loadField, readValue))
            (§ ass! graph (Graph''replaceFixed-3 graph, loadField, memoryRead))

            (when (AccessFieldNode''isVolatile-1 loadField)
                (Graph''addBeforeFixed-3 graph, memoryRead, (Graph''add-2 graph, (MembarNode'new-1 MemoryBarriers/JMM_PRE_VOLATILE_READ)))
                (Graph''addAfterFixed-3 graph, memoryRead, (Graph''add-2 graph, (MembarNode'new-1 MemoryBarriers/JMM_POST_VOLATILE_READ)))
            )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerStoreFieldNode-2 [#_"StoreFieldNode" storeField, #_"LoweringTool" lowerer]
        (let [
            #_"Graph" graph (:graph storeField)
            #_"ResolvedJavaField" field (AccessFieldNode''field-1 storeField)
            #_"ValueNode" object (if (AccessFieldNode''isStatic-1 storeField) (Lowerer'staticFieldBase-2 graph, field) (:object storeField))
            object (Lowerer'createNullCheckedValue-3 object, storeField, lowerer)
            #_"ValueNode" value (Lowerer'implicitStoreConvert-3 graph, (Lowerer'getStorageKind-1 field), (:value storeField))
            #_"AddressNode" address (Lowerer'createFieldAddress-3 graph, object, field)
            #_"WriteNode" memoryWrite (Graph''add-2 graph, (WriteNode'new-4 address, (Lowerer'fieldLocationIdentity-1 field), value, (Lowerer'fieldStoreBarrierType-1 field)))
        ]
            (AbstractWriteNode''setStateAfter-2 memoryWrite, (StoreFieldNode''stateAfter-1 storeField))
            (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, storeField, memoryWrite))

            (when (AccessFieldNode''isVolatile-1 storeField)
                (Graph''addBeforeFixed-3 graph, memoryWrite, (Graph''add-2 graph, (MembarNode'new-1 MemoryBarriers/JMM_PRE_VOLATILE_WRITE)))
                (Graph''addAfterFixed-3 graph, memoryWrite, (Graph''add-2 graph, (MembarNode'new-1 MemoryBarriers/JMM_POST_VOLATILE_WRITE)))
            )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerLoadIndexedNode-2 [#_"LoadIndexedNode" loadIndexed, #_"LoweringTool" lowerer]
        (let [
            #_"Graph" graph (:graph loadIndexed)
            #_"ValueNode" array (Lowerer'createNullCheckedValue-3 (AccessArrayNode''array-1 loadIndexed), loadIndexed, lowerer)
            #_"JavaKind" elementKind (:elementKind loadIndexed)
            #_"Stamp" loadStamp (Lowerer'loadStamp-2 (:stamp loadIndexed), elementKind)
            #_"GuardingNode" boundsCheck (Lowerer'getBoundsCheck-3 loadIndexed, array, lowerer)
            #_"AddressNode" address (Lowerer'createArrayIndexAddress-5 graph, array, elementKind, (AccessIndexedNode''index-1 loadIndexed), boundsCheck)
            #_"ReadNode" memoryRead (Graph''add-2 graph, (ReadNode'new-4 address, (NamedLocationIdentity'getArrayLocation-1 elementKind), loadStamp, BarrierType'NONE))
        ]
            (FixedAccessNode''setGuard-2 memoryRead, boundsCheck)
            (§ ass! loadIndexed (Node''replaceAtUsages-2 loadIndexed, (Lowerer'implicitLoadConvert-3 graph, elementKind, memoryRead)))
            (§ ass! graph (Graph''replaceFixed-3 graph, loadIndexed, memoryRead))
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerStoreIndexedNode-2 [#_"StoreIndexedNode" storeIndexed, #_"LoweringTool" lowerer]
        (let [
            #_"Graph" graph (:graph storeIndexed)
            #_"ValueNode" value (:value storeIndexed)
            #_"ValueNode" array (Lowerer'createNullCheckedValue-3 (AccessArrayNode''array-1 storeIndexed), storeIndexed, lowerer)
            #_"GuardingNode" boundsCheck (Lowerer'getBoundsCheck-3 storeIndexed, array, lowerer)
            #_"JavaKind" elementKind (:elementKind storeIndexed)
            #_"LogicNode" condition
                (when (and (= elementKind JavaKind/Object) (not (StampTool'isPointerAlwaysNull-1 (:stamp value))))
                    ;; Array store check.
                    (let [
                        #_"TypeReference" arrayType (StampTool'typeReferenceOrNull-1 (:stamp array))
                    ]
                        (if (and (some? arrayType) (:exactReference arrayType))
                            (let [
                                #_"ResolvedJavaType" elementType (#_"ResolvedJavaType" .getComponentType (:type arrayType))
                            ]
                                (when-not (#_"ResolvedJavaType" .isJavaLangObject elementType)
                                    (let [
                                        #_"LogicNode" typeTest (Graph''addOrUniqueWithInputs-2 graph, (InstanceOfNode'create-2 (TypeReference'createTrusted-1 elementType), value))
                                    ]
                                        (LogicNode'or-3 (Graph''add-2 graph, (IsNullNode'create-1 value)), typeTest, GraalDirectives'UNLIKELY_PROBABILITY)
                                    )
                                )
                            )
                            ;; The guard on the read hub should be the nil-check of the array that was introduced earlier.
                            (let [
                                #_"LogicNode" typeTest (Graph''add-2 graph, (InstanceOfDynamicNode'create-3 (Lowerer'createReadArrayComponentHub-3 graph, (Lowerer'createReadHub-3 graph, array, lowerer), storeIndexed), value, false))
                            ]
                                (LogicNode'or-3 (Graph''add-2 graph, (IsNullNode'create-1 value)), typeTest, GraalDirectives'UNLIKELY_PROBABILITY)
                            )
                        )
                    )
                )
            #_"AddressNode" address (Lowerer'createArrayIndexAddress-5 graph, array, elementKind, (AccessIndexedNode''index-1 storeIndexed), boundsCheck)
            #_"WriteNode" memoryWrite (Graph''add-2 graph, (WriteNode'new-4 address, (NamedLocationIdentity'getArrayLocation-1 elementKind), (Lowerer'implicitStoreConvert-3 graph, elementKind, value), (Lowerer'arrayStoreBarrierType-1 (:elementKind storeIndexed))))
        ]
            (FixedAccessNode''setGuard-2 memoryWrite, boundsCheck)
            (when (some? condition)
                (LoweringTool''createGuard-5 lowerer, storeIndexed, condition, DeoptimizationReason/ArrayStoreException, DeoptimizationAction/InvalidateReprofile)
            )
            (AbstractWriteNode''setStateAfter-2 memoryWrite, (StoreIndexedNode''stateAfter-1 storeIndexed))
            (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, storeIndexed, memoryWrite))
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerArrayLengthNode-2 [#_"ArrayLengthNode" node, #_"LoweringTool" lowerer]
        (§ ass! node (Node''replaceAtUsages-2 node, (Lowerer'createReadArrayLength-3 (:array node), node, lowerer)))
        (Graph''removeFixed-2 (:graph node), node)
        nil
    )

    (§ defn #_"void" Lowerer'lowerLoadHubNode-2 [#_"LoadHubNode" node, #_"LoweringTool" lowerer]
        (when (and (= (:loweringStage (:phase lowerer)) LoweringStage'LOW_TIER) (not (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph node)))))
            (Node''replaceAtUsagesAndDelete-2 node, (Lowerer'createReadHub-3 (:graph node), (:value node), lowerer))
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerMonitorEnterNode-3 [#_"MonitorEnterNode" monitorEnter, #_"LoweringTool" lowerer, #_"Graph" graph]
        (let [
            #_"ValueNode" object (Lowerer'createNullCheckedValue-3 (:object monitorEnter), monitorEnter, lowerer)
            #_"ValueNode" hub (Graph''add-2 graph, (LoadHubNode'create-1 object))
            #_"RawMonitorEnterNode" rawMonitorEnter (Graph''add-2 graph, (RawMonitorEnterNode'new-3 object, hub, (:monitorId monitorEnter)))
        ]
            (AccessMonitorNode''setStateBefore-2 rawMonitorEnter, (AccessMonitorNode''stateBefore-1 monitorEnter))
            (AbstractStateSplit''setStateAfter-2 rawMonitorEnter, (AbstractStateSplit''stateAfter-1 monitorEnter))
            (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, monitorEnter, rawMonitorEnter))
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerCompareAndSwapNode-1 [#_"UnsafeCompareAndSwapNode" node]
        (let [
            #_"Graph" graph (:graph node)
            #_"JavaKind" valueKind (:valueKind node)
            #_"ValueNode" expectedValue (Lowerer'implicitStoreConvert-3 graph, valueKind, (:expected node))
            #_"ValueNode" newValue (Lowerer'implicitStoreConvert-3 graph, valueKind, (:newValue node))
            #_"AddressNode" address (Graph''add-2 graph, (OffsetAddressNode'new-2 (:object node), (:offset node)))
            #_"BarrierType" barrierType (Lowerer'storeBarrierType-2 (:object node), expectedValue)
            #_"LogicCompareAndSwapNode" atomicNode (Graph''add-2 graph, (LogicCompareAndSwapNode'new-5 address, (UnsafeCompareAndSwapNode''getLocationIdentity-1 node), expectedValue, newValue, barrierType))
        ]
            (AbstractCompareAndSwapNode''setStateAfter-2 atomicNode, (AbstractStateSplit''stateAfter-1 node))
            (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, node, atomicNode))
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerAtomicReadAndWriteNode-1 [#_"AtomicReadAndWriteNode" node]
        (let [
            #_"Graph" graph (:graph node)
            #_"JavaKind" valueKind (:valueKind node)
            #_"ValueNode" newValue (Lowerer'implicitStoreConvert-3 graph, valueKind, (:newValue node))
            #_"AddressNode" address (Graph''add-2 graph, (OffsetAddressNode'new-2 (:object node), (:offset node)))
            #_"BarrierType" barrierType (Lowerer'storeBarrierType-2 (:object node), (:newValue node))
            #_"LoweredAtomicReadAndWriteNode" memoryRead (Graph''add-2 graph, (LoweredAtomicReadAndWriteNode'new-4 address, (AtomicReadAndWriteNode''getLocationIdentity-1 node), newValue, barrierType))
        ]
            (LoweredAtomicReadAndWriteNode''setStateAfter-2 memoryRead, (AbstractStateSplit''stateAfter-1 node))

            (let [
                #_"ValueNode" readValue (Lowerer'implicitLoadConvert-3 graph, valueKind, memoryRead)
            ]
                (Node''replaceFirstInput-3 (AbstractStateSplit''stateAfter-1 node), node, memoryRead)
                (§ ass! node (Node''replaceAtUsages-2 node, readValue))
                (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, node, memoryRead))
            )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerUnsafeLoadNode-2 [#_"RawLoadNode" load, #_"LoweringTool" lowerer]
        (cond
            (and (not (instance? GuardedUnsafeLoadNode load)) (not (GuardsStage'allowsFloatingGuards-1 (:guardsStage (:graph load)))) (Lowerer'addReadBarrier-1 load))
                (UnsafeLoadTemplates''lower-3 Lowerer'unsafeLoadSnippets, load, lowerer)
            (instance? GuardedUnsafeLoadNode load)
                (let [
                    #_"GuardingNode" guard (GuardedUnsafeLoadNode''getGuard-1 load)
                ]
                    (if (nil? guard)
                        ;; can float freely if the guard folded away
                        (let [
                            #_"ReadNode" memoryRead (Lowerer'createUnsafeRead-3 (:graph load), load, nil)
                        ]
                            (§ ass! memoryRead (FloatableAccessNode''setForceFixed-2 memoryRead, false))
                            (§ ass! (:graph load) (Graph''replaceFixedWithFixed-3 (:graph load), load, memoryRead))
                        )
                        ;; must be guarded, but flows below the guard
                        (let [
                            #_"ReadNode" memoryRead (Lowerer'createUnsafeRead-3 (:graph load), load, guard)
                        ]
                            (§ ass! (:graph load) (Graph''replaceFixedWithFixed-3 (:graph load), load, memoryRead))
                        )
                    )
                )
            :else
                ;; never had a guarding condition so it must be fixed, creation of the read will force it to be fixed
                (let [
                    #_"ReadNode" memoryRead (Lowerer'createUnsafeRead-3 (:graph load), load, nil)
                ]
                    (§ ass! (:graph load) (Graph''replaceFixedWithFixed-3 (:graph load), load, memoryRead))
                )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerUnsafeMemoryLoadNode-1 [#_"UnsafeMemoryLoadNode" load]
        (let [
            #_"Graph" graph (:graph load)
            #_"JavaKind" readKind (:kind load)
            #_"Stamp" loadStamp (Lowerer'loadStamp-3 (:stamp load), readKind, false)
            #_"AddressNode" address (Graph''addOrUniqueWithInputs-2 graph, (OffsetAddressNode'create-1 (:address load)))
            #_"ReadNode" memoryRead (Graph''add-2 graph, (ReadNode'new-4 address, (:locationIdentity load), loadStamp, BarrierType'NONE))
        ]
            ;; An unsafe read must not float, otherwise it may float above a test guaranteeing the read is safe.
            (§ ass! memoryRead (FloatableAccessNode''setForceFixed-2 memoryRead, true))
            (let [
                #_"ValueNode" readValue (Lowerer'performBooleanCoercionIfNecessary-2 (Lowerer'implicitLoadConvert-4 graph, readKind, memoryRead, false), readKind)
            ]
                (§ ass! load (Node''replaceAtUsages-2 load, readValue))
                (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, load, memoryRead))
            )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerUnsafeStoreNode-1 [#_"RawStoreNode" store]
        (let [
            #_"Graph" graph (:graph store)
            #_"boolean" compressible? (= (ValueNode''getStackKind-1 (:value store)) JavaKind/Object)
            #_"JavaKind" valueKind (:accessKind store)
            #_"ValueNode" value (Lowerer'implicitStoreConvert-4 graph, valueKind, (:value store), compressible?)
            #_"AddressNode" address (Lowerer'createUnsafeAddress-3 graph, (:object store), (:offset store))
            #_"WriteNode" write (Graph''add-2 graph, (WriteNode'new-4 address, (:locationIdentity store), value, (Lowerer'unsafeStoreBarrierType-1 store)))
        ]
            (AbstractWriteNode''setStateAfter-2 write, (RawStoreNode''stateAfter-1 store))
            (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, store, write))
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerUnsafeMemoryStoreNode-1 [#_"UnsafeMemoryStoreNode" store]
        (let [
            #_"Graph" graph (:graph store)
            #_"JavaKind" valueKind (:kind store)
            #_"ValueNode" value (Lowerer'implicitStoreConvert-4 graph, valueKind, (:value store), false)
            #_"AddressNode" address (Graph''addOrUniqueWithInputs-2 graph, (OffsetAddressNode'create-1 (:address store)))
            #_"WriteNode" write (Graph''add-2 graph, (WriteNode'new-4 address, (UnsafeMemoryStoreNode''getLocationIdentity-1 store), value, BarrierType'NONE))
        ]
            (AbstractWriteNode''setStateAfter-2 write, (AbstractStateSplit''stateAfter-1 store))
            (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, store, write))
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerJavaReadNode-1 [#_"JavaReadNode" read]
        (let [
            #_"Graph" graph (:graph read)
            #_"JavaKind" valueKind (:readKind read)
            #_"Stamp" loadStamp (Lowerer'loadStamp-3 (:stamp read), valueKind, (:compressible? read))
            #_"ReadNode" memoryRead (Graph''add-2 graph, (ReadNode'new-4 (FixedAccessNode''getAddress-1 read), (FixedAccessNode''getLocationIdentity-1 read), loadStamp, (FixedAccessNode''getBarrierType-1 read)))
            #_"GuardingNode" guard (FixedAccessNode''getGuard-1 read)
            #_"ValueNode" readValue (Lowerer'implicitLoadConvert-4 graph, valueKind, memoryRead, (:compressible? read))
        ]
            (if (some? guard)
                (FixedAccessNode''setGuard-2 memoryRead, guard)
                ;; An unsafe read must not float, otherwise it may float above a test guaranteeing the read is safe.
                (§ ass! memoryRead (FloatableAccessNode''setForceFixed-2 memoryRead, true))
            )
            (§ ass! read (Node''replaceAtUsages-2 read, readValue))
            (§ ass! graph (Graph''replaceFixed-3 graph, read, memoryRead))
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerJavaWriteNode-1 [#_"JavaWriteNode" write]
        (let [
            #_"Graph" graph (:graph write)
            #_"ValueNode" value (Lowerer'implicitStoreConvert-4 graph, (:writeKind write), (AbstractWriteNode''value-1 write), (:compressible? write))
            #_"WriteNode" memoryWrite (Graph''add-2 graph, (WriteNode'new-4 (FixedAccessNode''getAddress-1 write), (FixedAccessNode''getLocationIdentity-1 write), value, (FixedAccessNode''getBarrierType-1 write)))
        ]
            (AbstractWriteNode''setStateAfter-2 memoryWrite, (AbstractWriteNode''stateAfter-1 write))
            (§ ass! graph (Graph''replaceFixedWithFixed-3 graph, write, memoryWrite))
            (FixedAccessNode''setGuard-2 memoryWrite, (FixedAccessNode''getGuard-1 write))
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerCommitAllocationNode-2 [#_"CommitAllocationNode" commit, #_"LoweringTool" lowerer]
        (let [
            #_"Graph" graph (:graph commit)
        ]
            (when (= (:guardsStage graph) GuardsStage'FIXED_DEOPTS)
                (let [
                    #_"List<AbstractNewObjectNode>" recursiveLowerings (ArrayList.)
                    #_"ValueNode[]" allocations (make-array ValueNode (count (:virtualObjects commit)))
                    #_"BitSet" omittedValues (BitSet.)
                ]
                    (loop-when [#_"int" valuePos 0 #_"int" objIndex 0] (< objIndex (count (:virtualObjects commit)))
                        (let [
                            #_"VirtualObjectNode" virtual (nth (:virtualObjects commit) objIndex)
                            #_"int" entryCount (VirtualObjectNode''entryCount-1 virtual)
                            #_"AbstractNewObjectNode" newObject
                                (if (instance? VirtualInstanceNode virtual)
                                    (Graph''add-2 graph, (Lowerer'createNewInstanceFromVirtual-1 virtual))
                                    (Graph''add-2 graph, (Lowerer'createNewArrayFromVirtual-2 virtual, (ConstantNode'forInt-2 entryCount, graph)))
                                )
                        ]
                            (#_"List" .add recursiveLowerings, newObject)
                            (Graph''addBeforeFixed-3 graph, commit, newObject)
                            (aset allocations objIndex newObject)
                            (let [
                                valuePos
                                    (loop-when [valuePos valuePos #_"int" i 0] (< i entryCount) => valuePos
                                        (let [
                                            #_"ValueNode" value (nth (:values commit) valuePos)
                                            value
                                                (when (instance? VirtualObjectNode value) => value
                                                    (nth allocations (#_"List" .indexOf (:virtualObjects commit), value))
                                                )
                                        ]
                                            (cond
                                                (nil? value)
                                                    (#_"BitSet" .set omittedValues, valuePos)
                                                (not (and (instance? ConstantNode value) (#_"Constant" .isDefaultForKind (:value value))))
                                                    ;; Constant.illegal is always the defaultForKind, so it is skipped
                                                    (let [
                                                        #_"JavaKind" valueKind (ValueNode''getStackKind-1 value)
                                                        #_"JavaKind" entryKind (VirtualObjectNode''entryKind-2 virtual, i)
                                                        [#_"AddressNode" address #_"BarrierType" barrierType]
                                                            (if (instance? VirtualInstanceNode virtual)
                                                                (let [
                                                                    #_"long" offset (Lowerer'fieldOffset-1 (VirtualInstanceNode''field-2 virtual, i))
                                                                ]
                                                                    (when (<= 0 offset)
                                                                        [(Lowerer'createOffsetAddress-3 graph, newObject, offset) (Lowerer'fieldInitializationBarrier-1 entryKind)]
                                                                    )
                                                                )
                                                                [(Lowerer'createOffsetAddress-3 graph, newObject, (+ (HotSpot'arrayBaseOffset-1 entryKind) (* i (HotSpot'arrayIndexScale-1 entryKind)))) (Lowerer'arrayInitializationBarrier-1 entryKind)]
                                                            )
                                                    ]
                                                        (when (some? address)
                                                            (Graph''addAfterFixed-3 graph, newObject, (Graph''add-2 graph, (WriteNode'new-4 address, (LocationIdentity/init), (Lowerer'implicitStoreConvert-3 graph, entryKind, value), barrierType)))
                                                        )
                                                    )
                                            )
                                            (recur (inc valuePos) (inc i))
                                        )
                                    )
                            ]
                                (recur valuePos (inc objIndex))
                            )
                        )
                    )

                    (loop-when [#_"int" valuePos 0 #_"int" objIndex 0] (< objIndex (count (:virtualObjects commit)))
                        (let [
                            #_"VirtualObjectNode" virtual (nth (:virtualObjects commit) objIndex)
                            #_"int" entryCount (VirtualObjectNode''entryCount-1 virtual)
                            #_"ValueNode" newObject (nth allocations objIndex)
                            valuePos
                                (loop-when [valuePos valuePos #_"int" i 0] (< i entryCount) => valuePos
                                    (when (#_"BitSet" .get omittedValues, valuePos)
                                        (let [
                                            #_"ValueNode" value (nth (:values commit) valuePos)
                                            #_"ValueNode" allocValue (nth allocations (#_"List" .indexOf (:virtualObjects commit), value))
                                        ]
                                            (when-not (and (instance? ConstantNode allocValue) (#_"Constant" .isDefaultForKind (:value allocValue)))
                                                (let [
                                                    [#_"AddressNode" address #_"BarrierType" barrierType]
                                                        (if (instance? VirtualInstanceNode virtual)
                                                            [(Lowerer'createFieldAddress-3 graph, newObject, (VirtualInstanceNode''field-2 virtual, i)) BarrierType'IMPRECISE]
                                                            [(Lowerer'createArrayAddress-4 graph, newObject, (VirtualObjectNode''entryKind-2 virtual, i), (ConstantNode'forInt-2 i, graph)) BarrierType'PRECISE]
                                                        )
                                                ]
                                                    (when (some? address)
                                                        (Graph''addBeforeFixed-3 graph, commit, (Graph''add-2 graph, (WriteNode'new-4 address, (LocationIdentity/init), (Lowerer'implicitStoreConvert-3 graph, JavaKind/Object, allocValue), barrierType)))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (recur (inc valuePos) (inc i))
                                )
                        ]
                            (recur valuePos (inc objIndex))
                        )
                    )

                    (Lowerer'finishAllocatedObjects-3 lowerer, commit, allocations)
                    (Graph''removeFixed-2 graph, commit)

                    (doseq [#_"AbstractNewObjectNode" recursiveLowering recursiveLowerings]
                        (AbstractNewObjectNode''lower-2 recursiveLowering, lowerer)
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"void" Lowerer'lowerSecondHalf-1 [#_"UnpackEndianHalfNode" node]
        (UnpackEndianHalfNode''lower-2 node, (#_"Architecture" .getByteOrder (.arch HotSpot'target)))
        nil
    )
)

;;;
 ; A utility for manually creating a graph. This will be expanded as necessary to support all
 ; subsystems that employ manual graph creation (as opposed to {@linkplain GraphBuilderPhase
 ; bytecode parsing} based graph creation).
 ;;
(final-ns GraphKit (§ implements GraphBuilderTool)
    (§ final #_"Graph" :graph nil)
    (§ mutable #_"FixedWithNextNode" :lastFixedNode nil)

    (§ final #_"List<Structure>" :structures nil)

    (§ defn #_"GraphKit" GraphKit'new-1 [#_"ResolvedJavaMethod" stubMethod]
        (let [
            #_"GraphKit" this (Object.)
            this (assoc this :graph (Graph'new-1 stubMethod))
            this (assoc this :lastFixedNode (:start (:graph this)))
            this (assoc this :structures (ArrayList.))
            ;; Add a dummy element, so that the access of the last element never leads to an exception.
            _ (#_"List" .add (:structures this), (§ reify (Structure'new-0)))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" GraphKit''parsingIntrinsic-1 [#_"GraphKit" this]
        true
    )

    ;;;
     ; Ensures a floating node is added to or already present in the graph via Graph#unique.
     ;
     ; @return a node similar to {@code node} if one exists, otherwise {@code node}
     ;;
    (§ method! #_"FloatingNode" GraphKit''unique-2 [#_"GraphKit" this, #_"FloatingNode" node]
        (Graph''add-2 (:graph this), (GraphKit''changeToWord-2 this, node))
    )

    #_unused
    (§ method! #_"ValueNode" GraphKit''add-2 [#_"GraphKit" this, #_"ValueNode" node]
        (Graph''add-2 (:graph this), (GraphKit''changeToWord-2 this, node))
    )

    (§ method! #_"ValueNode" GraphKit''changeToWord-2 [#_"GraphKit" this, #_"ValueNode" node]
        (when (WordTypes'isWord-1 node)
            (§ ass! node (ValueNode''setStamp-2 node, (WordTypes'getWordStamp-1 (StampTool'typeOrNull-1 (:stamp node)))))
        )
        node
    )

    (§ override! #_"ValueNode" GraphKit''append-2 [#_"GraphKit" this, #_"ValueNode" node]
        (let [
            #_"ValueNode" result (Graph''addOrUniqueWithInputs-2 (:graph this), (GraphKit''changeToWord-2 this, node))
        ]
            (when (instance? FixedNode result)
                (§ ass! this (GraphKit''updateLastFixed-2 this, result))
            )
            result
        )
    )

    (§ method- #_"GraphKit" GraphKit''updateLastFixed-2 [#_"GraphKit" this, #_"FixedNode" result]
        (Graph''addAfterFixed-3 (:graph this), (:lastFixedNode this), result)
        (assoc this :lastFixedNode (when (instance? FixedWithNextNode result) result))
    )

    (§ method! #_"InvokeNode" GraphKit''createInvoke-4* [#_"GraphKit" this, #_"Class" declaringClass, #_"String" name, #_"ValueNode..." args]
        (GraphKit''createInvoke-7* this, declaringClass, name, InvokeKind'Static, nil, BytecodeFrame/UNKNOWN_BCI, args)
    )

    ;;;
     ; Creates and appends an InvokeNode for a call to a given method with a given set of
     ; arguments. The method is looked up via reflection based on the declaring class and name.
     ;
     ; @param declaringClass the class declaring the invoked method
     ; @param name the name of the invoked method
     ; @param args the arguments to the invocation
     ;;
    (§ method! #_"InvokeNode" GraphKit''createInvoke-7* [#_"GraphKit" this, #_"Class" declaringClass, #_"String" name, #_"InvokeKind" invokeKind, #_"FrameStateBuilder" frameStateBuilder, #_"int" bci, #_"ValueNode..." args]
        (GraphKit''createInvoke-6* this, (GraphKit''findMethod-4 this, declaringClass, name, (= invokeKind InvokeKind'Static)), invokeKind, frameStateBuilder, bci, args)
    )

    (§ method! #_"ResolvedJavaMethod" GraphKit''findMethod-4 [#_"GraphKit" this, #_"Class" declaringClass, #_"String" name, #_"boolean" static?]
        (let [
            #_"ResolvedJavaMethod" method
                (loop-when [method nil #_"ISeq" s (seq (#_"Class" .getDeclaredMethods declaringClass))] (some? s) => method
                    (let [
                        #_"Method" m (first s)
                        method
                            (when (and (= (Modifier/isStatic (#_"Method" .getModifiers m)) static?) (= (#_"Method" .getName m) name)) => method
                                (#_"MetaAccessProvider" .lookupJavaMethod HotSpot'metaAccess, m)
                            )
                    ]
                        (recur method (next s))
                    )
                )
        ]
            (or method (throw! (str "could not find " declaringClass "." name " (" (if static? "static" "non-static") ")")))
        )
    )

    #_unused
    (§ method! #_"ResolvedJavaMethod" GraphKit''findMethod-4* [#_"GraphKit" this, #_"Class" declaringClass, #_"String" name, #_"Class..." parameterTypes]
        (#_"MetaAccessProvider" .lookupJavaMethod HotSpot'metaAccess, (#_"Class" .getDeclaredMethod declaringClass, name, parameterTypes))
    )

    ;;;
     ; Creates and appends an InvokeNode for a call to a given method with a given set of arguments.
     ;;
    (§ method! #_"InvokeNode" GraphKit''createInvoke-6* [#_"GraphKit" this, #_"ResolvedJavaMethod" method, #_"InvokeKind" invokeKind, #_"FrameStateBuilder" frameStateBuilder, #_"int" bci, #_"ValueNode..." args]
        (let [
            #_"Signature" signature (#_"ResolvedJavaMethod" .getSignature method)
            #_"JavaType" returnType (#_"Signature" .getReturnType signature, nil)
            #_"StampPair" returnStamp
                (or (Plugins''getOverridingStamp-4 HotSpot'plugins, this, returnType, false)
                    (StampFactory'forDeclaredType-2 returnType, false)
                )
            #_"MethodCallTargetNode" callTarget (Graph''add-2 (:graph this), (MethodCallTargetNode'new-4 invokeKind, method, args, returnStamp))
            #_"InvokeNode" invoke (GraphKit''append-2 this, (InvokeNode'new-2 callTarget, bci))
        ]
            (when (some? frameStateBuilder)
                (when-not (= (ValueNode''getStackKind-1 invoke) JavaKind/Void)
                    (§ ass! frameStateBuilder (FrameStateBuilder''push-3 frameStateBuilder, (ValueNode''getStackKind-1 invoke), invoke))
                )
                (AbstractStateSplit''setStateAfter-2 invoke, (FrameStateBuilder''create-3 frameStateBuilder, bci, invoke))
                (when-not (= (ValueNode''getStackKind-1 invoke) JavaKind/Void)
                    (FrameStateBuilder''pop-2 frameStateBuilder, (ValueNode''getStackKind-1 invoke))
                )
            )
            invoke
        )
    )

    ;;;
     ; Inlines a given invocation to a method. The graph of the inlined method is processed in the
     ; same manner as for snippets and method substitutions.
     ;;
    (§ method! #_"void" GraphKit''inline-2 [#_"GraphKit" this, #_"InvokeNode" invoke]
        (let [
            #_"ResolvedJavaMethod" method (CallTargetNode''targetMethod-1 (:callTarget invoke))
            #_"GraphBuilderInstance" instance (GraphBuilderInstance'new-3 (GraphBuilderConfiguration'getSnippetDefault-1 HotSpot'plugins), OptimisticOptimizations'NONE, (IntrinsicContext'new-4 method, method, HotSpot'defaultBytecodeProvider, CompilationContext'INLINE_AFTER_PARSING))
            #_"Graph" calleeGraph (Graph'new-1 method)
        ]
            (Phase''apply-2 instance, calleeGraph)

            ;; Remove all frame states from inlinee.
            (Graph''clearAllStateAfter-1 calleeGraph)
            (Phase''apply-2 (DeadCodeEliminationPhase'new-1 Optionality'Required), calleeGraph)

            (InliningUtil'inline-4 invoke, calleeGraph, false, method)
        )
        nil
    )

    ;;;
     ; Recursively {@linkplain #inline inlines} all invocations currently in the graph.
     ;;
    (§ method! #_"void" GraphKit''inlineInvokes-1 [#_"GraphKit" this]
        (while (not (NodeIterable''isEmpty-1 (NodeIterable''filter-2 (Graph''getNodes-1 (:graph this)), InvokeNode)))
            (doseq [#_"InvokeNode" invoke (NodeIterable''snapshot-1 (NodeIterable''filter-2 (Graph''getNodes-1 (:graph this)), InvokeNode))]
                (GraphKit''inline-2 this, invoke)
            )
        )

        ;; Clean up all code that is now dead after inlining.
        (Phase''apply-2 (DeadCodeEliminationPhase'new-0), (:graph this))
        nil
    )

    (§ method! #_"void" GraphKit''pushStructure-2 [#_"GraphKit" this, #_"Structure" structure]
        (#_"List" .add (:structures this), structure)
        nil
    )

    (§ method! #_"<T extends Structure> T" GraphKit''getTopStructure-2 [#_"GraphKit" this, #_"Class<T>" expectedClass]
        (#_"Class" .cast expectedClass, (nth (:structures this) (dec (count (:structures this)))))
    )

    (§ method! #_"void" GraphKit''popStructure-1 [#_"GraphKit" this]
        (#_"List" .remove (:structures this), (dec (count (:structures this))))
        nil
    )

    ;;;
     ; Starts an if-block. This call can be followed by a call to #thenPart to start
     ; emitting the code executed when the condition hold; and a call to #elsePart to start
     ; emititng the code when the condition does not hold. It must be followed by a call to
     ; #endIf to close the if-block.
     ;
     ; @param condition The condition for the if-block
     ; @param trueProbability The estimated probability the condition is true
     ; @return the created IfNode
     ;;
    #_unused
    (§ method! #_"IfNode" GraphKit''startIf-3 [#_"GraphKit" this, #_"LogicNode" condition, #_"double" trueProbability]
        (let [
            #_"AbstractBeginNode" thenSuccessor (Graph''add-2 (:graph this), (BeginNode'new-0))
            #_"AbstractBeginNode" elseSuccessor (Graph''add-2 (:graph this), (BeginNode'new-0))
            #_"IfNode" node (GraphKit''append-2 this, (IfNode'new-4 condition, thenSuccessor, elseSuccessor, trueProbability))
        ]
            (§ ass! this (assoc this :lastFixedNode nil))

            (let [
                #_"IfStructure" s (IfStructure'new-0)
                s (assoc s :state IfState'CONDITION)
                s (assoc s :thenPart thenSuccessor)
                s (assoc s :elsePart elseSuccessor)
            ]
                (GraphKit''pushStructure-2 this, s)
                node
            )
        )
    )

    (§ method- #_"IfStructure" GraphKit''saveLastIfNode-1 [#_"GraphKit" this]
        (let [
            #_"IfStructure" s (GraphKit''getTopStructure-2 this, IfStructure)
            s
                (condp = (:state s)
                    IfState'THEN_PART (assoc s :thenPart (:lastFixedNode this))
                    IfState'ELSE_PART (assoc s :elsePart (:lastFixedNode this))
                                      s
                )
        ]
            (§ ass! this (assoc this :lastFixedNode nil))
            s
        )
    )

    #_unused
    (§ method! #_"GraphKit" GraphKit''thenPart-1 [#_"GraphKit" this]
        (let [
            #_"IfStructure" s (GraphKit''saveLastIfNode-1 this)
            this (assoc this :lastFixedNode (:thenPart s))
        ]
            (§ ass! s (assoc s :state IfState'THEN_PART))
            this
        )
    )

    #_unused
    (§ method! #_"GraphKit" GraphKit''elsePart-1 [#_"GraphKit" this]
        (let [
            #_"IfStructure" s (GraphKit''saveLastIfNode-1 this)
            this (assoc this :lastFixedNode (:elsePart s))
        ]
            (§ ass! s (assoc s :state IfState'ELSE_PART))
            this
        )
    )

    ;;;
     ; Ends an if block started with #startIf(LogicNode, double).
     ;
     ; @return the created merge node, or nil if no merge node was required (for example,
     ;         when one part ended with a control sink).
     ;;
    #_unused
    (§ method! #_"AbstractMergeNode" GraphKit''endIf-1 [#_"GraphKit" this]
        (let [
            #_"IfStructure" s (GraphKit''saveLastIfNode-1 this)
            #_"FixedWithNextNode" thenPart (when (instance? FixedWithNextNode (:thenPart s)) (:thenPart s))
            #_"FixedWithNextNode" elsePart (when (instance? FixedWithNextNode (:elsePart s)) (:elsePart s))
            #_"AbstractMergeNode" merge nil
        ]
            (cond
                (and (some? thenPart) (some? elsePart))
                ;; Both parts are alive, we need a real merge.
                    (let [
                        #_"EndNode" thenEnd (Graph''add-2 (:graph this), (EndNode'new-0))
                    ]
                        (Graph''addAfterFixed-3 (:graph this), thenPart, thenEnd)
                        (let [
                            #_"EndNode" elseEnd (Graph''add-2 (:graph this), (EndNode'new-0))
                        ]
                            (Graph''addAfterFixed-3 (:graph this), elsePart, elseEnd)

                            (§ ass merge (Graph''add-2 (:graph this), (MergeNode'new-0)))
                            (AbstractMergeNode''addForwardEnd-2 merge, thenEnd)
                            (AbstractMergeNode''addForwardEnd-2 merge, elseEnd)

                            (§ ass! this (assoc this :lastFixedNode merge))
                        )
                    )
                (some? thenPart)
                    ;; elsePart ended with a control sink, so we can continue with thenPart.
                    (§ ass! this (assoc this :lastFixedNode thenPart))
                (some? elsePart)
                    ;; thenPart ended with a control sink, so we can continue with elsePart.
                    (§ ass! this (assoc this :lastFixedNode elsePart))
                :else
                    nil ;; Both parts ended with a control sink, so no nodes can be added after the if.
            )
            (§ ass s (assoc s :state IfState'FINISHED))
            (GraphKit''popStructure-1 this)
            merge
        )
    )
)

;;;
 ; @anno GraphKit.Structure
 ;;
(class-ns Structure
    (§ defn #_"Structure" Structure'new-0 []
        (Object.)
    )
)

;;;
 ; @anno GraphKit.IfState
 ;;
(value-ns IfState
    (§ enum IfState'CONDITION)
    (§ enum IfState'THEN_PART)
    (§ enum IfState'ELSE_PART)
    (§ enum IfState'FINISHED)
)

;;;
 ; @anno GraphKit.IfStructure
 ;;
(final-ns IfStructure (§ extends Structure)
    (§ mutable #_"IfState" :state nil)
    (§ mutable #_"FixedNode" :thenPart nil)
    (§ mutable #_"FixedNode" :elsePart nil)

    (§ defn #_"IfStructure" IfStructure'new-0 []
        (Structure'new-0)
    )
)

(final-ns InlineDuringParsingPlugin (§ implements InlineInvokePlugin)
    (§ defn #_"InlineDuringParsingPlugin" InlineDuringParsingPlugin'new-0 []
        (Object.)
    )

    ;;;
     ; Budget which when exceeded reduces the effective value of
     ; GraalOptions#inlineDuringParsingMaxDepth to #maxDepthAfterBudgetExceeded.
     ;;
    (def- #_"int" InlineDuringParsingPlugin'nodeBudget 2000)
    (def- #_"int" InlineDuringParsingPlugin'maxDepthAfterBudgetExceeded 3)

    #_unused
    (§ override! #_"InlineInvokeInfo" InlineDuringParsingPlugin''shouldInlineInvoke-4 [#_"InlineDuringParsingPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
        (when (and (#_"ResolvedJavaMethod" .hasBytecodes method) (#_"ResolvedJavaType" .isLinked (#_"ResolvedJavaMethod" .getDeclaringClass method)) (#_"ResolvedJavaMethod" .canBeInlined method))
            ;; test force inlining first
            (cond
                (#_"ResolvedJavaMethod" .shouldBeInlined method)
                    (InlineInvokeInfo'createStandardInlineInfo-1 method)
                (and (not (#_"ResolvedJavaMethod" .isSynchronized method))
                    (InlineDuringParsingPlugin'checkSize-3 method, args, (:graph parser))
                    (InlineDuringParsingPlugin'checkInliningDepth-1 parser)
                )
                    (InlineInvokeInfo'createStandardInlineInfo-1 method)
            )
        )
    )

    (§ defn- #_"boolean" InlineDuringParsingPlugin'checkInliningDepth-1 [#_"BytecodeParser" parser]
        (let [
            #_"int" nodeCount (Graph''getNodeCount-1 (:graph parser))
            #_"int" maxDepth GraalOptions'inlineDuringParsingMaxDepth
            maxDepth
                (if (and (< InlineDuringParsingPlugin'nodeBudget nodeCount) (< InlineDuringParsingPlugin'maxDepthAfterBudgetExceeded maxDepth))
                    InlineDuringParsingPlugin'maxDepthAfterBudgetExceeded
                    maxDepth
                )
        ]
            (< (BytecodeParser''getDepth-1 parser) maxDepth)
        )
    )

    (§ defn- #_"boolean" InlineDuringParsingPlugin'checkSize-3 [#_"ResolvedJavaMethod" method, #_"ValueNode[]" args, #_"Graph" graph]
        (let [
            #_"int" n (loop-when-recur [n 1 #_"ISeq" s (seq args)] (some? s) [(if (instance? ConstantNode (first s)) (inc n) n) (next s)] => n)
        ]
            (<= (count (#_"ResolvedJavaMethod" .getCode method)) (* n GraalOptions'trivialInliningSize))
        )
    )
)

;;;
 ; Helper class for lowering InstanceOfNodes with snippets. The majority of the complexity
 ; in such a lowering derives from the fact that InstanceOfNode is a floating node. A
 ; snippet used to lower an InstanceOfNode will almost always incorporate control flow and
 ; replacing a floating node with control flow is not trivial.
 ;
 ; The mechanism implemented in this class ensures that the graph for an instanceof snippet is
 ; instantiated once per InstanceOfNode being lowered. The result produced is then re-used
 ; by all usages of the node. Additionally, if there is a single usage that is an IfNode,
 ; the control flow in the snippet is connected directly to the true and false successors of the
 ; IfNode. This avoids materializing the instanceof test as a boolean which is then retested
 ; by the IfNode.
 ;;
(class-ns InstanceOfSnippetsTemplates (§ extends AbstractTemplates)
    (§ defn #_"InstanceOfSnippetsTemplates" InstanceOfSnippetsTemplates'new-0 []
        (AbstractTemplates'new-0)
    )

    ;;;
     ; Gets the arguments used to retrieve and instantiate an instanceof snippet template.
     ;;
    (§ abstract #_"Arguments" InstanceOfSnippetsTemplates''makeArguments-3 [#_"InstanceOfSnippetsTemplates" this, #_"InstanceOfUsageReplacer" replacer, #_"LoweringTool" lowerer])

    (§ method #_"void" InstanceOfSnippetsTemplates''lower-3 [#_"InstanceOfSnippetsTemplates" this, #_"FloatingNode" instanceOf, #_"LoweringTool" lowerer]
        (let [
            #_"Instantiation" instantiation (Instantiation'new-0)
        ]
            (doseq [#_"Node" usage (NodeIterable''snapshot-1 (Node''usages-1 instanceOf))]
                (let [
                    #_"InstanceOfUsageReplacer" replacer (InstanceOfSnippetsTemplates''createReplacer-5 this, instanceOf, instantiation, usage, (:graph usage))
                ]
                    (if (Instantiation''isInitialized-1 instantiation)
                        ;; no need to re-instantiate the snippet - just re-use its result
                        (InstanceOfUsageReplacer''replaceUsingInstantiation-1 replacer)
                        (let [
                            #_"Arguments" args (InstanceOfSnippetsTemplates''makeArguments-3 this, replacer, lowerer)
                        ]
                            (SnippetTemplate''instantiate-5 (SnippetTemplate'new-2 args, instanceOf), instanceOf, replacer, lowerer, args)
                        )
                    )
                )
            )

            (when-not (Node''isDeleted-1 instanceOf)
                (GraphUtil'killWithUnusedFloatingInputs-1 instanceOf)
            )
        )
        nil
    )

    ;;;
     ; Gets the specific replacer object used to replace the usage of an instanceof node with
     ; the result of an instantiated instanceof snippet.
     ;;
    (§ method! #_"InstanceOfUsageReplacer" InstanceOfSnippetsTemplates''createReplacer-5 [#_"InstanceOfSnippetsTemplates" this, #_"FloatingNode" instanceOf, #_"Instantiation" instantiation, #_"Node" usage, #_"Graph" graph]
        (if (InstanceOfSnippetsTemplates''canMaterialize-2 this, usage)
            (MaterializationUsageReplacer'new-5 instantiation, (:trueValue usage), (:falseValue usage), instanceOf, usage)
            (let [
                #_"ValueNode" trueValue (ConstantNode'forInt-2 1, graph)
                #_"ValueNode" falseValue (ConstantNode'forInt-2 0, graph)
                [trueValue falseValue]
                    (if (and (Instantiation''isInitialized-1 instantiation) (not (and (= trueValue (:trueValue instantiation)) (= falseValue (:falseValue instantiation)))))
                        ;; This code doesn't really care what values are used, so adopt the values from the previous instantiation.
                        [(:trueValue instantiation) (:falseValue instantiation)]
                        [trueValue falseValue]
                    )
            ]
                (NonMaterializationUsageReplacer'new-5 instantiation, trueValue, falseValue, instanceOf, usage)
            )
        )
    )

    ;;;
     ; Determines if an {@code instanceof} usage can be materialized.
     ;;
    (§ method #_"boolean" InstanceOfSnippetsTemplates''canMaterialize-2 [#_"InstanceOfSnippetsTemplates" this, #_"Node" usage]
        (condp instance? usage
            ConditionalNode (and (instance? ConstantNode (:trueValue usage)) (instance? ConstantNode (:falseValue usage)))
            IfNode              false
            FixedGuardNode      false
            ShortCircuitOrNode  false
            ConditionAnchorNode false
                                true
        )
    )
)

;;;
 ; The result of instantiating an instanceof snippet. This enables a snippet instantiation to be
 ; re-used which reduces compile time and produces better code.
 ;
 ; @anno InstanceOfSnippetsTemplates.Instantiation
 ;;
(final-ns Instantiation
    (§ mutable #_"ValueNode" :result nil)
    (§ mutable #_"LogicNode" :condition nil)
    (§ mutable #_"ValueNode" :trueValue nil)
    (§ mutable #_"ValueNode" :falseValue nil)

    (§ defn #_"Instantiation" Instantiation'new-0 []
        (Object.)
    )

    ;;;
     ; Determines if the instantiation has occurred.
     ;;
    (§ method! #_"boolean" Instantiation''isInitialized-1 [#_"Instantiation" this]
        (some? (:result this))
    )

    (§ method! #_"Instantiation" Instantiation''initialize-4 [#_"Instantiation" this, #_"ValueNode" r, #_"ValueNode" t, #_"ValueNode" f]
        (let [
            this (assoc this :result r)
            this (assoc this :trueValue t)
            this (assoc this :falseValue f)
        ]
            this
        )
    )

    ;;;
     ; Gets the result of this instantiation as a condition.
     ;
     ; @param testValue the returned condition is true if the result is equal to this value
     ;;
    (§ method! #_"LogicNode" Instantiation''asCondition-2 [#_"Instantiation" this, #_"ValueNode" testValue]
        (if (instance? ConstantNode (:result this))
            (LogicConstantNode'forBoolean-2 (= (:value (:result this)) (ValueNode''asConstant-1 testValue)), (:graph (:result this)))
            (do
                (when-not (and (some? (:condition this)) (instance? CompareNode (:condition this)) (= (:y (:condition this)) testValue))
                    ;; re-use previously generated condition if the trueValue for the test is the same
                    (§ ass! this (assoc this :condition (CompareNode'createCompareNode-4 (:graph (:result this)), CanonicalCondition'EQ, (:result this), testValue)))
                )
                (:condition this)
            )
        )
    )

    ;;;
     ; Gets the result of the instantiation as a materialized value.
     ;
     ; @param t the true value for the materialization
     ; @param f the false value for the materialization
     ;;
    (§ method! #_"ValueNode" Instantiation''asMaterialization-4 [#_"Instantiation" this, #_"Graph" graph, #_"ValueNode" t, #_"ValueNode" f]
        (if (and (= t (:trueValue this)) (= f (:falseValue this)))
            ;; Can simply use the phi result if the same materialized values are expected.
            (:result this)
            (Graph''add-2 graph, (ConditionalNode'new-3 (Instantiation''asCondition-2 this, (:trueValue this)), t, f))
        )
    )
)

;;;
 ; Replaces a usage of an InstanceOfNode or InstanceOfDynamicNode.
 ;
 ; @anno InstanceOfSnippetsTemplates.InstanceOfUsageReplacer
 ;;
(class-ns InstanceOfUsageReplacer (§ implements UsageReplacer)
    (§ final #_"Instantiation" :instantiation nil)
    (§ final #_"FloatingNode" :instanceOf nil)
    (§ final #_"ValueNode" :trueValue nil)
    (§ final #_"ValueNode" :falseValue nil)

    (§ defn #_"InstanceOfUsageReplacer" InstanceOfUsageReplacer'new-4 [#_"Instantiation" instantiation, #_"FloatingNode" instanceOf, #_"ValueNode" trueValue, #_"ValueNode" falseValue]
        (let [
            #_"InstanceOfUsageReplacer" this (Object.)
            this (assoc this :instantiation instantiation)
            this (assoc this :instanceOf instanceOf)
            this (assoc this :trueValue trueValue)
            this (assoc this :falseValue falseValue)
        ]
            this
        )
    )

    ;;;
     ; Does the replacement based on a previously snippet instantiation.
     ;;
    (§ abstract #_"void" InstanceOfUsageReplacer''replaceUsingInstantiation-1 [#_"InstanceOfUsageReplacer" this])
)

;;;
 ; Replaces the usage of an InstanceOfNode or InstanceOfDynamicNode that does
 ; not materialize the result of the type test.
 ;
 ; @anno InstanceOfSnippetsTemplates.NonMaterializationUsageReplacer
 ;;
(final-ns NonMaterializationUsageReplacer (§ extends InstanceOfUsageReplacer)
    (§ final #_"Node" :usage nil)

    (§ defn #_"NonMaterializationUsageReplacer" NonMaterializationUsageReplacer'new-5 [#_"Instantiation" instantiation, #_"ValueNode" trueValue, #_"ValueNode" falseValue, #_"FloatingNode" instanceOf, #_"Node" usage]
        (let [
            #_"NonMaterializationUsageReplacer" this (InstanceOfUsageReplacer'new-4 instantiation, instanceOf, trueValue, falseValue)
            this (assoc this :usage usage)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" NonMaterializationUsageReplacer''replaceUsingInstantiation-1 [#_"NonMaterializationUsageReplacer" this]
        (Node''replaceFirstInput-3 (:usage this), (:instanceOf this), (Instantiation''asCondition-2 (:instantiation this), (:trueValue this)))
        nil
    )

    #_unused
    (§ override! #_"void" NonMaterializationUsageReplacer''replace-3 [#_"NonMaterializationUsageReplacer" this, #_"ValueNode" oldNode, #_"ValueNode" newNode]
        (ValueNode''inferStamp-1 newNode)
        (§ ass! (:instantiation this) (Instantiation''initialize-4 (:instantiation this), newNode, (:trueValue this), (:falseValue this)))
        (Node''replaceFirstInput-3 (:usage this), oldNode, (Instantiation''asCondition-2 (:instantiation this), (:trueValue this)))
        nil
    )
)

;;;
 ; Replaces the usage of an InstanceOfNode or InstanceOfDynamicNode that does
 ; materializes the result of the type test.
 ;
 ; @anno InstanceOfSnippetsTemplates.MaterializationUsageReplacer
 ;;
(final-ns MaterializationUsageReplacer (§ extends InstanceOfUsageReplacer)
    (§ final #_"ConditionalNode" :usage nil)

    (§ defn #_"MaterializationUsageReplacer" MaterializationUsageReplacer'new-5 [#_"Instantiation" instantiation, #_"ValueNode" trueValue, #_"ValueNode" falseValue, #_"FloatingNode" instanceOf, #_"ConditionalNode" usage]
        (let [
            #_"MaterializationUsageReplacer" this (InstanceOfUsageReplacer'new-4 instantiation, instanceOf, trueValue, falseValue)
            this (assoc this :usage usage)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" MaterializationUsageReplacer''replaceUsingInstantiation-1 [#_"MaterializationUsageReplacer" this]
        (let [
            #_"ValueNode" newValue (Instantiation''asMaterialization-4 (:instantiation this), (:graph (:usage this)), (:trueValue this), (:falseValue this))
        ]
            (§ ass! (:usage this) (Node''replaceAtUsages-2 (:usage this), newValue))
            (GraphUtil'killWithUnusedFloatingInputs-1 (:usage this))
        )
        nil
    )

    #_unused
    (§ override! #_"void" MaterializationUsageReplacer''replace-3 [#_"MaterializationUsageReplacer" this, #_"ValueNode" oldNode, #_"ValueNode" newNode]
        (ValueNode''inferStamp-1 newNode)
        (§ ass! (:instantiation this) (Instantiation''initialize-4 (:instantiation this), newNode, (:trueValue this), (:falseValue this)))
        (§ ass! (:usage this) (Node''replaceAtUsages-2 (:usage this), newNode))
        (GraphUtil'killWithUnusedFloatingInputs-1 (:usage this))
        nil
    )
)

(final-ns MethodHandlePlugin (§ implements NodePlugin)
    (§ final #_"MethodHandleAccessProvider" :methodHandleAccess nil)
    (§ final #_"boolean" :safeForDeoptimization false)

    (§ defn #_"MethodHandlePlugin" MethodHandlePlugin'new-2 [#_"MethodHandleAccessProvider" methodHandleAccess, #_"boolean" safeForDeoptimization]
        (let [
            #_"MethodHandlePlugin" this (Object.)
            this (assoc this :methodHandleAccess methodHandleAccess)
            this (assoc this :safeForDeoptimization safeForDeoptimization)
        ]
            this
        )
    )

    (§ defn- #_"int" MethodHandlePlugin'countRecursiveInlining-2 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" method]
        (loop-when-recur [#_"int" n 0 parser (BytecodeParser''getParent-1 parser)]
                         (some? parser)
                         [(if (= method (BytecodeParser''getMethod-1 parser)) (inc n) n) (BytecodeParser''getParent-1 parser)]
                      => n
        )
    )

    #_unused
    (§ override! #_"boolean" MethodHandlePlugin''handleInvoke-4 [#_"MethodHandlePlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
        (let [
            #_"MethodHandleAccessProvider$IntrinsicMethod" intrinsicMethod (#_"MethodHandleAccessProvider" .lookupMethodHandleIntrinsic (:methodHandleAccess this), method)
        ]
            (and (some? intrinsicMethod)
                (let [
                    #_"InvokeKind" invokeKind (BytecodeParser''getInvokeKind-1 parser)
                ]
                    (when-not (= invokeKind InvokeKind'Static)
                        (aset args 0 (BytecodeParser''nullCheckedValue-2 parser, (nth args 0)))
                    )

                    (let [
                        #_"StampPair" invokeReturnStamp (BytecodeParser''getInvokeReturnStamp-1 parser)
                        #_"GraphAdder" adder
                            (§ reify #_"GraphAdder" (GraphAdder'new-1 (:graph parser))
                                (§ override! #_"ValueNode" GraphAdder''add-2 [#_"GraphAdder" this, #_"ValueNode" node]
                                    (BytecodeParser''add-2 parser, node)
                                )
                            )
                        #_"InvokeNode" invoke (MethodHandleNode'tryResolveTargetInvoke-7* adder, (:methodHandleAccess this), intrinsicMethod, method, (BytecodeParser''bci-1 parser), invokeReturnStamp, args)
                    ]
                        (if (nil? invoke)
                            (let [
                                #_"MethodHandleNode" methodHandleNode (MethodHandleNode'new-6* intrinsicMethod, invokeKind, method, (BytecodeParser''bci-1 parser), invokeReturnStamp, args)
                            ]
                                (if (= (Stamp''getStackKind-1 (:trustedStamp invokeReturnStamp)) JavaKind/Void)
                                    (BytecodeParser''add-2 parser, methodHandleNode)
                                    (BytecodeParser''addPush-3 parser, (Stamp''getStackKind-1 (:trustedStamp invokeReturnStamp)), methodHandleNode)
                                )
                                true
                            )
                            (let [
                                #_"CallTargetNode" callTarget (:callTarget invoke)
                                #_"NodeInputList<ValueNode>" argumentsList (CallTargetNode''arguments-1 callTarget)
                            ]
                                (dotimes [#_"int" i (count argumentsList)]
                                    (NodeList''initialize-3 argumentsList, i, (BytecodeParser''append-2 parser, (nth argumentsList i)))
                                )

                                ;; If a MemberName suffix argument is dropped, the replaced call cannot
                                ;; deoptimized since the necessary frame state cannot be reconstructed.
                                ;; As such, it needs to recursively inline everything.
                                (let [
                                    #_"boolean" inlineEverything (and (:safeForDeoptimization this) (not= (count args) (count argumentsList)))
                                    #_"ResolvedJavaMethod" targetMethod (CallTargetNode''targetMethod-1 callTarget)
                                ]
                                    (if (and inlineEverything (not (#_"ResolvedJavaMethod" .hasBytecodes targetMethod)))
                                        false ;; we need to force-inline but we can not, leave the invoke as-is
                                        (and (<= (MethodHandlePlugin'countRecursiveInlining-2 parser, targetMethod) GraalOptions'maximumRecursiveInlining)
                                            (do
                                                (§ ass! parser (BytecodeParser''handleReplacedInvoke-5 parser, (InvokeNode''getInvokeKind-1 invoke), targetMethod, (NodeList''toArray-2 argumentsList, (make-array ValueNode (count argumentsList))), inlineEverything))
                                                true
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

;;;
 ; Node representing an exact integer addition that will throw an ArithmeticException in
 ; case the addition would overflow the 32 bit range.
 ;;
(final-ns IntegerAddExactNode (§ extends AddNode) (§ implements IntegerExactArithmeticNode)
    (§ def #_"NodeClass<IntegerAddExactNode>" IntegerAddExactNode'TYPE (NodeClass'create-1 IntegerAddExactNode))

    (§ defn #_"IntegerAddExactNode" IntegerAddExactNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"IntegerAddExactNode" this (AddNode'new-3 IntegerAddExactNode'TYPE, x, y)
        ]
            (§ ass! this (ValueNode''setStamp-2 this, (Stamp''unrestricted-1 (:stamp x))))
            this
        )
    )

    #_unused
    (§ override! #_"boolean" IntegerAddExactNode''inferStamp-1 [#_"IntegerAddExactNode" this]
        ;; Note: it is not allowed to use the foldStamp method of the regular add node as we do not know
        ;; the result stamp of this node if we do not know whether we may deopt. If we know we can never
        ;; overflow we will replace this node with its non overflow checking counterpart anyway.
        false
    )

    #_unused
    (§ override! #_"Stamp" IntegerAddExactNode''foldStamp-3 [#_"IntegerAddExactNode" this, #_"Stamp" a, #_"Stamp" b]
        (let [
            #_"int" bits (:bits a)
            #_"long" defaultMask (CodeUtil/mask bits)
            #_"long" variableBits (| (bit-xor (:downMask a) (:upMask a)) (bit-xor (:downMask b) (:upMask b)))
            #_"long" variableBitsWithCarry (| variableBits (bit-xor (IntegerStamp'carryBits-2 (:downMask a), (:downMask b)) (IntegerStamp'carryBits-2 (:upMask a), (:upMask b))))
            #_"long" newDownMask (& (+ (:downMask a) (:downMask b)) (bit-not variableBitsWithCarry))
            #_"long" newUpMask (| (+ (:downMask a) (:downMask b)) variableBitsWithCarry)
            newDownMask (& newDownMask defaultMask)
            newUpMask (& newUpMask defaultMask)
            #_"long" lower
                (cond
                    (IntegerStamp'addOverflowsPositively-3 (:lowerBound a), (:lowerBound b), bits) (CodeUtil/maxValue bits)
                    (IntegerStamp'addOverflowsNegatively-3 (:lowerBound a), (:lowerBound b), bits) (CodeUtil/minValue bits)
                    :else
                        (CodeUtil/signExtend (& (+ (:lowerBound a) (:lowerBound b)) defaultMask), bits)
                )
            #_"long" upper
                (cond
                    (IntegerStamp'addOverflowsPositively-3 (:upperBound a), (:upperBound b), bits) (CodeUtil/maxValue bits)
                    (IntegerStamp'addOverflowsNegatively-3 (:upperBound a), (:upperBound b), bits) (CodeUtil/minValue bits)
                    :else
                        (CodeUtil/signExtend (& (+ (:upperBound a) (:upperBound b)) defaultMask), bits)
                )
            #_"IntegerStamp" limit (StampFactory'forInteger-3 bits, lower, upper)
            newUpMask (& newUpMask (:upMask limit))
            upper (CodeUtil/signExtend (& upper newUpMask), bits)
            newDownMask (| newDownMask (:downMask limit))
            lower (| lower newDownMask)
        ]
            (IntegerStamp'create-5 bits, lower, upper, newDownMask, newUpMask)
        )
    )

    #_unused
    (§ override! #_"ValueNode" IntegerAddExactNode''canonical-4 [#_"IntegerAddExactNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (if (and (instance? ConstantNode forX) (not (instance? ConstantNode forY)))
            (AddNode''canonical-2 (IntegerAddExactNode'new-2 forY, forX), tool)
            (do
                (cond
                    (instance? ConstantNode forX)
                        (let [
                            #_"ConstantNode" constantNode (IntegerAddExactNode'canonicalXconstant-2 forX, forY)
                        ]
                            (when (some? constantNode)
                                (§ return constantNode)
                            )
                        )
                    (instance? ConstantNode forY)
                        (when (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)))
                            (§ return forX)
                        )
                )
                (when-not (IntegerStamp'addCanOverflow-2 (:stamp forX), (:stamp forY)) => this
                    (BinaryArithmeticNode''canonical-2 (AddNode'new-2 forX, forY), tool)
                )
            )
        )
    )

    (§ defn- #_"ConstantNode" IntegerAddExactNode'canonicalXconstant-2 [#_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"JavaConstant" xConst (ValueNode''asJavaConstant-1 forX)
            #_"JavaConstant" yConst (ValueNode''asJavaConstant-1 forY)
        ]
            (when (and (some? xConst) (some? yConst))
                (try
                    (if (= (#_"JavaConstant" .getJavaKind xConst) JavaKind/Int)
                        (ConstantNode'forInt-1 (Math/addExact (#_"JavaConstant" .asInt xConst), (#_"JavaConstant" .asInt yConst)))
                        (ConstantNode'forLong-1 (Math/addExact (#_"JavaConstant" .asLong xConst), (#_"JavaConstant" .asLong yConst)))
                    )
                    (catch ArithmeticException _
                        nil ;; the operation will result in an overflow exception, so do not canonicalize
                    )
                )
            )
        )
    )

    #_unused
    (§ override! #_"IntegerExactArithmeticSplitNode" IntegerAddExactNode''createSplit-3 [#_"IntegerAddExactNode" this, #_"AbstractBeginNode" next, #_"AbstractBeginNode" deopt]
        (Graph''add-2 (:graph this), (IntegerAddExactSplitNode'new-5 (:stamp this), (:x this), (:y this), next, deopt))
    )

    #_unused
    (§ override! #_"void" IntegerAddExactNode''lower-2 [#_"IntegerAddExactNode" this, #_"LoweringTool" lowerer]
        (IntegerExactArithmeticSplitNode'lower-2 lowerer, this)
        nil
    )
)

(final-ns IntegerAddExactSplitNode (§ extends IntegerExactArithmeticSplitNode)
    (§ def #_"NodeClass<IntegerAddExactSplitNode>" IntegerAddExactSplitNode'TYPE (NodeClass'create-1 IntegerAddExactSplitNode))

    (§ defn #_"IntegerAddExactSplitNode" IntegerAddExactSplitNode'new-5 [#_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y, #_"AbstractBeginNode" next, #_"AbstractBeginNode" overflowSuccessor]
        (IntegerExactArithmeticSplitNode'new-6 IntegerAddExactSplitNode'TYPE, stamp, x, y, next, overflowSuccessor)
    )

    #_unused
    (§ override! #_"Value" IntegerAddExactSplitNode''generateArithmetic-2 [#_"IntegerAddExactSplitNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''emitAdd-4 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this)), true)
    )

    #_unused
    (§ override! #_"void" IntegerAddExactSplitNode''simplify-2 [#_"IntegerAddExactSplitNode" this, #_"SimplifierTool" tool]
        (when-not (IntegerStamp'addCanOverflow-2 (:stamp (:x this)), (:stamp (:y this)))
            (SimplifierTool''deleteBranch-2 tool, (:overflowSuccessor this))
            (SimplifierTool''addToWorkList-2 tool, (:next this))
            (let [
                #_"AddNode" replacement (Graph''add-2 (:graph this), (AddNode'new-2 (:x this), (:y this)))
            ]
                (Graph''replaceSplitWithFloating-4 (:graph this), this, replacement, (:next this))
                (SimplifierTool''addToWorkList-2 tool, replacement)
            )
        )
        nil
    )
)

(§ interface IntegerExactArithmeticNode (§ extends Lowerable)
    (§ abstract #_"IntegerExactArithmeticSplitNode" IntegerExactArithmeticNode''createSplit-3 [#_"IntegerExactArithmeticNode" this, #_"AbstractBeginNode" next, #_"AbstractBeginNode" deopt])
)

(class-ns IntegerExactArithmeticSplitNode (§ extends ControlSplitNode) (§ implements Simplifiable, LIRLowerable)
    (§ def #_"NodeClass<IntegerExactArithmeticSplitNode>" IntegerExactArithmeticSplitNode'TYPE (NodeClass'create-1 IntegerExactArithmeticSplitNode))

    ; @Successor
    (§ mutable #_"AbstractBeginNode" :next nil)
    ; @Successor
    (§ mutable #_"AbstractBeginNode" :overflowSuccessor nil)
    ; @Input
    (§ mutable #_"ValueNode" :x nil)
    ; @Input
    (§ mutable #_"ValueNode" :y nil)

    (§ defn #_"IntegerExactArithmeticSplitNode" IntegerExactArithmeticSplitNode'new-6 [#_"NodeClass<? extends IntegerExactArithmeticSplitNode>" c, #_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y, #_"AbstractBeginNode" next, #_"AbstractBeginNode" overflowSuccessor]
        (let [
            #_"IntegerExactArithmeticSplitNode" this (ControlSplitNode'new-2 c, stamp)
            this (assoc this :x x)
            this (assoc this :y y)
            this (assoc this :overflowSuccessor overflowSuccessor)
            this (assoc this :next next)
        ]
            this
        )
    )

    #_unused
    (§ override #_"AbstractBeginNode" IntegerExactArithmeticSplitNode''getPrimarySuccessor-1 [#_"IntegerExactArithmeticSplitNode" this]
        (:next this)
    )

    (§ override #_"double" IntegerExactArithmeticSplitNode''probability-2 [#_"IntegerExactArithmeticSplitNode" this, #_"AbstractBeginNode" successor]
        (if (= successor (:next this)) 1 0)
    )

    #_unused
    (§ override #_"boolean" IntegerExactArithmeticSplitNode''setProbability-3 [#_"IntegerExactArithmeticSplitNode" this, #_"AbstractBeginNode" successor, #_"double" value]
        ;; Successor probabilities for arithmetic split nodes are fixed.
        false
    )

    (§ method #_"AbstractBeginNode" IntegerExactArithmeticSplitNode''getNext-1 [#_"IntegerExactArithmeticSplitNode" this]
        (:next this)
    )

    #_unused
    (§ override #_"void" IntegerExactArithmeticSplitNode''generate-2 [#_"IntegerExactArithmeticSplitNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (IntegerExactArithmeticSplitNode''generateArithmetic-2 this, builder))
        (LIRBuilder''emitOverflowCheckBranch-5 builder, (:overflowSuccessor this), (IntegerExactArithmeticSplitNode''getNext-1 this), (:stamp this), (IntegerExactArithmeticSplitNode''probability-2 this, (:overflowSuccessor this)))
        nil
    )

    (§ abstract #_"Value" IntegerExactArithmeticSplitNode''generateArithmetic-2 [#_"IntegerExactArithmeticSplitNode" this, #_"LIRBuilder" builder])

    (§ defn #_"void" IntegerExactArithmeticSplitNode'lower-2 [#_"LoweringTool" lowerer, #_"IntegerExactArithmeticNode" node]
        (when (= (:guardsStage (:graph node)) GuardsStage'FIXED_DEOPTS)
            (let [
                #_"FixedWithNextNode" previous (:lastFixedNode lowerer)
                #_"FixedNode" next (:next previous)
            ]
                (§ ass! previous (FixedWithNextNode''setNext-2 previous, nil))
                (let [
                    #_"DeoptimizeNode" deopt (Graph''add-2 (:graph node), (DeoptimizeNode'new-2 DeoptimizationAction/InvalidateReprofile, DeoptimizationReason/ArithmeticException))
                    #_"AbstractBeginNode" normalBegin (Graph''add-2 (:graph node), (BeginNode'new-0))
                ]
                    (§ ass! normalBegin (FixedWithNextNode''setNext-2 normalBegin, next))
                    (let [
                        #_"IntegerExactArithmeticSplitNode" split (IntegerExactArithmeticNode''createSplit-3 node, normalBegin, (BeginNode'begin-1 deopt))
                    ]
                        (§ ass! previous (FixedWithNextNode''setNext-2 previous, split))
                        (§ ass! node (Node''replaceAndDelete-2 node, split))
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override #_"int" IntegerExactArithmeticSplitNode''getSuccessorCount-1 [#_"IntegerExactArithmeticSplitNode" this]
        2
    )
)

;;;
 ; Node representing an exact integer multiplication that will throw an ArithmeticException
 ; in case the addition would overflow the 32 bit range.
 ;;
(final-ns IntegerMulExactNode (§ extends MulNode) (§ implements IntegerExactArithmeticNode)
    (§ def #_"NodeClass<IntegerMulExactNode>" IntegerMulExactNode'TYPE (NodeClass'create-1 IntegerMulExactNode))

    (§ defn #_"IntegerMulExactNode" IntegerMulExactNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"IntegerMulExactNode" this (MulNode'new-3 IntegerMulExactNode'TYPE, x, y)
        ]
            (§ ass! this (ValueNode''setStamp-2 this, (Stamp''unrestricted-1 (:stamp x))))
            this
        )
    )

    #_unused
    (§ override! #_"boolean" IntegerMulExactNode''inferStamp-1 [#_"IntegerMulExactNode" this]
        ;; Note: it is not allowed to use the foldStamp method of the regular mul node as we do not know
        ;; the result stamp of this node if we do not know whether we may deopt. If we know we can never
        ;; overflow we will replace this node with its non overflow checking counterpart anyway.
        false
    )

    #_unused
    (§ override! #_"ValueNode" IntegerMulExactNode''canonical-4 [#_"IntegerMulExactNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (and (instance? ConstantNode forX) (not (instance? ConstantNode forY)))
                (§ return (MulNode''canonical-2 (IntegerMulExactNode'new-2 forY, forX), tool))
            (instance? ConstantNode forX)
                (§ return (IntegerMulExactNode''canonicalXconstant-3 this, forX, forY))
            (instance? ConstantNode forY)
                (let [
                    #_"long" c (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY))
                ]
                    (cond
                        (= c 1)
                            (§ return forX)
                        (zero? c)
                            (§ return (ConstantNode'forIntegerStamp-2 (:stamp this), 0))
                    )
                )
        )
        (when-not (IntegerStamp'multiplicationCanOverflow-2 (:stamp (:x this)), (:stamp (:y this))) => this
            (BinaryArithmeticNode''canonical-2 (MulNode'new-2 (:x this), (:y this)), tool)
        )
    )

    (§ method- #_"ValueNode" IntegerMulExactNode''canonicalXconstant-3 [#_"IntegerMulExactNode" this, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"JavaConstant" xConst (ValueNode''asJavaConstant-1 forX)
            #_"JavaConstant" yConst (ValueNode''asJavaConstant-1 forY)
        ]
            (try
                (if (= (#_"JavaConstant" .getJavaKind xConst) JavaKind/Int)
                    (ConstantNode'forInt-1 (Math/multiplyExact (#_"JavaConstant" .asInt xConst), (#_"JavaConstant" .asInt yConst)))
                    (ConstantNode'forLong-1 (Math/multiplyExact (#_"JavaConstant" .asLong xConst), (#_"JavaConstant" .asLong yConst)))
                )
                (catch ArithmeticException _
                    this ;; the operation will result in an overflow exception, so do not canonicalize
                )
            )
        )
    )

    #_unused
    (§ override! #_"IntegerExactArithmeticSplitNode" IntegerMulExactNode''createSplit-3 [#_"IntegerMulExactNode" this, #_"AbstractBeginNode" next, #_"AbstractBeginNode" deopt]
        (Graph''add-2 (:graph this), (IntegerMulExactSplitNode'new-5 (:stamp this), (:x this), (:y this), next, deopt))
    )

    #_unused
    (§ override! #_"void" IntegerMulExactNode''lower-2 [#_"IntegerMulExactNode" this, #_"LoweringTool" lowerer]
        (IntegerExactArithmeticSplitNode'lower-2 lowerer, this)
        nil
    )
)

(final-ns IntegerMulExactSplitNode (§ extends IntegerExactArithmeticSplitNode)
    (§ def #_"NodeClass<IntegerMulExactSplitNode>" IntegerMulExactSplitNode'TYPE (NodeClass'create-1 IntegerMulExactSplitNode))

    (§ defn #_"IntegerMulExactSplitNode" IntegerMulExactSplitNode'new-5 [#_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y, #_"AbstractBeginNode" next, #_"AbstractBeginNode" overflowSuccessor]
        (IntegerExactArithmeticSplitNode'new-6 IntegerMulExactSplitNode'TYPE, stamp, x, y, next, overflowSuccessor)
    )

    #_unused
    (§ override! #_"Value" IntegerMulExactSplitNode''generateArithmetic-2 [#_"IntegerMulExactSplitNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''emitMul-4 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this)), true)
    )

    #_unused
    (§ override! #_"void" IntegerMulExactSplitNode''simplify-2 [#_"IntegerMulExactSplitNode" this, #_"SimplifierTool" tool]
        (when-not (IntegerStamp'multiplicationCanOverflow-2 (:stamp (:x this)), (:stamp (:y this)))
            (SimplifierTool''deleteBranch-2 tool, (:overflowSuccessor this))
            (SimplifierTool''addToWorkList-2 tool, (:next this))
            (let [
                #_"MulNode" replacement (Graph''add-2 (:graph this), (MulNode'new-2 (:x this), (:y this)))
            ]
                (Graph''replaceSplitWithFloating-4 (:graph this), this, replacement, (:next this))
                (SimplifierTool''addToWorkList-2 tool, replacement)
            )
        )
        nil
    )
)

(final-ns IntegerMulHighNode (§ extends BinaryArithmeticNode #_"<MulHigh>") (§ implements BinaryCommutative #_"<ValueNode>")
    (§ def #_"NodeClass<IntegerMulHighNode>" IntegerMulHighNode'TYPE (NodeClass'create-1 IntegerMulHighNode))

    (§ defn #_"IntegerMulHighNode" IntegerMulHighNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (BinaryArithmeticNode'new-4 IntegerMulHighNode'TYPE, :mulHigh, x, y)
    )

    #_unused
    (§ override! #_"void" IntegerMulHighNode''generate-2 [#_"IntegerMulHighNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value" a (LIRBuilder''operand-2 builder, (:x this))
            #_"Value" b (LIRBuilder''operand-2 builder, (:y this))
        ]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitMulHigh-3 (:gen builder), a, b))
        )
        nil
    )

    #_unused
    (§ override! #_"ValueNode" IntegerMulHighNode''canonical-4 [#_"IntegerMulHighNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (BinaryArithmeticNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (when (and (instance? ConstantNode forX) (not (instance? ConstantNode forY))) => (IntegerMulHighNode'canonical-2 this, forY)
                    ;; we try to swap and canonicalize
                    (let [
                        #_"ValueNode" improvement (BinaryArithmeticNode''canonical-4 this, tool, forY, forX)
                    ]
                        (when (= improvement this) => improvement
                            ;; if this fails we only swap
                            (IntegerMulHighNode'new-2 forY, forX)
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"ValueNode" IntegerMulHighNode'canonical-2 [#_"IntegerMulHighNode" self, #_"ValueNode" forY]
        (when (instance? ConstantNode forY) => self
            (let [
                #_"Constant" constant (:value forY)
            ]
                (when (and (instance? PrimitiveConstant constant) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind constant)) (any = (#_"PrimitiveConstant" .asLong constant) 0 1)) => self
                    (ConstantNode'forIntegerStamp-2 (:stamp self), 0)
                )
            )
        )
    )
)

;;;
 ; Node representing an exact integer substraction that will throw an ArithmeticException in
 ; case the addition would overflow the 32 bit range.
 ;;
(final-ns IntegerSubExactNode (§ extends SubNode) (§ implements IntegerExactArithmeticNode)
    (§ def #_"NodeClass<IntegerSubExactNode>" IntegerSubExactNode'TYPE (NodeClass'create-1 IntegerSubExactNode))

    #_unused
    (§ defn #_"IntegerSubExactNode" IntegerSubExactNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (let [
            #_"IntegerSubExactNode" this (SubNode'new-3 IntegerSubExactNode'TYPE, x, y)
            this (ValueNode''setStamp-2 this, (Stamp''unrestricted-1 (:stamp x)))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" IntegerSubExactNode''inferStamp-1 [#_"IntegerSubExactNode" this]
        ;; Note: it is not allowed to use the foldStamp method of the regular sub node as we do not know
        ;; the result stamp of this node if we do not know whether we may deopt. If we know we can never
        ;; overflow we will replace this node with its non overflow checking counterpart anyway.
        false
    )

    #_unused
    (§ override! #_"ValueNode" IntegerSubExactNode''canonical-4 [#_"IntegerSubExactNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (cond
            (= (GraphUtil'unproxify-1 forX) (GraphUtil'unproxify-1 forY))                                             (ConstantNode'forIntegerStamp-2 (:stamp this), 0)
            (and (instance? ConstantNode forX) (instance? ConstantNode forY))                                         (IntegerSubExactNode''canonicalXYconstant-3 this, forX, forY)
            (and (instance? ConstantNode forY) (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 forY)))) forX
            (IntegerStamp'subtractionCanOverflow-2 (:stamp (:x this)), (:stamp (:y this)))                            this
            :else                                                                                                     (BinaryArithmeticNode''canonical-2 (SubNode'new-2 (:x this), (:y this)), tool)
        )
    )

    (§ method- #_"ValueNode" IntegerSubExactNode''canonicalXYconstant-3 [#_"IntegerSubExactNode" this, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"JavaConstant" xConst (ValueNode''asJavaConstant-1 forX)
            #_"JavaConstant" yConst (ValueNode''asJavaConstant-1 forY)
        ]
            (try
                (if (= (#_"JavaConstant" .getJavaKind xConst) JavaKind/Int)
                    (ConstantNode'forInt-1 (Math/subtractExact (#_"JavaConstant" .asInt xConst), (#_"JavaConstant" .asInt yConst)))
                    (ConstantNode'forLong-1 (Math/subtractExact (#_"JavaConstant" .asLong xConst), (#_"JavaConstant" .asLong yConst)))
                )
                (catch ArithmeticException _
                    this ;; the operation will result in an overflow exception, so do not canonicalize
                )
            )
        )
    )

    #_unused
    (§ override! #_"IntegerExactArithmeticSplitNode" IntegerSubExactNode''createSplit-3 [#_"IntegerSubExactNode" this, #_"AbstractBeginNode" next, #_"AbstractBeginNode" deopt]
        (Graph''add-2 (:graph this), (IntegerSubExactSplitNode'new-5 (:stamp this), (:x this), (:y this), next, deopt))
    )

    #_unused
    (§ override! #_"void" IntegerSubExactNode''lower-2 [#_"IntegerSubExactNode" this, #_"LoweringTool" lowerer]
        (IntegerExactArithmeticSplitNode'lower-2 lowerer, this)
        nil
    )
)

(final-ns IntegerSubExactSplitNode (§ extends IntegerExactArithmeticSplitNode)
    (§ def #_"NodeClass<IntegerSubExactSplitNode>" IntegerSubExactSplitNode'TYPE (NodeClass'create-1 IntegerSubExactSplitNode))

    (§ defn #_"IntegerSubExactSplitNode" IntegerSubExactSplitNode'new-5 [#_"Stamp" stamp, #_"ValueNode" x, #_"ValueNode" y, #_"AbstractBeginNode" next, #_"AbstractBeginNode" overflowSuccessor]
        (IntegerExactArithmeticSplitNode'new-6 IntegerSubExactSplitNode'TYPE, stamp, x, y, next, overflowSuccessor)
    )

    #_unused
    (§ override! #_"Value" IntegerSubExactSplitNode''generateArithmetic-2 [#_"IntegerSubExactSplitNode" this, #_"LIRBuilder" builder]
        (LIRGenerator''emitSub-4 (:gen builder), (LIRBuilder''operand-2 builder, (:x this)), (LIRBuilder''operand-2 builder, (:y this)), true)
    )

    #_unused
    (§ override! #_"void" IntegerSubExactSplitNode''simplify-2 [#_"IntegerSubExactSplitNode" this, #_"SimplifierTool" tool]
        (when-not (IntegerStamp'subtractionCanOverflow-2 (:stamp (:x this)), (:stamp (:y this)))
            (SimplifierTool''deleteBranch-2 tool, (:overflowSuccessor this))
            (SimplifierTool''addToWorkList-2 tool, (:next this))
            (let [
                #_"SubNode" replacement (Graph''add-2 (:graph this), (SubNode'new-2 (:x this), (:y this)))
            ]
                (Graph''replaceSplitWithFloating-4 (:graph this), this, replacement, (:next this))
                (SimplifierTool''addToWorkList-2 tool, replacement)
            )
        )
        nil
    )
)

(final-ns UnsignedMulHighNode (§ extends BinaryArithmeticNode #_"<UMulHigh>") (§ implements BinaryCommutative #_"<ValueNode>")
    (§ def #_"NodeClass<UnsignedMulHighNode>" UnsignedMulHighNode'TYPE (NodeClass'create-1 UnsignedMulHighNode))

    (§ defn #_"UnsignedMulHighNode" UnsignedMulHighNode'new-2 [#_"ValueNode" x, #_"ValueNode" y]
        (BinaryArithmeticNode'new-4 UnsignedMulHighNode'TYPE, :umulHigh, x, y)
    )

    #_unused
    (§ override! #_"void" UnsignedMulHighNode''generate-2 [#_"UnsignedMulHighNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value" a (LIRBuilder''operand-2 builder, (:x this))
            #_"Value" b (LIRBuilder''operand-2 builder, (:y this))
        ]
            (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitUMulHigh-3 (:gen builder), a, b))
        )
        nil
    )

    #_unused
    (§ override! #_"ValueNode" UnsignedMulHighNode''canonical-4 [#_"UnsignedMulHighNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" forX, #_"ValueNode" forY]
        (let [
            #_"ValueNode" ret (BinaryArithmeticNode''canonical-4 (§ super ), tool, forX, forY)
        ]
            (when (= ret this) => ret
                (when (and (instance? ConstantNode forX) (not (instance? ConstantNode forY))) => (UnsignedMulHighNode'canonical-2 this, forY)
                    ;; we try to swap and canonicalize
                    (let [
                        #_"ValueNode" improvement (BinaryArithmeticNode''canonical-4 this, tool, forY, forX)
                    ]
                        (when (= improvement this) => improvement
                            ;; if this fails we only swap
                            (UnsignedMulHighNode'new-2 forY, forX)
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"ValueNode" UnsignedMulHighNode'canonical-2 [#_"UnsignedMulHighNode" self, #_"ValueNode" forY]
        (when (instance? ConstantNode forY) => self
            (let [
                #_"Constant" constant (:value forY)
            ]
                (when (and (instance? PrimitiveConstant constant) (#_"JavaKind" .isNumericInteger (#_"PrimitiveConstant" .getJavaKind constant)) (any = (#_"PrimitiveConstant" .asLong constant) 0 1)) => self
                    (ConstantNode'forIntegerStamp-2 (:stamp self), 0)
                )
            )
        )
    )
)

(final-ns BitCountNode (§ extends UnaryNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<BitCountNode>" BitCountNode'TYPE (NodeClass'create-1 BitCountNode))

    #_unused
    (§ defn #_"BitCountNode" BitCountNode'new-1 [#_"ValueNode" value]
        (UnaryNode'new-3 BitCountNode'TYPE, (BitCountNode'computeStamp-2 (:stamp value), value), value)
    )

    #_unused
    (§ override! #_"Stamp" BitCountNode''foldStamp-2 [#_"BitCountNode" this, #_"Stamp" stamp]
        (BitCountNode'computeStamp-2 stamp, (UnaryNode''getValue-1 this))
    )

    (§ defn #_"Stamp" BitCountNode'computeStamp-2 [#_"Stamp" stamp, #_"ValueNode" value]
        (StampFactory'forInteger-3 JavaKind/Int, (Long/bitCount (:downMask stamp)), (Long/bitCount (:upMask stamp)))
    )

    #_unused
    (§ override! #_"ValueNode" BitCountNode''canonical-3 [#_"BitCountNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (when (instance? ConstantNode value) => this
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 value)
            ]
                (ConstantNode'forInt-1 (if (= (ValueNode''getStackKind-1 value) JavaKind/Int) (Integer/bitCount (#_"JavaConstant" .asInt constant)) (Long/bitCount (#_"JavaConstant" .asLong constant))))
            )
        )
    )

    #_unused
    (§ override! #_"void" BitCountNode''generate-2 [#_"BitCountNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitBitCount-2 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this))))
        nil
    )
)

;;;
 ; Determines the index of the least significant "1" bit. Note that the result is undefined if the
 ; input is zero.
 ;;
(final-ns BitScanForwardNode (§ extends UnaryNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<BitScanForwardNode>" BitScanForwardNode'TYPE (NodeClass'create-1 BitScanForwardNode))

    #_unused
    (§ defn #_"BitScanForwardNode" BitScanForwardNode'new-1 [#_"ValueNode" value]
        (UnaryNode'new-3 BitScanForwardNode'TYPE, (StampFactory'forInteger-3 JavaKind/Int, 0, (:bits (:stamp value))), value)
    )

    #_unused
    (§ override! #_"Stamp" BitScanForwardNode''foldStamp-2 [#_"BitScanForwardNode" this, #_"Stamp" stamp]
        (let [
            #_"long" mask (CodeUtil/mask (:bits stamp))
            #_"int" firstAlwaysSetBit (BitScanForwardNode'scan-1 (& (:downMask stamp) mask))
            #_"int" lower (BitScanForwardNode'scan-1 (& (:upMask stamp) mask))
            #_"int" upper
                (when (= firstAlwaysSetBit -1) => firstAlwaysSetBit
                    (BitScanReverseNode'scan-1 (& (:upMask stamp) mask))
                )
        ]
            (StampFactory'forInteger-3 JavaKind/Int, lower, upper)
        )
    )

    (§ defn #_"ValueNode" BitScanForwardNode'tryFold-1 [#_"ValueNode" value]
        (when (instance? ConstantNode value)
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 value)
            ]
                (when-not (zero? (#_"JavaConstant" .asLong constant))
                    (ConstantNode'forInt-1 (if (= (ValueNode''getStackKind-1 value) JavaKind/Int) (BitScanForwardNode'scan-1 (#_"JavaConstant" .asInt constant)) (BitScanForwardNode'scan-1 (#_"JavaConstant" .asLong constant))))
                )
            )
        )
    )

    #_unused
    (§ override! #_"ValueNode" BitScanForwardNode''canonical-3 [#_"BitScanForwardNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (or (BitScanForwardNode'tryFold-1 value)
            this
        )
    )

    ;;;
     ; Utility method with defined return value for 0.
     ;
     ; @return number of trailing zeros or -1 if {@code v} == 0
     ;;
    (§ defn #_"int" BitScanForwardNode'scan-1 [#_"long" v]
        (if (zero? v) -1 (Long/numberOfTrailingZeros v))
    )

    ;;;
     ; Utility method with defined return value for 0.
     ;
     ; @return number of trailing zeros or -1 if {@code v} == 0
     ;;
    (§ defn #_"int" BitScanForwardNode'scan-1 [#_"int" v]
        (BitScanForwardNode'scan-1 (& 0xffffffff v))
    )

    ;;;
     ; Raw intrinsic for bsf instruction.
     ;
     ; @return number of trailing zeros or an undefined value if {@code v} == 0
     ;;
    ; @NodeIntrinsic
    #_unused
    (§ native #_"int" BitScanForwardNode'unsafeScan-1 [#_"long" v])

    ;;;
     ; Raw intrinsic for bsf instruction.
     ;
     ; @return number of trailing zeros or an undefined value if {@code v} == 0
     ;;
    ; @NodeIntrinsic
    #_unused
    (§ native #_"int" BitScanForwardNode'unsafeScan-1 [#_"int" v])

    #_unused
    (§ override! #_"void" BitScanForwardNode''generate-2 [#_"BitScanForwardNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitBitScanForward-2 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this))))
        nil
    )
)

;;;
 ; Determines the index of the most significant "1" bit. Note that the result is undefined if the
 ; input is zero.
 ;;
(final-ns BitScanReverseNode (§ extends UnaryNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<BitScanReverseNode>" BitScanReverseNode'TYPE (NodeClass'create-1 BitScanReverseNode))

    #_unused
    (§ defn #_"BitScanReverseNode" BitScanReverseNode'new-1 [#_"ValueNode" value]
        (UnaryNode'new-3 BitScanReverseNode'TYPE, (StampFactory'forInteger-3 JavaKind/Int, 0, (:bits (:stamp value))), value)
    )

    #_unused
    (§ override! #_"Stamp" BitScanReverseNode''foldStamp-2 [#_"BitScanReverseNode" this, #_"Stamp" stamp]
        (let [
            #_"long" mask (CodeUtil/mask (:bits stamp))
            #_"int" lastAlwaysSetBit (BitScanReverseNode'scan-1 (& (:downMask stamp) mask))
            #_"int" lower
                (when (= lastAlwaysSetBit -1) => lastAlwaysSetBit
                    (BitScanForwardNode'scan-1 (& (:upMask stamp) mask))
                )
            #_"int" upper (BitScanReverseNode'scan-1 (& (:upMask stamp) mask))
        ]
            (StampFactory'forInteger-3 JavaKind/Int, lower, upper)
        )
    )

    #_unused
    (§ override! #_"ValueNode" BitScanReverseNode''canonical-3 [#_"BitScanReverseNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (when (instance? ConstantNode value) => this
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 value)
            ]
                (when-not (zero? (#_"JavaConstant" .asLong constant)) => this
                    (ConstantNode'forInt-1 (if (= (ValueNode''getStackKind-1 value) JavaKind/Int) (BitScanReverseNode'scan-1 (#_"JavaConstant" .asInt constant)) (BitScanReverseNode'scan-1 (#_"JavaConstant" .asLong constant))))
                )
            )
        )
    )

    ;;;
     ; Utility method with defined return value for 0.
     ;
     ; @return index of first set bit or -1 if {@code v} == 0
     ;;
    (§ defn #_"int" BitScanReverseNode'scan-1 [#_"long" v]
        (- 63 (Long/numberOfLeadingZeros v))
    )

    ;;;
     ; Utility method with defined return value for 0.
     ;
     ; @return index of first set bit or -1 if {@code v} == 0
     ;;
    (§ defn #_"int" BitScanReverseNode'scan-1 [#_"int" v]
        (- 31 (Integer/numberOfLeadingZeros v))
    )

    ;;;
     ; Raw intrinsic for bsr instruction.
     ;
     ; @return index of first set bit or an undefined value if {@code v} == 0
     ;;
    ; @NodeIntrinsic
    #_unused
    (§ native #_"int" BitScanReverseNode'unsafeScan-1 [#_"int" v])

    ;;;
     ; Raw intrinsic for bsr instruction.
     ;
     ; @return index of first set bit or an undefined value if {@code v} == 0
     ;;
    ; @NodeIntrinsic
    #_unused
    (§ native #_"int" BitScanReverseNode'unsafeScan-1 [#_"long" v])

    #_unused
    (§ override! #_"void" BitScanReverseNode''generate-2 [#_"BitScanReverseNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitBitScanReverse-2 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this))))
        nil
    )
)

;;;
 ; Represents a compile-time constant zero-terminated UTF-8 string installed with the generated code.
 ;;
(final-ns CStringConstant (§ extends DataPointerConstant)
    (§ def- #_"Charset" CStringConstant'UTF8 (Charset/forName "utf8"))

    (§ final #_"String" :string nil)

    (§ defn #_"CStringConstant" CStringConstant'new-1 [#_"String" string]
        (let [
            #_"CStringConstant" this (DataPointerConstant'new-1 1)
            this (assoc this :string string)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"int" CStringConstant''getSerializedSize-1 [#_"CStringConstant" this]
        (inc (count (#_"String" .getBytes (:string this), CStringConstant'UTF8)))
    )

    #_unused
    (§ override! #_"void" CStringConstant''serialize-2 [#_"CStringConstant" this, #_"ByteBuffer" buffer]
        (let [
            #_"byte[]" bytes (#_"String" .getBytes (:string this), CStringConstant'UTF8)
        ]
            (#_"ByteBuffer" .put buffer, bytes)
            (#_"ByteBuffer" .put buffer, (byte 0))
        )
        nil
    )

    #_unused
    (§ override! #_"String" CStringConstant''toValueString-1 [#_"CStringConstant" this]
        (str "c\"" (:string this) "\"")
    )

    #_unused
    (§ defn #_"boolean" CStringConstant'intrinsify-3 [#_"BytecodeParser" parser, #_"ResolvedJavaMethod" targetMethod, #_"String" string]
        (BytecodeParser''addPush-3 parser, JavaKind/Object, (ConstantNode'new-2 (CStringConstant'new-1 string), StampFactory'rawPointer))
        true
    )

    ; @NodeIntrinsic
    (§ native #_"Word" CStringConstant'cstring-1 [#_@ConstantNodeParameter #_"String" string])
)

;;;
 ; A special purpose store node that differs from RawStoreNode in that it is not a
 ; StateSplit and takes a computed address instead of an object.
 ;;
(final-ns DirectStoreNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<DirectStoreNode>" DirectStoreNode'TYPE (NodeClass'create-1 DirectStoreNode))

    ; @Input
    (§ mutable #_"ValueNode" :address nil)
    ; @Input
    (§ mutable #_"ValueNode" :value nil)

    (§ final #_"JavaKind" :kind nil)

    #_unused
    (§ defn #_"DirectStoreNode" DirectStoreNode'new-3 [#_"ValueNode" address, #_"ValueNode" value, #_"JavaKind" kind]
        (let [
            #_"DirectStoreNode" this (FixedWithNextNode'new-2 DirectStoreNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :address address)
            this (assoc this :value value)
            this (assoc this :kind kind)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" DirectStoreNode''generate-2 [#_"DirectStoreNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value" value (LIRBuilder''operand-2 builder, (:value this))
            #_"LIRKind" lirKind (LIRKind'fromJavaKind-2 (.arch HotSpot'target), (:kind this))
        ]
            (LIRGenerator''emitStore-4 (:gen builder), lirKind, (LIRBuilder''operand-2 builder, (:address this)), value)
        )
        nil
    )

    ; @NodeIntrinsic
    (§ native #_"void" DirectStoreNode'storeBoolean-3 [#_"long" address, #_"boolean" value, #_@ConstantNodeParameter #_"JavaKind" kind])
)

;;;
 ; Placeholder node to denote to snippet preparation that the following loop must be completely unrolled.
 ;;
(final-ns ExplodeLoopNode (§ extends FixedWithNextNode)
    (§ def #_"NodeClass<ExplodeLoopNode>" ExplodeLoopNode'TYPE (NodeClass'create-1 ExplodeLoopNode))

    #_unused
    (§ defn #_"ExplodeLoopNode" ExplodeLoopNode'new-0 []
        (FixedWithNextNode'new-2 ExplodeLoopNode'TYPE, (StampFactory'forVoid-0))
    )

    (§ method! #_"LoopBeginNode" ExplodeLoopNode''findLoopBegin-1 [#_"ExplodeLoopNode" this]
        (let [
            #_"ArrayList<Node>" succs (ArrayList.)
        ]
            (loop-when [#_"Node" next (:next this)] (not (instance? LoopBeginNode next)) => next
                (doseq [#_"Node" node (Node''cfgSuccessors-1 next)]
                    (#_"ArrayList" .add succs, node)
                )
                (when (and (= (count succs) 1) (not= (nth succs 0) next))
                    (recur (nth succs 0))
                )
            )
        )
    )

    ;;;
     ; A call to this method must be placed immediately prior to the loop that is to be exploded.
     ;;
    ; @NodeIntrinsic
    (§ native #_"void" ExplodeLoopNode'explodeLoop-0 [])
)

;;;
 ; Implements the semantics of VarargsParameter.
 ;;
(final-ns LoadSnippetVarargParameterNode (§ extends FixedWithNextNode) (§ implements Canonicalizable)
    (§ def #_"NodeClass<LoadSnippetVarargParameterNode>" LoadSnippetVarargParameterNode'TYPE (NodeClass'create-1 LoadSnippetVarargParameterNode))

    ; @Input
    (§ mutable #_"ValueNode" :index nil)

    ; @Input
    (§ mutable #_"NodeInputList<ParameterNode>" :parameters nil)

    (§ defn #_"LoadSnippetVarargParameterNode" LoadSnippetVarargParameterNode'new-3 [#_"ParameterNode[]" locals, #_"ValueNode" index, #_"Stamp" stamp]
        (let [
            #_"LoadSnippetVarargParameterNode" this (FixedWithNextNode'new-2 LoadSnippetVarargParameterNode'TYPE, stamp)
            this (assoc this :index index)
            this (assoc this :parameters (NodeInputList'new-2 this, locals))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Node" LoadSnippetVarargParameterNode''canonical-2 [#_"LoadSnippetVarargParameterNode" this, #_"CanonicalizerTool" tool]
        (when (instance? ConstantNode (:index this)) => this
            (let [
                #_"int" i (#_"JavaConstant" .asInt (ValueNode''asJavaConstant-1 (:index this)))
            ]
                (when (< i (count (:parameters this))) => this
                    (nth (:parameters this) i)
                )
            )
        )
    )
)

;;;
 ; Macro nodes can be used to temporarily replace an invoke. They can, for example, be used
 ; to implement constant folding for known JDK functions like Class#isInterface().
 ;
 ; During lowering, multiple sources are queried in order to look for a replacement:
 ;
 ; (1) If #getLoweredSnippetGraph(LoweringTool) returns a non-nil result, this graph
 ; is used as a replacement.
 ; (3) Otherwise, the macro node is replaced with an InvokeNode. Note that this is only
 ; possible if the macro node is a MacroStateSplitNode.
 ;;
(class-ns MacroNode (§ extends FixedWithNextNode) (§ implements Lowerable)
    (§ def #_"NodeClass<MacroNode>" MacroNode'TYPE (NodeClass'create-1 MacroNode))

    ; @Input
    (§ mutable #_"NodeInputList<ValueNode>" :arguments nil)

    (§ final #_"int" :bci 0)
    (§ final #_"ResolvedJavaMethod" :targetMethod nil)
    (§ final #_"StampPair" :returnStamp nil)
    (§ final #_"InvokeKind" :invokeKind nil)

    (§ defn #_"MacroNode" MacroNode'new-6* [#_"NodeClass<? extends MacroNode>" c, #_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode..." arguments]
        (let [
            #_"MacroNode" this (FixedWithNextNode'new-2 c, (:trustedStamp returnStamp))
            this (assoc this :arguments (NodeInputList'new-2 this, arguments))
            this (assoc this :bci bci)
            this (assoc this :targetMethod targetMethod)
            this (assoc this :returnStamp returnStamp)
            this (assoc this :invokeKind invokeKind)
        ]
            this
        )
    )

    #_unused
    (§ method #_"ValueNode" MacroNode''getArgument-2 [#_"MacroNode" this, #_"int" i]
        (nth (:arguments this) i)
    )

    #_unused
    (§ method #_"int" MacroNode''getArgumentCount-1 [#_"MacroNode" this]
        (count (:arguments this))
    )

    #_unused
    (§ method! #_"ValueNode[]" MacroNode''toArgumentArray-1 [#_"MacroNode" this]
        (NodeList''toArray-2 (:arguments this), (make-array ValueNode 0))
    )

    #_unused
    (§ method! #_"ResolvedJavaMethod" MacroNode''getTargetMethod-1 [#_"MacroNode" this]
        (:targetMethod this)
    )

    (§ method #_"FrameState" MacroNode''stateAfter-1 [#_"MacroNode" this]
        nil
    )

    #_unused
    (§ override #_"void" MacroNode''afterClone-2 [#_"MacroNode" this, #_"Node" other]
        nil
    )

    ;;;
     ; Gets a snippet to be used for lowering this macro node. The returned graph (if non-nil) must
     ; have been {@linkplain #lowerReplacement(Graph, LoweringTool) lowered}.
     ;;
    (§ method #_"Graph" MacroNode''getLoweredSnippetGraph-2 [#_"MacroNode" this, #_"LoweringTool" lowerer]
        nil
    )

    ;;;
     ; Applies lowering to a replacement graph.
     ;
     ; @param replacementGraph a replacement (i.e. snippet or method substitution) graph
     ;;
    #_unused
    (§ method! #_"Graph" MacroNode''lowerReplacement-3 [#_"MacroNode" this, #_"Graph" replacementGraph, #_"LoweringTool" lowerer]
        (let [
            #_"PhaseContext" c (PhaseContext'new-0)
        ]
            (when-not (:hasValueProxies (:graph this))
                (Phase''apply-2 (RemoveValueProxyPhase'new-0), replacementGraph)
            )
            (let [
                #_"GuardsStage" guardsStage (:guardsStage (:graph this))
            ]
                (when-not (GuardsStage'allowsFloatingGuards-1 guardsStage)
                    (BasePhase''apply-3 (GuardLoweringPhase'new-0), replacementGraph, nil)
                    (when (GuardsStage'areFrameStatesAtDeopts-1 guardsStage)
                        (Phase''apply-2 (FrameStateAssignmentPhase'new-0), replacementGraph)
                    )
                )
                (BasePhase''apply-3 (LoweringPhase'new-2 (CanonicalizerPhase'new-0), (:loweringStage (:phase lowerer))), replacementGraph, c)
                replacementGraph
            )
        )
    )

    #_unused
    (§ override #_"void" MacroNode''lower-2 [#_"MacroNode" this, #_"LoweringTool" lowerer]
        (let [
            #_"Graph" replacementGraph (MacroNode''getLoweredSnippetGraph-2 this, lowerer)
            #_"InvokeNode" invoke (MacroNode''replaceWithInvoke-1 this)
        ]
            (if (some? replacementGraph)
                (do
                    ;; pull out the receiver nil-check, so that a replaced receiver can be lowered if necessary
                    (when-not (#_"ResolvedJavaMethod" .isStatic (:targetMethod this))
                        (let [
                            #_"ValueNode" nonNullReceiver (InliningUtil'nonNullReceiver-1 invoke)
                        ]
                            (when (instance? Lowerable nonNullReceiver)
                                (Lowerable''lower-2 nonNullReceiver, lowerer)
                            )
                        )
                    )
                    (InliningUtil'inline-4 invoke, replacementGraph, false, (:targetMethod this))
                )
                (do
                    (when (BytecodeFrame/isPlaceholderBci (:bci invoke))
                        (throw! (str (:graph this) ": cannot lower to invoke with placeholder BCI: " this))
                    )

                    (when (nil? (AbstractStateSplit''stateAfter-1 invoke))
                        (let [
                            #_"ResolvedJavaMethod" method (:rootMethod (:graph this))
                        ]
                            (when (some? (#_"ResolvedJavaMethod" .getAnnotation method, Snippet)) => (throw! (str (:graph this) ": cannot lower to invoke without state: " this))
                                ;; One cause for this is that a MacroNode is created for a method that no longer
                                ;; needs a MacroNode. For example, Class.getComponentType() only needs a MacroNode
                                ;; prior to JDK9 as it was given a non-native implementation in JDK9.
                                (throw! (str (#_"Class" .getSimpleName (#_"Object" .getClass this)) " macro created for call to " (#_"ResolvedJavaMethod" .format (:targetMethod this), "%h.\n(%p)") " in " (:graph this) " must be lowerable to a snippet or intrinsic graph. Maybe a macro node is not needed for this method in the current JDK?"))
                            )
                        )
                    )
                    (InvokeNode''lower-2 invoke, lowerer)
                )
            )
        )
        nil
    )

    (§ method #_"InvokeNode" MacroNode''replaceWithInvoke-1 [#_"MacroNode" this]
        (let [
            #_"InvokeNode" invoke (MacroNode''createInvoke-1 this)
        ]
            (§ ass! (:graph this) (Graph''replaceFixedWithFixed-3 (:graph this), this, invoke))
            invoke
        )
    )

    (§ method #_"InvokeNode" MacroNode''createInvoke-1 [#_"MacroNode" this]
        (let [
            #_"MethodCallTargetNode" callTarget (Graph''add-2 (:graph this), (MethodCallTargetNode'new-4 (:invokeKind this), (:targetMethod this), (NodeList''toArray-2 (:arguments this), (make-array ValueNode (count (:arguments this)))), (:returnStamp this)))
            #_"InvokeNode" invoke (Graph''add-2 (:graph this), (InvokeNode'new-2 callTarget, (:bci this)))
        ]
            (when (some? (MacroNode''stateAfter-1 this))
                (AbstractStateSplit''setStateAfter-2 invoke, (FrameState''duplicate-1 (MacroNode''stateAfter-1 this)))
                (when-not (= (ValueNode''getStackKind-1 this) JavaKind/Void)
                    (Node''replaceFirstInput-3 (AbstractStateSplit''stateAfter-1 invoke), this, invoke)
                )
            )
            invoke
        )
    )
)

;;;
 ; This is an extension of MacroNode that is a StateSplit and a MemoryCheckpoint.
 ;;
(class-ns MacroStateSplitNode (§ extends MacroNode) (§ implements StateSplit, Single)
    (§ def #_"NodeClass<MacroStateSplitNode>" MacroStateSplitNode'TYPE (NodeClass'create-1 MacroStateSplitNode))

    ; @OptionalInput(InputType'StateI)
    (§ mutable #_"FrameState" :stateAfter nil)

    (§ defn #_"MacroStateSplitNode" MacroStateSplitNode'new-6* [#_"NodeClass<? extends MacroNode>" c, #_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode..." arguments]
        (MacroNode'new-6* c, invokeKind, targetMethod, bci, returnStamp, arguments)
    )

    #_unused
    (§ override #_"FrameState" MacroStateSplitNode''stateAfter-1 [#_"MacroStateSplitNode" this]
        (:stateAfter this)
    )

    #_unused
    (§ override #_"void" MacroStateSplitNode''setStateAfter-2 [#_"MacroStateSplitNode" this, #_"FrameState" x]
        (Node''updateUsages-3 this, (:stateAfter this), x)
        (§ ass! this (assoc this :stateAfter x))
        nil
    )

    #_unused
    (§ override #_"boolean" MacroStateSplitNode''hasSideEffect-1 [#_"MacroStateSplitNode" this]
        true
    )

    #_unused
    (§ override #_"LocationIdentity" MacroStateSplitNode''getLocationIdentity-1 [#_"MacroStateSplitNode" this]
        (LocationIdentity/any)
    )
)

;;;
 ; Node for invocation methods defined on the class MethodHandle.
 ;;
(final-ns MethodHandleNode (§ extends MacroStateSplitNode) (§ implements Simplifiable)
    (§ def #_"NodeClass<MethodHandleNode>" MethodHandleNode'TYPE (NodeClass'create-1 MethodHandleNode))

    (§ final #_"MethodHandleAccessProvider$IntrinsicMethod" :intrinsicMethod nil)

    (§ defn #_"MethodHandleNode" MethodHandleNode'new-6* [#_"MethodHandleAccessProvider$IntrinsicMethod" intrinsicMethod, #_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode..." arguments]
        (let [
            #_"MethodHandleNode" this (MacroStateSplitNode'new-6* MethodHandleNode'TYPE, invokeKind, targetMethod, bci, returnStamp, arguments)
            this (assoc this :intrinsicMethod intrinsicMethod)
        ]
            this
        )
    )

    ;;;
     ; Attempts to transform application of an intrinsifiable MethodHandle method into an
     ; invocation on another method with possibly transformed arguments.
     ;
     ; @param methodHandleAccess objects for accessing the implementation internals of a MethodHandle
     ; @param intrinsicMethod denotes the intrinsifiable MethodHandle method being processed
     ; @param bci the BCI of the original MethodHandle call
     ; @param returnStamp return stamp of the original MethodHandle call
     ; @param arguments arguments to the original MethodHandle call
     ; @return a more direct invocation derived from the MethodHandle call or nil
     ;;
    (§ defn #_"InvokeNode" MethodHandleNode'tryResolveTargetInvoke-7* [#_"GraphAdder" adder, #_"MethodHandleAccessProvider" methodHandleAccess, #_"MethodHandleAccessProvider$IntrinsicMethod" intrinsicMethod, #_"ResolvedJavaMethod" original, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode..." arguments]
        (condp =? intrinsicMethod
            INVOKE_BASIC
                (MethodHandleNode'getInvokeBasicTarget-7 adder, intrinsicMethod, methodHandleAccess, original, bci, returnStamp, arguments)
           [LINK_TO_STATIC LINK_TO_SPECIAL LINK_TO_VIRTUAL LINK_TO_INTERFACE]
                (MethodHandleNode'getLinkToTarget-7 adder, intrinsicMethod, methodHandleAccess, original, bci, returnStamp, arguments)
        )
    )

    #_unused
    (§ override! #_"void" MethodHandleNode''simplify-2 [#_"MethodHandleNode" this, #_"SimplifierTool" tool]
        (let [
            #_"MethodHandleAccessProvider" methodHandleAccess (#_"ConstantReflectionProvider" .getMethodHandleAccess HotSpot'constantReflection)
            #_"ValueNode[]" argumentsArray (NodeList''toArray-2 (:arguments this), (make-array ValueNode (count (:arguments this))))
            #_"FixedNode" before this
            #_"GraphAdder" adder
                (§ reify #_"GraphAdder" (GraphAdder'new-1 (:graph before))
                    (§ override! #_"ValueNode" GraphAdder''add-2 [#_"GraphAdder" this, #_"ValueNode" node]
                        (let [
                            #_"ValueNode" added (Graph''add-2 (:graph before), node)
                        ]
                            (when (instance? FixedWithNextNode added)
                                (Graph''addBeforeFixed-3 (:graph before), before, added)
                            )
                            added
                        )
                    )
                )
            #_"InvokeNode" invoke (MethodHandleNode'tryResolveTargetInvoke-7* adder, methodHandleAccess, (:intrinsicMethod this), (:targetMethod this), (:bci this), (:returnStamp this), argumentsArray)
        ]
            (when (some? invoke)
                (§ ass invoke (Graph''addOrUniqueWithInputs-2 (:graph this), invoke))
                (AbstractStateSplit''setStateAfter-2 invoke, (MacroNode''stateAfter-1 this))
                (let [
                    #_"FixedNode" currentNext (:next this)
                ]
                    (§ ass! this (Node''replaceAtUsages-2 this, invoke))
                    (GraphUtil'removeFixedWithUnusedInputs-1 this)
                    (Graph''addBeforeFixed-3 (:graph this), currentNext, invoke)
                )
            )
        )
        nil
    )

    ;;;
     ; Get the receiver of a MethodHandle.invokeBasic call.
     ;
     ; @return the receiver argument node
     ;;
    (§ defn- #_"ValueNode" MethodHandleNode'getReceiver-1 [#_"ValueNode[]" arguments]
        (nth arguments 0)
    )

    ;;;
     ; Get the MemberName argument of a MethodHandle.linkTo* call.
     ;
     ; @return the MemberName argument node (which is the last argument)
     ;;
    (§ defn- #_"ValueNode" MethodHandleNode'getMemberName-1 [#_"ValueNode[]" arguments]
        (nth arguments (dec (count arguments)))
    )

    ;;;
     ; Used for the MethodHandle.invokeBasic method (the {@link MethodHandleAccessProvider$IntrinsicMethod#INVOKE_BASIC}
     ; method) to get the target InvokeNode if the method handle receiver is constant.
     ;
     ; @return invoke node for the {@link java.lang.invoke.MethodHandle} target
     ;;
    (§ defn- #_"InvokeNode" MethodHandleNode'getInvokeBasicTarget-7 [#_"GraphAdder" adder, #_"MethodHandleAccessProvider$IntrinsicMethod" intrinsicMethod, #_"MethodHandleAccessProvider" methodHandleAccess, #_"ResolvedJavaMethod" original, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode[]" arguments]
        (let [
            #_"ValueNode" methodHandleNode (MethodHandleNode'getReceiver-1 arguments)
        ]
            (when (instance? ConstantNode methodHandleNode)
                (MethodHandleNode'getTargetInvokeNode-7 adder, intrinsicMethod, bci, returnStamp, arguments, (#_"MethodHandleAccessProvider" .resolveInvokeBasicTarget methodHandleAccess, (ValueNode''asJavaConstant-1 methodHandleNode), true), original)
            )
        )
    )

    ;;;
     ; Used for the MethodHandle.linkTo* methods (the {@link MethodHandleAccessProvider$IntrinsicMethod#LINK_TO_STATIC},
     ; {@link MethodHandleAccessProvider$IntrinsicMethod#LINK_TO_SPECIAL}, {@link MethodHandleAccessProvider$IntrinsicMethod#LINK_TO_VIRTUAL},
     ; and {@link MethodHandleAccessProvider$IntrinsicMethod#LINK_TO_INTERFACE} methods) to get the target InvokeNode
     ; if the member name argument is constant.
     ;
     ; @return invoke node for the member name target
     ;;
    (§ defn- #_"InvokeNode" MethodHandleNode'getLinkToTarget-7 [#_"GraphAdder" adder, #_"MethodHandleAccessProvider$IntrinsicMethod" intrinsicMethod, #_"MethodHandleAccessProvider" methodHandleAccess, #_"ResolvedJavaMethod" original, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode[]" arguments]
        (let [
            #_"ValueNode" memberNameNode (MethodHandleNode'getMemberName-1 arguments)
        ]
            (when (instance? ConstantNode memberNameNode)
                (MethodHandleNode'getTargetInvokeNode-7 adder, intrinsicMethod, bci, returnStamp, arguments, (#_"MethodHandleAccessProvider" .resolveLinkToTarget methodHandleAccess, (ValueNode''asJavaConstant-1 memberNameNode)), original)
            )
        )
    )

    ;;;
     ; Helper function to get the InvokeNode for the targetMethod of a java.lang.invoke.MemberName.
     ;
     ; @param target the target, already loaded from the member name node
     ;
     ; @return invoke node for the member name target
     ;;
    (§ defn- #_"InvokeNode" MethodHandleNode'getTargetInvokeNode-7 [#_"GraphAdder" adder, #_"MethodHandleAccessProvider$IntrinsicMethod" intrinsicMethod, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode[]" originalArguments, #_"ResolvedJavaMethod" target, #_"ResolvedJavaMethod" original]
        (when (some? target)
            ;; In lambda forms we erase signature types to avoid resolving issues involving
            ;; class loaders. When we optimize a method handle invoke to a direct call
            ;; we must cast the receiver and arguments to its actual types.
            (let [
                #_"ResolvedJavaMethod" realTarget
                    (when (#_"ResolvedJavaMethod" .canBeStaticallyBound target)
                        target
                    )
            ]
                (when (some? realTarget)
                    (let [
                        #_"boolean" static? (#_"ResolvedJavaMethod" .isStatic target)
                        ;; don't mutate the passed in arguments
                        #_"ValueNode[]" arguments (#_"Object" .clone originalArguments)
                        #_"Signature" signature (#_"ResolvedJavaMethod" .getSignature target)
                    ]
                        ;; cast receiver to its type
                        (when-not static?
                            (MethodHandleNode'maybeCastArgument-4 adder, arguments, 0, (#_"ResolvedJavaMethod" .getDeclaringClass target))
                        )
                        ;; cast reference arguments to its type
                        (dotimes [#_"int" index (#_"Signature" .getParameterCount signature, false)]
                            (MethodHandleNode'maybeCastArgument-4 adder, arguments, (+ (if static? 0 1) index), (#_"Signature" .getParameterType signature, index, (#_"ResolvedJavaMethod" .getDeclaringClass target)))
                        )
                        (MethodHandleNode'createTargetInvokeNode-6 intrinsicMethod, realTarget, original, bci, returnStamp, arguments)
                    )
                )
            )
        )
    )

    ;;;
     ; Inserts a node to cast the argument at index to the given type if the given type is more
     ; concrete than the argument type.
     ;
     ; @param index of the argument to be cast
     ; @param type the type the argument should be cast to
     ;;
    (§ defn- #_"void" MethodHandleNode'maybeCastArgument-4 [#_"GraphAdder" adder, #_"ValueNode[]" arguments, #_"int" index, #_"JavaType" type]
        (when (and (instance? ResolvedJavaType type) (not (#_"ResolvedJavaType" .isJavaLangObject type)))
            (let [
                #_"TypeReference" targetType (TypeReference'create-1 type)
                #_"ValueNode" argument (nth arguments index)
            ]
                ;; When an argument is a Word type, we can have a mismatch of primitive/object types here.
                ;; Not inserting a PiNode is a safe fallback, and Word types need no additional type information anyway.
                (when (and (some? targetType) (not (#_"ResolvedJavaType" .isPrimitive (:type targetType))) (not (#_"JavaKind" .isPrimitive (ValueNode''getStackKind-1 argument))))
                    (let [
                        #_"ResolvedJavaType" argumentType (StampTool'typeOrNull-1 (:stamp argument))
                    ]
                        (when (or (nil? argumentType) (and (#_"ResolvedJavaType" .isAssignableFrom argumentType, (:type targetType)) (not (= argumentType (:type targetType)))))
                            (let [
                                #_"LogicNode" logic (InstanceOfNode'createAllowNull-2 targetType, argument)
                            ]
                                (when-not (LogicNode''isTautology-1 logic)
                                    (let [
                                        logic (GraphAdder''add-2 adder, logic)
                                        #_"AnchoringNode" guardAnchor nil
                                        #_"DeoptimizationReason" reason DeoptimizationReason/ClassCastException
                                        #_"DeoptimizationAction" action DeoptimizationAction/InvalidateRecompile
                                        #_"JavaConstant" speculation JavaConstant/NULL_POINTER
                                        #_"GuardingNode" guard
                                            (when (some? guardAnchor) => (GraphAdder''add-2 adder, (FixedGuardNode'new-5 logic, reason, action, speculation, false))
                                                (let [
                                                    #_"GuardNode" newGuard (GraphAdder''add-2 adder, (GuardNode'new-6 logic, guardAnchor, reason, action, false, speculation))
                                                ]
                                                    (GraphAdder''add-2 adder, (ValueAnchorNode'new-1 newGuard))
                                                    newGuard
                                                )
                                            )
                                    ]
                                        (aset arguments index (GraphAdder''add-2 adder, (PiNode'create-3 argument, (StampFactory'object-1 targetType), guard)))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Creates an InvokeNode for the given target method. The CallTargetNode passed
     ; to the InvokeNode is in fact a ResolvedMethodHandleCallTargetNode.
     ;
     ; @return invoke node for the member name target
     ;;
    (§ defn- #_"InvokeNode" MethodHandleNode'createTargetInvokeNode-6 [#_"MethodHandleAccessProvider$IntrinsicMethod" intrinsicMethod, #_"ResolvedJavaMethod" target, #_"ResolvedJavaMethod" original, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode[]" arguments]
        (let [
            #_"InvokeKind" targetInvokeKind (if (#_"ResolvedJavaMethod" .isStatic target) InvokeKind'Static InvokeKind'Special)
            #_"JavaType" targetReturnType (#_"Signature" .getReturnType (#_"ResolvedJavaMethod" .getSignature target), nil)
            ;; MethodHandleLinkTo* nodes have a trailing MemberName argument which needs to be popped.
            #_"ValueNode[]" targetArguments
                (condp =? intrinsicMethod
                    INVOKE_BASIC arguments
                   [LINK_TO_STATIC LINK_TO_SPECIAL LINK_TO_VIRTUAL LINK_TO_INTERFACE] (Arrays/copyOfRange arguments, 0, (dec (count arguments)))
                )
            #_"StampPair" targetReturnStamp (StampFactory'forDeclaredType-2 targetReturnType, false)
            #_"MethodCallTargetNode" callTarget (ResolvedMethodHandleCallTargetNode'create-7 targetInvokeKind, target, targetArguments, targetReturnStamp, original, arguments, returnStamp)
        ]
            ;; The call target can have a different return type than the invoker, e.g. the target returns
            ;; an Object but the invoker void. In this case we need to use the stamp of the invoker.
            ;; Note: always using the invoker's stamp would be wrong because it's a less concrete type
            ;; (usually java.lang.Object).
            (if (= (Stamp''getStackKind-1 (:trustedStamp returnStamp)) JavaKind/Void)
                (InvokeNode'new-3 callTarget, bci, (StampFactory'forVoid-0))
                (InvokeNode'new-2 callTarget, bci)
            )
        )
    )
)

;;;
 ; A simple utility class for adding nodes to the graph when building a MethodHandle invoke.
 ;
 ; @anno MethodHandleNode.GraphAdder
 ;;
(class-ns GraphAdder
    (§ final #_"Graph" :graph nil)

    (§ defn #_"GraphAdder" GraphAdder'new-1 [#_"Graph" graph]
        (let [
            #_"GraphAdder" this (Object.)
            this (assoc this :graph graph)
        ]
            this
        )
    )

    ;;;
     ; Call Graph#addOrUnique(Node) on {@code node}
     ; and link any FixedWithNextNodes into the current control flow.
     ;
     ; @return the newly added node
     ;;
    (§ abstract #_"ValueNode" GraphAdder''add-2 [#_"GraphAdder" this, #_"ValueNode" node])
)

;;;
 ; Access the value of a specific register.
 ;;
(final-ns ReadRegisterNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<ReadRegisterNode>" ReadRegisterNode'TYPE (NodeClass'create-1 ReadRegisterNode))

    ;;;
     ; The fixed register to access.
     ;;
    (§ final #_"Register" :register nil)

    ;;;
     ; When true, subsequent uses of this node use the fixed register; when false, the value is
     ; moved into a new virtual register so that the fixed register is not seen by uses.
     ;;
    (§ final #_"boolean" :directUse false)

    ;;;
     ; When true, this node is also an implicit definition of the value for the register allocator,
     ; i.e. the register is an implicit incoming value; when false, the register must be defined in
     ; the same method or must be an register excluded from register allocation.
     ;;
    (§ final #_"boolean" :incoming false)

    (§ defn #_"ReadRegisterNode" ReadRegisterNode'new-4 [#_"Register" register, #_"JavaKind" kind, #_"boolean" directUse, #_"boolean" incoming]
        (let [
            #_"ReadRegisterNode" this (FixedWithNextNode'new-2 ReadRegisterNode'TYPE, (StampFactory'forKind-1 kind))
            this (assoc this :register register)
            this (assoc this :directUse directUse)
            this (assoc this :incoming incoming)
        ]
            this
        )
    )

    (§ defn #_"ReadRegisterNode" ReadRegisterNode'new-4 [#_@InjectedNodeParameter #_"Stamp" stamp, #_"Register" register, #_"boolean" directUse, #_"boolean" incoming]
        (let [
            #_"ReadRegisterNode" this (FixedWithNextNode'new-2 ReadRegisterNode'TYPE, stamp)
            this (assoc this :register register)
            this (assoc this :directUse directUse)
            this (assoc this :incoming incoming)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ReadRegisterNode''generate-2 [#_"ReadRegisterNode" this, #_"LIRBuilder" builder]
        (let [
            #_"LIRKind" kind (Stamp''getLIRKind-1 (:stamp this))
            #_"Value" result (#_"Register" .asValue (:register this), kind)
        ]
            (when (:incoming this)
                (LIRGenerator''emitIncomingValues-2 (:gen builder), (into-array Value [ result ]))
            )
            (when-not (:directUse this)
                (§ ass result (LIRGenerator''emitMove-2 (:gen builder), result))
            )
            (LIRBuilder''setResult-3 builder, this, result)
        )
        nil
    )
)

;;;
 ; A call target that replaces itself in the graph when being lowered by restoring the original
 ; MethodHandle invocation target. Prior to
 ; https://bugs.openjdk.java.net/browse/JDK-8072008, this is required for when a
 ; MethodHandle call is resolved to a constant target but the target was not inlined. In
 ; that case, the original invocation must be restored with all of its original arguments. Why?
 ; HotSpot linkage for MethodHandle intrinsics (see
 ; {@code MethodHandles::generate_method_handle_dispatch}) expects certain implicit arguments to be
 ; on the stack such as the MemberName suffix argument for a call to one of the MethodHandle.linkTo*
 ; methods. An {@linkplain MethodHandleNode#tryResolveTargetInvoke resolved} MethodHandle
 ; invocation drops these arguments which means the interpreter won't find them.
 ;;
(final-ns ResolvedMethodHandleCallTargetNode (§ extends MethodCallTargetNode) (§ implements Lowerable)
    (§ def #_"NodeClass<ResolvedMethodHandleCallTargetNode>" ResolvedMethodHandleCallTargetNode'TYPE (NodeClass'create-1 ResolvedMethodHandleCallTargetNode))

    ;;;
     ; Creates a call target for an invocation on a direct target derived by resolving a constant MethodHandle.
     ;;
    (§ defn #_"MethodCallTargetNode" ResolvedMethodHandleCallTargetNode'create-7 [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode[]" arguments, #_"StampPair" returnStamp, #_"ResolvedJavaMethod" originalTargetMethod, #_"ValueNode[]" originalArguments, #_"StampPair" originalReturnStamp]
        (ResolvedMethodHandleCallTargetNode'new-7 invokeKind, targetMethod, arguments, returnStamp, originalTargetMethod, originalArguments, originalReturnStamp)
    )

    (§ final #_"ResolvedJavaMethod" :originalTargetMethod nil)
    (§ final #_"StampPair" :originalReturnStamp nil)
    ; @Input
    (§ mutable #_"NodeInputList<ValueNode>" :originalArguments nil)

    (§ defn #_"ResolvedMethodHandleCallTargetNode" ResolvedMethodHandleCallTargetNode'new-7 [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"ValueNode[]" arguments, #_"StampPair" returnStamp, #_"ResolvedJavaMethod" originalTargetMethod, #_"ValueNode[]" originalArguments, #_"StampPair" originalReturnStamp]
        (let [
            #_"ResolvedMethodHandleCallTargetNode" this (MethodCallTargetNode'new-5 ResolvedMethodHandleCallTargetNode'TYPE, invokeKind, targetMethod, arguments, returnStamp)
            this (assoc this :originalTargetMethod originalTargetMethod)
            this (assoc this :originalReturnStamp originalReturnStamp)
            this (assoc this :originalArguments (NodeInputList'new-2 this, originalArguments))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" ResolvedMethodHandleCallTargetNode''lower-2 [#_"ResolvedMethodHandleCallTargetNode" this, #_"LoweringTool" lowerer]
        (let [
            #_"InvokeKind" replacementInvokeKind (if (#_"ResolvedJavaMethod" .isStatic (:originalTargetMethod this)) InvokeKind'Static InvokeKind'Special)
            #_"MethodCallTargetNode" replacement (Graph''add-2 (:graph this), (MethodCallTargetNode'new-4 replacementInvokeKind, (:originalTargetMethod this), (NodeList''toArray-2 (:originalArguments this), (make-array ValueNode (count (:originalArguments this)))), (:originalReturnStamp this)))
        ]
            ;; Replace myself...
            (§ ass! this (Node''replaceAndDelete-2 this, replacement))
        )
        nil
    )

    #_unused
    (§ override! #_"void" ResolvedMethodHandleCallTargetNode''generate-2 [#_"ResolvedMethodHandleCallTargetNode" this, #_"LIRBuilder" builder]
        (throw! "should have replaced itself")
    )
)

(final-ns ReverseBytesNode (§ extends UnaryNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<ReverseBytesNode>" ReverseBytesNode'TYPE (NodeClass'create-1 ReverseBytesNode))

    #_unused
    (§ defn #_"ReverseBytesNode" ReverseBytesNode'new-1 [#_"ValueNode" value]
        (UnaryNode'new-3 ReverseBytesNode'TYPE, (StampFactory'forKind-1 (ValueNode''getStackKind-1 value)), value)
    )

    #_unused
    (§ override! #_"Stamp" ReverseBytesNode''foldStamp-2 [#_"ReverseBytesNode" this, #_"Stamp" stamp]
        (condp = (ValueNode''getStackKind-1 this)
            JavaKind/Int
                (let [
                    #_"long" mask (CodeUtil/mask (#_"JavaKind" .getBitCount JavaKind/Int))
                ]
                    (IntegerStamp'stampForMask-3 (:bits stamp), (& (Integer/reverse (int (:downMask stamp))) mask), (& (Integer/reverse (int (:upMask stamp))) mask))
                )
            JavaKind/Long
                (IntegerStamp'stampForMask-3 (:bits stamp), (Long/reverse (:downMask stamp)), (Long/reverse (:upMask stamp)))
            (:stamp this)
        )
    )

    #_unused
    (§ override! #_"ValueNode" ReverseBytesNode''canonical-3 [#_"ReverseBytesNode" this, #_"CanonicalizerTool" tool, #_"ValueNode" value]
        (when (instance? ConstantNode value) => this
            (let [
                #_"JavaConstant" constant (ValueNode''asJavaConstant-1 value)
            ]
                (ConstantNode'forIntegerKind-2 (ValueNode''getStackKind-1 this), (if (= (ValueNode''getStackKind-1 this) JavaKind/Int) (Integer/reverseBytes (#_"JavaConstant" .asInt constant)) (Long/reverseBytes (#_"JavaConstant" .asLong constant))))
            )
        )
    )

    #_unused
    (§ override! #_"void" ReverseBytesNode''generate-2 [#_"ReverseBytesNode" this, #_"LIRBuilder" builder]
        (LIRBuilder''setResult-3 builder, this, (LIRGenerator''emitByteSwap-2 (:gen builder), (LIRBuilder''operand-2 builder, (UnaryNode''getValue-1 this))))
        nil
    )
)

;;;
 ; A helper class to allow elimination of byte code instrumentation that could interfere with escape analysis.
 ;;
(final-ns VirtualizableInvokeMacroNode (§ extends MacroStateSplitNode) (§ implements Virtualizable)
    (§ def #_"NodeClass<VirtualizableInvokeMacroNode>" VirtualizableInvokeMacroNode'TYPE (NodeClass'create-1 VirtualizableInvokeMacroNode))

    (§ defn #_"VirtualizableInvokeMacroNode" VirtualizableInvokeMacroNode'new-5* [#_"InvokeKind" invokeKind, #_"ResolvedJavaMethod" targetMethod, #_"int" bci, #_"StampPair" returnStamp, #_"ValueNode..." arguments]
        (MacroStateSplitNode'new-6* VirtualizableInvokeMacroNode'TYPE, invokeKind, targetMethod, bci, returnStamp, arguments)
    )

    #_unused
    (§ override! #_"void" VirtualizableInvokeMacroNode''virtualize-2 [#_"VirtualizableInvokeMacroNode" this, #_"VirtualizerTool" tool]
        (doseq [#_"ValueNode" arg (:arguments this)]
            (let [
                #_"ValueNode" alias (VirtualizerTool''getAlias-2 tool, arg)
            ]
                (when (instance? VirtualObjectNode alias)
                    (VirtualizerTool''delete-1 tool)
                )
            )
        )
        nil
    )
)

;;;
 ; Changes the value of a specific register.
 ;;
(final-ns WriteRegisterNode (§ extends FixedWithNextNode) (§ implements LIRLowerable)
    (§ def #_"NodeClass<WriteRegisterNode>" WriteRegisterNode'TYPE (NodeClass'create-1 WriteRegisterNode))

    ;;;
     ; The fixed register to access.
     ;;
    (§ final #_"Register" :register nil)

    ;;;
     ; The new value assigned to the register.
     ;;
    ; @Input
    (§ mutable #_"ValueNode" :value nil)

    #_unused
    (§ defn #_"WriteRegisterNode" WriteRegisterNode'new-2 [#_"Register" register, #_"ValueNode" value]
        (let [
            #_"WriteRegisterNode" this (FixedWithNextNode'new-2 WriteRegisterNode'TYPE, (StampFactory'forVoid-0))
            this (assoc this :register register)
            this (assoc this :value value)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" WriteRegisterNode''generate-2 [#_"WriteRegisterNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value" val (LIRBuilder''operand-2 builder, (:value this))
        ]
            (LIRGenerator''emitMove-3 (:gen builder), (#_"Register" .asValue (:register this), (#_"Value" .getValueKind val)), val)
        )
        nil
    )
)

(final-ns Replacements (§ implements InlineInvokePlugin)
    (§ defn #_"Replacements" Replacements'new-0 []
        (Object.)
    )

    ;;;
     ; Determines whether a given method should be inlined based on whether it has a substitution or
     ; whether the inlining context is already within a substitution.
     ;
     ; @return an object specifying how {@code method} is to be inlined or nil if it should not be
     ;         inlined based on substitution related criteria
     ;;
    #_unused
    (§ override! #_"InlineInvokeInfo" Replacements''shouldInlineInvoke-4 [#_"Replacements" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
        (when (BytecodeParser''parsingIntrinsic-1 parser)
            ;; force inlining when parsing replacements
            (InlineInvokeInfo'createIntrinsicInlineInfo-1 method)
        )
    )

    #_unused
    (§ override! #_"void" Replacements''notifyNotInlined-4 [#_"Replacements" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"InvokeNode" invoke]
        (when (BytecodeParser''parsingIntrinsic-1 parser)
            (let [
                #_"IntrinsicContext" intrinsic (:intrinsicContext parser)
            ]
                (when-not (IntrinsicContext''isCallToOriginal-2 intrinsic, method)
                    (throw! (str "All non-recursive calls in the intrinsic " (#_"ResolvedJavaMethod" .format (:intrinsicMethod intrinsic), "%H.\n(%p)") " must be inlined or intrinsified: found call to " (#_"ResolvedJavaMethod" .format method, "%h.\n(%p)")))
                )
            )
        )
        nil
    )

    ;;;
     ; Creates a preprocessed graph for a snippet or method substitution.
     ;
     ; @param method the snippet or method substitution for which a graph will be created
     ; @param args arguments to the snippet if available, otherwise nil
     ; @return the snippet graph, if any, that is derived from {@code method}
     ;;
    (§ defn #_"Graph" Replacements'createSnippet-2 [#_"ResolvedJavaMethod" method, #_"Object[]" args]
        (GraphMaker''makeGraph-2 (GraphMaker'new-1 method), args)
    )
)

;;;
 ; Creates and preprocesses a graph for a replacement.
 ;
 ; @anno Replacements.GraphMaker
 ;;
(final-ns GraphMaker
    ;;;
     ; The method for which a graph is being created.
     ;;
    (§ final #_"ResolvedJavaMethod" :method nil)

    (§ defn #_"GraphMaker" GraphMaker'new-1 [#_"ResolvedJavaMethod" substitute]
        (let [
            #_"GraphMaker" this (Object.)
            this (assoc this :method substitute)
        ]
            this
        )
    )

    (§ method! #_"Graph" GraphMaker''makeGraph-2 [#_"GraphMaker" this, #_"Object[]" args]
        (let [
            #_"Graph" graph (GraphMaker''buildInitialGraph-3 this, (:method this), args)
        ]
            (GraphMaker''finalizeGraph-2 this, graph)

            graph
        )
    )

    ;;;
     ; Does final processing of a snippet graph.
     ;;
    (§ method! #_"void" GraphMaker''finalizeGraph-2 [#_"GraphMaker" this, #_"Graph" graph]
        (BasePhase''apply-3 (ConvertDeoptimizeToGuardPhase'new-0), graph, nil)
        (Phase''apply-2 (DeadCodeEliminationPhase'new-1 Optionality'Required), graph)
        nil
    )

    ;;;
     ; Builds the initial graph for a replacement.
     ;;
    (§ method! #_"Graph" GraphMaker''buildInitialGraph-3 [#_"GraphMaker" this, #_"ResolvedJavaMethod" method, #_"Object[]" args]
        (let [
            #_"Graph" graph (Graph'new-1 method)
            #_"Plugins" plugins (Plugins'copy-1 HotSpot'plugins)
            _
                (when (some? args)
                    (§ ass! plugins (Plugins''prependParameterPlugin-2 plugins, (ConstantBindingParameterPlugin'new-1 args)))
                )
            #_"IntrinsicContext" initialIntrinsicContext
                (if (some? (#_"ResolvedJavaMethod" .getAnnotation (:method this), Snippet))
                    ;; snippet
                    (IntrinsicContext'new-4 (:method this), (:method this), HotSpot'defaultBytecodeProvider, CompilationContext'INLINE_AFTER_PARSING)
                    ;; post-parse inlined intrinsic
                    (IntrinsicContext'new-4 nil, (:method this), HotSpot'defaultBytecodeProvider, CompilationContext'INLINE_AFTER_PARSING)
                )
        ]
            (Phase''apply-2 (GraphBuilderInstance'new-3 (GraphBuilderConfiguration'getSnippetDefault-1 plugins), OptimisticOptimizations'NONE, initialIntrinsicContext), graph)
            (BasePhase''apply-3 (CanonicalizerPhase'new-0), graph, (PhaseContext'new-0))

            graph
        )
    )
)

(final-ns SnippetLowerableMemoryNode (§ extends FixedWithNextNode) (§ implements Lowerable, MemoryAccess)
    (§ def #_"NodeClass<SnippetLowerableMemoryNode>" SnippetLowerableMemoryNode'TYPE (NodeClass'create-1 SnippetLowerableMemoryNode))

    ; @Input
    (§ mutable #_"NodeInputList<ValueNode>" :arguments nil)
    ; @OptionalInput(InputType'Memory)
    (§ mutable #_"MemoryNode" :lastLocationAccess nil)
    (§ final #_"LocationIdentity" :locationIdentity nil)
    (§ mutable #_"SnippetLowering" :lowering nil)

    (§ defn #_"SnippetLowerableMemoryNode" SnippetLowerableMemoryNode'new-4* [#_"SnippetLowering" lowering, #_"LocationIdentity" locationIdentity, #_"Stamp" stamp, #_"ValueNode..." arguments]
        (let [
            #_"SnippetLowerableMemoryNode" this (FixedWithNextNode'new-2 SnippetLowerableMemoryNode'TYPE, stamp)
            this (assoc this :arguments (NodeInputList'new-2 this, arguments))
            this (assoc this :lowering lowering)
            this (assoc this :locationIdentity locationIdentity)
        ]
            this
        )
    )

    #_unused
    (§ method! #_"ValueNode" SnippetLowerableMemoryNode''getArgument-2 [#_"SnippetLowerableMemoryNode" this, #_"int" i]
        (nth (:arguments this) i)
    )

    #_unused
    (§ method! #_"int" SnippetLowerableMemoryNode''getArgumentCount-1 [#_"SnippetLowerableMemoryNode" this]
        (count (:arguments this))
    )

    #_unused
    (§ override! #_"void" SnippetLowerableMemoryNode''lower-2 [#_"SnippetLowerableMemoryNode" this, #_"LoweringTool" lowerer]
        (SnippetLowering''lower-3 (:lowering this), this, lowerer)
        nil
    )

    #_unused
    (§ override! #_"LocationIdentity" SnippetLowerableMemoryNode''getLocationIdentity-1 [#_"SnippetLowerableMemoryNode" this]
        (:locationIdentity this)
    )

    #_unused
    (§ override! #_"void" SnippetLowerableMemoryNode''setLastLocationAccess-2 [#_"SnippetLowerableMemoryNode" this, #_"MemoryNode" lla]
        (Node''updateUsages-3 this, (:lastLocationAccess this), lla)
        (§ ass! this (assoc this :lastLocationAccess lla))
        nil
    )
)

;;;
 ; @anno SnippetLowerableMemoryNode.SnippetLowering
 ;;
(§ interface SnippetLowering
    (§ abstract #_"void" SnippetLowering''lower-3 [#_"SnippetLowering" this, #_"SnippetLowerableMemoryNode" node, #_"LoweringTool" lowerer])
)

;;;
 ; Marker interface for a class that defines one or more Snippets.
 ;;
(§ interface Snippets
)

;;;
 ; A snippet template is a graph created by parsing a snippet method and then specialized by binding
 ; constants to the snippet's ConstantParameter parameters.
 ;;
(final-ns SnippetTemplate
    ;; These values must be compared with equals() not '==' to support replay compilation.
    (def- #_"Object" SnippetTemplate'UNUSED_PARAMETER "UNUSED_PARAMETER")
    (def- #_"Object" SnippetTemplate'CONSTANT_PARAMETER "CONSTANT_PARAMETER")

    ;;;
     ; The graph built from the snippet method.
     ;;
    (§ final #_"Graph" :snippet nil)
    (§ final #_"SnippetInfo" :info nil)
    ;;;
     ; The named parameters of this template that must be bound to values during instantiation.
     ; For a parameter that is still live after specialization, the value in this map is either
     ; a ParameterNode instance or a ParameterNode array. For an eliminated parameter,
     ; the value is identical to the key.
     ;;
    (§ final #_"Object[]" :parameters nil)
    ;;;
     ; The return node (if any) of the snippet.
     ;;
    (§ final #_"ReturnNode" :returnNode nil)
    ;;;
     ; The memory anchor (if any) of the snippet.
     ;;
    (§ final #_"MemoryAnchorNode" :memoryAnchor nil)
    ;;;
     ; Nodes that inherit the StateSplit#stateAfter() from the replacee during instantiation.
     ;;
    (§ final #_"ArrayList<StateSplit>" :sideEffectNodes nil)
    ;;;
     ; Nodes that inherit a deoptimization FrameState from the replacee during instantiation.
     ;;
    (§ final #_"ArrayList<DeoptimizingNode>" :deoptNodes nil)
    ;;;
     ; Nodes that have a stamp originating from a Placeholder.
     ;;
    (§ final #_"ArrayList<ValueNode>" :placeholderStampedNodes nil)
    ;;;
     ; The nodes to be inlined when this specialization is instantiated.
     ;;
    (§ final #_"ArrayList<Node>" :nodes nil)

    (§ mutable #_"boolean" :mayRemoveLocation false)

    (§ defn #_"SnippetTemplate" SnippetTemplate'new-2 [#_"Arguments" args, #_"Node" replacee]
        (let [
            #_"SnippetTemplate" this (Object.)
            this (assoc this :info (:info args))
            #_"Object[]" constantArgs (SnippetTemplate''getConstantArgs-2 this, args)
            #_"Graph" snippetGraph (Replacements'createSnippet-2 (:method (:info args)), constantArgs)
            #_"ResolvedJavaMethod" method (:rootMethod snippetGraph)
            #_"Signature" signature (#_"ResolvedJavaMethod" .getSignature method)
            #_"PhaseContext" phaseContext (PhaseContext'new-0)
            ;; copy snippet graph replacing constant parameters with given arguments
            #_"Graph" snippetCopy (Graph'new-1 (:rootMethod snippetGraph))
            #_"EconomicMap<Node, Node>" nodeReplacements (EconomicMap/create Equivalence/IDENTITY)
            _ (#_"EconomicMap" .put nodeReplacements, (:start snippetGraph), (:start snippetCopy))
            #_"int" parameterCount (SnippetInfo''getParameterCount-1 (:info args))
            #_"VarargsPlaceholderNode[]" placeholders (make-array VarargsPlaceholderNode parameterCount)
            _
                (dotimes [#_"int" i parameterCount]
                    (let [
                        #_"ParameterNode" parameter (Graph''getParameter-2 snippetGraph, i)
                    ]
                        (when (some? parameter)
                            (cond
                                (SnippetInfo''isConstantParameter-2 (:info args), i)
                                    (let [
                                        #_"Object" arg (nth (:values args) i)
                                        #_"JavaKind" kind (#_"Signature" .getParameterKind signature, i)
                                        #_"ConstantNode" constantNode
                                            (if (instance? Constant arg)
                                                (let [
                                                    #_"Stamp" stamp (nth (:constStamps args) i)
                                                ]
                                                    (if (nil? stamp)
                                                        (ConstantNode'forConstant-2 (§ cast #_"JavaConstant" arg), snippetCopy)
                                                        (ConstantNode'forConstant-3 stamp, (§ cast #_"Constant" arg), snippetCopy)
                                                    )
                                                )
                                                (ConstantNode'forConstant-2 (SnippetReflection'forBoxed-2 kind, arg), snippetCopy)
                                            )
                                    ]
                                        (#_"EconomicMap" .put nodeReplacements, parameter, constantNode)
                                    )
                                (SnippetInfo''isVarargsParameter-2 (:info args), i)
                                    (let [
                                        #_"Varargs" varargs (nth (:values args) i)
                                        #_"VarargsPlaceholderNode" placeholder (Graph''add-2 snippetCopy, (VarargsPlaceholderNode'new-1 varargs))
                                    ]
                                        (#_"EconomicMap" .put nodeReplacements, parameter, placeholder)
                                        (aset placeholders i placeholder)
                                    )
                                (SnippetInfo''isNonNullParameter-2 (:info args), i)
                                    (§ ass! parameter (ValueNode''setStamp-2 parameter, (Stamp''join-2 (:stamp parameter), StampFactory'objectNonNullStamp)))
                            )
                        )
                    )
                )
        ]
            (Graph''addDuplicates-5 snippetCopy, (Graph''getNodes-1 snippetGraph), snippetGraph, (Graph''getNodeCount-1 snippetGraph), nodeReplacements)

            ;; gather the template parameters
            (let [
                this (assoc this :parameters (make-array Object parameterCount))
                _
                    (loop-when-recur [#_"int" i 0] (< i parameterCount) [(inc i)]
                        (cond
                            (SnippetInfo''isConstantParameter-2 (:info args), i)
                                (aset (:parameters this) i SnippetTemplate'CONSTANT_PARAMETER)
                            (SnippetInfo''isVarargsParameter-2 (:info args), i)
                                (let [
                                    #_"Varargs" varargs (nth (:values args) i)
                                    #_"int" length (:length varargs)
                                    #_"ParameterNode[]" params (make-array ParameterNode length)
                                ]
                                    (dotimes [#_"int" j length]
                                        ;; use a decimal friendly numbering make it more obvious how values map
                                        (aset params j (Graph''add-2 snippetCopy, (ParameterNode'new-2 (+ (* (inc i) 10000) j), (StampPair'new-2 (:stamp varargs), nil))))
                                    )
                                    (aset (:parameters this) i params)

                                    (let [
                                        #_"VarargsPlaceholderNode" placeholder (nth placeholders i)
                                    ]
                                        (when (some? placeholder)
                                            (doseq [#_"Node" usage (NodeIterable''snapshot-1 (Node''usages-1 placeholder))]
                                                (condp instance? usage
                                                    LoadIndexedNode
                                                        (§ ass! snippetCopy (Graph''replaceFixedWithFixed-3 snippetCopy, usage, (Graph''add-2 snippetCopy, (LoadSnippetVarargParameterNode'new-3 params, (AccessIndexedNode''index-1 usage), (:stamp usage)))))
                                                    StoreIndexedNode
                                                        ;; The template lowering doesn't really treat this as an array,
                                                        ;; so you can't store back into the varargs. Allocate your own
                                                        ;; array if you really need this and EA should eliminate it.
                                                        (throw! "can't store into VarargsParameter array")
                                                    nil
                                                )
                                            )
                                        )
                                    )
                                )
                            :else
                                (aset (:parameters this) i (or (Graph''getParameter-2 snippetCopy, i) SnippetTemplate'UNUSED_PARAMETER)) ;; parameter value was eliminated
                        )
                    )
            ]
                (SnippetTemplate'explodeLoops-2 snippetCopy, phaseContext)

                (let [
                    #_"GuardsStage" guardsStage (:guardsStage (:cacheKey args))
                ]
                    ;; perform lowering on the snippet
                    (when-not (GuardsStage'allowsFloatingGuards-1 guardsStage)
                        (BasePhase''apply-3 (GuardLoweringPhase'new-0), snippetCopy, nil)
                    )
                    (§ ass! snippetCopy (Graph''setGuardsStage-2 snippetCopy, guardsStage))
                    (BasePhase''apply-3 (LoweringPhase'new-2 (CanonicalizerPhase'new-0), (:loweringStage (:cacheKey args))), snippetCopy, phaseContext)

                    (let [
                        #_"ArrayList<StateSplit>" curSideEffectNodes (ArrayList.)
                        #_"ArrayList<DeoptimizingNode>" curDeoptNodes (ArrayList.)
                        #_"ArrayList<ValueNode>" curPlaceholderStampedNodes (ArrayList.)
                    ]
                        (doseq [#_"Node" node (Graph''getNodes-1 snippetCopy)]
                            (when (and (instance? ValueNode node) (= (:stamp node) PlaceholderStamp'SINGLETON))
                                (#_"ArrayList" .add curPlaceholderStampedNodes, node)
                            )
                            (when (instance? StateSplit node)
                                (let [
                                    #_"FrameState" frameState (StateSplit''stateAfter-1 node)
                                ]
                                    (when (StateSplit''hasSideEffect-1 node)
                                        (#_"ArrayList" .add curSideEffectNodes, node)
                                    )
                                    (when (some? frameState)
                                        (StateSplit''setStateAfter-2 node, nil)
                                    )
                                )
                            )
                            (when (and (instance? DeoptimizingNode node) (DeoptimizingNode''canDeoptimize-1 node))
                                (#_"ArrayList" .add curDeoptNodes, node)
                            )
                        )

                        (Phase''apply-2 (DeadCodeEliminationPhase'new-1 Optionality'Required), snippetCopy)

                        (Phase''apply-2 (FloatingReadPhase'new-2 true, true), snippetCopy)
                        (Phase''apply-2 (RemoveValueProxyPhase'new-0), snippetCopy)

                        (let [
                            #_"MemoryAnchorNode" anchor (Graph''add-2 snippetCopy, (MemoryAnchorNode'new-0))
                        ]
                            (Node''replaceAtUsages-3 (:start snippetCopy), InputType'Memory, anchor)

                            (let [
                                this (assoc this :snippet snippetCopy)
                                #_"StartNode" entryPointNode (:start (:snippet this))
                            ]
                                (if (Node''hasNoUsages-1 anchor)
                                    (do
                                        (Node''safeDelete-1 anchor)
                                        (§ ass this (assoc this :memoryAnchor nil))
                                    )
                                    ;; find out if all the return memory maps point to the anchor (i.e. there's no kill anywhere)
                                    (let [
                                        #_"boolean" needsMemoryMaps
                                            (loop-when [#_"ISeq" s (seq (Graph''getNodes-2 (:snippet this), ReturnNode'TYPE))] (some? s) => false
                                                (let [
                                                    #_"MemoryMapNode" memoryMap (:memoryMap (first s))
                                                ]
                                                    (or (< 1 (count (MemoryMapNode''getLocations-1 memoryMap))) (not= (MemoryMapNode''getLastLocationAccess-2 memoryMap, (LocationIdentity/any)) anchor)
                                                        (recur (next s))
                                                    )
                                                )
                                            )
                                        #_"boolean" needsAnchor
                                            (or needsMemoryMaps
                                                ;; check that all those memory maps where the only usages of the anchor
                                                (let [
                                                    needsAnchor (NodeIterable''isNotEmpty-1 (NodeIterable''filter-2 (Node''usages-1 anchor), (NegativeTypePredicate'new-1 MemoryMapNode)))
                                                    ;; remove the useless memory map
                                                    #_"MemoryMapNode" memoryMap
                                                        (loop-when [memoryMap nil #_"ISeq" s (seq (Graph''getNodes-2 (:snippet this), ReturnNode'TYPE))] (some? s) => memoryMap
                                                            (let [
                                                                #_"ReturnNode" retNode (first s)
                                                                memoryMap (or memoryMap (:memoryMap retNode))
                                                            ]
                                                                (§ ass! retNode (ReturnNode''setMemoryMap-2 retNode, nil))
                                                                (recur memoryMap (next s))
                                                            )
                                                        )
                                                ]
                                                    (Node''safeDelete-1 memoryMap)
                                                    needsAnchor
                                                )
                                            )
                                    ]
                                        (if needsAnchor
                                            (do
                                                (Graph''addAfterFixed-3 snippetCopy, (:start snippetCopy), anchor)
                                                (§ ass this (assoc this :memoryAnchor anchor))
                                            )
                                            (do
                                                (Node''safeDelete-1 anchor)
                                                (§ ass this (assoc this :memoryAnchor nil))
                                            )
                                        )
                                    )
                                )

                                (let [
                                    #_"List<ReturnNode>" returnNodes (NodeIterable''snapshot-1 (Graph''getNodes-2 (:snippet this), ReturnNode'TYPE))
                                    this
                                        (case (count returnNodes)
                                            0 (assoc this :returnNode nil)
                                            1 (assoc this :returnNode (nth returnNodes 0))
                                            (let [
                                                #_"AbstractMergeNode" merge (Graph''add-2 (:snippet this), (MergeNode'new-0))
                                                #_"List<MemoryMapNode>" memMaps (ArrayList.)
                                                _
                                                    (doseq [#_"ReturnNode" retNode returnNodes]
                                                        (let [
                                                            #_"MemoryMapNode" memoryMapNode (:memoryMap retNode)
                                                        ]
                                                            (when (some? memoryMapNode)
                                                                (#_"List" .add memMaps, memoryMapNode)
                                                            )
                                                        )
                                                    )
                                                this (assoc this :returnNode (Graph''add-2 (:snippet this), (ReturnNode'new-1 (ValueMergeUtil'mergeReturns-2 merge, returnNodes))))
                                            ]
                                                (when (seq memMaps)
                                                    (let [
                                                        #_"MemoryMapNode" memoryMap (Graph''add-2 (:snippet this), (MemoryMapNode'new-1 (:lastMemorySnapshot (FloatingReadPhase'mergeMemoryMaps-2 merge, memMaps))))
                                                    ]
                                                        (§ ass! (:returnNode this) (ReturnNode''setMemoryMap-2 (:returnNode this), memoryMap))
                                                        (doseq [#_"MemoryMapNode" mm memMaps]
                                                            (when (and (not= mm memoryMap) (Node''isAlive-1 mm))
                                                                (GraphUtil'killWithUnusedFloatingInputs-1 mm)
                                                            )
                                                        )
                                                    )
                                                )
                                                (§ ass! merge (FixedWithNextNode''setNext-2 merge, (:returnNode this)))
                                                this
                                            )
                                        )
                                    this (assoc this :sideEffectNodes curSideEffectNodes)
                                    this (assoc this :deoptNodes curDeoptNodes)
                                    this (assoc this :placeholderStampedNodes curPlaceholderStampedNodes)
                                    this (assoc this :nodes (ArrayList.))
                                    _
                                        (doseq [#_"Node" node (Graph''getNodes-1 (:snippet this))]
                                            (when-not (any = node entryPointNode (BeginStateSplitNode''stateAfter-1 entryPointNode))
                                                (#_"ArrayList" .add (:nodes this), node)
                                            )
                                        )
                                ]
                                    (§ ass! (:snippet this) (Graph''freeze-1 (:snippet this)))

                                    this
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" SnippetTemplate'explodeLoops-2 [#_"Graph" snippetCopy, #_"PhaseContext" phaseContext]
        ;; do any required loop explosion
        (loop []
            (let [
                #_"boolean" exploded? false
                #_"ExplodeLoopNode" explodeLoop (NodeIterable''first-1 (NodeIterable''filter-2 (Graph''getNodes-1 snippetCopy), ExplodeLoopNode))
            ]
                (when (some? explodeLoop) ;; earlier canonicalization may have removed the loop altogether
                    (let [
                        #_"LoopBeginNode" loopBegin (ExplodeLoopNode''findLoopBegin-1 explodeLoop)
                    ]
                        (when (some? loopBegin)
                            (let [
                                #_"LoopEx" loop (LoopsData''loop-2 (LoopsData'new-1 snippetCopy), loopBegin)
                                #_"NodeMark" mark (NodeMark'new-1 snippetCopy)
                            ]
                                (LoopTransformations'fullUnroll-3 loop, phaseContext, (CanonicalizerPhase'new-0))
                                (CanonicalizerPhase''applyIncremental-4 (CanonicalizerPhase'new-0), snippetCopy, phaseContext, mark)
                                (LoopEx''deleteUnusedNodes-1 loop)
                            )
                        )
                        (GraphUtil'removeFixedWithUnusedInputs-1 explodeLoop)
                        (§ ass exploded? true)
                    )
                )
                (recur-if exploded? [])
            )
        )
        nil
    )

    (§ method! #_"Object[]" SnippetTemplate''getConstantArgs-2 [#_"SnippetTemplate" this, #_"Arguments" args]
        (let [
            #_"Object[]" constantArgs (#_"Object" .clone (:values args))
        ]
            (dotimes [#_"int" i (SnippetInfo''getParameterCount-1 (:info args))]
                (when-not (SnippetInfo''isConstantParameter-2 (:info args), i)
                    (aset constantArgs i nil)
                )
            )
            constantArgs
        )
    )

    ;;;
     ; Gets the instantiation-time bindings to this template's parameters.
     ;
     ; @return the map that will be used to bind arguments to parameters when inlining this template
     ;;
    (§ method- #_"EconomicMap<Node, Node>" SnippetTemplate''bind-3 [#_"SnippetTemplate" this, #_"Graph" replaceeGraph, #_"Arguments" args]
        (let [
            #_"EconomicMap<Node, Node>" replacements (EconomicMap/create Equivalence/IDENTITY)
        ]
            (loop-when-recur [#_"int" i 0] (< i (count (:parameters this))) [(inc i)]
                (let [
                    #_"Object" parameter (nth (:parameters this) i)
                    #_"Object" argument (nth (:values args) i)
                ]
                    (condp instance? parameter
                        ParameterNode
                            (#_"EconomicMap" .put replacements, parameter, (if (instance? ValueNode argument) argument (ConstantNode'forConstant-2 (SnippetTemplate''forBoxed-3 this, argument, (ValueNode''getStackKind-1 parameter)), replaceeGraph)))
                        ParameterNode*'class
                            (let [
                                [#_"List" list #_"Object" array] (if (instance? List (:value argument)) [(:value argument) nil] [nil (:value argument)])
                            ]
                                (dotimes [#_"int" j (count parameter)]
                                    (let [
                                        #_"ParameterNode" param (nth parameter j)
                                        #_"Object" value (if (some? list) (nth list j) (Array/get array, j))
                                    ]
                                        (#_"EconomicMap" .put replacements, param, (if (instance? ValueNode value) value (ConstantNode'forConstant-2 (SnippetTemplate''forBoxed-3 this, value, (ValueNode''getStackKind-1 param)), replaceeGraph)))
                                    )
                                )
                            )
                        nil
                    )
                )
            )
            replacements
        )
    )

    ;;;
     ; Converts a Java boxed value to a JavaConstant of the right kind. This adjusts for the
     ; limitation that a Local's kind is a {@linkplain JavaKind#getStackKind() stack kind}
     ; and so cannot be used for re-boxing primitives smaller than an int.
     ;
     ; @param argument a Java boxed value
     ; @param localKind the kind of the Local to which {@code argument} will be bound
     ;;
    (§ method! #_"JavaConstant" SnippetTemplate''forBoxed-3 [#_"SnippetTemplate" this, #_"Object" argument, #_"JavaKind" localKind]
        (if (= localKind JavaKind/Int)
            (JavaConstant/forBoxedPrimitive argument)
            (SnippetReflection'forBoxed-2 localKind, argument)
        )
    )

    ;;;
     ; Represents the default {@link UsageReplacer usage replacer} logic which
     ; simply delegates to Node#replaceAtUsages(Node).
     ;;
    (§ def #_"UsageReplacer" SnippetTemplate'DEFAULT_REPLACER
        (§ reify #_"UsageReplacer" (UsageReplacer'new-0)
            (§ override! #_"void" UsageReplacer''replace-3 [#_"UsageReplacer" this, #_"ValueNode" oldNode, #_"ValueNode" newNode]
                (when (some? newNode)
                    (§ ass! oldNode (Node''replaceAtUsages-2 oldNode, newNode))
                )
                nil
            )
        )
    )

    (§ method- #_"void" SnippetTemplate''rewireMemoryGraph-3 [#_"SnippetTemplate" this, #_"ValueNode" replacee, #_"UnmodifiableEconomicMap<Node, Node>" duplicates]
        (when (:isAfterFloatingReadPhase (:graph replacee))
            ;; rewire outgoing memory edges
            (SnippetTemplate''replaceMemoryUsages-3 this, replacee, (MemoryOutputMap'new-3 this, replacee, duplicates))

            (when (some? (:returnNode this))
                (let [
                    #_"ReturnNode" ret (get duplicates (:returnNode this))
                ]
                    (when (some? ret)
                        (let [
                            #_"MemoryMapNode" memoryMap (:memoryMap ret)
                        ]
                            (when (some? memoryMap)
                                (§ ass! ret (ReturnNode''setMemoryMap-2 ret, nil))
                                (Node''safeDelete-1 memoryMap)
                            )
                        )
                    )
                )
            )
            (when (some? (:memoryAnchor this))
                ;; rewire incoming memory edges
                (let [
                    #_"MemoryAnchorNode" memoryDuplicate (get duplicates (:memoryAnchor this))
                ]
                    (SnippetTemplate''replaceMemoryUsages-3 this, memoryDuplicate, (MemoryInputMap'new-1 replacee))

                    (when (Node''hasNoUsages-1 memoryDuplicate)
                        (if (some? (:next memoryDuplicate))
                            (Graph''removeFixed-2 (:graph memoryDuplicate), memoryDuplicate)
                            (do
                                ;; this was a dummy memory node used when instantiating pure data-flow
                                ;; snippets: it was not attached to the control flow.
                                (Node''safeDelete-1 memoryDuplicate)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"LocationIdentity" SnippetTemplate'getLocationIdentity-1 [#_"Node" node]
        (condp instance? node
            MemoryAccess  (MemoryAccess''getLocationIdentity-1 node)
            MemoryPhiNode (:locationIdentity node)
            nil
        )
    )

    (§ method- #_"void" SnippetTemplate''replaceMemoryUsages-3 [#_"SnippetTemplate" this, #_"ValueNode" node, #_"MemoryMap" map]
        (doseq [#_"Node" usage (NodeIterable''snapshot-1 (Node''usages-1 node))]
            (when-not (instance? MemoryMapNode usage)
                (when-some [#_"LocationIdentity" location (SnippetTemplate'getLocationIdentity-1 usage)]
                    (doseq [#_"Position" pos (Node''inputPositions-1 usage)]
                        (when (and (= (Position''getInputType-1 pos) InputType'Memory) (= (Position''get-2 pos, usage) node))
                            (when-some [#_"MemoryNode" replacement (MemoryMap''getLastLocationAccess-2 map, location)]
                                (Position''set-3 pos, usage, replacement)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Replaces a given fixed node with this specialized snippet.
     ;
     ; @param replacee the node that will be replaced
     ; @param replacer object that replaces the usages of {@code replacee}
     ; @param args the arguments to be bound to the flattened positional parameters of the snippet
     ; @return the map of duplicated nodes (original -> duplicate)
     ;;
    (§ method! #_"UnmodifiableEconomicMap<Node, Node>" SnippetTemplate''instantiate-4 [#_"SnippetTemplate" this, #_"FixedNode" replacee, #_"UsageReplacer" replacer, #_"Arguments" args]
        (SnippetTemplate''instantiate-5 this, replacee, replacer, args, true)
    )

    ;;;
     ; Replaces a given fixed node with this specialized snippet.
     ;
     ; @param replacee the node that will be replaced
     ; @param replacer object that replaces the usages of {@code replacee}
     ; @param args the arguments to be bound to the flattened positional parameters of the snippet
     ; @param killReplacee is true, the replacee node is deleted
     ; @return the map of duplicated nodes (original -> duplicate)
     ;;
    (§ method! #_"UnmodifiableEconomicMap<Node, Node>" SnippetTemplate''instantiate-5 [#_"SnippetTemplate" this, #_"FixedNode" replacee, #_"UsageReplacer" replacer, #_"Arguments" args, #_"boolean" killReplacee]
        ;; inline the snippet nodes replacing parameters with the given args in the process
        (let [
            #_"StartNode" entryPointNode (:start (:snippet this))
            #_"FixedNode" firstCFGNode (:next entryPointNode)
            #_"Graph" replaceeGraph (:graph replacee)
            #_"EconomicMap<Node, Node>" replacements (SnippetTemplate''bind-3 this, replaceeGraph, args)
        ]
            (#_"EconomicMap" .put replacements, entryPointNode, (AbstractBeginNode'prevBegin-1 replacee))
            (let [
                #_"UnmodifiableEconomicMap<Node, Node>" duplicates (SnippetTemplate''inlineSnippet-4 this, replacee, replaceeGraph, replacements)
                ;; re-wire the control flow graph around the replacee
                #_"FixedNode" firstCFGNodeDuplicate (get duplicates firstCFGNode)
            ]
                (Node''replaceAtPredecessor-2 replacee, firstCFGNodeDuplicate)

                (SnippetTemplate''rewireFrameStates-3 this, replacee, duplicates)

                (when (instance? DeoptimizingNode replacee)
                    (let [
                        #_"FrameState" stateBefore nil
                        #_"FrameState" stateDuring nil
                        #_"FrameState" stateAfter nil
                    ]
                        (when (DeoptimizingNode''canDeoptimize-1 replacee)
                            (when (instance? DeoptBefore replacee)
                                (§ ass stateBefore (DeoptBefore''stateBefore-1 replacee))
                            )
                            (when (instance? DeoptDuring replacee)
                                (§ ass stateDuring (DeoptDuring''stateDuring-1 replacee))
                            )
                            (when (instance? DeoptAfter replacee)
                                (§ ass stateAfter (DeoptAfter''stateAfter-1 replacee))
                            )
                        )

                        (doseq [#_"DeoptimizingNode" deoptNode (:deoptNodes this)]
                            (let [
                                #_"DeoptimizingNode" deoptDup (get duplicates deoptNode)
                            ]
                                (when (DeoptimizingNode''canDeoptimize-1 deoptDup)
                                    (when (instance? DeoptBefore deoptDup)
                                        (DeoptBefore''setStateBefore-2 deoptDup, stateBefore)
                                    )
                                    (when (instance? DeoptDuring deoptDup)
                                        (cond
                                            (some? stateDuring) (DeoptDuring''setStateDuring-2 deoptDup, stateDuring)
                                            (some? stateAfter)  (DeoptDuring''computeStateDuring-2 deoptDup, stateAfter)
                                            (some? stateBefore) (DeoptDuring''setStateDuring-2 deoptDup, stateBefore)
                                        )
                                    )
                                    (when (instance? DeoptAfter deoptDup)
                                        (DeoptAfter''setStateAfter-2 deoptDup, (or stateAfter stateBefore))
                                    )
                                )
                            )
                        )
                    )
                )

                (SnippetTemplate''updateStamps-3 this, replacee, duplicates)
                (SnippetTemplate''rewireMemoryGraph-3 this, replacee, duplicates)

                ;; replace all usages of the replacee with the value returned by the snippet
                (when (and (some? (:returnNode this)) (not (instance? ControlSinkNode replacee)))
                    (let [
                        #_"ReturnNode" returnDuplicate (get duplicates (:returnNode this))
                    ]
                        (UsageReplacer''replace-3 replacer, replacee, (:result returnDuplicate))
                        (when (Node''isAlive-1 returnDuplicate)
                            (let [
                                #_"FixedNode" next
                                    (when (instance? FixedWithNextNode replacee)
                                        (let [
                                            next (:next replacee)
                                        ]
                                            (§ ass! replacee (FixedWithNextNode''setNext-2 replacee, nil))
                                            next
                                        )
                                    )
                            ]
                                (§ ass! returnDuplicate (Node''replaceAndDelete-2 returnDuplicate, next))
                            )
                        )
                    )
                )

                (when killReplacee
                    ;; remove the replacee from its graph
                    (GraphUtil'killCFG-1 replacee)
                )

                duplicates
            )
        )
    )

    (§ method- #_"UnmodifiableEconomicMap<Node, Node>" SnippetTemplate''inlineSnippet-4 [#_"SnippetTemplate" this, #_"Node" replacee, #_"Graph" replaceeGraph, #_"EconomicMap<Node, Node>" replacements]
        (Graph''addDuplicates-5 replaceeGraph, (:nodes this), (:snippet this), (Graph''getNodeCount-1 (:snippet this)), replacements)
    )

    (§ method- #_"void" SnippetTemplate''propagateStamp-2 [#_"SnippetTemplate" this, #_"Node" node]
        (when (and (instance? PhiNode node) (ValueNode''inferStamp-1 node))
            (doseq [#_"Node" usage (Node''usages-1 node)]
                (SnippetTemplate''propagateStamp-2 this, usage)
            )
        )
        nil
    )

    (§ method- #_"void" SnippetTemplate''updateStamps-3 [#_"SnippetTemplate" this, #_"ValueNode" replacee, #_"UnmodifiableEconomicMap<Node, Node>" duplicates]
        (doseq [#_"ValueNode" node (:placeholderStampedNodes this)]
            (let [
                #_"ValueNode" dup (get duplicates node)
                #_"Stamp" replaceeStamp (:stamp replacee)
            ]
                (if (instance? Placeholder node)
                    (Placeholder''makeReplacement-2 dup, replaceeStamp)
                    (§ ass! dup (ValueNode''setStamp-2 dup, replaceeStamp))
                )
            )
        )
        (doseq [#_"ParameterNode" paramNode (Graph''getNodes-2 (:snippet this), ParameterNode'TYPE)]
            (doseq [#_"Node" usage (Node''usages-1 paramNode)]
                (SnippetTemplate''propagateStamp-2 this, (get duplicates usage))
            )
        )
        nil
    )

    ;;;
     ; Replaces a given floating node with this specialized snippet.
     ;
     ; @param replacee the node that will be replaced
     ; @param replacer object that replaces the usages of {@code replacee}
     ; @param lowerer lowering tool used to insert the snippet into the control-flow
     ; @param args the arguments to be bound to the flattened positional parameters of the snippet
     ;;
    (§ method! #_"void" SnippetTemplate''instantiate-5 [#_"SnippetTemplate" this, #_"FloatingNode" replacee, #_"UsageReplacer" replacer, #_"LoweringTool" lowerer, #_"Arguments" args]
        ;; inline the snippet nodes replacing parameters with the given args in the process
        (let [
            #_"StartNode" entryPointNode (:start (:snippet this))
            #_"FixedNode" firstCFGNode (:next entryPointNode)
            #_"Graph" replaceeGraph (:graph replacee)
            #_"EconomicMap<Node, Node>" replacements (SnippetTemplate''bind-3 this, replaceeGraph, args)
            _ (#_"EconomicMap" .put replacements, entryPointNode, (:guardAnchor lowerer))
            #_"UnmodifiableEconomicMap<Node, Node>" duplicates (SnippetTemplate''inlineSnippet-4 this, replacee, replaceeGraph, replacements)
            #_"FixedWithNextNode" lastFixedNode (:lastFixedNode lowerer)
            #_"FixedNode" next (:next lastFixedNode)
            _ (§ ass! lastFixedNode (FixedWithNextNode''setNext-2 lastFixedNode, nil))
            #_"FixedNode" firstCFGNodeDuplicate (get duplicates firstCFGNode)
        ]
            (Graph''addAfterFixed-3 replaceeGraph, lastFixedNode, firstCFGNodeDuplicate)

            (SnippetTemplate''rewireFrameStates-3 this, replacee, duplicates)
            (SnippetTemplate''updateStamps-3 this, replacee, duplicates)

            (SnippetTemplate''rewireMemoryGraph-3 this, replacee, duplicates)

            ;; replace all usages of the replacee with the value returned by the snippet
            (let [
                #_"ReturnNode" returnDuplicate (get duplicates (:returnNode this))
            ]
                (UsageReplacer''replace-3 replacer, replacee, (:result returnDuplicate))

                (when (Node''isAlive-1 returnDuplicate)
                    (§ ass! returnDuplicate (Node''replaceAndDelete-2 returnDuplicate, next))
                )
            )
        )
        nil
    )

    ;;;
     ; Replaces a given floating node with this specialized snippet.
     ;
     ; This snippet must be pure data-flow.
     ;
     ; @param replacee the node that will be replaced
     ; @param replacer object that replaces the usages of {@code replacee}
     ; @param args the arguments to be bound to the flattened positional parameters of the snippet
     ;;
    (§ method! #_"void" SnippetTemplate''instantiate-4 [#_"SnippetTemplate" this, #_"FloatingNode" replacee, #_"UsageReplacer" replacer, #_"Arguments" args]
        ;; inline the snippet nodes replacing parameters with the given args in the process
        (let [
            #_"StartNode" start (:start (:snippet this))
            #_"EconomicMap<Node, Node>" replacements (SnippetTemplate''bind-3 this, (:graph replacee), args)
            #_"MemoryAnchorNode" anchorDuplicate
                (when (some? (:memoryAnchor this))
                    (let [
                        anchorDuplicate (Graph''add-2 (:graph replacee), (MemoryAnchorNode'new-0))
                    ]
                        (#_"EconomicMap" .put replacements, (:memoryAnchor this), anchorDuplicate)
                        anchorDuplicate
                    )
                )
            #_"List<Node>" floatingNodes (ArrayList.)
            _
                (doseq [#_"Node" n (:nodes this)]
                    (when-not (any = n start (:returnNode this))
                        (#_"List" .add floatingNodes, n)
                    )
                )
            #_"UnmodifiableEconomicMap<Node, Node>" duplicates (SnippetTemplate''inlineSnippet-4 this, replacee, (:graph replacee), replacements)
        ]
            (SnippetTemplate''rewireFrameStates-3 this, replacee, duplicates)
            (SnippetTemplate''updateStamps-3 this, replacee, duplicates)
            (SnippetTemplate''rewireMemoryGraph-3 this, replacee, duplicates)
            ;; replace all usages of the replacee with the value returned by the snippet
            (UsageReplacer''replace-3 replacer, replacee, (get duplicates (:result (:returnNode this))))
        )
        nil
    )

    (§ method! #_"void" SnippetTemplate''rewireFrameStates-3 [#_"SnippetTemplate" this, #_"ValueNode" replacee, #_"UnmodifiableEconomicMap<Node, Node>" duplicates]
        (when (instance? StateSplit replacee)
            (doseq [#_"StateSplit" sideEffectNode (:sideEffectNodes this)]
                (StateSplit''setStateAfter-2 (get duplicates sideEffectNode), (StateSplit''stateAfter-1 replacee))
            )
        )
        nil
    )

    #_unused
    (§ method! #_"SnippetTemplate" SnippetTemplate''setMayRemoveLocation-2 [#_"SnippetTemplate" this, #_"boolean" mayRemoveLocation]
        (assoc this :mayRemoveLocation mayRemoveLocation)
    )
)

;;;
 ; Holds the ResolvedJavaMethod of the snippet, together with some information about the
 ; method that needs to be computed only once. The SnippetInfo should be
 ; created once per snippet and then cached.
 ;
 ; @anno SnippetTemplate.SnippetInfo
 ;;
(class-ns SnippetInfo
    (§ final #_"ResolvedJavaMethod" :method nil)
    (§ final #_"LocationIdentity[]" :privateLocations nil)

    (§ abstract #_"Lazy" SnippetInfo''lazy-1 [#_"SnippetInfo" this])

    (§ defn #_"SnippetInfo" SnippetInfo'new-2 [#_"ResolvedJavaMethod" method, #_"LocationIdentity[]" privateLocations]
        (let [
            #_"SnippetInfo" this (Object.)
            this (assoc this :method method)
            this (assoc this :privateLocations privateLocations)
        ]
            this
        )
    )

    #_unused
    (§ method #_"ResolvedJavaMethod" SnippetInfo''getMethod-1 [#_"SnippetInfo" this]
        (:method this)
    )

    (§ method! #_"int" SnippetInfo''getParameterCount-1 [#_"SnippetInfo" this]
        (count (:constantParameters (SnippetInfo''lazy-1 this)))
    )

    (§ method! #_"boolean" SnippetInfo''isConstantParameter-2 [#_"SnippetInfo" this, #_"int" paramIdx]
        (nth (:constantParameters (SnippetInfo''lazy-1 this)) paramIdx)
    )

    (§ method! #_"boolean" SnippetInfo''isVarargsParameter-2 [#_"SnippetInfo" this, #_"int" paramIdx]
        (nth (:varargsParameters (SnippetInfo''lazy-1 this)) paramIdx)
    )

    (§ method! #_"boolean" SnippetInfo''isNonNullParameter-2 [#_"SnippetInfo" this, #_"int" paramIdx]
        (nth (:nonNullParameters (SnippetInfo''lazy-1 this)) paramIdx)
    )
)

;;;
 ; Lazily constructed parts of SnippetInfo.
 ;
 ; @anno SnippetTemplate.SnippetInfo.Lazy
 ;;
(final-ns Lazy
    (§ final #_"boolean[]" :constantParameters nil)
    (§ final #_"boolean[]" :varargsParameters nil)
    (§ final #_"boolean[]" :nonNullParameters nil)

    (§ defn #_"Lazy" Lazy'new-1 [#_"ResolvedJavaMethod" method]
        (let [
            #_"int" n (#_"Signature" .getParameterCount (#_"ResolvedJavaMethod" .getSignature method), false)
            #_"Lazy" this (Object.)
            this (assoc this :constantParameters (boolean-array n))
            this (assoc this :varargsParameters (boolean-array n))
            this (assoc this :nonNullParameters (boolean-array n))
            _
                (dotimes [#_"int" i n]
                    (aset (:constantParameters this) i (some? (#_"ResolvedJavaMethod" .getParameterAnnotation method, ConstantParameter, i)))
                    (aset (:varargsParameters this) i (some? (#_"ResolvedJavaMethod" .getParameterAnnotation method, VarargsParameter, i)))
                    (aset (:nonNullParameters this) i (some? (#_"ResolvedJavaMethod" .getParameterAnnotation method, NonNullParameter, i)))
                )
        ]
            this
        )
    )
)

;;;
 ; @anno SnippetTemplate.LazySnippetInfo
 ;;
(final-ns LazySnippetInfo (§ extends SnippetInfo)
    (§ final #_"AtomicReference<Lazy>" :lazy (AtomicReference. nil))

    (§ defn #_"LazySnippetInfo" LazySnippetInfo'new-2 [#_"ResolvedJavaMethod" method, #_"LocationIdentity[]" privateLocations]
        (SnippetInfo'new-2 method, privateLocations)
    )

    #_unused
    (§ override! #_"Lazy" LazySnippetInfo''lazy-1 [#_"LazySnippetInfo" this]
        (when (nil? (#_"AtomicReference" .get (:lazy this)))
            (#_"AtomicReference" .compareAndSet (:lazy this), nil, (Lazy'new-1 (:method this)))
        )
        (#_"AtomicReference" .get (:lazy this))
    )
)

;;;
 ; @anno SnippetTemplate.EagerSnippetInfo
 ;;
(final-ns EagerSnippetInfo (§ extends SnippetInfo)
    (§ final #_"Lazy" :lazy nil)

    (§ defn #_"EagerSnippetInfo" EagerSnippetInfo'new-2 [#_"ResolvedJavaMethod" method, #_"LocationIdentity[]" privateLocations]
        (let [
            #_"EagerSnippetInfo" this (SnippetInfo'new-2 method, privateLocations)
            this (assoc this :lazy (Lazy'new-1 method))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Lazy" EagerSnippetInfo''lazy-1 [#_"EagerSnippetInfo" this]
        (:lazy this)
    )
)

;;;
 ; Values that are bound to the snippet method parameters. The methods #add,
 ; #addConst, and #addVarargs must be called in the same order as in the signature of
 ; the snippet method. The parameter name is passed to the add methods for assertion checking, i.e.
 ; to enforce that the order matches. Which method needs to be called depends on the annotation of the
 ; snippet method parameter:
 ;
 ; Use #add for a parameter without an annotation. The value is bound when the
 ; SnippetTemplate is {@link SnippetTemplate#instantiate instantiated}.
 ;
 ; Use #addConst for a parameter annotated with ConstantParameter.
 ; The value is bound when the SnippetTemplate is {@link SnippetTemplate#SnippetTemplate created}.
 ;
 ; Use #addVarargs for an array parameter annotated with VarargsParameter.
 ; A separate SnippetTemplate is {@link SnippetTemplate#SnippetTemplate created} for every distinct
 ; array length. The actual values are bound when the SnippetTemplate is
 ; {@link SnippetTemplate#instantiate instantiated}.
 ;
 ; @anno SnippetTemplate.Arguments
 ;;
(final-ns Arguments
    (§ final #_"SnippetInfo" :info nil)
    (§ final #_"CacheKey" :cacheKey nil)
    (§ final #_"Object[]" :values nil)
    (§ final #_"Stamp[]" :constStamps nil)

    (§ mutable #_"int" :nextParamIdx 0)

    (§ defn #_"Arguments" Arguments'new-3 [#_"SnippetInfo" info, #_"GuardsStage" guardsStage, #_"LoweringStage" loweringStage]
        (let [
            #_"Arguments" this (Object.)
            this (assoc this :info info)
            this (assoc this :cacheKey (CacheKey'new-3 info, guardsStage, loweringStage))
            this (assoc this :values (make-array Object (SnippetInfo''getParameterCount-1 info)))
            this (assoc this :constStamps (make-array Stamp (SnippetInfo''getParameterCount-1 info)))
        ]
            this
        )
    )

    (§ method! #_"Arguments" Arguments''add-3 [#_"Arguments" this, #_"String" name, #_"Object" value]
        (aset (:values this) (:nextParamIdx this) value)
        (§ ass this (update this :nextParamIdx inc))
        this
    )

    (§ method! #_"Arguments" Arguments''addConst-3 [#_"Arguments" this, #_"String" name, #_"Object" value]
        (Arguments''addConst-4 this, name, value, nil)
    )

    (§ method! #_"Arguments" Arguments''addConst-4 [#_"Arguments" this, #_"String" name, #_"Object" value, #_"Stamp" stamp]
        (aset (:values this) (:nextParamIdx this) value)
        (aset (:constStamps this) (:nextParamIdx this) stamp)
        (CacheKey''setParam-3 (:cacheKey this), (:nextParamIdx this), value)
        (§ ass this (update this :nextParamIdx inc))
        this
    )

    (§ method! #_"Arguments" Arguments''addVarargs-5 [#_"Arguments" this, #_"String" name, #_"Class" componentType, #_"Stamp" argStamp, #_"Object" value]
        (let [
            #_"Varargs" varargs (Varargs'new-3 componentType, argStamp, value)
        ]
            (aset (:values this) (:nextParamIdx this) varargs)
            ;; a separate template is necessary for every distinct array length
            (CacheKey''setParam-3 (:cacheKey this), (:nextParamIdx this), (:length varargs))
            (§ ass this (update this :nextParamIdx inc))
            this
        )
    )
)

;;;
 ; Wrapper for the prototype value of a varargs parameter.
 ;
 ; @anno SnippetTemplate.Varargs
 ;;
(final-ns Varargs
    (§ final #_"Class" :componentType nil)
    (§ final #_"Stamp" :stamp nil)
    (§ final #_"Object" :value nil)
    (§ final #_"int" :length 0)

    (§ defn #_"Varargs" Varargs'new-3 [#_"Class" componentType, #_"Stamp" stamp, #_"Object" value]
        (let [
            #_"Varargs" this (Object.)
            this (assoc this :componentType componentType)
            this (assoc this :stamp stamp)
            this (assoc this :value value)
        ]
            (if (instance? List value)
                (§ ass this (assoc this :length (count value)))
                (§ ass this (assoc this :length (Array/getLength value)))
            )
            this
        )
    )
)

;;;
 ; @anno SnippetTemplate.VarargsPlaceholderNode
 ;;
(final-ns VarargsPlaceholderNode (§ extends FloatingNode) (§ implements ArrayLengthProvider)
    (§ def #_"NodeClass<VarargsPlaceholderNode>" VarargsPlaceholderNode'TYPE (NodeClass'create-1 VarargsPlaceholderNode))

    (§ final #_"Varargs" :varargs nil)

    (§ defn #_"VarargsPlaceholderNode" VarargsPlaceholderNode'new-1 [#_"Varargs" varargs]
        (let [
            #_"VarargsPlaceholderNode" this (FloatingNode'new-2 VarargsPlaceholderNode'TYPE, (StampFactory'objectNonNull-1 (TypeReference'createExactTrusted-1 (#_"ResolvedJavaType" .getArrayClass (#_"MetaAccessProvider" .lookupJavaType HotSpot'metaAccess, (:componentType varargs))))))
            this (assoc this :varargs varargs)
        ]
            this
        )
    )

    (§ override! #_"ValueNode" ArrayLengthProvider''length-1 [#_"VarargsPlaceholderNode" this]
        (ConstantNode'forInt-1 (:length (:varargs this)))
    )
)

;;;
 ; @anno SnippetTemplate.CacheKey
 ;;
(final-ns CacheKey
    (§ final #_"ResolvedJavaMethod" :method nil)
    (§ final #_"Object[]" :values nil)
    (§ final #_"GuardsStage" :guardsStage nil)
    (§ final #_"LoweringStage" :loweringStage nil)

    (§ defn #_"CacheKey" CacheKey'new-3 [#_"SnippetInfo" info, #_"GuardsStage" guardsStage, #_"LoweringStage" loweringStage]
        (let [
            #_"CacheKey" this (Object.)
            this (assoc this :method (:method info))
            this (assoc this :guardsStage guardsStage)
            this (assoc this :loweringStage loweringStage)
            this (assoc this :values (make-array Object (SnippetInfo''getParameterCount-1 info)))
        ]
            this
        )
    )

    (§ method! #_"void" CacheKey''setParam-3 [#_"CacheKey" this, #_"int" paramIdx, #_"Object" value]
        (aset (:values this) paramIdx value)
        nil
    )
)

;;;
 ; Base class for snippet classes. It provides a cache for SnippetTemplates.
 ;
 ; @anno SnippetTemplate.AbstractTemplates
 ;;
(class-ns AbstractTemplates
    (§ defn #_"AbstractTemplates" AbstractTemplates'new-0 []
        (Object.)
    )

    (§ defn #_"Method" AbstractTemplates'findMethod-3 [#_"Class<? extends Snippets>" declaringClass, #_"String" methodName]
        (loop-when [#_"ISeq" s (seq (#_"Class" .getDeclaredMethods declaringClass))] (some? s)
            (let [
                #_"Method" method (first s)
            ]
                (if (= (#_"Method" .getName method) methodName) method (recur (next s)))
            )
        )
    )

    ;;;
     ; Finds the unique method in {@code declaringClass} named {@code methodName} annotated by Snippet
     ; and returns a SnippetInfo value describing it. There must be exactly one snippet method in
     ; {@code declaringClass}.
     ;;
    (§ method #_"SnippetInfo" AbstractTemplates''snippet-4* [#_"AbstractTemplates" this, #_"Class<? extends Snippets>" declaringClass, #_"String" methodName, #_"LocationIdentity..." initialPrivateLocations]
        (let [
            #_"Method" method (AbstractTemplates'findMethod-3 declaringClass, methodName)
            #_"ResolvedJavaMethod" javaMethod (#_"MetaAccessProvider" .lookupJavaMethod HotSpot'metaAccess, method)
        ]
            (if GraalOptions'eagerSnippets
                (EagerSnippetInfo'new-2 javaMethod, initialPrivateLocations)
                (LazySnippetInfo'new-2 javaMethod, initialPrivateLocations)
            )
        )
    )
)

;;;
 ; Logic for replacing a snippet-lowered node at its usages with the return value of the
 ; snippet. An alternative to the {@linkplain SnippetTemplate#DEFAULT_REPLACER default}
 ; replacement logic can be used to handle mismatches between the stamp of the node being
 ; lowered and the stamp of the snippet's return value.
 ;
 ; @anno SnippetTemplate.UsageReplacer
 ;;
(§ interface UsageReplacer
    ;;;
     ; Replaces all usages of {@code oldNode} with direct or indirect usages of {@code newNode}.
     ;;
    (§ abstract #_"void" UsageReplacer''replace-3 [#_"UsageReplacer" this, #_"ValueNode" oldNode, #_"ValueNode" newNode])
)

;;;
 ; @anno SnippetTemplate.MemoryInputMap
 ;;
(class-ns MemoryInputMap (§ implements MemoryMap)
    (§ final #_"LocationIdentity" :locationIdentity nil)
    (§ final #_"MemoryNode" :lastLocationAccess nil)

    (§ defn #_"MemoryInputMap" MemoryInputMap'new-1 [#_"ValueNode" replacee]
        (let [
            #_"MemoryInputMap" this (Object.)
        ]
            (if (instance? MemoryAccess replacee)
                (do
                    (§ ass this (assoc this :locationIdentity (MemoryAccess''getLocationIdentity-1 replacee)))
                    (§ ass this (assoc this :lastLocationAccess (:lastLocationAccess replacee)))
                )
                (do
                    (§ ass this (assoc this :locationIdentity nil))
                    (§ ass this (assoc this :lastLocationAccess nil))
                )
            )
            this
        )
    )

    (§ override #_"MemoryNode" MemoryInputMap''getLastLocationAccess-2 [#_"MemoryInputMap" this, #_"LocationIdentity" location]
        (when (and (some? (:locationIdentity this)) (= (:locationIdentity this) location))
            (:lastLocationAccess this)
        )
    )

    #_unused
    (§ override #_"Collection<LocationIdentity>" MemoryInputMap''getLocations-1 [#_"MemoryInputMap" this]
        (if (some? (:locationIdentity this)) (Collections/singleton (:locationIdentity this)) (Collections/emptySet))
    )
)

;;;
 ; @anno SnippetTemplate.MemoryOutputMap
 ;;
(final-ns MemoryOutputMap (§ extends MemoryInputMap)
    (§ final #_"SnippetTemplate" :template nil)

    (§ final #_"UnmodifiableEconomicMap<Node, Node>" :duplicates nil)

    (§ defn #_"MemoryOutputMap" MemoryOutputMap'new-3 [#_"SnippetTemplate" template, #_"ValueNode" replacee, #_"UnmodifiableEconomicMap<Node, Node>" duplicates]
        (let [
            #_"MemoryOutputMap" this (MemoryInputMap'new-1 replacee)
            this (assoc this :template template)
            this (assoc this :duplicates duplicates)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"MemoryNode" MemoryOutputMap''getLastLocationAccess-2 [#_"MemoryOutputMap" this, #_"LocationIdentity" locationIdentity]
        (let [
            #_"MemoryNode" lastLocationAccess (MemoryMapNode''getLastLocationAccess-2 (:memoryMap (:returnNode (:template this))), locationIdentity)
        ]
            (if (= lastLocationAccess (:memoryAnchor (:template this)))
                (MemoryInputMap''getLastLocationAccess-2 (§ super ), locationIdentity)
                (get (:duplicates this) lastLocationAccess)
            )
        )
    )

    #_unused
    (§ override! #_"Collection<LocationIdentity>" MemoryOutputMap''getLocations-1 [#_"MemoryOutputMap" this]
        (MemoryMapNode''getLocations-1 (:memoryMap (:returnNode (:template this))))
    )
)

;;;
 ; This class encapsulated the materialized state of an escape analyzed object.
 ;;
(final-ns MaterializedObjectState (§ extends EscapeObjectState)
    (§ def #_"NodeClass<MaterializedObjectState>" MaterializedObjectState'TYPE (NodeClass'create-1 MaterializedObjectState))

    ; @Input
    (§ mutable #_"ValueNode" :materializedValue nil)

    (§ defn #_"MaterializedObjectState" MaterializedObjectState'new-2 [#_"VirtualObjectNode" object, #_"ValueNode" materializedValue]
        (let [
            #_"MaterializedObjectState" this (EscapeObjectState'new-2 MaterializedObjectState'TYPE, object)
            this (assoc this :materializedValue materializedValue)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"MaterializedObjectState" MaterializedObjectState''duplicateWithVirtualState-1 [#_"MaterializedObjectState" this]
        (Graph''add-2 (:graph this), (MaterializedObjectState'new-2 (:object this), (:materializedValue this)))
    )

    #_unused
    (§ override! #_"void" MaterializedObjectState''applyToNonVirtual-2 [#_"MaterializedObjectState" this, #_"NodeClosure<? super ValueNode>" closure]
        (NodeClosure''apply-3 closure, this, (:materializedValue this))
        nil
    )
)

;;;
 ; This class encapsulated the virtual state of an escape analyzed object.
 ;;
(final-ns VirtualObjectState (§ extends EscapeObjectState)
    (§ def #_"NodeClass<VirtualObjectState>" VirtualObjectState'TYPE (NodeClass'create-1 VirtualObjectState))

    ; @OptionalInput
    (§ mutable #_"NodeInputList<ValueNode>" :values nil)

    (§ defn #_"VirtualObjectState" VirtualObjectState'new-2 [#_"VirtualObjectNode" object, #_"ValueNode[]" values]
        (let [
            #_"VirtualObjectState" this (EscapeObjectState'new-2 VirtualObjectState'TYPE, object)
            this (assoc this :values (NodeInputList'new-2 this, values))
        ]
            this
        )
    )

    (§ defn #_"VirtualObjectState" VirtualObjectState'new-2 [#_"VirtualObjectNode" object, #_"List<ValueNode>" values]
        (let [
            #_"VirtualObjectState" this (EscapeObjectState'new-2 VirtualObjectState'TYPE, object)
            this (assoc this :values (NodeInputList'new-2 this, values))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"VirtualObjectState" VirtualObjectState''duplicateWithVirtualState-1 [#_"VirtualObjectState" this]
        (Graph''add-2 (:graph this), (VirtualObjectState'new-2 (:object this), (:values this)))
    )

    #_unused
    (§ override! #_"void" VirtualObjectState''applyToNonVirtual-2 [#_"VirtualObjectState" this, #_"NodeClosure<? super ValueNode>" closure]
        (doseq [#_"ValueNode" value (:values this)]
            (when (some? value)
                (NodeClosure''apply-3 closure, this, value)
            )
        )
        nil
    )
)

(final-ns EarlyReadEliminationPhase (§ extends EffectsPhase #_"<PhaseContext>")
    (§ defn #_"EarlyReadEliminationPhase" EarlyReadEliminationPhase'new-1 [#_"CanonicalizerPhase" canonicalizer]
        (EffectsPhase'new-3 1, canonicalizer, true)
    )

    #_unused
    (§ override! #_"Closure" EarlyReadEliminationPhase''createEffectsClosure-4 [#_"EarlyReadEliminationPhase" this, #_"PhaseContext" context, #_"ScheduleResult" schedule, #_"ControlFlowGraph" cfg]
        (ReadEliminationClosure'new-2 cfg, true)
    )

    #_unused
    (§ override! #_"void" EarlyReadEliminationPhase''run-3 [#_"EarlyReadEliminationPhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (EffectsPhase''runAnalysis-3 this, graph, context)
        nil
    )
)

;;;
 ; An EffectList can be used to maintain a list of Effects and backtrack
 ; to a previous state by truncating the list.
 ;;
(class-ns EffectList (§ implements Iterable #_"<Effect>")
    (§ def- #_"Effect[]" EffectList'EMPTY_ARRAY (make-array Effect 0))
    (§ def- #_"String[]" EffectList'EMPTY_STRING_ARRAY (make-array String 0))

    (§ mutable #_"Effect[]" :effects EffectList'EMPTY_ARRAY)
    (§ mutable #_"int" :size 0)

    (§ defn #_"EffectList" EffectList'new-0 []
        (Object.)
    )

    (§ method- #_"EffectList" EffectList''enlarge-2 [#_"EffectList" this, #_"int" elements]
        (let [
            #_"int" n (count (:effects this))
        ]
            (when (< n (+ (:size this) elements)) => this
                (let [
                    n (loop-when-recur n (< n (+ (:size this) elements)) (max (<< n 1) 4) => n)
                ]
                    (assoc this :effects (Arrays/copyOf (:effects this), n))
                )
            )
        )
    )

    (§ method #_"void" EffectList''add-3 [#_"EffectList" this, #_"String" name, #_"Effect" effect]
        (§ ass! this (EffectList''enlarge-2 this, 1))
        (aset (:effects this) (:size this) effect)
        (§ ass! this (update this :size inc))
        nil
    )

    (§ method #_"void" EffectList''addAll-2 [#_"EffectList" this, #_"EffectList" list]
        (§ ass! this (EffectList''enlarge-2 this, (:size list)))
        (System/arraycopy (:effects list), 0, (:effects this), (:size this), (:size list))
        (§ ass! this (assoc this :size (+ (:size this) (:size list))))
        nil
    )

    (§ method! #_"EffectList" EffectList''insertAll-3 [#_"EffectList" this, #_"EffectList" list, #_"int" position]
        (let [
            this (EffectList''enlarge-2 this, (:size list))
            _ (System/arraycopy (:effects this), position, (:effects this), (+ position (:size list)), (- (:size this) position))
            _ (System/arraycopy (:effects list), 0, (:effects this), position, (:size list))
            this (assoc this :size (+ (:size this) (:size list)))
        ]
            this
        )
    )

    #_unused
    (§ method! #_"int" EffectList''checkpoint-1 [#_"EffectList" this]
        (:size this)
    )

    (§ method #_"int" EffectList''size-1 [#_"EffectList" this]
        (:size this)
    )

    #_unused
    (§ method! #_"EffectList" EffectList''backtrack-2 [#_"EffectList" this, #_"int" checkpoint]
        (assoc this :size checkpoint)
    )

    (§ override #_"Iterator<Effect>" #_"Iterable" .iterator [#_"EffectList" this]
        (let [
            #_"EffectList" effectList this
        ]
            (§ reify #_"Iterator<Effect>" (Iterator.)
                (§ mutable #_"int" :index 0)
                (§ final #_"int" :listSize (:size effectList))

                (§ override! #_"boolean" #_"Iterator" .hasNext [#_"Iterator<Effect>" this]
                    (< (:index this) (:listSize this))
                )

                (§ override! #_"Effect" #_"Iterator" .next [#_"Iterator<Effect>" this]
                    (let [
                        _ (nth (:effects effectList) (:index this))
                    ]
                        (§ ass! this (update this :index inc))
                        _
                    )
                )
            )
        )
    )

    #_unused
    (§ method #_"Effect" EffectList''get-2 [#_"EffectList" this, #_"int" index]
        (when (<= (:size this) index)
            (throw (IndexOutOfBoundsException.))
        )
        (nth (:effects this) index)
    )

    (§ method #_"void" EffectList''clear-1 [#_"EffectList" this]
        (§ ass! this (assoc this :size 0))
        nil
    )

    (§ method #_"boolean" EffectList''isEmpty-1 [#_"EffectList" this]
        (zero? (:size this))
    )

    (§ method #_"void" EffectList''apply-4 [#_"EffectList" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes, #_"boolean" cfgKills]
        (dotimes [#_"int" i (EffectList''size-1 this)]
            (let [
                #_"Effect" effect (nth (:effects this) i)
            ]
                (when (= (Effect''isCfgKill-1 effect) cfgKills)
                    (Effect''apply-3 effect, graph, obsoleteNodes)
                )
            )
        )
        nil
    )
)

;;;
 ; @anno EffectList.Effect
 ;;
(§ interface Effect
    #_unused
    (§ default #_"boolean" Effect''isVisible-1 [#_"Effect" this]
        true
    )

    (§ default #_"boolean" Effect''isCfgKill-1 [#_"Effect" this]
        false
    )

    (§ default #_"void" Effect''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
        (Effect''apply-2 this, graph)
        nil
    )

    (§ abstract #_"void" Effect''apply-2 [#_"Effect" this, #_"Graph" graph])
)

(class-ns EffectsBlockState #_"<T extends EffectsBlockState<T>>"
    ;;;
     ; This flag specifies whether this block is unreachable, which can happen during analysis
     ; if conditions turn constant or nodes canonicalize to cfg sinks.
     ;;
    (§ mutable #_"boolean" :dead false)

    (§ defn #_"EffectsBlockState" EffectsBlockState'new-0 []
        (let [
            #_"EffectsBlockState" this (Object.)
        ]
            ;; emtpy
            this
        )
    )

    (§ defn #_"EffectsBlockState" EffectsBlockState'new-1 [#_"EffectsBlockState<T>" other]
        (let [
            #_"EffectsBlockState" this (Object.)
            this (assoc this :dead (:dead other))
        ]
            this
        )
    )

    (§ abstract #_"boolean" EffectsBlockState''equivalentTo-2 [#_"EffectsBlockState<T extends EffectsBlockState<T>>" this, #_"T" other])

    (§ method! #_"boolean" EffectsBlockState''isDead-1 [#_"EffectsBlockState<T extends EffectsBlockState<T>>" this]
        (:dead this)
    )

    (§ method! #_"EffectsBlockState<T extends EffectsBlockState<T>>" EffectsBlockState''markAsDead-1 [#_"EffectsBlockState<T extends EffectsBlockState<T>>" this]
        (assoc this :dead true)
    )

    ;;;
     ; Returns true if every value in subMap is also present in the superMap (according to "equals" semantics).
     ;;
    (§ defn #_"<K, V> boolean" EffectsBlockState'isSubMapOf-2 [#_"EconomicMap<K, V>" superMap, #_"EconomicMap<K, V>" subMap]
        (or (= superMap subMap)
            (loop-when [#_"UnmodifiableMapCursor<K, V>" cursor (#_"EconomicMap" .getEntries subMap)] (#_"UnmodifiableMapCursor" .advance cursor) => true
                (let [
                    #_"K" key (#_"UnmodifiableMapCursor" .getKey cursor)
                    #_"V" value (#_"UnmodifiableMapCursor" .getValue cursor)
                    #_"V" otherValue (get superMap key)
                ]
                    (and (or (= otherValue value) (= value otherValue)) ;; %% oops!
                        (recur cursor)
                    )
                )
            )
        )
    )

    ;;;
     ; Modifies target so that only entries that have corresponding entries in source remain.
     ;;
    #_unused
    (§ defn #_"<U, V> void" EffectsBlockState'meetMaps-2 [#_"Map<U, V>" target, #_"Map<U, V>" source]
        (let [
            #_"Iterator<Map$Entry<U, V>>" it (#_"Set" .iterator (#_"Map" .entrySet target))
        ]
            (while (#_"Iterator" .hasNext it)
                (when-not (#_"Map" .containsKey source, (#_"Map$Entry" .getKey (#_"Iterator" .next it)))
                    (#_"Iterator" .remove it)
                )
            )
        )
        nil
    )
)

(class-ns EffectsClosure #_"<BlockT extends EffectsBlockState<BlockT>>" (§ extends Closure #_"<BlockT>")
    (§ final #_"ControlFlowGraph" :cfg nil)
    (§ final #_"ScheduleResult" :schedule nil)

    ;;;
     ; If a node has an alias, this means that it was replaced with another node during analysis.
     ; Nodes can be replaced by normal ("scalar") nodes, e.g. a LoadIndexedNode with a ConstantNode,
     ; or by virtual nodes, e.g. a NewInstanceNode with a VirtualInstanceNode. A node was replaced
     ; with a virtual value iff the alias is a subclass of VirtualObjectNode.
     ;
     ; This alias map exists only once and is not part of the block state, so that during iterative
     ; loop processing the alias of a node may be changed to another value.
     ;;
    (§ final #_"NodeMap<ValueNode>" :aliases nil)

    ;;;
     ; This set allows for a quick check whether a node has inputs that were replaced with "scalar" values.
     ;;
    (§ final #_"NodeBitMap" :hasScalarReplacedInputs nil)

    ;; TODO if it was possible to introduce your own subclasses of Block and Loop, these maps would
    ;; not be necessary. We could merge the GraphEffectsList logic into them.

    ;;;
     ; The effects accumulated during analysis of nodes. They may be cleared and re-filled during
     ; iterative loop processing.
     ;;
    (§ final #_"BlockMap<GraphEffectList>" :blockEffects nil)

    ;;;
     ; Effects that can only be applied after the effects from within the loop have been applied and
     ; that must be applied before any effect from after the loop is applied. E.g., updating phis.
     ;;
    (§ final #_"EconomicMap<Loop, GraphEffectList>" :loopMergeEffects (EconomicMap/create Equivalence/IDENTITY))

    ;;;
     ; The entry state of loops is needed when loop proxies are processed.
     ;;
    (§ final #_"EconomicMap<LoopBeginNode, BlockT>" :loopEntryStates (EconomicMap/create Equivalence/IDENTITY))

    ;; Intended to be used by read-eliminating phases based on the effects phase.
    (§ final #_"EconomicMap<Loop, LoopKillCache>" :loopLocationKillCache (EconomicMap/create Equivalence/IDENTITY))

    (§ mutable #_"boolean" :changed? false)

    (§ defn #_"EffectsClosure" EffectsClosure'new-2 [#_"ScheduleResult" schedule, #_"ControlFlowGraph" cfg]
        (let [
            #_"EffectsClosure" this (Closure'new-0)
            this (assoc this :schedule schedule)
            this (assoc this :cfg cfg)
            this (assoc this :aliases (NodeMap'new-1 (:graph cfg)))
            this (assoc this :hasScalarReplacedInputs (NodeBitMap'new-1 (:graph cfg)))
            this (assoc this :blockEffects (BlockMap'new-1 cfg))
        ]
            (doseq [#_"Block" block (:reversePostOrder cfg)]
                (BlockMap''put-3 (:blockEffects this), block, (GraphEffectList'new-0))
            )
            this
        )
    )

    #_unused
    (§ override #_"boolean" EffectsClosure''needsApplyEffects-1 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this]
        true
    )

    #_unused
    (§ override #_"void" EffectsClosure''applyEffects-1 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this]
        (let [
            #_"Graph" graph (:graph (:cfg this))
            #_"ArrayList<Node>" obsoleteNodes (ArrayList.)
            #_"ArrayList<GraphEffectList>" effectList (ArrayList.)
            #_"EffectsClosure<BlockT>" effectsClosure this
            ;; Effects are applied during a ordered iteration over the blocks to apply them in the correct
            ;; order, e.g. apply the effect that adds a node to the graph before the node is used.
            #_"BlockIteratorClosure<Void>" closure
                (§ reify #_"BlockIteratorClosure<Void>" (BlockIteratorClosure'new-0)
                    (§ override! #_"Void" BlockIteratorClosure''getInitialState-1 [#_"BlockIteratorClosure<Void>" this]
                        nil
                    )

                    (§ method- #_"void" BlockIteratorClosure''apply-2 [#_"BlockIteratorClosure<Void>" this, #_"GraphEffectList" effects]
                        (when (and (some? effects) (not (EffectList''isEmpty-1 effects)))
                            (#_"ArrayList" .add effectList, effects)
                        )
                        nil
                    )

                    (§ override! #_"Void" BlockIteratorClosure''processBlock-3 [#_"BlockIteratorClosure<Void>" this, #_"Block" block, #_"Void" currentState]
                        (BlockIteratorClosure''apply-2 this, (BlockMap''get-2 (:blockEffects effectsClosure), block))
                        currentState
                    )

                    (§ override! #_"Void" BlockIteratorClosure''merge-3 [#_"BlockIteratorClosure<Void>" this, #_"Block" merge, #_"List<Void>" states]
                        nil
                    )

                    (§ override! #_"Void" BlockIteratorClosure''cloneState-2 [#_"BlockIteratorClosure<Void>" this, #_"Void" oldState]
                        oldState
                    )

                    (§ override! #_"List<Void>" BlockIteratorClosure''processLoop-3 [#_"BlockIteratorClosure<Void>" this, #_"Loop" loop, #_"Void" initialState]
                        (let [
                            #_"BlockLoopInfo<Void>" info (ReentrantBlockIterator'processLoop-3 this, loop, initialState)
                        ]
                            (BlockIteratorClosure''apply-2 this, (get (:loopMergeEffects effectsClosure) loop))
                            (:exitStates info)
                        )
                    )
                )
        ]
            (ReentrantBlockIterator'apply-2 closure, (ControlFlowGraph''getStartBlock-1 (:cfg this)))

            (doseq [#_"GraphEffectList" effects effectList]
                (EffectList''apply-4 effects, graph, obsoleteNodes, false)
            )
            ;; Effects that modify the cfg (e.g. removing a branch for an if that got a constant condition)
            ;; need to be performed after all other effects, because they change phi value indexes.
            (doseq [#_"GraphEffectList" effects effectList]
                (EffectList''apply-4 effects, graph, obsoleteNodes, true)
            )
            (doseq [#_"Node" node obsoleteNodes]
                (when (and (Node''isAlive-1 node) (Node''hasNoUsages-1 node))
                    (§ ass! node (Node''replaceAtUsages-2 node, nil))
                    (GraphUtil'killWithUnusedFloatingInputs-1 node)
                )
            )
        )
        nil
    )

    #_unused
    (§ override #_"BlockT" EffectsClosure''processBlock-3 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"Block" block, #_"BlockT" state]
        (when-not (EffectsBlockState''isDead-1 state) => state
            (let [
                #_"GraphEffectList" effects (BlockMap''get-2 (:blockEffects this), block)
            ]
                ;; If we enter an if branch that is known to be unreachable, we mark it as dead and
                ;; cease to do any more analysis on it. At merges, these dead branches will be ignored.
                (when (instance? IfNode (:predecessor (:beginNode block)))
                    (let [
                        #_"IfNode" ifNode (:predecessor (:beginNode block))
                        #_"Node" alias (EffectsClosure''getScalarAlias-2 this, (:condition ifNode))
                    ]
                        (when (and (instance? LogicConstantNode alias) (not (= (:value alias) (= (:beginNode block) (:trueSuccessor ifNode)))))
                            (§ ass! state (EffectsBlockState''markAsDead-1 state))
                            (GraphEffectList''killIfBranch-3 effects, ifNode, (:value alias))
                            (§ return state)
                        )
                    )
                )

                ;; a lastFixedNode is needed in case we want to insert fixed nodes
                (loop-when [#_"FixedWithNextNode" lastFixedNode nil #_"ISeq" s (seq (if (some? (:schedule this)) (BlockMap''get-2 (:blockToNodesMap (:schedule this)), block) (Block''getNodes-1 block)))] (some? s)
                    (let [
                        #_"Node" node (first s)
                    ]
                        ;; reset the aliases (may be non-nil due to iterative loop processing)
                        (NodeMap''set-3 (:aliases this), node, nil)
                        (when (instance? LoopExitNode node)
                            (loop-when-recur [#_"ISeq" s (seq (LoopExitNode''proxies-1 node))] (some? s) [(next s)]
                                (let [
                                    #_"ProxyNode" proxy (first s)
                                ]
                                    (NodeMap''set-3 (:aliases this), proxy, nil)
                                    (§ ass! this (assoc this :changed? (or (:changed? this) (and (EffectsClosure''processNode-5 this, proxy, state, effects, lastFixedNode) (EffectsClosure'isSignificantNode-1 node)))))
                                )
                            )
                            (EffectsClosure''processLoopExit-5 this, node, (get (:loopEntryStates this) (:loopBegin node)), state, (BlockMap''get-2 (:blockEffects this), block))
                        )
                        (§ ass! this (assoc this :changed? (or (:changed? this) (and (EffectsClosure''processNode-5 this, node, state, effects, lastFixedNode) (EffectsClosure'isSignificantNode-1 node)))))
                        (when-not (EffectsBlockState''isDead-1 state)
                            (recur (if (instance? FixedWithNextNode node) node lastFixedNode) (next s))
                        )
                    )
                )

                state
            )
        )
    )

    ;;;
     ; Changes to CommitAllocationNodes, AllocatedObjectNodes and BoxNodes
     ; are not considered to be "important". If only changes to those nodes are discovered during
     ; analysis, the effects need not be applied.
     ;;
    (§ defn- #_"boolean" EffectsClosure'isSignificantNode-1 [#_"Node" node]
        (not (or (instance? CommitAllocationNode node) (instance? AllocatedObjectNode node) (instance? BoxNode node)))
    )

    ;;;
     ; Collects the effects of virtualizing the given node.
     ;
     ; @return true if the effects include removing the node, false otherwise
     ;;
    (§ abstract #_"boolean" EffectsClosure''processNode-5 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"Node" node, #_"BlockT" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode])

    #_unused
    (§ override #_"BlockT" EffectsClosure''merge-3 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"Block" merge, #_"List<BlockT>" states]
        (let [
            #_"MergeProcessor<BlockT>" processor (EffectsClosure''createMergeProcessor-2 this, merge)
        ]
            (EffectsClosure''doMergeWithoutDead-3 this, processor, states)
            (EffectList''addAll-2 (BlockMap''get-2 (:blockEffects this), merge), (:mergeEffects processor))
            (EffectList''addAll-2 (BlockMap''get-2 (:blockEffects this), merge), (:afterMergeEffects processor))
            (:newState processor)
        )
    )

    #_unused
    (§ override! #_"List<BlockT>" EffectsClosure''processLoop-3 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"Loop" loop, #_"BlockT" initialState]
        (if (EffectsBlockState''isDead-1 initialState)
            (let [
                #_"ArrayList<BlockT>" states (ArrayList.)
            ]
                (dotimes [#_"int" i (count (:exits loop))]
                    (#_"ArrayList" .add states, initialState)
                )
                states
            )
            ;; Special case nested loops: To avoid an exponential runtime for nested loops we try to
            ;; only process them as little times as possible.
            ;;
            ;; In the first iteration of an outer most loop we go into the inner most loop(s). We run
            ;; the first iteration of the inner most loop and then, if necessary, a second iteration.
            ;;
            ;; We return from the recursion and finish the first iteration of the outermost loop. If we
            ;; have to do a second iteration in the outer most loop we go again into the inner most
            ;; loop(s) but this time we already know all states that are killed by the loop so inside
            ;; the loop we will only have those changes that propagate from the first iteration of the
            ;; outer most loop into the current loop. We strip the initial loop state for the inner most
            ;; loops and do the first iteration with the (possible) changes from outer loops. If there
            ;; are no changes we only have to do 1 iteration and are done.
            (let [
                #_"BlockT" initialStateRemovedKilledLocations (EffectsClosure''stripKilledLoopLocations-3 this, loop, (BlockIteratorClosure''cloneState-2 this, initialState))
                #_"BlockT" loopEntryState initialStateRemovedKilledLocations
                #_"BlockT" lastMergedState (BlockIteratorClosure''cloneState-2 this, initialStateRemovedKilledLocations)
            ]
                (EffectsClosure''processInitialLoopState-3 this, loop, lastMergedState)
                (let [
                    #_"MergeProcessor<BlockT>" mergeProcessor (EffectsClosure''createMergeProcessor-2 this, (:header loop))
                ]
                    ;; Iterative loop processing: we take the predecessor state as the loop's starting state,
                    ;; processing the loop contents, merge the states of all loop ends, and check whether the
                    ;; resulting state is equal to the starting state. If it is, the loop processing has
                    ;; finished, if not, another iteration is needed.
                    ;;
                    ;; This processing converges because the merge processing always makes the starting state
                    ;; more generic, e.g. adding phis instead of non-phi values.
                    (loop-when [#_"int" iteration 0] (< iteration 10) => (throw! (str "too many iterations at " loop))
                        (let [
                            #_"BlockLoopInfo<BlockT>" info (ReentrantBlockIterator'processLoop-3 this, loop, (BlockIteratorClosure''cloneState-2 this, lastMergedState))
                            #_"List<BlockT>" states (ArrayList.)
                        ]
                            (#_"ArrayList" .add states, initialStateRemovedKilledLocations)
                            (#_"List" .addAll states, (:endStates info))
                            (EffectsClosure''doMergeWithoutDead-3 this, mergeProcessor, states)

                            (if (EffectsBlockState''equivalentTo-2 (:newState mergeProcessor), lastMergedState)
                                (do
                                    (§ ass! (BlockMap''get-2 (:blockEffects this), (:header loop)) (EffectList''insertAll-3 (BlockMap''get-2 (:blockEffects this), (:header loop)), (:mergeEffects mergeProcessor), 0))
                                    (#_"EconomicMap" .put (:loopMergeEffects this), loop, (:afterMergeEffects mergeProcessor))
                                    (#_"EconomicMap" .put (:loopEntryStates this), (:beginNode (:header loop)), loopEntryState)
                                    (EffectsClosure''processKilledLoopLocations-4 this, loop, initialStateRemovedKilledLocations, (:newState mergeProcessor))
                                    (:exitStates info)
                                )
                                (do
                                    (§ ass lastMergedState (:newState mergeProcessor))
                                    (doseq [#_"Block" block (:blocks loop)]
                                        (GraphEffectList''clear-1 (BlockMap''get-2 (:blockEffects this), block))
                                    )
                                    (recur (inc iteration))
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method #_"BlockT" EffectsClosure''stripKilledLoopLocations-3 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"Loop" loop, #_"BlockT" initialState]
        initialState
    )

    (§ method #_"void" EffectsClosure''processKilledLoopLocations-4 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"Loop" loop, #_"BlockT" initialState, #_"BlockT" mergedStates]
        ;; nothing to do
        nil
    )

    (§ method #_"void" EffectsClosure''processInitialLoopState-3 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"Loop" loop, #_"BlockT" initialState]
        ;; nothing to do
        nil
    )

    (§ method- #_"void" EffectsClosure''doMergeWithoutDead-3 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"MergeProcessor<BlockT>" mergeProcessor, #_"List<BlockT>" states]
        (let [
            #_"int" alive
                (loop-when-recur [alive 0 #_"ISeq" s (seq states)]
                                 (some? s)
                                 [(if (EffectsBlockState''isDead-1 (first s)) alive (inc alive)) (next s)]
                              => alive
                )
        ]
            (cond
                (zero? alive)
                    (§ ass! mergeProcessor (MergeProcessor''setNewState-2 mergeProcessor, (nth states 0)))
                (= alive (count states))
                    (let [
                        #_"int[]" stateIndexes (int-array (count states))
                    ]
                        (dotimes [#_"int" i (count stateIndexes)]
                            (aset stateIndexes i i)
                        )
                        (§ ass! mergeProcessor (MergeProcessor''setStateIndexes-2 mergeProcessor, stateIndexes))
                        (§ ass! mergeProcessor (MergeProcessor''setNewState-2 mergeProcessor, (BlockIteratorClosure''getInitialState-1 this)))
                        (MergeProcessor''merge-2 mergeProcessor, states)
                    )
                :else
                    (let [
                        #_"ArrayList<BlockT>" aliveStates (ArrayList.)
                        #_"int[]" stateIndexes (int-array alive)
                    ]
                        (dotimes [#_"int" i (count states)]
                            (when-not (EffectsBlockState''isDead-1 (nth states i))
                                (aset stateIndexes (count aliveStates) i)
                                (#_"ArrayList" .add aliveStates, (nth states i))
                            )
                        )
                        (§ ass! mergeProcessor (MergeProcessor''setStateIndexes-2 mergeProcessor, stateIndexes))
                        (§ ass! mergeProcessor (MergeProcessor''setNewState-2 mergeProcessor, (BlockIteratorClosure''getInitialState-1 this)))
                        (MergeProcessor''merge-2 mergeProcessor, aliveStates)
                    )
            )
        )
        nil
    )

    (§ abstract #_"void" EffectsClosure''processLoopExit-5 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"LoopExitNode" exitNode, #_"BlockT" initialState, #_"BlockT" exitState, #_"GraphEffectList" effects])

    (§ abstract #_"MergeProcessor<BlockT>" EffectsClosure''createMergeProcessor-2 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"Block" merge])

    (§ method! #_"void" EffectsClosure''addScalarAlias-3 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"ValueNode" node, #_"ValueNode" alias]
        (NodeMap''set-3 (:aliases this), node, alias)
        (doseq [#_"Node" usage (Node''usages-1 node)]
            (when-not (NodeBitMap''isNew-2 (:hasScalarReplacedInputs this), usage)
                (NodeBitMap''mark-2 (:hasScalarReplacedInputs this), usage)
            )
        )
        nil
    )

    (§ method! #_"boolean" EffectsClosure''hasScalarReplacedInputs-2 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"Node" node]
        (NodeBitMap''isMarked-2 (:hasScalarReplacedInputs this), node)
    )

    (§ method! #_"ValueNode" EffectsClosure''getScalarAlias-2 [#_"EffectsClosure<BlockT extends EffectsBlockState<BlockT>>" this, #_"ValueNode" node]
        (when (and (some? node) (Node''isAlive-1 node) (not (NodeMap''isNew-2 (:aliases this), node))) => node
            (let [
                #_"ValueNode" result (NodeMap''get-2 (:aliases this), node)
            ]
                (if (and (some? result) (not (instance? VirtualObjectNode result))) result node)
            )
        )
    )
)

;;;
 ; @anno EffectsClosure.LoopKillCache
 ;;
(final-ns LoopKillCache
    (§ mutable #_"int" :visits 0)
    (§ mutable #_"LocationIdentity" :firstLocation nil)
    (§ mutable #_"EconomicSet<LocationIdentity>" :killedLocations nil)
    (§ mutable #_"boolean" :killsAll false)

    (§ defn #_"LoopKillCache" LoopKillCache'new-1 [#_"int" visits]
        (let [
            #_"LoopKillCache" this (Object.)
            this (assoc this :visits visits)
        ]
            this
        )
    )

    (§ method! #_"LoopKillCache" LoopKillCache''visited-1 [#_"LoopKillCache" this]
        (update this :visits inc)
    )

    (§ method! #_"LoopKillCache" LoopKillCache''setKillsAll-1 [#_"LoopKillCache" this]
        (let [
            this (assoc this :killsAll true)
            this (assoc this :firstLocation nil)
            this (assoc this :killedLocations nil)
        ]
            this
        )
    )

    (§ method! #_"boolean" LoopKillCache''containsLocation-2 [#_"LoopKillCache" this, #_"LocationIdentity" locationIdentity]
        (or (:killsAll this)
            (and (some? (:firstLocation this))
                (or (= (:firstLocation this) locationIdentity)
                    (and (some? (:killedLocations this)) (contains? (:killedLocations this) locationIdentity))
                )
            )
        )
    )

    (§ method! #_"LoopKillCache" LoopKillCache''rememberLoopKilledLocation-2 [#_"LoopKillCache" this, #_"LocationIdentity" locationIdentity]
        (when-not (:killsAll this) => this
            (if (or (nil? (:firstLocation this)) (= (:firstLocation this) locationIdentity))
                (assoc this :firstLocation locationIdentity)
                (let [
                    this
                        (when (nil? (:killedLocations this)) => this
                            (assoc this :killedLocations (EconomicSet/create Equivalence/IDENTITY))
                        )
                ]
                    (#_"EconomicSet" .add (:killedLocations this), locationIdentity)
                    this
                )
            )
        )
    )

    (§ method! #_"boolean" LoopKillCache''loopKillsLocations-1 [#_"LoopKillCache" this]
        (or (:killsAll this) (some? (:firstLocation this)))
    )
)

;;;
 ; The main workhorse for merging states, both for loops and for normal merges.
 ;
 ; @anno EffectsClosure.MergeProcessor
 ;;
(class-ns MergeProcessor #_"<BlockT extends EffectsBlockState<BlockT>>"
    (§ final #_"Block" :mergeBlock nil)
    (§ final #_"AbstractMergeNode" :merge nil)

    (§ final #_"GraphEffectList" :mergeEffects (GraphEffectList'new-0))
    (§ final #_"GraphEffectList" :afterMergeEffects (GraphEffectList'new-0))

    ;;;
     ; The indexes are used to map from an index in the list of active (non-dead) predecessors
     ; to an index in the list of all predecessors (the latter may be larger).
     ;;
    (§ mutable #_"int[]" :stateIndexes nil)
    (§ mutable #_"BlockT" :newState nil)

    (§ defn #_"MergeProcessor" MergeProcessor'new-1 [#_"Block" mergeBlock]
        (let [
            #_"MergeProcessor" this (Object.)
            this (assoc this :mergeBlock mergeBlock)
            this (assoc this :merge (§ cast #_"AbstractMergeNode" (:beginNode mergeBlock)))
        ]
            this
        )
    )

    ;;;
     ; @param states the states that should be merged.
     ;;
    (§ abstract #_"void" MergeProcessor''merge-2 [#_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" this, #_"List<BlockT>" states])

    (§ method- #_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" MergeProcessor''setNewState-2 [#_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" this, #_"BlockT" state]
        (let [
            this (assoc this :newState state)
        ]
            (GraphEffectList''clear-1 (:mergeEffects this))
            (GraphEffectList''clear-1 (:afterMergeEffects this))
            this
        )
    )

    (§ method- #_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" MergeProcessor''setStateIndexes-2 [#_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" this, #_"int[]" stateIndexes]
        (assoc this :stateIndexes stateIndexes)
    )

    (§ method! #_"Block" MergeProcessor''getPredecessor-2 [#_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" this, #_"int" index]
        (nth (:predecessors (:mergeBlock this)) (nth (:stateIndexes this) index))
    )

    (§ method! #_"NodeIterable<PhiNode>" MergeProcessor''getPhis-1 [#_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" this]
        (AbstractMergeNode''phis-1 (:merge this))
    )

    (§ method! #_"ValueNode" MergeProcessor''getPhiValueAt-3 [#_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" this, #_"PhiNode" phi, #_"int" index]
        (PhiNode''valueAt-2 phi, (nth (:stateIndexes this) index))
    )

    (§ method! #_"ValuePhiNode" MergeProcessor''createValuePhi-2 [#_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" this, #_"Stamp" stamp]
        (ValuePhiNode'new-3 stamp, (:merge this), (make-array ValueNode (count (:predecessors (:mergeBlock this)))))
    )

    (§ method! #_"void" MergeProcessor''setPhiInput-4 [#_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" this, #_"PhiNode" phi, #_"int" index, #_"ValueNode" value]
        (GraphEffectList''initializePhiInput-4 (:afterMergeEffects this), phi, (nth (:stateIndexes this) index), value)
        nil
    )

    (§ method! #_"Graph" MergeProcessor''graph-1 [#_"MergeProcessor<BlockT extends EffectsBlockState<BlockT>>" this]
        (:graph (:merge this))
    )
)

(class-ns EffectsPhase #_"<PhaseContextT extends PhaseContext>" (§ extends BasePhase #_"<PhaseContextT>")
    (§ final #_"int" :maxIterations 0)
    (§ final #_"CanonicalizerPhase" :canonicalizer nil)
    (§ final #_"boolean" :unscheduled false)

    (§ defn #_"EffectsPhase" EffectsPhase'new-2 [#_"int" maxIterations, #_"CanonicalizerPhase" canonicalizer]
        (EffectsPhase'new-3 maxIterations, canonicalizer, false)
    )

    (§ defn #_"EffectsPhase" EffectsPhase'new-3 [#_"int" maxIterations, #_"CanonicalizerPhase" canonicalizer, #_"boolean" unscheduled]
        (let [
            #_"EffectsPhase" this (BasePhase'new-0)
            this (assoc this :maxIterations maxIterations)
            this (assoc this :canonicalizer canonicalizer)
            this (assoc this :unscheduled unscheduled)
        ]
            this
        )
    )

    (§ method! #_"boolean" EffectsPhase''runAnalysis-3 [#_"EffectsPhase<PhaseContextT extends PhaseContext>" this, #_"Graph" graph, #_"PhaseContextT" context]
        (loop-when [#_"boolean" changed? false #_"int" iteration 0] (< iteration (:maxIterations this)) => changed?
            (let [
                [#_"ScheduleResult" schedule #_"ControlFlowGraph" cfg]
                    (if (:unscheduled this)
                        [nil (ControlFlowGraph'compute-5 graph, true, true, false, false)]
                        (do
                            (Phase''apply-2 (SchedulePhase'new-1 SchedulingStrategy'EARLIEST), graph)
                            (let [
                                schedule (:lastSchedule graph)
                            ]
                                [schedule (:cfg schedule)]
                            )
                        )
                    )
                #_"Closure" closure (EffectsPhase''createEffectsClosure-4 this, context, schedule, cfg)
            ]
                (ReentrantBlockIterator'apply-2 closure, (ControlFlowGraph''getStartBlock-1 cfg))

                (when (Closure''needsApplyEffects-1 closure)
                    ;; apply the effects collected during this iteration
                    (let [
                        #_"HashSetNodeEventListener" listener (HashSetNodeEventListener'new-0)
                    ]
                        (try (§ with [#_"NodeEventScope" _ (Graph''trackNodeEvents-2 graph, listener)])
                            (Closure''applyEffects-1 closure)
                        )
                        (Phase''apply-2 (DeadCodeEliminationPhase'new-1 Optionality'Required), graph)
                        (let [
                            #_"EconomicSet<Node>" changedNodes (:nodes listener)
                        ]
                            (doseq [#_"Node" node (Graph''getNodes-1 graph)]
                                (when (instance? Simplifiable node)
                                    (#_"EconomicSet" .add changedNodes, node)
                                )
                            )
                            (EffectsPhase''postIteration-4 this, graph, context, changedNodes)
                        )
                    )
                )
                (when (:changed? closure) => changed?
                    (recur true (inc iteration))
                )
            )
        )
    )

    #_unused
    (§ override #_"void" EffectsPhase''run-3 [#_"EffectsPhase<PhaseContextT extends PhaseContext>" this, #_"Graph" graph, #_"PhaseContextT" context]
        (EffectsPhase''runAnalysis-3 this, graph, context)
        nil
    )

    (§ method #_"void" EffectsPhase''postIteration-4 [#_"EffectsPhase<PhaseContextT extends PhaseContext>" this, #_"Graph" graph, #_"PhaseContextT" context, #_"EconomicSet<Node>" changedNodes]
        (when (some? (:canonicalizer this))
            (CanonicalizerPhase''applyIncremental-4 (:canonicalizer this), graph, context, changedNodes)
        )
        nil
    )

    (§ abstract #_"Closure" EffectsPhase''createEffectsClosure-4 [#_"EffectsPhase<PhaseContextT extends PhaseContext>" this, #_"PhaseContextT" context, #_"ScheduleResult" schedule, #_"ControlFlowGraph" cfg])
)

;;;
 ; @anno EffectsPhase.Closure
 ;;
(class-ns Closure #_"<T>" (§ extends BlockIteratorClosure #_"<T>")
    (§ defn #_"Closure" Closure'new-0 []
        (BlockIteratorClosure'new-0)
    )

    (§ abstract #_"boolean" Closure''needsApplyEffects-1 [#_"Closure<T>" this])

    (§ abstract #_"void" Closure''applyEffects-1 [#_"Closure<T>" this])
)

(final-ns GraphEffectList (§ extends EffectList)
    (§ defn #_"GraphEffectList" GraphEffectList'new-0 []
        (EffectList'new-0)
    )

    ;;;
     ; Determines how many objects are virtualized (positive) or materialized (negative) by this effect.
     ;;
    (§ mutable #_"int" :virtualizationDelta 0)

    (§ override! #_"void" GraphEffectList''clear-1 [#_"GraphEffectList" this]
        (EffectList''clear-1 (§ super ))
        (§ ass! this (assoc this :virtualizationDelta 0))
        nil
    )

    ;;;
     ; Adds the given fixed node to the graph's control flow, before position (so that the original
     ; predecessor of position will then be node's predecessor).
     ;
     ; @param node The fixed node to be added to the graph.
     ; @param position The fixed node before which the node should be added.
     ;;
    (§ method! #_"void" GraphEffectList''addFixedNodeBefore-3 [#_"GraphEffectList" this, #_"FixedWithNextNode" node, #_"FixedNode" position]
        (EffectList''add-3 this, "add fixed node", (ß graph ->
            (§ fun
                (Graph''addBeforeFixed-3 graph, position, (Graph''add-2 graph, node))
            ))
        )
        nil
    )

    #_unused
    (§ method! #_"void" GraphEffectList''ensureAdded-3 [#_"GraphEffectList" this, #_"ValueNode" node, #_"FixedNode" position]
        (EffectList''add-3 this, "ensure added", (ß graph ->
            (§ fun
                (when-not (Node''isAlive-1 node)
                    (Graph''addOrUniqueWithInputs-2 graph, node)
                    (when (instance? FixedWithNextNode node)
                        (Graph''addBeforeFixed-3 graph, position, node)
                    )
                )
            ))
        )
        nil
    )

    (§ method! #_"GraphEffectList" GraphEffectList''addVirtualizationDelta-2 [#_"GraphEffectList" this, #_"int" delta]
        (update this :virtualizationDelta + delta)
    )

    ;;;
     ; Add the given floating node to the graph.
     ;
     ; @param node The floating node to be added.
     ;;
    (§ method! #_"void" GraphEffectList''addFloatingNode-3 [#_"GraphEffectList" this, #_"ValueNode" node, #_"String" cause]
        (EffectList''add-3 this, "add floating node", (ß graph ->
            (§ fun
                (Graph''addInputs-2 graph, node)
                (Graph''add-2 graph, node)
            ))
        )
        nil
    )

    ;;;
     ; Sets the phi node's input at the given index to the given value, adding new phi inputs as needed.
     ;
     ; @param node The phi node whose input should be changed.
     ; @param index The index of the phi input to be changed.
     ; @param value The new value for the phi input.
     ;;
    (§ method! #_"void" GraphEffectList''initializePhiInput-4 [#_"GraphEffectList" this, #_"PhiNode" node, #_"int" index, #_"ValueNode" value]
        (EffectList''add-3 this, "set phi input", (ß (graph, obsoleteNodes) ->
            (§ fun
                (PhiNode''initializeValueAt-3 node, index, (Graph''addOrUniqueWithInputs-2 graph, value))
            ))
        )
        nil
    )

    ;;;
     ; Adds a virtual object's state to the given frame state. If the given reusedVirtualObjects set
     ; contains the virtual object then old states for this object will be removed.
     ;
     ; @param node The frame state to which the state should be added.
     ; @param state The virtual object state to add.
     ;;
    (§ method! #_"void" GraphEffectList''addVirtualMapping-3 [#_"GraphEffectList" this, #_"FrameState" node, #_"EscapeObjectState" state]
        (EffectList''add-3 this, "add virtual mapping",
            (§ reify #_"Effect" (Effect'reify-0)
                (§ override! #_"void" Effect''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                    (when (Node''isAlive-1 node)
                        (dotimes [#_"int" i (FrameState''virtualObjectMappingCount-1 node)]
                            (when (= (:object (FrameState''virtualObjectMappingAt-2 node, i)) (:object state))
                                (NodeList''remove-2 (:virtualObjectMappings node), i)
                            )
                        )
                        (§ ass! node (FrameState''addVirtualObjectMapping-2 node, (Graph''addOrUniqueWithInputs-2 graph, state)))
                    )
                    nil
                )

                #_unused
                (§ override! #_"boolean" Effect''isVisible-1 [#_"Effect" this]
                    false
                )
            )
        )
        nil
    )

    ;;;
     ; Removes the given fixed node from the control flow and deletes it.
     ;
     ; @param node The fixed node that should be deleted.
     ;;
    (§ method! #_"void" GraphEffectList''deleteNode-2 [#_"GraphEffectList" this, #_"Node" node]
        (EffectList''add-3 this, "delete fixed node", (ß (graph, obsoleteNodes) ->
            (§ fun
                (when (instance? FixedWithNextNode node)
                    (GraphUtil'unlinkFixedNode-1 node)
                )
                (#_"ArrayList" .add obsoleteNodes, node)
            ))
        )
        nil
    )

    (§ method! #_"void" GraphEffectList''killIfBranch-3 [#_"GraphEffectList" this, #_"IfNode" ifNode, #_"boolean" constantCondition]
        (EffectList''add-3 this, "kill if branch",
            (§ reify #_"Effect" (Effect'reify-0)
                (§ override! #_"void" Effect''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                    (Graph''removeSplitPropagate-3 graph, ifNode, (IfNode''getSuccessor-2 ifNode, constantCondition))
                    nil
                )

                (§ override! #_"boolean" Effect''isCfgKill-1 [#_"Effect" this]
                    true
                )
            )
        )
        nil
    )

    (§ method! #_"void" GraphEffectList''replaceWithSink-3 [#_"GraphEffectList" this, #_"FixedWithNextNode" node, #_"ControlSinkNode" sink]
        (EffectList''add-3 this, "kill if branch",
            (§ reify #_"Effect" (Effect'reify-0)
                (§ override! #_"void" Effect''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                    (Graph''add-2 graph, sink)
                    (Node''replaceAtPredecessor-2 node, sink)
                    (GraphUtil'killCFG-1 node)
                    nil
                )

                (§ override! #_"boolean" Effect''isCfgKill-1 [#_"Effect" this]
                    true
                )
            )
        )
        nil
    )

    ;;;
     ; Replaces the given node at its usages without deleting it. If the current node is a fixed
     ; node it will be disconnected from the control flow, so that it will be deleted by a
     ; subsequent DeadCodeEliminationPhase
     ;
     ; @param node The node to be replaced.
     ; @param replacement The node that should replace the original value. If the replacement is a
     ;            non-connected FixedWithNextNode it will be added to the control flow.
     ;;
    (§ method! #_"void" GraphEffectList''replaceAtUsages-4 [#_"GraphEffectList" this, #_"ValueNode" node, #_"ValueNode" replacement, #_"FixedNode" insertBefore]
        (EffectList''add-3 this, "replace at usages", (ß (graph, obsoleteNodes) ->
            (§ fun
                (let [
                    #_"ValueNode" replacementNode (Graph''addOrUniqueWithInputs-2 graph, replacement)
                ]
                    (when (and (instance? FixedWithNextNode replacementNode) (nil? (:next replacementNode)))
                        (Graph''addBeforeFixed-3 graph, insertBefore, replacementNode)
                    )
                    ;; Keep the (better) stamp information when replacing a node with another one if the
                    ;; replacement has a less precise stamp than the original node. This can happen for
                    ;; example in the context of read nodes and unguarded pi nodes where the pi will be used
                    ;; to improve the stamp information of the read. Such a read might later be replaced
                    ;; with a read with a less precise stamp.
                    (when-not (= (:stamp node) (:stamp replacementNode))
                        (§ ass replacementNode (Graph''add-2 graph, (PiNode'new-2 replacementNode, (:stamp node))))
                    )
                    (§ ass! node (Node''replaceAtUsages-2 node, replacementNode))
                    (when (instance? FixedWithNextNode node)
                        (GraphUtil'unlinkFixedNode-1 node)
                    )
                    (#_"ArrayList" .add obsoleteNodes, node)
                )
            ))
        )
        nil
    )

    ;;;
     ; Replaces the first occurrence of oldInput in node with newInput.
     ;
     ; @param node The node whose input should be changed.
     ; @param oldInput The value to look for.
     ; @param newInput The value to replace with.
     ;;
    (§ method! #_"void" GraphEffectList''replaceFirstInput-4 [#_"GraphEffectList" this, #_"Node" node, #_"Node" oldInput, #_"Node" newInput]
        (EffectList''add-3 this, "replace first input",
            (§ reify #_"Effect" (Effect'reify-0)
                (§ override! #_"void" Effect''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                    (when (Node''isAlive-1 node)
                        (Node''replaceFirstInput-3 node, oldInput, newInput)
                    )
                    nil
                )

                #_unused
                (§ override! #_"boolean" Effect''isVisible-1 [#_"Effect" this]
                    (not (instance? FrameState node))
                )
            )
        )
        nil
    )
)

;;;
 ; This class describes the state of a virtual object while iterating over the graph.
 ; It describes the fields or array elements (called "entries") and the lock count if the object is
 ; still virtual. If the object was materialized, it contains the current materialized value.
 ;;
(final-ns ObjectState
    ;;;
     ; Users of this method are not allowed to change the entries of the returned array.
     ;;
    (§ mutable #_"ValueNode[]" :entries nil)

    (§ mutable #_"ValueNode" :materializedValue nil)
    (§ mutable #_"LockState" :locks nil)
    (§ mutable #_"boolean" :ensureVirtualized false)

    (§ mutable #_"EscapeObjectState" :cachedState nil)

    ;;;
     ; ObjectStates are duplicated lazily, if this field is true then the state needs to be copied
     ; before it is modified.
     ;;
    (§ mutable #_"boolean" :copyOnWrite false)

    (§ defn #_"ObjectState" ObjectState'new-3 [#_"ValueNode[]" entries, #_"List<MonitorIdNode>" locks, #_"boolean" ensureVirtualized]
        (let [
            #_"ObjectState" this (ObjectState'new-3 entries, (§ cast #_"LockState" nil), ensureVirtualized)
        ]
            (loop-when-recur [#_"int" i (dec (count locks))] (<= 0 i) [(dec i)]
                (§ ass this (assoc this :locks (LockState'new-2 (nth locks i), (:locks this))))
            )
            this
        )
    )

    (§ defn #_"ObjectState" ObjectState'new-3 [#_"ValueNode[]" entries, #_"LockState" locks, #_"boolean" ensureVirtualized]
        (let [
            #_"ObjectState" this (Object.)
            this (assoc this :entries entries)
            this (assoc this :locks locks)
            this (assoc this :ensureVirtualized ensureVirtualized)
        ]
            this
        )
    )

    (§ defn #_"ObjectState" ObjectState'new-3 [#_"ValueNode" materializedValue, #_"LockState" locks, #_"boolean" ensureVirtualized]
        (let [
            #_"ObjectState" this (Object.)
            this (assoc this :materializedValue materializedValue)
            this (assoc this :locks locks)
            this (assoc this :ensureVirtualized ensureVirtualized)
        ]
            this
        )
    )

    (§ defn- #_"ObjectState" ObjectState'new-1 [#_"ObjectState" other]
        (let [
            #_"ObjectState" this (Object.)
            this (assoc this :entries (when (some? (:entries other)) (#_"Object" .clone (:entries other))))
            this (assoc this :materializedValue (:materializedValue other))
            this (assoc this :locks (:locks other))
            this (assoc this :cachedState (:cachedState other))
            this (assoc this :ensureVirtualized (:ensureVirtualized other))
        ]
            this
        )
    )

    (§ method! #_"ObjectState" ObjectState''cloneState-1 [#_"ObjectState" this]
        (ObjectState'new-1 this)
    )

    (§ method! #_"EscapeObjectState" ObjectState''createEscapeObjectState-2 [#_"ObjectState" this, #_"VirtualObjectNode" virtual]
        (when (nil? (:cachedState this))
            (if (ObjectState''isVirtual-1 this)
                ;; Clear out entries that are default values anyway.
                ;;
                ;; TODO this should be propagated into ObjectState.entries, but that will take some more refactoring
                (let [
                    #_"ValueNode[]" newEntries (#_"Object" .clone (:entries this))
                ]
                    (dotimes [#_"int" i (count newEntries)]
                        (when (= (ValueNode''asJavaConstant-1 (nth newEntries i)) (JavaConstant/defaultForKind (#_"JavaKind" .getStackKind (VirtualObjectNode''entryKind-2 virtual, i))))
                            (aset newEntries i nil)
                        )
                    )
                    (§ ass! this (assoc this :cachedState (VirtualObjectState'new-2 virtual, newEntries)))
                )
                (§ ass! this (assoc this :cachedState (MaterializedObjectState'new-2 virtual, (:materializedValue this))))
            )
        )
        (:cachedState this)
    )

    (§ method! #_"boolean" ObjectState''isVirtual-1 [#_"ObjectState" this]
        (nil? (:materializedValue this))
    )

    (§ method! #_"ValueNode" ObjectState''getEntry-2 [#_"ObjectState" this, #_"int" index]
        (nth (:entries this) index)
    )

    (§ method! #_"ObjectState" ObjectState''setEntry-3 [#_"ObjectState" this, #_"int" index, #_"ValueNode" value]
        (let [
            this (assoc this :cachedState nil)
        ]
            (aset (:entries this) index value)
            this
        )
    )

    (§ method! #_"ObjectState" ObjectState''escape-2 [#_"ObjectState" this, #_"ValueNode" materialized]
        (let [
            this (assoc this :materializedValue materialized)
            this (assoc this :entries nil)
            this (assoc this :cachedState nil)
        ]
            this
        )
    )

    (§ method! #_"ObjectState" ObjectState''updateMaterializedValue-2 [#_"ObjectState" this, #_"ValueNode" value]
        (let [
            this (assoc this :cachedState nil)
            this (assoc this :materializedValue value)
        ]
            this
        )
    )

    (§ method! #_"ObjectState" ObjectState''addLock-2 [#_"ObjectState" this, #_"MonitorIdNode" monitorId]
        (assoc this :locks (LockState'new-2 monitorId, (:locks this)))
    )

    (§ method! #_"MonitorIdNode" ObjectState''removeLock-1 [#_"ObjectState" this]
        (try
            (:monitorId (:locks this))
            (finally
                (§ ass! this (assoc this :locks (:next (:locks this))))
            )
        )
    )

    (§ method! #_"boolean" ObjectState''hasLocks-1 [#_"ObjectState" this]
        (some? (:locks this))
    )

    (§ method! #_"boolean" ObjectState''locksEqual-2 [#_"ObjectState" this, #_"ObjectState" other]
        (loop-when-recur [#_"LockState" a (:locks this) #_"LockState" b (:locks other)]
                         (and (some? a) (some? b) (= (:monitorId a) (:monitorId b)))
                         [(:next a) (:next b)]
                      => (and (nil? a) (nil? b))
        )
    )

    (§ method! #_"ObjectState" ObjectState''setEnsureVirtualized-2 [#_"ObjectState" this, #_"boolean" ensureVirtualized]
        (assoc this :ensureVirtualized ensureVirtualized)
    )

    (§ override! #_"boolean" #_"Object" .equals [#_"ObjectState" this, #_"Object" that]
        (or (= this that)
            (and (some? that) (= (#_"Object" .getClass this) (#_"Object" .getClass that))
                (Arrays/equals (:entries this), (:entries that))
                (ObjectState''locksEqual-2 this, that)
                (if (nil? (:materializedValue this))
                    (nil? (:materializedValue that))
                    (= (:materializedValue this) (:materializedValue that))
                )
            )
        )
    )

    (§ method! #_"ObjectState" ObjectState''share-1 [#_"ObjectState" this]
        (§ ass this (assoc this :copyOnWrite true))
        this
    )
)

(class-ns PartialEscapeBlockState #_"<T extends PartialEscapeBlockState<T>>" (§ extends EffectsBlockState #_"<T>")
    (§ def- #_"ObjectState[]" PartialEscapeBlockState'EMPTY_ARRAY (make-array ObjectState 0))

    ;;;
     ; This array contains the state of all virtual objects, indexed by VirtualObjectNode#getObjectId().
     ; Entries in this array may be nil if the corresponding virtual object is not alive or reachable currently.
     ;;
    (§ mutable #_"ObjectState[]" :objectStates nil)

    (§ method #_"boolean" PartialEscapeBlockState''contains-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"VirtualObjectNode" value]
        (loop [#_"ISeq" s (seq (:objectStates this))]
            (and (some? s)
                (or
                    (let [
                        #_"ObjectState" state (first s)
                    ]
                        (when (and (some? state) (ObjectState''isVirtual-1 state))
                            (loop-when [#_"ISeq" s (seq (:entries state))] (some? s)
                                (or (= (first s) value)
                                    (recur (next s))
                                )
                            )
                        )
                    )
                    (recur (next s))
                )
            )
        )
    )

    ;;;
     ; Usage count for the objectStates array, to avoid unneessary copying.
     ;;
    (§ mutable #_"RefCount" :arrayRefCount nil)

    (§ defn #_"PartialEscapeBlockState" PartialEscapeBlockState'new-0 []
        (let [
            #_"PartialEscapeBlockState" this (EffectsBlockState'new-0)
            this (assoc this :objectStates PartialEscapeBlockState'EMPTY_ARRAY)
            this (assoc this :arrayRefCount (RefCount'new-0))
        ]
            this
        )
    )

    (§ defn #_"PartialEscapeBlockState" PartialEscapeBlockState'new-1 [#_"PartialEscapeBlockState<T>" other]
        (let [
            #_"PartialEscapeBlockState" this (EffectsBlockState'new-1 other)
        ]
            (§ ass! this (PartialEscapeBlockState''adoptAddObjectStates-2 this, other))
            this
        )
    )

    (§ method #_"ObjectState" PartialEscapeBlockState''getObjectState-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" object]
        (nth (:objectStates this) object)
    )

    (§ method! #_"ObjectState" PartialEscapeBlockState''getObjectStateOptional-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" object]
        (when (< object (count (:objectStates this))) (nth (:objectStates this) object))
    )

    ;;;
     ; Asserts that the given virtual object is available/reachable in the current state.
     ;;
    (§ method #_"ObjectState" PartialEscapeBlockState''getObjectState-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"VirtualObjectNode" object]
        (nth (:objectStates this) (VirtualObjectNode''getObjectId-1 object))
    )

    (§ method! #_"ObjectState" PartialEscapeBlockState''getObjectStateOptional-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"VirtualObjectNode" object]
        (let [
            #_"int" id (VirtualObjectNode''getObjectId-1 object)
        ]
            (when (< id (count (:objectStates this))) (nth (:objectStates this) id))
        )
    )

    (§ method- #_"ObjectState[]" PartialEscapeBlockState''getObjectStateArrayForModification-1 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this]
        (when (< 1 (:refCount (:arrayRefCount this)))
            (§ ass! this (assoc this :objectStates (#_"Object" .clone (:objectStates this))))
            (§ ass! (:refCount (:arrayRefCount this)) (dec (:refCount (:arrayRefCount this))))
            (§ ass! this (assoc this :arrayRefCount (RefCount'new-0)))
        )
        (:objectStates this)
    )

    (§ method- #_"ObjectState" PartialEscapeBlockState''getObjectStateForModification-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" object]
        (let [
            #_"ObjectState[]" array (PartialEscapeBlockState''getObjectStateArrayForModification-1 this)
            #_"ObjectState" objectState (nth array object)
        ]
            (when (:copyOnWrite objectState)
                (§ ass objectState (ObjectState''cloneState-1 objectState))
                (aset array object objectState)
            )
            objectState
        )
    )

    (§ method #_"void" PartialEscapeBlockState''setEntry-4 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" object, #_"int" entryIndex, #_"ValueNode" value]
        (when-not (= (ObjectState''getEntry-2 (nth (:objectStates this) object), entryIndex) value)
            (§ ass! (PartialEscapeBlockState''getObjectStateForModification-2 this, object) (ObjectState''setEntry-3 (PartialEscapeBlockState''getObjectStateForModification-2 this, object), entryIndex, value))
        )
        nil
    )

    (§ method #_"void" PartialEscapeBlockState''escape-3 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" object, #_"ValueNode" materialized]
        (§ ass! (PartialEscapeBlockState''getObjectStateForModification-2 this, object) (ObjectState''escape-2 (PartialEscapeBlockState''getObjectStateForModification-2 this, object), materialized))
        nil
    )

    (§ method #_"void" PartialEscapeBlockState''addLock-3 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" object, #_"MonitorIdNode" monitorId]
        (§ ass! (PartialEscapeBlockState''getObjectStateForModification-2 this, object) (ObjectState''addLock-2 (PartialEscapeBlockState''getObjectStateForModification-2 this, object), monitorId))
        nil
    )

    (§ method #_"MonitorIdNode" PartialEscapeBlockState''removeLock-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" object]
        (ObjectState''removeLock-1 (PartialEscapeBlockState''getObjectStateForModification-2 this, object))
    )

    (§ method #_"void" PartialEscapeBlockState''setEnsureVirtualized-3 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" object, #_"boolean" ensureVirtualized]
        (when-not (= (:ensureVirtualized (nth (:objectStates this) object)) ensureVirtualized)
            (§ ass! (PartialEscapeBlockState''getObjectStateForModification-2 this, object) (ObjectState''setEnsureVirtualized-2 (PartialEscapeBlockState''getObjectStateForModification-2 this, object), ensureVirtualized))
        )
        nil
    )

    (§ method #_"void" PartialEscapeBlockState''updateMaterializedValue-3 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" object, #_"ValueNode" value]
        (when-not (= (:materializedValue (nth (:objectStates this) object)) value)
            (§ ass! (PartialEscapeBlockState''getObjectStateForModification-2 this, object) (ObjectState''updateMaterializedValue-2 (PartialEscapeBlockState''getObjectStateForModification-2 this, object), value))
        )
        nil
    )

    ;;;
     ; Materializes the given virtual object and produces the necessary effects in the effects list.
     ; This transitively also materializes all other virtual objects that are reachable from the entries.
     ;;
    (§ method! #_"void" PartialEscapeBlockState''materializeBefore-4 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"FixedNode" fixed, #_"VirtualObjectNode" virtual, #_"GraphEffectList" materializeEffects]
        (let [
            #_"List<AllocatedObjectNode>" objects (ArrayList.)
            #_"List<ValueNode>" values (ArrayList.)
            #_"List<List<MonitorIdNode>>" locks (ArrayList.)
            #_"List<ValueNode>" otherAllocations (ArrayList.)
            #_"List<Boolean>" ensureVirtual (ArrayList.)
        ]
            (PartialEscapeBlockState''materializeWithCommit-8 this, fixed, virtual, objects, locks, values, ensureVirtual, otherAllocations)

            (§ ass! materializeEffects (GraphEffectList''addVirtualizationDelta-2 materializeEffects, (- (+ (count objects) (count otherAllocations)))))

            (EffectList''add-3 materializeEffects, "materializeBefore",
                (§ reify #_"Effect" (Effect'reify-0)
                    (§ override! #_"void" Effect''apply-3 [#_"Effect" this, #_"Graph" graph, #_"ArrayList<Node>" obsoleteNodes]
                        (doseq [#_"ValueNode" alloc otherAllocations]
                            (let [
                                #_"ValueNode" otherAllocation (Graph''addOrUniqueWithInputs-2 graph, alloc)
                            ]
                                (when (instance? FixedWithNextNode otherAllocation)
                                    (Graph''addBeforeFixed-3 graph, fixed, otherAllocation)
                                )
                            )
                        )
                        (when (seq objects)
                            (let [
                                #_"CommitAllocationNode" commit
                                    (if (instance? CommitAllocationNode (:predecessor fixed))
                                        (:predecessor fixed)
                                        (let [
                                            commit (Graph''add-2 graph, (CommitAllocationNode'new-0))
                                        ]
                                            (Graph''addBeforeFixed-3 graph, fixed, commit)
                                            commit
                                        )
                                    )
                            ]
                                (doseq [#_"AllocatedObjectNode" obj objects]
                                    (Graph''add-2 graph, obj)
                                    (#_"List" .add (:virtualObjects commit), (:virtualObject obj))
                                    (§ ass! obj (AllocatedObjectNode''setCommit-2 obj, commit))
                                )
                                (doseq [#_"ValueNode" value values]
                                    (#_"List" .add (:values commit), (Graph''addOrUniqueWithInputs-2 graph, value))
                                )
                                (doseq [#_"List<MonitorIdNode>" monitorIds locks]
                                    (CommitAllocationNode''addLocks-2 commit, monitorIds)
                                )
                                (#_"List" .addAll (:ensureVirtual commit), ensureVirtual)

                                (let [
                                    #_"List<AllocatedObjectNode>" materializedValues (NodeIterable''snapshot-1 (NodeIterable''filter-2 (Node''usages-1 commit), AllocatedObjectNode))
                                ]
                                    (dotimes [#_"int" i (count (:values commit))]
                                        (when (#_"List" .contains materializedValues, (nth (:values commit) i))
                                            (#_"List" .set (:values commit), i, (:virtualObject (nth (:values commit) i)))
                                        )
                                    )
                                )
                            )
                        )
                        nil
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" PartialEscapeBlockState''materializeWithCommit-8 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"FixedNode" fixed, #_"VirtualObjectNode" virtual, #_"List<AllocatedObjectNode>" objects, #_"List<List<MonitorIdNode>>" locks, #_"List<ValueNode>" values, #_"List<Boolean>" ensureVirtual, #_"List<ValueNode>" otherAllocations]
        (let [
            #_"ObjectState" obj (PartialEscapeBlockState''getObjectState-2 this, virtual)
            #_"ValueNode[]" entries (:entries obj)
            #_"ValueNode" representation (VirtualObjectNode''getMaterializedRepresentation-4 virtual, fixed, entries, (:locks obj))
            _ (PartialEscapeBlockState''escape-3 this, (VirtualObjectNode''getObjectId-1 virtual), representation)
            obj (PartialEscapeBlockState''getObjectState-2 this, virtual)
            _ (PartialEscapeClosure'updateStatesForMaterialized-3 this, virtual, (:materializedValue obj))
        ]
            (when (instance? AllocatedObjectNode representation) => (#_"List" .add otherAllocations, representation)
                (#_"List" .add objects, representation)
                (#_"List" .add locks, (LockState'asList-1 (:locks obj)))
                (#_"List" .add ensureVirtual, (:ensureVirtualized obj))
                (let [
                    #_"int" pos (count values)
                ]
                    (while (< (count values) (+ pos (count entries)))
                        (#_"List" .add values, nil)
                    )
                    (dotimes [#_"int" i (count entries)]
                        (if (instance? VirtualObjectNode (nth entries i))
                            (let [
                                #_"VirtualObjectNode" entryVirtual (nth entries i)
                                #_"ObjectState" entryObj (PartialEscapeBlockState''getObjectState-2 this, entryVirtual)
                                entryObj
                                    (when (ObjectState''isVirtual-1 entryObj) => entryObj
                                        (PartialEscapeBlockState''materializeWithCommit-8 this, fixed, entryVirtual, objects, locks, values, ensureVirtual, otherAllocations)
                                        (PartialEscapeBlockState''getObjectState-2 this, entryVirtual)
                                    )
                            ]
                                (#_"List" .set values, (+ pos i), (:materializedValue entryObj))
                            )
                            (#_"List" .set values, (+ pos i), (nth entries i))
                        )
                    )
                    (PartialEscapeBlockState''objectMaterialized-4 this, virtual, (§ cast #_"AllocatedObjectNode" representation), (#_"List" .subList values, pos, (+ pos (count entries))))
                )
            )
        )
        nil
    )

    (§ method #_"void" PartialEscapeBlockState''objectMaterialized-4 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"VirtualObjectNode" virtual, #_"AllocatedObjectNode" representation, #_"List<ValueNode>" values]
        nil
    )

    (§ method- #_"ObjectState[]" PartialEscapeBlockState''ensureSize-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" objectId]
        (if (< objectId (count (:objectStates this)))
            (PartialEscapeBlockState''getObjectStateArrayForModification-1 this)
            (do
                (§ ass! this (assoc this :objectStates (Arrays/copyOf (:objectStates this), (max (<< objectId 1) 4))))
                (§ ass! (:refCount (:arrayRefCount this)) (dec (:refCount (:arrayRefCount this))))
                (§ ass! this (assoc this :arrayRefCount (RefCount'new-0)))
                (:objectStates this)
            )
        )
    )

    (§ method! #_"void" PartialEscapeBlockState''addObject-3 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" virtual, #_"ObjectState" state]
        (aset (PartialEscapeBlockState''ensureSize-2 this, virtual) virtual state)
        nil
    )

    (§ override #_"boolean" PartialEscapeBlockState''equivalentTo-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"T" other]
        (let [
            #_"int" n (max (count (:objectStates this)) (count (:objectStates other)))
        ]
            (loop-when [#_"int" i 0] (< i n) => true
                (and (= (PartialEscapeBlockState''getObjectStateOptional-2 this, i) (PartialEscapeBlockState''getObjectStateOptional-2 other, i))
                    (recur (inc i))
                )
            )
        )
    )

    (§ method! #_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" PartialEscapeBlockState''resetObjectStates-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"int" size]
        (assoc this :objectStates (make-array ObjectState size))
    )

    (§ defn #_"boolean" PartialEscapeBlockState'identicalObjectStates-1 [#_"PartialEscapeBlockState[]" states]
        (loop-when [#_"int" i 1] (< i (count states)) => true
            (and (= (:objectStates (nth states 0)) (:objectStates (nth states i)))
                (recur (inc i))
            )
        )
    )

    (§ defn #_"boolean" PartialEscapeBlockState'identicalObjectStates-2 [#_"PartialEscapeBlockState[]" states, #_"int" object]
        (loop-when [#_"int" i 1] (< i (count states)) => true
            (and (= (nth (:objectStates (nth states 0)) object) (nth (:objectStates (nth states i)) object))
                (recur (inc i))
            )
        )
    )

    (§ method! #_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" PartialEscapeBlockState''adoptAddObjectStates-2 [#_"PartialEscapeBlockState<T extends PartialEscapeBlockState<T>>" this, #_"PartialEscapeBlockState" other]
        (let [
            this
                (when (some? (:objectStates this)) => this
                    (update-in this [:arrayRefCount :refCount] dec)
                )
            this (assoc this :objectStates (:objectStates other))
            this (assoc this :arrayRefCount (:arrayRefCount other))
        ]
            (when (= (:refCount (:arrayRefCount this)) 1)
                (doseq [#_"ObjectState" state (:objectStates this)]
                    (when (some? state)
                        (ObjectState''share-1 state)
                    )
                )
            )
            (update-in this [:arrayRefCount :refCount] inc)
        )
    )
)

;;;
 ; @anno PartialEscapeBlockState.RefCount
 ;;
(final-ns RefCount
    (§ defn #_"RefCount" RefCount'new-0 []
        (Object.)
    )

    (§ mutable #_"int" :refCount 1)
)

;;;
 ; Final subclass of PartialEscapeBlockState, for performance and to make everything
 ; behave nicely with generics.
 ;
 ; @anno PartialEscapeBlockState.FinalState
 ;;
(final-ns FinalState (§ extends PartialEscapeBlockState #_"<FinalState>")
    (§ defn #_"FinalState" FinalState'new-0 []
        (PartialEscapeBlockState'new-0)
    )

    (§ defn #_"FinalState" FinalState'new-1 [#_"FinalState" other]
        (PartialEscapeBlockState'new-1 other)
    )
)

(class-ns PartialEscapeClosure #_"<BlockT extends PartialEscapeBlockState<BlockT>>" (§ extends EffectsClosure #_"<BlockT>")
    ;;;
     ; Nodes with inputs that were modified during analysis are marked in this bitset - this way
     ; nodes that are not influenced at all by analysis can be rejected quickly.
     ;;
    (§ final #_"NodeBitMap" :hasVirtualInputs nil)

    ;;;
     ; This is handed out to implementers of Virtualizable.
     ;;
    (§ final #_"VirtualizerToolImpl" :tool nil)

    ;;;
     ; The indexes into this array correspond to VirtualObjectNode#getObjectId().
     ;;
    (§ final #_"ArrayList<VirtualObjectNode>" :virtualObjects (ArrayList.))

    (§ defn #_"PartialEscapeClosure" PartialEscapeClosure'new-1 [#_"ScheduleResult" schedule]
        (let [
            #_"Graph" graph (:graph (:cfg schedule))
            #_"PartialEscapeClosure" this (EffectsClosure'new-2 schedule, (:cfg schedule))
            this (assoc this :hasVirtualInputs (NodeBitMap'new-1 graph))
            this (assoc this :tool (VirtualizerToolImpl'new-1 this))
        ]
            this
        )
    )

    #_unused
    (§ override #_"boolean" PartialEscapeClosure''needsApplyEffects-1 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this]
        (or (:changed? this)
            ;; If there is a mismatch between the number of materializations and the number of virtualizations,
            ;; we need to apply effects, even if there were no other significant changes to the graph.
            (let [
                #_"int" delta 0
                delta
                    (loop-when [delta delta #_"ISeq" s (seq (:reversePostOrder (:cfg this)))] (some? s) => delta
                        (let [
                            #_"GraphEffectList" effects (BlockMap''get-2 (:blockEffects this), (first s))
                        ]
                            (recur (if (some? effects) (+ delta (:virtualizationDelta effects)) delta) (next s))
                        )
                    )
                delta
                    (loop-when [delta delta #_"ISeq" s (seq (:loops (:cfg this)))] (some? s) => delta
                        (let [
                            #_"GraphEffectList" effects (get (:loopMergeEffects this) (first s))
                        ]
                            (recur (if (some? effects) (+ delta (:virtualizationDelta effects)) delta) (next s))
                        )
                    )
            ]
                (not (zero? delta))
            )
        )
    )

    ;;;
     ; @return true if the node was deleted, false otherwise
     ;;
    (§ override #_"boolean" PartialEscapeClosure''processNode-5 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"Node" node, #_"BlockT" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode]
        ;; These checks make up for the fact that an earliest schedule moves CallTargetNodes upwards
        ;; and thus materializes virtual objects needlessly. Also, FrameStates and ConstantNodes are
        ;; scheduled, but can safely be ignored.
        (if (or (instance? CallTargetNode node) (instance? FrameState node) (instance? ConstantNode node))
            false
            (if (instance? InvokeNode node)
                (PartialEscapeClosure''processNodeInternal-5 this, (:callTarget node), state, effects, lastFixedNode)
                (PartialEscapeClosure''processNodeInternal-5 this, node, state, effects, lastFixedNode)
            )
        )
    )

    (§ method- #_"boolean" PartialEscapeClosure''processNodeInternal-5 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"Node" node, #_"BlockT" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode]
        (let [
            #_"FixedNode" nextFixedNode (when (some? lastFixedNode) (:next lastFixedNode))
        ]
            (when (PartialEscapeClosure''requiresProcessing-2 this, node)
                (when-not (PartialEscapeClosure''processVirtualizable-5 this, (§ cast #_"ValueNode" node), nextFixedNode, state, effects)
                    (§ return false)
                )
                (when (:deleted (:tool this))
                    (§ return true)
                )
            )
            (when (and (NodeBitMap''isMarked-2 (:hasVirtualInputs this), node) (instance? ValueNode node))
                (when (instance? Virtualizable node)
                    (when-not (PartialEscapeClosure''processVirtualizable-5 this, node, nextFixedNode, state, effects)
                        (§ return false)
                    )
                    (when (:deleted (:tool this))
                        (§ return true)
                    )
                )
                (PartialEscapeClosure''processNodeInputs-5 this, (§ cast #_"ValueNode" node), nextFixedNode, state, effects)
            )

            (and (EffectsClosure''hasScalarReplacedInputs-2 this, node) (instance? ValueNode node) (PartialEscapeClosure''processNodeWithScalarReplacedInputs-5 this, node, nextFixedNode, state, effects))
        )
    )

    (§ method! #_"boolean" PartialEscapeClosure''requiresProcessing-2 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"Node" node]
        (instance? VirtualizableAllocation node)
    )

    (§ method- #_"boolean" PartialEscapeClosure''processVirtualizable-5 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValueNode" node, #_"FixedNode" insertBefore, #_"BlockT" state, #_"GraphEffectList" effects]
        (§ ass! (:tool this) (VirtualizerToolImpl''reset-5 (:tool this), state, node, insertBefore, effects))
        (PartialEscapeClosure''virtualize-3 this, node, (:tool this))
    )

    (§ method #_"boolean" PartialEscapeClosure''virtualize-3 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValueNode" node, #_"VirtualizerTool" vt]
        (Virtualizable''virtualize-2 node, vt)
        true ;; request further processing
    )

    ;;;
     ; This tries to canonicalize the node based on improved (replaced) inputs.
     ;;
    (§ method- #_"boolean" PartialEscapeClosure''processNodeWithScalarReplacedInputs-5 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValueNode" node, #_"FixedNode" insertBefore, #_"BlockT" state, #_"GraphEffectList" effects]
        (let [
            #_"ValueNode" canonicalizedValue
                (condp instance? node
                    Unary
                        (let [
                            #_"ObjectState" valueObj (PartialEscapeClosure''getObjectState-3 this, state, (Unary''getValue-1 node))
                            #_"ValueNode" valueAlias (if (some? valueObj) (:materializedValue valueObj) (EffectsClosure''getScalarAlias-2 this, (Unary''getValue-1 node)))
                        ]
                            (when-not (= valueAlias (Unary''getValue-1 node)) => node
                                (Unary''canonical-3 node, (:tool this), valueAlias)
                            )
                        )
                    Binary
                        (let [
                            #_"ObjectState" xObj (PartialEscapeClosure''getObjectState-3 this, state, (:x node))
                            #_"ValueNode" xAlias (if (some? xObj) (:materializedValue xObj) (EffectsClosure''getScalarAlias-2 this, (:x node)))
                            #_"ObjectState" yObj (PartialEscapeClosure''getObjectState-3 this, state, (:y node))
                            #_"ValueNode" yAlias (if (some? yObj) (:materializedValue yObj) (EffectsClosure''getScalarAlias-2 this, (:y node)))
                        ]
                            (when-not (and (= xAlias (:x node)) (= yAlias (:y node))) => node
                                (Binary''canonical-4 node, (:tool this), xAlias, yAlias)
                            )
                        )
                    (§ return false)
                )
        ]
            (and (some? canonicalizedValue) (not= canonicalizedValue node)
                (if (Node''isAlive-1 canonicalizedValue)
                    (let [
                        #_"ValueNode" alias (PartialEscapeClosure''getAliasAndResolve-3 this, state, canonicalizedValue)
                    ]
                        (if (instance? VirtualObjectNode alias)
                            (do
                                (PartialEscapeClosure''addVirtualAlias-3 this, alias, node)
                                (GraphEffectList''deleteNode-2 effects, node)
                            )
                            (do
                                (GraphEffectList''replaceAtUsages-4 effects, node, alias, insertBefore)
                                (EffectsClosure''addScalarAlias-3 this, node, alias)
                            )
                        )
                        true
                    )
                    (and (PartialEscapeClosure''prepareCanonicalNode-4 this, canonicalizedValue, state, effects)
                        (do
                            (if (instance? ControlSinkNode canonicalizedValue)
                                (do
                                    (GraphEffectList''replaceWithSink-3 effects, (§ cast #_"FixedWithNextNode" node), canonicalizedValue)
                                    (§ ass! state (EffectsBlockState''markAsDead-1 state))
                                )
                                (do
                                    (GraphEffectList''replaceAtUsages-4 effects, node, canonicalizedValue, insertBefore)
                                    (EffectsClosure''addScalarAlias-3 this, node, canonicalizedValue)
                                )
                            )
                            true
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Nodes created during canonicalizations need to be scanned for values that were replaced.
     ;;
    (§ method- #_"boolean" PartialEscapeClosure''prepareCanonicalNode-4 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValueNode" node, #_"BlockT" state, #_"GraphEffectList" effects]
        (loop-when [#_"ISeq" s (seq (Node''inputPositions-1 node))] (some? s) => true
            (let [
                #_"Position" pos (first s)
                #_"Node" input (Position''get-2 pos, node)
            ]
                (and
                    (when (instance? ValueNode input) => true
                        (if (Node''isAlive-1 input)
                            (when-not (instance? VirtualObjectNode input) => true
                                (let [
                                    #_"ObjectState" obj (PartialEscapeClosure''getObjectState-3 this, state, input)
                                ]
                                    (if (nil? obj)
                                        (do
                                            (Position''initialize-3 pos, node, (EffectsClosure''getScalarAlias-2 this, input))
                                            true
                                        )
                                        (if (ObjectState''isVirtual-1 obj)
                                            false
                                            (do
                                                (Position''initialize-3 pos, node, (:materializedValue obj))
                                                true
                                            )
                                        )
                                    )
                                )
                            )
                            (PartialEscapeClosure''prepareCanonicalNode-4 this, input, state, effects)
                        )
                    )
                    (recur (next s))
                )
            )
        )
    )

    ;;;
     ; This replaces all inputs that point to virtual or materialized values with the actual value,
     ; materializing if necessary.
     ; Also takes care of frame states, adding the necessary VirtualObjectState.
     ;;
    (§ method- #_"void" PartialEscapeClosure''processNodeInputs-5 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValueNode" node, #_"FixedNode" insertBefore, #_"BlockT" state, #_"GraphEffectList" effects]
        (doseq [#_"Node" input (Node''inputs-1 node)]
            (when (instance? ValueNode input)
                (let [
                    #_"ValueNode" alias (PartialEscapeClosure''getAlias-2 this, input)
                ]
                    (when (instance? VirtualObjectNode alias)
                        (let [
                            #_"int" id (VirtualObjectNode''getObjectId-1 alias)
                        ]
                            (PartialEscapeClosure''ensureMaterialized-5 this, state, id, insertBefore, effects)
                            (GraphEffectList''replaceFirstInput-4 effects, node, input, (:materializedValue (PartialEscapeBlockState''getObjectState-2 state, id)))
                        )
                    )
                )
            )
        )
        (when (instance? NodeWithState node)
            (PartialEscapeClosure''processNodeWithState-4 this, node, state, effects)
        )
        nil
    )

    (§ method- #_"void" PartialEscapeClosure''processNodeWithState-4 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"NodeWithState" nodeWithState, #_"BlockT" state, #_"GraphEffectList" effects]
        (doseq [#_"FrameState" fs (NodeWithState''states-1 nodeWithState)]
            (let [
                #_"FrameState" frameState (PartialEscapeClosure'getUniqueFramestate-2 nodeWithState, fs)
                #_"EconomicSet<VirtualObjectNode>" virtual (EconomicSet/create Equivalence/IDENTITY_WITH_SYSTEM_HASHCODE)
            ]
                (FrameState''applyToNonVirtual-2 frameState, (CollectVirtualObjectsClosure'new-4 this, virtual, effects, state))
                (PartialEscapeClosure''collectLockedVirtualObjects-3 this, state, virtual)
                (PartialEscapeClosure''collectReferencedVirtualObjects-3 this, state, virtual)
                (PartialEscapeClosure''addVirtualMappings-5 this, frameState, virtual, state, effects)
            )
        )
        nil
    )

    (§ defn- #_"FrameState" PartialEscapeClosure'getUniqueFramestate-2 [#_"NodeWithState" nodeWithState, #_"FrameState" frameState]
        (when (Node''hasMoreThanOneUsage-1 frameState) => frameState
            ;; Can happen for example from inlined snippets with multiple state split nodes.
            (let [
                #_"FrameState" copy (Node''copyWithInputs-1 frameState)
            ]
                (Node''replaceFirstInput-3 nodeWithState, frameState, copy)
                copy
            )
        )
    )

    (§ method- #_"void" PartialEscapeClosure''addVirtualMappings-5 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"FrameState" frameState, #_"EconomicSet<VirtualObjectNode>" virtual, #_"BlockT" state, #_"GraphEffectList" effects]
        (doseq [#_"VirtualObjectNode" obj virtual]
            (GraphEffectList''addVirtualMapping-3 effects, frameState, (ObjectState''createEscapeObjectState-2 (PartialEscapeBlockState''getObjectState-2 state, obj), obj))
        )
        nil
    )

    (§ method- #_"void" PartialEscapeClosure''collectReferencedVirtualObjects-3 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"BlockT" state, #_"EconomicSet<VirtualObjectNode>" virtual]
        (let [
            #_"Iterator<VirtualObjectNode>" it (#_"EconomicSet" .iterator virtual)
        ]
            (while (#_"Iterator" .hasNext it)
                (let [
                    #_"int" id (VirtualObjectNode''getObjectId-1 (#_"Iterator" .next it))
                ]
                    (when-not (= id -1)
                        (let [
                            #_"ObjectState" objState (PartialEscapeBlockState''getObjectStateOptional-2 state, id)
                        ]
                            (when (and (some? objState) (ObjectState''isVirtual-1 objState))
                                (doseq [#_"ValueNode" entry (:entries objState)]
                                    (when (instance? VirtualObjectNode entry)
                                        (when-not (contains? virtual entry)
                                            (#_"EconomicSet" .add virtual, entry)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" PartialEscapeClosure''collectLockedVirtualObjects-3 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"BlockT" state, #_"EconomicSet<VirtualObjectNode>" virtual]
        (dotimes [#_"int" i (count (:objectStates state))]
            (let [
                #_"ObjectState" objState (PartialEscapeBlockState''getObjectStateOptional-2 state, i)
            ]
                (when (and (some? objState) (ObjectState''isVirtual-1 objState) (ObjectState''hasLocks-1 objState))
                    (#_"EconomicSet" .add virtual, (nth (:virtualObjects this) i))
                )
            )
        )
        nil
    )

    ;;;
     ; @return true if materialization happened, false if not
     ;;
    (§ method #_"boolean" PartialEscapeClosure''ensureMaterialized-5 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"PartialEscapeBlockState" state, #_"int" object, #_"FixedNode" materializeBefore, #_"GraphEffectList" effects]
        (and (ObjectState''isVirtual-1 (PartialEscapeBlockState''getObjectState-2 state, object))
            (do
                (PartialEscapeBlockState''materializeBefore-4 state, materializeBefore, (nth (:virtualObjects this) object), effects)
                true
            )
        )
    )

    (§ defn #_"boolean" PartialEscapeClosure'updateStatesForMaterialized-3 [#_"PartialEscapeBlockState" state, #_"VirtualObjectNode" virtual, #_"ValueNode" materializedValue]
        ;; update all existing states with the newly materialized object
        (loop-when [#_"boolean" changed? false #_"int" i 0] (< i (count (:objectStates state))) => changed?
            (let [
                #_"ObjectState" objState (PartialEscapeBlockState''getObjectStateOptional-2 state, i)
                changed?
                    (when (and (some? objState) (ObjectState''isVirtual-1 objState)) => changed?
                        (let [
                            #_"ValueNode[]" entries (:entries objState)
                        ]
                            (loop-when [changed? changed? #_"int" j 0] (< j (count entries)) => changed?
                                (let [
                                    changed?
                                        (when (= (nth entries j) virtual) => changed?
                                            (PartialEscapeBlockState''setEntry-4 state, i, j, materializedValue)
                                            true
                                        )
                                ]
                                    (recur changed? (inc j))
                                )
                            )
                        )
                    )
            ]
                (recur changed? (inc i))
            )
        )
    )

    (§ override #_"BlockT" PartialEscapeClosure''stripKilledLoopLocations-3 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"Loop" loop, #_"BlockT" originalInitialState]
        (let [
            #_"BlockT" initialState (EffectsClosure''stripKilledLoopLocations-3 (§ super ), loop, originalInitialState)
        ]
            (when (< GraalOptions'escapeAnalysisLoopCutoff (:depth loop))
                ;; After we've reached the maximum loop nesting, we'll simply materialize everything we
                ;; can to make sure that the loops only need to be iterated one time. Care is taken here
                ;; to not materialize virtual objects that have the "ensureVirtualized" flag set.
                (let [
                    #_"LoopBeginNode" loopBegin (:beginNode (:header loop))
                    #_"AbstractEndNode" end (LoopBeginNode''forwardEnd-1 loopBegin)
                    #_"Block" loopPredecessor (Block''getFirstPredecessor-1 (:header loop))
                    #_"int" length (count (:objectStates initialState))
                    #_"BitSet" ensureVirtualized (BitSet. length)
                ]
                    (dotimes [#_"int" i length]
                        (let [
                            #_"ObjectState" state (PartialEscapeBlockState''getObjectStateOptional-2 initialState, i)
                        ]
                            (when (and (some? state) (ObjectState''isVirtual-1 state) (:ensureVirtualized state))
                                (#_"BitSet" .set ensureVirtualized, i)
                            )
                        )
                    )
                    (loop []
                        ;; propagate "ensureVirtualized" flag
                        (let [
                            #_"boolean" changed?
                                (loop-when [changed? false #_"int" i 0] (< i length) => changed?
                                    (let [
                                        changed?
                                            (when-not (#_"BitSet" .get ensureVirtualized, i) => changed?
                                                (let [
                                                    #_"ObjectState" state (PartialEscapeBlockState''getObjectStateOptional-2 initialState, i)
                                                ]
                                                    (when (and (some? state) (ObjectState''isVirtual-1 state)) => changed?
                                                        (loop-when [changed? changed? #_"ISeq" s (seq (:entries state))] (some? s) => changed?
                                                            (let [
                                                                #_"ValueNode" entry (first s)
                                                            ]
                                                                (when (and (instance? VirtualObjectNode entry) (#_"BitSet" .get ensureVirtualized, (VirtualObjectNode''getObjectId-1 entry))) => (recur changed? (next s))
                                                                    (#_"BitSet" .set ensureVirtualized, i)
                                                                    true
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                    ]
                                        (recur changed? (inc i))
                                    )
                                )
                        ]
                            (recur-if changed? [])
                        )
                    )

                    (dotimes [#_"int" i length]
                        (let [
                            #_"ObjectState" state (PartialEscapeBlockState''getObjectStateOptional-2 initialState, i)
                        ]
                            (when (and (some? state) (ObjectState''isVirtual-1 state) (not (#_"BitSet" .get ensureVirtualized, i)))
                                (PartialEscapeBlockState''materializeBefore-4 initialState, end, (nth (:virtualObjects this) i), (BlockMap''get-2 (:blockEffects this), loopPredecessor))
                            )
                        )
                    )
                )
            )
            initialState
        )
    )

    (§ override #_"void" PartialEscapeClosure''processInitialLoopState-3 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"Loop" loop, #_"BlockT" initialState]
        (doseq [#_"PhiNode" phi (AbstractMergeNode''phis-1 (:beginNode (:header loop)))]
            (when (some? (PhiNode''valueAt-2 phi, 0))
                (let [
                    #_"ValueNode" alias (PartialEscapeClosure''getAliasAndResolve-3 this, initialState, (PhiNode''valueAt-2 phi, 0))
                ]
                    (if (instance? VirtualObjectNode alias)
                        (PartialEscapeClosure''addVirtualAlias-3 this, alias, phi)
                        (NodeMap''set-3 (:aliases this), phi, nil)
                    )
                )
            )
        )
        nil
    )

    (§ override #_"void" PartialEscapeClosure''processLoopExit-5 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"LoopExitNode" exitNode, #_"BlockT" initialState, #_"BlockT" exitState, #_"GraphEffectList" effects]
        (when (:hasValueProxies (:graph exitNode))
            (let [
                #_"EconomicMap<Integer, ProxyNode>" proxies (EconomicMap/create Equivalence/DEFAULT)
            ]
                (doseq [#_"ProxyNode" proxy (LoopExitNode''proxies-1 exitNode)]
                    (let [
                        #_"ValueNode" alias (PartialEscapeClosure''getAlias-2 this, (ProxyNode''value-1 proxy))
                    ]
                        (when (instance? VirtualObjectNode alias)
                            (#_"EconomicMap" .put proxies, (VirtualObjectNode''getObjectId-1 alias), proxy)
                        )
                    )
                )
                (dotimes [#_"int" i (count (:objectStates exitState))]
                    (let [
                        #_"ObjectState" exitObjState (PartialEscapeBlockState''getObjectStateOptional-2 exitState, i)
                    ]
                        (when (some? exitObjState)
                            (let [
                                #_"ObjectState" initialObjState (PartialEscapeBlockState''getObjectStateOptional-2 initialState, i)
                            ]
                                (if (ObjectState''isVirtual-1 exitObjState)
                                    (PartialEscapeClosure'processVirtualAtLoopExit-6 exitNode, effects, i, exitObjState, initialObjState, exitState)
                                    (PartialEscapeClosure'processMaterializedAtLoopExit-7 exitNode, effects, proxies, i, exitObjState, initialObjState, exitState)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" PartialEscapeClosure'processMaterializedAtLoopExit-7 [#_"LoopExitNode" exitNode, #_"GraphEffectList" effects, #_"EconomicMap<Integer, ProxyNode>" proxies, #_"int" object, #_"ObjectState" exitObjState, #_"ObjectState" initialObjState, #_"PartialEscapeBlockState" exitState]
        (when (or (nil? initialObjState) (ObjectState''isVirtual-1 initialObjState))
            (let [
                #_"ProxyNode" proxy (get proxies object)
            ]
                (if (nil? proxy)
                    (do
                        (§ ass proxy (ValueProxyNode'new-2 (:materializedValue exitObjState), exitNode))
                        (GraphEffectList''addFloatingNode-3 effects, proxy, "proxy")
                    )
                    (do
                        (GraphEffectList''replaceFirstInput-4 effects, proxy, (ProxyNode''value-1 proxy), (:materializedValue exitObjState))
                        ;; nothing to do - will be handled in processNode
                    )
                )
                (PartialEscapeBlockState''updateMaterializedValue-3 exitState, object, proxy)
            )
        )
        nil
    )

    (§ defn- #_"void" PartialEscapeClosure'processVirtualAtLoopExit-6 [#_"LoopExitNode" exitNode, #_"GraphEffectList" effects, #_"int" object, #_"ObjectState" exitObjState, #_"ObjectState" initialObjState, #_"PartialEscapeBlockState" exitState]
        (dotimes [#_"int" i (count (:entries exitObjState))]
            (let [
                #_"ValueNode" value (ObjectState''getEntry-2 (PartialEscapeBlockState''getObjectState-2 exitState, object), i)
            ]
                (when-not (or (instance? VirtualObjectNode value) (instance? ConstantNode value))
                    (when-not (and (not (AbstractMergeNode''isPhiAtMerge-2 (:loopBegin exitNode), value)) (some? initialObjState) (ObjectState''isVirtual-1 initialObjState) (= (ObjectState''getEntry-2 initialObjState, i) value))
                        (let [
                            #_"ProxyNode" proxy (ValueProxyNode'new-2 value, exitNode)
                        ]
                            (PartialEscapeBlockState''setEntry-4 exitState, object, i, proxy)
                            (GraphEffectList''addFloatingNode-3 effects, proxy, "virtualProxy")
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override #_"PEMergeProcessor<BlockT>" PartialEscapeClosure''createMergeProcessor-2 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"Block" merge]
        (PEMergeProcessor'new-2 this, merge)
    )

    (§ method #_"ObjectState" PartialEscapeClosure''getObjectState-3 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"PartialEscapeBlockState" state, #_"ValueNode" value]
        (when (some? value)
            (if (and (Node''isAlive-1 value) (not (NodeMap''isNew-2 (:aliases this), value)))
                (let [
                    #_"ValueNode" object (NodeMap''get-2 (:aliases this), value)
                ]
                    (when (instance? VirtualObjectNode object) (PartialEscapeBlockState''getObjectStateOptional-2 state, object))
                )
                (when (instance? VirtualObjectNode value) (PartialEscapeBlockState''getObjectStateOptional-2 state, value))
            )
        )
    )

    (§ method #_"ValueNode" PartialEscapeClosure''getAlias-2 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValueNode" value]
        (if (and (some? value) (not (instance? VirtualObjectNode value)) (Node''isAlive-1 value) (not (NodeMap''isNew-2 (:aliases this), value)))
            (or (NodeMap''get-2 (:aliases this), value)
                value
            )
            value
        )
    )

    (§ method! #_"ValueNode" PartialEscapeClosure''getAliasAndResolve-3 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"PartialEscapeBlockState" state, #_"ValueNode" value]
        (let [
            #_"ValueNode" result (PartialEscapeClosure''getAlias-2 this, value)
        ]
            (when (instance? VirtualObjectNode result)
                (let [
                    #_"int" id (VirtualObjectNode''getObjectId-1 result)
                ]
                    (when (and (not= id -1) (not (ObjectState''isVirtual-1 (PartialEscapeBlockState''getObjectState-2 state, id))))
                        (§ ass result (:materializedValue (PartialEscapeBlockState''getObjectState-2 state, id)))
                    )
                )
            )
            result
        )
    )

    (§ method! #_"void" PartialEscapeClosure''addVirtualAlias-3 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"VirtualObjectNode" virtual, #_"ValueNode" node]
        (when (Node''isAlive-1 node)
            (NodeMap''set-3 (:aliases this), node, virtual)
            (doseq [#_"Node" usage (Node''usages-1 node)]
                (PartialEscapeClosure''markVirtualUsages-2 this, usage)
            )
        )
        nil
    )

    (§ method- #_"void" PartialEscapeClosure''markVirtualUsages-2 [#_"PartialEscapeClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"Node" node]
        (when (and (not (NodeBitMap''isNew-2 (:hasVirtualInputs this), node)) (not (NodeBitMap''isMarked-2 (:hasVirtualInputs this), node)))
            (NodeBitMap''mark-2 (:hasVirtualInputs this), node)
            (when (instance? VirtualState node)
                (doseq [#_"Node" usage (Node''usages-1 node)]
                    (PartialEscapeClosure''markVirtualUsages-2 this, usage)
                )
            )
        )
        nil
    )
)

;;;
 ; @anno PartialEscapeClosure.PEMergeProcessor
 ;;
(class-ns PEMergeProcessor #_"<BlockT extends PartialEscapeBlockState<BlockT>>" (§ extends MergeProcessor #_"<BlockT>")
    (§ final #_"PartialEscapeClosure<BlockT>" :peClosure nil)

    (§ mutable #_"EconomicMap<Object, ValuePhiNode>" :materializedPhis nil)
    (§ mutable #_"EconomicMap<ValueNode, ValuePhiNode[]>" :valuePhis nil)
    (§ mutable #_"EconomicMap<ValuePhiNode, VirtualObjectNode>" :valueObjectVirtuals nil)

    (§ final #_"boolean" :needsCaching false)

    (§ defn #_"PEMergeProcessor" PEMergeProcessor'new-2 [#_"PartialEscapeClosure<BlockT>" peClosure, #_"Block" mergeBlock]
        (let [
            #_"PEMergeProcessor" this (MergeProcessor'new-1 mergeBlock)
            this (assoc this :peClosure peClosure)
            ;; merge will only be called multiple times for loop headers
            this (assoc this :needsCaching (Block''isLoopHeader-1 mergeBlock))
        ]
            this
        )
    )

    (§ method! #_"<T> PhiNode" PEMergeProcessor''getPhi-3 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"T" virtual, #_"Stamp" stamp]
        (if (:needsCaching this)
            (PEMergeProcessor''getPhiCached-3 this, virtual, stamp)
            (MergeProcessor''createValuePhi-2 this, stamp)
        )
    )

    (§ method- #_"<T> PhiNode" PEMergeProcessor''getPhiCached-3 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"T" virtual, #_"Stamp" stamp]
        (when (nil? (:materializedPhis this))
            (§ ass! this (assoc this :materializedPhis (EconomicMap/create Equivalence/DEFAULT)))
        )
        (let [
            #_"ValuePhiNode" result (get (:materializedPhis this) virtual)
        ]
            (when (nil? result)
                (§ ass result (MergeProcessor''createValuePhi-2 this, stamp))
                (#_"EconomicMap" .put (:materializedPhis this), virtual, result)
            )
            result
        )
    )

    (§ method- #_"PhiNode[]" PEMergeProcessor''getValuePhis-3 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValueNode" key, #_"int" entryCount]
        (if (:needsCaching this)
            (PEMergeProcessor''getValuePhisCached-3 this, key, entryCount)
            (make-array ValuePhiNode entryCount)
        )
    )

    (§ method- #_"PhiNode[]" PEMergeProcessor''getValuePhisCached-3 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValueNode" key, #_"int" entryCount]
        (when (nil? (:valuePhis this))
            (§ ass! this (assoc this :valuePhis (EconomicMap/create Equivalence/IDENTITY_WITH_SYSTEM_HASHCODE)))
        )
        (let [
            #_"ValuePhiNode[]" result (get (:valuePhis this) key)
        ]
            (when (nil? result)
                (§ ass result (make-array ValuePhiNode entryCount))
                (#_"EconomicMap" .put (:valuePhis this), key, result)
            )
            result
        )
    )

    (§ method- #_"VirtualObjectNode" PEMergeProcessor''getValueObjectVirtual-3 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValuePhiNode" phi, #_"VirtualObjectNode" virtual]
        (if (:needsCaching this)
            (PEMergeProcessor''getValueObjectVirtualCached-3 this, phi, virtual)
            (VirtualObjectNode''duplicate-1 virtual)
        )
    )

    (§ method- #_"VirtualObjectNode" PEMergeProcessor''getValueObjectVirtualCached-3 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValuePhiNode" phi, #_"VirtualObjectNode" virtual]
        (when (nil? (:valueObjectVirtuals this))
            (§ ass! this (assoc this :valueObjectVirtuals (EconomicMap/create Equivalence/IDENTITY)))
        )
        (let [
            #_"VirtualObjectNode" result (get (:valueObjectVirtuals this) phi)
        ]
            (when (nil? result)
                (§ ass result (VirtualObjectNode''duplicate-1 virtual))
                (#_"EconomicMap" .put (:valueObjectVirtuals this), phi, result)
            )
            result
        )
    )

    ;;;
     ; Merge all predecessor block states into one block state. This is an iterative process,
     ; because merging states can lead to materializations which make previous parts of the
     ; merging operation invalid. The merging process is executed until a stable state has been
     ; reached. This method needs to be careful to place the effects of the merging operation
     ; into the correct blocks.
     ;
     ; @param statesList the predecessor block states of the merge
     ;;
    (§ override #_"void" PEMergeProcessor''merge-2 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"List<BlockT>" statesList]
        (let [
            #_"PartialEscapeBlockState[]" states (make-array PartialEscapeBlockState (count statesList))
            _
                (dotimes [#_"int" i (count statesList)]
                    (aset states i (nth statesList i))
                )
            ;; calculate the set of virtual objects that exist in all predecessors
            #_"int[]" virtualObjTemp (PEMergeProcessor''intersectVirtualObjects-2 this, states)
        ]
            (loop []
                (let [
                    #_"boolean" materialized?
                        (if (PartialEscapeBlockState'identicalObjectStates-1 states)
                            (do
                                (§ ass! (:newState this) (PartialEscapeBlockState''adoptAddObjectStates-2 (:newState this), (nth states 0)))
                                false
                            )
                            (loop-when [materialized? false #_"ISeq" s (seq virtualObjTemp)] (some? s) => materialized?
                                (let [
                                    #_"int" object (first s)
                                    materialized?
                                        (when (PartialEscapeBlockState'identicalObjectStates-2 states, object) => materialized?
                                            (PartialEscapeBlockState''addObject-3 (:newState this), object, (ObjectState''share-1 (PartialEscapeBlockState''getObjectState-2 (nth states 0), object)))
                                            ;; determine if all inputs are virtual or the same materialized value
                                            (let [
                                                #_"ObjectState" startObj (PartialEscapeBlockState''getObjectState-2 (nth states 0), object)
                                                [#_"boolean" ensureVirtual #_"int" virtualCount #_"ValueNode" uniqueMaterializedValue #_"boolean" locksMatch]
                                                    (loop-when [ensureVirtual true virtualCount 0 uniqueMaterializedValue (when-not (ObjectState''isVirtual-1 startObj) (:materializedValue startObj)) locksMatch true #_"int" i 0] (< i (count states)) => [ensureVirtual virtualCount uniqueMaterializedValue locksMatch]
                                                        (let [
                                                            #_"ObjectState" obj (PartialEscapeBlockState''getObjectState-2 (nth states i), object)
                                                            ensureVirtual (and ensureVirtual (:ensureVirtualized obj))
                                                            [virtualCount uniqueMaterializedValue locksMatch]
                                                                (if (ObjectState''isVirtual-1 obj)
                                                                    [(inc virtualCount) nil (and locksMatch (ObjectState''locksEqual-2 obj, startObj))]
                                                                    [virtualCount (when (= (:materializedValue obj) uniqueMaterializedValue) uniqueMaterializedValue) locksMatch]
                                                                )
                                                        ]
                                                            (recur ensureVirtual virtualCount uniqueMaterializedValue locksMatch (inc i))
                                                        )
                                                    )
                                            ]
                                                (cond
                                                    (and (= virtualCount (count states)) locksMatch)
                                                        (or materialized? (PEMergeProcessor''mergeObjectStates-4 this, object, nil, states))
                                                    (some? uniqueMaterializedValue)
                                                        (do
                                                            (PartialEscapeBlockState''addObject-3 (:newState this), object, (ObjectState'new-3 uniqueMaterializedValue, nil, ensureVirtual))
                                                            materialized?
                                                        )
                                                    :else
                                                        (let [
                                                            #_"PhiNode" materializedValuePhi (PEMergeProcessor''getPhi-3 this, object, (StampFactory'forKind-1 JavaKind/Object))
                                                            _ (GraphEffectList''addFloatingNode-3 (:mergeEffects this), materializedValuePhi, "materializedPhi")
                                                            materialized?
                                                                (loop-when [materialized? materialized? #_"int" i 0] (< i (count states)) => materialized?
                                                                    (let [
                                                                        #_"ObjectState" obj (PartialEscapeBlockState''getObjectState-2 (nth states i), object)
                                                                        [materialized? obj]
                                                                            (when (ObjectState''isVirtual-1 obj) => [materialized? obj]
                                                                                (let [
                                                                                    #_"Block" predecessor (MergeProcessor''getPredecessor-2 this, i)
                                                                                ]
                                                                                    (when (and (not ensureVirtual) (ObjectState''isVirtual-1 obj))
                                                                                        ;; we can materialize if not all inputs are "ensureVirtualized"
                                                                                        (§ ass! obj (ObjectState''setEnsureVirtualized-2 obj, false))
                                                                                    )
                                                                                    [(or materialized? (PartialEscapeClosure''ensureMaterialized-5 (:peClosure this), (nth states i), object, (:endNode predecessor), (BlockMap''get-2 (:blockEffects (:peClosure this)), predecessor))) (PartialEscapeBlockState''getObjectState-2 (nth states i), object)]
                                                                                )
                                                                            )
                                                                    ]
                                                                        (MergeProcessor''setPhiInput-4 this, materializedValuePhi, i, (:materializedValue obj))
                                                                        (recur materialized? (inc i))
                                                                    )
                                                                )
                                                        ]
                                                            (PartialEscapeBlockState''addObject-3 (:newState this), object, (ObjectState'new-3 materializedValuePhi, nil, false))
                                                            materialized?
                                                        )
                                                )
                                            )
                                        )
                                ]
                                    (recur materialized? (next s))
                                )
                            )
                        )
                    materialized?
                        (loop-when [materialized? materialized? #_"ISeq" s (seq (MergeProcessor''getPhis-1 this))] (some? s) => materialized?
                            (let [
                                #_"PhiNode" phi (first s)
                            ]
                                (NodeMap''set-3 (:aliases (:peClosure this)), phi, nil)
                                (recur (or materialized? (and (NodeBitMap''isMarked-2 (:hasVirtualInputs (:peClosure this)), phi) (instance? ValuePhiNode phi) (PEMergeProcessor''processPhi-3 this, phi, states))) (next s))
                            )
                        )
                ]
                    (when materialized?
                        (§ ass! (:newState this) (PartialEscapeBlockState''resetObjectStates-2 (:newState this), (count (:virtualObjects (:peClosure this)))))
                        (GraphEffectList''clear-1 (:mergeEffects this))
                        (GraphEffectList''clear-1 (:afterMergeEffects this))
                    )
                    (recur-if materialized? [])
                )
            )
        )
        nil
    )

    (§ method- #_"int[]" PEMergeProcessor''intersectVirtualObjects-2 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"PartialEscapeBlockState[]" states]
        (let [
            #_"int" m
                (loop-when-recur [m (count (:objectStates (nth states 0))) #_"int" i 1]
                                 (< i (count states))
                                 [(min m (count (:objectStates (nth states i)))) (inc i)]
                              => m
                )
            #_"int" n
                (loop-when-recur [n 0 #_"int" j 0] (< j m) [(if (PEMergeProcessor''intersectObjectState-3 this, states, j) (inc n) n) (inc j)] => n)
            #_"int[]" a (int-array n)
        ]
            (loop-when [#_"int" i 0 #_"int" j 0] (< j m)
                (when (PEMergeProcessor''intersectObjectState-3 this, states, j) => (recur i (inc j))
                    (aset a i j)
                    (recur (inc i) (inc j))
                )
            )
            a
        )
    )

    (§ method- #_"boolean" PEMergeProcessor''intersectObjectState-3 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"PartialEscapeBlockState[]" states, #_"int" objectIndex]
        (loop-when [#_"int" i 0] (< i (count states)) => true
            (and (some? (PartialEscapeBlockState''getObjectStateOptional-2 (nth states i), objectIndex))
                (recur (inc i))
            )
        )
    )

    ;;;
     ; Try to merge multiple virtual object states into a single object state. If the incoming
     ; object states are compatible, then this method will create PhiNodes for the object's
     ; entries where needed. If they are incompatible, then all incoming virtual objects will be
     ; materialized, and a PhiNode for the materialized values will be created. Object states
     ; can be incompatible if they contain {@code long} or {@code double} values occupying two
     ; {@code int} slots in such a way that that their values cannot be merged using PhiNodes.
     ;
     ; @param states the predecessor block states of the merge
     ; @return true if materialization happened during the merge, false otherwise
     ;;
    (§ method- #_"boolean" PEMergeProcessor''mergeObjectStates-4 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"int" resultObject, #_"int[]" sourceObjects, #_"PartialEscapeBlockState[]" states]
        (let [
            #_"IntUnaryOperator" getObject (ß index -> (§ fun (if (some? sourceObjects) (nth sourceObjects index) resultObject)))
            #_"VirtualObjectNode" virtual (nth (:virtualObjects (:peClosure this)) resultObject)
            #_"int" entryCount (VirtualObjectNode''entryCount-1 virtual)
            ;; determine all entries that have a two-slot value
            [#_"boolean" ensure? #_"boolean" compatible? #_"JavaKind[]" twoSlotKinds]
                (loop-when [ensure? true #_"int" j 0 twoSlotKinds nil] (< j (count states)) => [ensure? true twoSlotKinds]
                    (let [
                        #_"ObjectState" objectState (PartialEscapeBlockState''getObjectState-2 (nth states j), (#_"IntUnaryOperator" .applyAsInt getObject, j))
                        #_"ValueNode[]" entries (:entries objectState)
                        ensure? (and ensure? (:ensureVirtualized objectState))
                        [compatible? twoSlotKinds]
                            (loop-when [twoSlotKinds twoSlotKinds #_"int" i 0] (< i entryCount) => [true twoSlotKinds]
                                (let [
                                    #_"JavaKind" otherKind (ValueNode''getStackKind-1 (nth entries i))
                                    #_"JavaKind" entryKind (VirtualObjectNode''entryKind-2 virtual, i)
                                ]
                                    (when (and (= entryKind JavaKind/Int) (#_"JavaKind" .needsTwoSlots otherKind)) => (recur twoSlotKinds (inc i))
                                        (let [
                                            twoSlotKinds (or twoSlotKinds (make-array JavaKind entryCount))
                                        ]
                                            (when (or (nil? (nth twoSlotKinds i)) (= (nth twoSlotKinds i) otherKind)) => [false twoSlotKinds]
                                                (aset twoSlotKinds i otherKind)
                                                ;; skip the next entry
                                                (recur twoSlotKinds (+ i 2))
                                            )
                                        )
                                    )
                                )
                            )
                    ]
                        (recur-if compatible? [ensure? (inc j) twoSlotKinds] => [ensure? false twoSlotKinds])
                    )
                )
            compatible?
                (when (and compatible? (some? twoSlotKinds)) => compatible?
                    ;; if there are two-slot values then make sure the incoming states can be merged
                    (loop-when [#_"int" i 0] (< i entryCount) => true
                        (let [
                            compatible?
                                (when (some? (nth twoSlotKinds i)) => true
                                    (loop-when [#_"int" j 0] (< j (count states)) => true
                                        (let [
                                            #_"int" object (#_"IntUnaryOperator" .applyAsInt getObject, j)
                                            #_"ObjectState" objectState (PartialEscapeBlockState''getObjectState-2 (nth states j), object)
                                            #_"ValueNode" value (ObjectState''getEntry-2 objectState, i)
                                            #_"JavaKind" valueKind (ValueNode''getStackKind-1 value)
                                            compatible?
                                                (when-not (= valueKind (nth twoSlotKinds i)) => true
                                                    (let [
                                                        #_"ValueNode" nextValue (ObjectState''getEntry-2 objectState, (inc i))
                                                    ]
                                                        (and (instance? ConstantNode value) (= (:value value) JavaConstant/INT_0) (instance? ConstantNode nextValue) (= (:value nextValue) JavaConstant/INT_0)
                                                            (do
                                                                ;; rewrite to a zero constant of the larger kind
                                                                (PartialEscapeBlockState''setEntry-4 (nth states j), object, i, (ConstantNode'defaultForKind-2 (nth twoSlotKinds i), (MergeProcessor''graph-1 this)))
                                                                (PartialEscapeBlockState''setEntry-4 (nth states j), object, (inc i), (ConstantNode'forConstant-2 (JavaConstant/forIllegal), (MergeProcessor''graph-1 this)))
                                                                true
                                                            )
                                                        )
                                                    )
                                                )
                                        ]
                                            (recur-if compatible? [(inc j)] => false)
                                        )
                                    )
                                )
                        ]
                            (recur-if compatible? [(inc i)] => false)
                        )
                    )
                )
        ]
            (if compatible?
                ;; virtual objects are compatible: create phis for all entries that need them
                (let [
                    #_"ValueNode[]" values (#_"Object" .clone (:entries (PartialEscapeBlockState''getObjectState-2 (nth states 0), (#_"IntUnaryOperator" .applyAsInt getObject, 0))))
                    #_"PhiNode[]" phis (PEMergeProcessor''getValuePhis-3 this, virtual, (VirtualObjectNode''entryCount-1 virtual))
                ]
                    (loop-when [#_"int" i 0] (< i (count values))
                        (loop-when-recur [#_"int" j 1] (< j (count states)) [(inc j)]
                            (when-not (or (some? (nth phis i)) (= (nth values i) (ObjectState''getEntry-2 (PartialEscapeBlockState''getObjectState-2 (nth states j), (#_"IntUnaryOperator" .applyAsInt getObject, j)), i)))
                                (aset phis i (MergeProcessor''createValuePhi-2 this, (Stamp''unrestricted-1 (:stamp (nth values i)))))
                            )
                        )
                        (when (and (some? (nth phis i)) (not (Stamp''isCompatible-2 (:stamp (nth phis i)), (:stamp (nth values i)))))
                            (aset phis i (MergeProcessor''createValuePhi-2 this, (Stamp''unrestricted-1 (:stamp (nth values i)))))
                        )
                        (let [
                            i
                                (when (and (some? twoSlotKinds) (some? (nth twoSlotKinds i))) => i
                                    ;; skip an entry after a long/double value that occupies two int slots
                                    (let [
                                        i (inc i)
                                    ]
                                        (aset phis i nil)
                                        (aset values i (ConstantNode'forConstant-2 (JavaConstant/forIllegal), (MergeProcessor''graph-1 this)))
                                        i
                                    )
                                )
                        ]
                            (recur (inc i))
                        )
                    )

                    (let [
                        #_"boolean" materialized?
                            (loop-when [materialized? false #_"int" i 0] (< i (count values)) => materialized?
                                (let [
                                    #_"PhiNode" phi (nth phis i)
                                    materialized?
                                        (when (some? phi) => materialized?
                                            (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phi, "virtualMergePhi")
                                            (let [
                                                materialized?
                                                    (if (= (VirtualObjectNode''entryKind-2 virtual, i) JavaKind/Object)
                                                        (or materialized? (PEMergeProcessor''mergeObjectEntry-5 this, getObject, states, phi, i))
                                                        (loop-when [#_"int" j 0] (< j (count states)) => materialized?
                                                            (let [
                                                                #_"ObjectState" state (PartialEscapeBlockState''getObjectState-2 (nth states j), (#_"IntUnaryOperator" .applyAsInt getObject, j))
                                                            ]
                                                                (when (ObjectState''isVirtual-1 state) => materialized?
                                                                    (MergeProcessor''setPhiInput-4 this, phi, j, (ObjectState''getEntry-2 state, i))
                                                                    (recur (inc j))
                                                                )
                                                            )
                                                        )
                                                    )
                                            ]
                                                (aset values i phi)
                                                materialized?
                                            )
                                        )
                                ]
                                    (recur materialized? (inc i))
                                )
                            )
                    ]
                        (PartialEscapeBlockState''addObject-3 (:newState this), resultObject, (ObjectState'new-3 values, (:locks (PartialEscapeBlockState''getObjectState-2 (nth states 0), (#_"IntUnaryOperator" .applyAsInt getObject, 0))), ensure?))
                        materialized?
                    )
                )
                ;; not compatible: materialize in all predecessors
                (let [
                    #_"PhiNode" materializedValuePhi (PEMergeProcessor''getPhi-3 this, resultObject, (StampFactory'forKind-1 JavaKind/Object))
                ]
                    (dotimes [#_"int" i (count states)]
                        (let [
                            #_"Block" predecessor (MergeProcessor''getPredecessor-2 this, i)
                        ]
                            (when (and (not ensure?) (ObjectState''isVirtual-1 (PartialEscapeBlockState''getObjectState-2 (nth states i), (#_"IntUnaryOperator" .applyAsInt getObject, i))))
                                ;; we can materialize if not all inputs are "ensureVirtualized"
                                (§ ass! (PartialEscapeBlockState''getObjectState-2 (nth states i), (#_"IntUnaryOperator" .applyAsInt getObject, i)) (ObjectState''setEnsureVirtualized-2 (PartialEscapeBlockState''getObjectState-2 (nth states i), (#_"IntUnaryOperator" .applyAsInt getObject, i)), false))
                            )
                            (PartialEscapeClosure''ensureMaterialized-5 (:peClosure this), (nth states i), (#_"IntUnaryOperator" .applyAsInt getObject, i), (:endNode predecessor), (BlockMap''get-2 (:blockEffects (:peClosure this)), predecessor))
                            (MergeProcessor''setPhiInput-4 this, materializedValuePhi, i, (:materializedValue (PartialEscapeBlockState''getObjectState-2 (nth states i), (#_"IntUnaryOperator" .applyAsInt getObject, i))))
                        )
                    )
                    (PartialEscapeBlockState''addObject-3 (:newState this), resultObject, (ObjectState'new-3 materializedValuePhi, nil, ensure?))
                    true
                )
            )
        )
    )

    ;;;
     ; Fill the inputs of the PhiNode corresponding to one JavaKind#Object entry in the virtual object.
     ;
     ; @return true if materialization happened during the merge, false otherwise
     ;;
    (§ method- #_"boolean" PEMergeProcessor''mergeObjectEntry-5 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"IntUnaryOperator" objectIdFunc, #_"PartialEscapeBlockState[]" states, #_"PhiNode" phi, #_"int" index]
        (loop-when [#_"boolean" materialized? false #_"int" i 0] (< i (count states)) => materialized?
            (let [
                #_"int" object (#_"IntUnaryOperator" .applyAsInt objectIdFunc, i)
                #_"ObjectState" state (PartialEscapeBlockState''getObjectState-2 (nth states i), object)
            ]
                (when (ObjectState''isVirtual-1 state) => materialized?
                    (let [
                        #_"ValueNode" entry (ObjectState''getEntry-2 state, index)
                        [materialized? entry]
                            (when (instance? VirtualObjectNode entry) => [materialized? entry]
                                (let [
                                    #_"Block" predecessor (MergeProcessor''getPredecessor-2 this, i)
                                    materialized? (or materialized? (PartialEscapeClosure''ensureMaterialized-5 (:peClosure this), (nth states i), (VirtualObjectNode''getObjectId-1 entry), (:endNode predecessor), (BlockMap''get-2 (:blockEffects (:peClosure this)), predecessor)))
                                    entry
                                        (when (ObjectState''isVirtual-1 (PartialEscapeBlockState''getObjectState-2 (nth states i), object)) => entry
                                            (let [
                                                entry (:materializedValue (PartialEscapeBlockState''getObjectState-2 (nth states i), (VirtualObjectNode''getObjectId-1 entry)))
                                            ]
                                                (PartialEscapeBlockState''setEntry-4 (nth states i), object, index, entry)
                                                entry
                                            )
                                        )
                                ]
                                    [materialized? entry]
                                )
                            )
                    ]
                        (MergeProcessor''setPhiInput-4 this, phi, i, entry)
                        (recur materialized? (inc i))
                    )
                )
            )
        )
    )

    ;;;
     ; Examine a PhiNode and try to replace it with merging of virtual objects if all its inputs refer to
     ; virtual object states. In order for the merging to happen, all incoming object states need to be
     ; compatible and without object identity (meaning that their object identity if not used later on).
     ;
     ; @param phi the PhiNode that should be processed
     ; @param states the predecessor block states of the merge
     ; @return true if materialization happened during the merge, false otherwise
     ;;
    (§ method- #_"boolean" PEMergeProcessor''processPhi-3 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValuePhiNode" phi, #_"PartialEscapeBlockState[]" states]
        ;; determine how many inputs are virtual and if they're all the same virtual object
        (let [
            #_"VirtualObjectNode[]" objects (make-array VirtualObjectNode (count states))
            [#_"boolean" unique? #_"boolean" ensure? #_"int" virtualInputs]
                (loop-when [unique? true ensure? true virtualInputs 0 #_"int" i 0] (< i (count states)) => [unique? ensure? virtualInputs]
                    (let [
                        #_"ValueNode" alias (PartialEscapeClosure''getAlias-2 (:peClosure this), (MergeProcessor''getPhiValueAt-3 this, phi, i))
                        [unique? ensure? virtualInputs]
                            (when (instance? VirtualObjectNode alias) => [unique? ensure? virtualInputs]
                                (aset objects i alias)
                                (let [
                                    #_"ObjectState" objectState (PartialEscapeBlockState''getObjectStateOptional-2 (nth states i), alias)
                                ]
                                    (when (some? objectState) => (§ return false)
                                        (when (ObjectState''isVirtual-1 objectState) => [unique? ensure? virtualInputs]
                                            [(and (= (nth objects 0) alias) unique?) (and ensure? (:ensureVirtualized objectState)) (inc virtualInputs)]
                                        )
                                    )
                                )
                            )
                    ]
                        (recur unique? ensure? virtualInputs (inc i))
                    )
                )
        ]
            (when (= virtualInputs (count states))
                (if unique?
                    (do
                        ;; all inputs refer to the same object: just make the phi node an alias
                        (PartialEscapeClosure''addVirtualAlias-3 (:peClosure this), (nth objects 0), phi)
                        (GraphEffectList''deleteNode-2 (:mergeEffects this), phi)
                        (§ return false)
                    )
                    ;; all inputs are virtual: check if they're compatible and without identity
                    (let [
                        #_"boolean" compatible?
                            (loop-when [#_"int" i 0] (< i (count states)) => true
                                (and
                                    (= (VirtualObjectNode''type-1 (nth objects 0)) (VirtualObjectNode''type-1 (nth objects i)))
                                    (= (VirtualObjectNode''entryCount-1 (nth objects 0)) (VirtualObjectNode''entryCount-1 (nth objects i)))
                                    (ObjectState''locksEqual-2 (PartialEscapeBlockState''getObjectState-2 (nth states 0), (nth objects 0)), (PartialEscapeBlockState''getObjectState-2 (nth states i), (nth objects i)))
                                    (recur (inc i))
                                )
                            )
                        compatible?
                            (and compatible?
                                (loop-when [compatible? true #_"int" i 0] (< i (count states)) => compatible?
                                    ;; check whether we trivially see that this is the only reference to this allocation
                                    (let [
                                        compatible?
                                            (and compatible?
                                                (or (not (VirtualObjectNode''hasIdentity-1 (nth objects i))) (PEMergeProcessor''isSingleUsageAllocation-4 this, (MergeProcessor''getPhiValueAt-3 this, phi, i), objects, (nth states i)))
                                            )
                                    ]
                                        (recur compatible? (inc i))
                                    )
                                )
                            )
                    ]
                        (when compatible?
                            (let [
                                #_"VirtualObjectNode" virtual (PEMergeProcessor''getValueObjectVirtual-3 this, phi, (nth objects 0))
                            ]
                                (GraphEffectList''addFloatingNode-3 (:mergeEffects this), virtual, "valueObjectNode")
                                (GraphEffectList''deleteNode-2 (:mergeEffects this), phi)
                                (when (= (VirtualObjectNode''getObjectId-1 virtual) -1)
                                    (let [
                                        #_"int" id (count (:virtualObjects (:peClosure this)))
                                    ]
                                        (#_"ArrayList" .add (:virtualObjects (:peClosure this)), virtual)
                                        (§ ass! virtual (VirtualObjectNode''setObjectId-2 virtual, id))
                                    )
                                )

                                (let [
                                    #_"int[]" virtualObjectIds (int-array (count states))
                                    _
                                        (dotimes [#_"int" i (count states)]
                                            (aset virtualObjectIds i (VirtualObjectNode''getObjectId-1 (nth objects i)))
                                        )
                                    #_"boolean" materialized? (PEMergeProcessor''mergeObjectStates-4 this, (VirtualObjectNode''getObjectId-1 virtual), virtualObjectIds, states)
                                ]
                                    (PartialEscapeClosure''addVirtualAlias-3 (:peClosure this), virtual, virtual)
                                    (PartialEscapeClosure''addVirtualAlias-3 (:peClosure this), virtual, phi)
                                    (§ return materialized?)
                                )
                            )
                        )
                    )
                )
            )

            ;; otherwise: materialize all phi inputs
            (let [
                #_"boolean" materialized?
                    (and (pos? virtualInputs)
                        (loop-when [materialized? false #_"int" i 0] (< i (count states)) => materialized?
                            (let [
                                materialized?
                                    (when (some? (nth objects i)) => materialized?
                                        (let [
                                            #_"Block" predecessor (MergeProcessor''getPredecessor-2 this, i)
                                            #_"ObjectState" objectState (PartialEscapeBlockState''getObjectState-2 (nth states i), (nth objects i))
                                        ]
                                            (when (and (not ensure?) (ObjectState''isVirtual-1 objectState))
                                                ;; we can materialize if not all inputs are "ensureVirtualized"
                                                (§ ass! objectState (ObjectState''setEnsureVirtualized-2 objectState, false))
                                            )
                                            (or materialized?
                                                (PartialEscapeClosure''ensureMaterialized-5 (:peClosure this), (nth states i), (VirtualObjectNode''getObjectId-1 (nth objects i)), (:endNode predecessor), (BlockMap''get-2 (:blockEffects (:peClosure this)), predecessor))
                                            )
                                        )
                                    )
                            ]
                                (recur materialized? (inc i))
                            )
                        )
                    )
            ]
                (dotimes [#_"int" i (count states)]
                    (when (some? (nth objects i))
                        (MergeProcessor''setPhiInput-4 this, phi, i, (PartialEscapeClosure''getAliasAndResolve-3 (:peClosure this), (nth states i), (nth objects i)))
                    )
                )
                materialized?
            )
        )
    )

    (§ method- #_"boolean" PEMergeProcessor''isSingleUsageAllocation-4 [#_"PEMergeProcessor<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"ValueNode" value, #_"VirtualObjectNode[]" objects, #_"PartialEscapeBlockState" state]
        ;; If the phi input is an allocation, we know that it is a "fresh" value, i.e. that
        ;; this is a value that will only appear through this source, and cannot appear anywhere
        ;; else. If the phi is also the only usage of this input, we know that no other place
        ;; can check object identity against it, so it is safe to lose the object identity here.
        (and (instance? AllocatedObjectNode value) (Node''hasExactlyOneUsage-1 value)
            ;; Check that the state only references the one virtual object from the Phi.
            (loop-when [#_"VirtualObjectNode" singleVirtual nil #_"int" i 0] (< i (count objects)) => true
                (let [
                    singleVirtual
                        (when (PartialEscapeBlockState''contains-2 state, (nth objects i)) => singleVirtual
                            (cond
                                (nil? singleVirtual)              (nth objects i)
                                (= singleVirtual (nth objects i)) singleVirtual
                                :else
                                    ;; More than one virtual object is visible in the object state.
                                    (§ return false)
                            )
                        )
                ]
                    (recur singleVirtual (inc i))
                )
            )
        )
    )
)

;;;
 ; @anno PartialEscapeClosure.CollectVirtualObjectsClosure
 ;;
(final-ns CollectVirtualObjectsClosure #_"<BlockT extends PartialEscapeBlockState<BlockT>>" (§ extends NodeClosure #_"<ValueNode>")
    (§ final #_"PartialEscapeClosure<BlockT>" :peClosure nil)

    (§ final #_"EconomicSet<VirtualObjectNode>" :virtual nil)
    (§ final #_"GraphEffectList" :effects nil)
    (§ final #_"BlockT" :state nil)

    (§ defn- #_"CollectVirtualObjectsClosure" CollectVirtualObjectsClosure'new-4 [#_"PartialEscapeClosure<BlockT>" peClosure, #_"EconomicSet<VirtualObjectNode>" virtual, #_"GraphEffectList" effects, #_"BlockT" state]
        (let [
            #_"CollectVirtualObjectsClosure" this (NodeClosure'new-0)
            this (assoc this :peClosure peClosure)
            this (assoc this :virtual virtual)
            this (assoc this :effects effects)
            this (assoc this :state state)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" CollectVirtualObjectsClosure''apply-3 [#_"CollectVirtualObjectsClosure<BlockT extends PartialEscapeBlockState<BlockT>>" this, #_"Node" usage, #_"ValueNode" value]
        (if (instance? VirtualObjectNode value)
            (when (and (not= (VirtualObjectNode''getObjectId-1 value) -1) (some? (PartialEscapeBlockState''getObjectStateOptional-2 (:state this), value)))
                (#_"EconomicSet" .add (:virtual this), value)
            )
            (let [
                #_"ValueNode" alias (PartialEscapeClosure''getAlias-2 (:peClosure this), value)
            ]
                (when (instance? VirtualObjectNode alias)
                    (#_"EconomicSet" .add (:virtual this), alias)
                    (GraphEffectList''replaceFirstInput-4 (:effects this), usage, value, alias)
                )
            )
        )
        nil
    )
)

;;;
 ; Final subclass of PartialEscapeClosure, for performance and to make everything
 ; behave nicely with generics.
 ;
 ; @anno PartialEscapeClosure.FinalClosure
 ;;
(final-ns FinalClosure (§ extends PartialEscapeClosure #_"<FinalState>")
    (§ defn #_"FinalClosure" FinalClosure'new-1 [#_"ScheduleResult" schedule]
        (PartialEscapeClosure'new-1 schedule)
    )

    #_unused
    (§ override! #_"FinalState" FinalClosure''getInitialState-1 [#_"FinalClosure" this]
        (FinalState'new-0)
    )

    #_unused
    (§ override! #_"FinalState" FinalClosure''cloneState-2 [#_"FinalClosure" this, #_"FinalState" oldState]
        (FinalState'new-1 oldState)
    )
)

(final-ns PartialEscapePhase (§ extends EffectsPhase #_"<PhaseContext>")
    (§ final #_"boolean" :readElimination false)
    (§ final #_"BasePhase<PhaseContext>" :cleanupPhase nil)

    (§ defn #_"PartialEscapePhase" PartialEscapePhase'new-2 [#_"boolean" iterative, #_"CanonicalizerPhase" canonicalizer]
        (PartialEscapePhase'new-4 iterative, GraalOptions'optEarlyReadElimination, canonicalizer, nil)
    )

    #_unused
    (§ defn #_"PartialEscapePhase" PartialEscapePhase'new-3 [#_"boolean" iterative, #_"CanonicalizerPhase" canonicalizer, #_"BasePhase<PhaseContext>" cleanupPhase]
        (PartialEscapePhase'new-4 iterative, GraalOptions'optEarlyReadElimination, canonicalizer, cleanupPhase)
    )

    (§ defn #_"PartialEscapePhase" PartialEscapePhase'new-4 [#_"boolean" iterative, #_"boolean" readElimination, #_"CanonicalizerPhase" canonicalizer, #_"BasePhase<PhaseContext>" cleanupPhase]
        (let [
            #_"PartialEscapePhase" this (EffectsPhase'new-2 (if iterative GraalOptions'escapeAnalysisIterations 1), canonicalizer)
            this (assoc this :readElimination readElimination)
            this (assoc this :cleanupPhase cleanupPhase)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"void" PartialEscapePhase''run-3 [#_"PartialEscapePhase" this, #_"Graph" graph, #_"PhaseContext" context]
        (when (or (:readElimination this) (Graph''hasVirtualizableAllocation-1 graph))
            (EffectsPhase''runAnalysis-3 this, graph, context)
        )
        nil
    )

    #_unused
    (§ override! #_"void" PartialEscapePhase''postIteration-4 [#_"PartialEscapePhase" this, #_"Graph" graph, #_"PhaseContext" context, #_"EconomicSet<Node>" changedNodes]
        (EffectsPhase''postIteration-4 (§ super ), graph, context, changedNodes)
        (when (some? (:cleanupPhase this))
            (BasePhase''apply-3 (:cleanupPhase this), graph, context)
        )
        nil
    )

    #_unused
    (§ override! #_"Closure" PartialEscapePhase''createEffectsClosure-4 [#_"PartialEscapePhase" this, #_"PhaseContext" context, #_"ScheduleResult" schedule, #_"ControlFlowGraph" cfg]
        (doseq [#_"VirtualObjectNode" virtual (Graph''getNodes-2 (:graph cfg), VirtualObjectNode'TYPE)]
            (§ ass! virtual (VirtualObjectNode''resetObjectId-1 virtual))
        )
        (if (:readElimination this)
            (PEReadEliminationClosure'new-1 schedule)
            (FinalClosure'new-1 schedule)
        )
    )
)

(final-ns PEReadEliminationBlockState (§ extends PartialEscapeBlockState #_"<PEReadEliminationBlockState>")
    (§ final #_"EconomicMap<ReadCacheEntry, ValueNode>" :readCache nil)

    (§ defn #_"PEReadEliminationBlockState" PEReadEliminationBlockState'new-0 []
        (let [
            #_"PEReadEliminationBlockState" this (PartialEscapeBlockState'new-0)
            this (assoc this :readCache (EconomicMap/create Equivalence/DEFAULT))
        ]
            this
        )
    )

    (§ defn #_"PEReadEliminationBlockState" PEReadEliminationBlockState'new-1 [#_"PEReadEliminationBlockState" other]
        (let [
            #_"PEReadEliminationBlockState" this (PartialEscapeBlockState'new-1 other)
            this (assoc this :readCache (EconomicMap/create Equivalence/DEFAULT, (:readCache other)))
        ]
            this
        )
    )

    (§ defn- #_"JavaKind" PEReadEliminationBlockState'stampToJavaKind-1 [#_"Stamp" stamp]
        (if (instance? IntegerStamp stamp)
            (case (:bits stamp)
                 1 JavaKind/Boolean
                 8 JavaKind/Byte
                16 (if (IntegerStamp''isPositive-1 stamp) JavaKind/Char JavaKind/Short)
                32 JavaKind/Int
                64 JavaKind/Long
            )
            (Stamp''getStackKind-1 stamp)
        )
    )

    #_unused
    (§ override! #_"void" PEReadEliminationBlockState''objectMaterialized-4 [#_"PEReadEliminationBlockState" this, #_"VirtualObjectNode" virtual, #_"AllocatedObjectNode" representation, #_"List<ValueNode>" values]
        (when (instance? VirtualInstanceNode virtual)
            (dotimes [#_"int" i (VirtualInstanceNode''entryCount-1 virtual)]
                (let [
                    #_"JavaKind" declaredKind (#_"ResolvedJavaField" .getJavaKind (VirtualInstanceNode''field-2 virtual, i))
                ]
                    (when (= declaredKind (PEReadEliminationBlockState'stampToJavaKind-1 (:stamp (nth values i))))
                        ;; We won't cache unaligned field writes upon instantiation unless we add
                        ;; support for non-array objects in PEReadEliminationClosure.processUnsafeLoad.
                        (#_"EconomicMap" .put (:readCache this), (ReadCacheEntry'new-5 (FieldLocationIdentity'new-1 (VirtualInstanceNode''field-2 virtual, i)), representation, -1, declaredKind, false), (nth values i))
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" PEReadEliminationBlockState''equivalentTo-2 [#_"PEReadEliminationBlockState" this, #_"PEReadEliminationBlockState" other]
        (and (EffectsBlockState'isSubMapOf-2 (:readCache this), (:readCache other)) (PartialEscapeBlockState''equivalentTo-2 (§ super ), other))
    )

    (§ method! #_"void" PEReadEliminationBlockState''addReadCache-8 [#_"PEReadEliminationBlockState" this, #_"ValueNode" object, #_"LocationIdentity" identity, #_"int" index, #_"JavaKind" kind, #_"boolean" overflowAccess, #_"ValueNode" value, #_"PartialEscapeClosure" closure]
        (let [
            #_"ObjectState" obj (PartialEscapeClosure''getObjectState-3 closure, this, object)
            #_"ValueNode" cacheObject (if (some? obj) (:materializedValue obj) object)
        ]
            (#_"EconomicMap" .put (:readCache this), (ReadCacheEntry'new-5 identity, cacheObject, index, kind, overflowAccess), value)
        )
        nil
    )

    (§ method! #_"ValueNode" PEReadEliminationBlockState''getReadCache-6 [#_"PEReadEliminationBlockState" this, #_"ValueNode" object, #_"LocationIdentity" identity, #_"int" index, #_"JavaKind" kind, #_"PartialEscapeClosure" closure]
        (let [
            #_"ObjectState" obj (PartialEscapeClosure''getObjectState-3 closure, this, object)
            #_"ValueNode" cacheObject (if (some? obj) (:materializedValue obj) object)
            #_"ValueNode" cacheValue (get (:readCache this) (ReadCacheEntry'new-5 identity, cacheObject, index, kind, false))
            obj (PartialEscapeClosure''getObjectState-3 closure, this, cacheValue)
        ]
            (if (some? obj)
                (:materializedValue obj)
                ;; assert !scalarAliases.containsKey(cacheValue);
                (EffectsClosure''getScalarAlias-2 closure, cacheValue)
            )
        )
    )

    (§ method! #_"void" PEReadEliminationBlockState''killReadCache-1 [#_"PEReadEliminationBlockState" this]
        (#_"EconomicMap" .clear (:readCache this))
        nil
    )

    (§ method! #_"void" PEReadEliminationBlockState''killReadCache-3 [#_"PEReadEliminationBlockState" this, #_"LocationIdentity" identity, #_"int" index]
        (let [
            #_"Iterator<ReadCacheEntry>" it (#_"Iterable" .iterator (keys (:readCache this)))
        ]
            (while (#_"Iterator" .hasNext it)
                (let [
                    #_"ReadCacheEntry" entry (#_"Iterator" .next it)
                ]
                    (when (and (= (:identity entry) identity) (or (= index -1) (= (:index entry) -1) (= index (:index entry)) (:overflowAccess entry)))
                        (#_"Iterator" .remove it)
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; @anno PEReadEliminationBlockState.ReadCacheEntry
 ;;
(final-ns ReadCacheEntry
    (§ final #_"LocationIdentity" :identity nil)
    (§ final #_"ValueNode" :object nil)
    (§ final #_"int" :index 0)
    (§ final #_"JavaKind" :kind nil)

    ;; This flag does not affect hashCode or equals implementations.
    (§ final #_"boolean" :overflowAccess false)

    (§ defn #_"ReadCacheEntry" ReadCacheEntry'new-5 [#_"LocationIdentity" identity, #_"ValueNode" object, #_"int" index, #_"JavaKind" kind, #_"boolean" overflowAccess]
        (let [
            #_"ReadCacheEntry" this (Object.)
            this (assoc this :identity identity)
            this (assoc this :object object)
            this (assoc this :index index)
            this (assoc this :kind kind)
            this (assoc this :overflowAccess overflowAccess)
        ]
            this
        )
    )
)

(final-ns PEReadEliminationClosure (§ extends PartialEscapeClosure #_"<PEReadEliminationBlockState>")
    (§ def- #_"EnumMap<JavaKind, LocationIdentity>" PEReadEliminationClosure'UNBOX_LOCATIONS (EnumMap. JavaKind))

    (§ init
        (doseq [#_"JavaKind" kind (JavaKind/values)]
            (#_"EnumMap" .put PEReadEliminationClosure'UNBOX_LOCATIONS, kind, (NamedLocationIdentity'immutable-1 (str "PEA unbox " (#_"JavaKind" .getJavaName kind))))
        )
    )

    (§ defn #_"PEReadEliminationClosure" PEReadEliminationClosure'new-1 [#_"ScheduleResult" schedule]
        (PartialEscapeClosure'new-1 schedule)
    )

    #_unused
    (§ override! #_"PEReadEliminationBlockState" PEReadEliminationClosure''getInitialState-1 [#_"PEReadEliminationClosure" this]
        (PEReadEliminationBlockState'new-0)
    )

    #_unused
    (§ override! #_"boolean" PEReadEliminationClosure''processNode-5 [#_"PEReadEliminationClosure" this, #_"Node" node, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode]
        (or (PartialEscapeClosure''processNode-5 (§ super ), node, state, effects, lastFixedNode)
            (condp instance? node
                LoadFieldNode    (PEReadEliminationClosure''processLoadField-4 this, node, state, effects)
                StoreFieldNode   (PEReadEliminationClosure''processStoreField-4 this, node, state, effects)
                LoadIndexedNode  (PEReadEliminationClosure''processLoadIndexed-4 this, node, state, effects)
                StoreIndexedNode (PEReadEliminationClosure''processStoreIndexed-4 this, node, state, effects)
                ArrayLengthNode  (PEReadEliminationClosure''processArrayLength-4 this, node, state, effects)
                UnboxNode        (PEReadEliminationClosure''processUnbox-4 this, node, state, effects)
                RawLoadNode      (PEReadEliminationClosure''processUnsafeLoad-4 this, node, state, effects)
                RawStoreNode     (PEReadEliminationClosure''processUnsafeStore-4 this, node, state, effects)
                Single
                    (let [
                        #_"LocationIdentity" identity (Single''getLocationIdentity-1 node)
                    ]
                        (PEReadEliminationClosure'processIdentity-2 state, identity)
                        false
                    )
                Multi
                    (do
                        (doseq [#_"LocationIdentity" identity (Multi''getLocationIdentities-1 node)]
                            (PEReadEliminationClosure'processIdentity-2 state, identity)
                        )
                        false
                    )
                false
            )
        )
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processStore-10 [#_"PEReadEliminationClosure" this, #_"FixedNode" store, #_"ValueNode" object, #_"LocationIdentity" identity, #_"int" index, #_"JavaKind" accessKind, #_"boolean" overflowAccess, #_"ValueNode" value, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (let [
            #_"ValueNode" unproxiedObject (GraphUtil'unproxify-1 object)
            #_"ValueNode" cachedValue (PEReadEliminationBlockState''getReadCache-6 state, object, identity, index, accessKind, this)
            #_"ValueNode" finalValue (EffectsClosure''getScalarAlias-2 this, value)
            #_"boolean" result
                (when (= (GraphUtil'unproxify-1 finalValue) (GraphUtil'unproxify-1 cachedValue)) => false
                    (GraphEffectList''deleteNode-2 effects, store)
                    true
                )
        ]
            (PEReadEliminationBlockState''killReadCache-3 state, identity, index)
            (PEReadEliminationBlockState''addReadCache-8 state, unproxiedObject, identity, index, accessKind, overflowAccess, finalValue, this)
            result
        )
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processLoad-8 [#_"PEReadEliminationClosure" this, #_"FixedNode" load, #_"ValueNode" object, #_"LocationIdentity" identity, #_"int" index, #_"JavaKind" kind, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (let [
            #_"ValueNode" unproxiedObject (GraphUtil'unproxify-1 object)
            #_"ValueNode" cachedValue (PEReadEliminationBlockState''getReadCache-6 state, unproxiedObject, identity, index, kind, this)
        ]
            (if (some? cachedValue)
                (do
                    ;; perform the read elimination
                    (GraphEffectList''replaceAtUsages-4 effects, load, cachedValue, load)
                    (EffectsClosure''addScalarAlias-3 this, load, cachedValue)
                    true
                )
                (do
                    (PEReadEliminationBlockState''addReadCache-8 state, unproxiedObject, identity, index, kind, false, load, this)
                    false
                )
            )
        )
    )

    (§ defn- #_"boolean" PEReadEliminationClosure'isOverflowAccess-2 [#_"JavaKind" accessKind, #_"JavaKind" declaredKind]
        (cond
            (= accessKind declaredKind)
                false
            (= accessKind JavaKind/Object)
                (condp = declaredKind
                    JavaKind/Object false
                    JavaKind/Long   false
                    JavaKind/Double (throw! "should not reach here")
                                    true
                )
            (#_"JavaKind" .isPrimitive declaredKind)
                (< (#_"JavaKind" .getBitCount declaredKind) (#_"JavaKind" .getBitCount accessKind))
            :else
                true
        )
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processUnsafeLoad-4 [#_"PEReadEliminationClosure" this, #_"RawLoadNode" load, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (and (instance? ConstantNode (:offset load))
            (let [
                #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp (:object load)))
            ]
                (and (some? type) (#_"ResolvedJavaType" .isArray type)
                    (let [
                        #_"JavaKind" accessKind (:accessKind load)
                        #_"JavaKind" componentKind (#_"ResolvedJavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType type))
                        #_"long" offset (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset load)))
                        #_"int" index (VirtualArrayNode'entryIndexForOffset-4 offset, accessKind, (#_"ResolvedJavaType" .getComponentType type), Integer/MAX_VALUE)
                        #_"ValueNode" object (GraphUtil'unproxify-1 (:object load))
                        #_"LocationIdentity" location (NamedLocationIdentity'getArrayLocation-1 componentKind)
                        #_"ValueNode" cachedValue (PEReadEliminationBlockState''getReadCache-6 state, object, location, index, accessKind, this)
                    ]
                        (if (some? cachedValue)
                            (do
                                (GraphEffectList''replaceAtUsages-4 effects, load, cachedValue, load)
                                (EffectsClosure''addScalarAlias-3 this, load, cachedValue)
                                true
                            )
                            (do
                                (PEReadEliminationBlockState''addReadCache-8 state, object, location, index, accessKind, (PEReadEliminationClosure'isOverflowAccess-2 accessKind, componentKind), load, this)
                                false
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processUnsafeStore-4 [#_"PEReadEliminationClosure" this, #_"RawStoreNode" store, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (let [
            #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp (:object store)))
        ]
            (if (and (some? type) (#_"ResolvedJavaType" .isArray type))
                (let [
                    #_"JavaKind" accessKind (:accessKind store)
                    #_"JavaKind" componentKind (#_"ResolvedJavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType type))
                    #_"LocationIdentity" location (NamedLocationIdentity'getArrayLocation-1 componentKind)
                ]
                    (if (instance? ConstantNode (:offset store))
                        (let [
                            #_"long" offset (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:offset store)))
                            #_"boolean" overflowAccess (PEReadEliminationClosure'isOverflowAccess-2 accessKind, componentKind)
                            #_"int" index (if overflowAccess -1 (VirtualArrayNode'entryIndexForOffset-4 offset, accessKind, (#_"ResolvedJavaType" .getComponentType type), Integer/MAX_VALUE))
                        ]
                            (PEReadEliminationClosure''processStore-10 this, store, (:object store), location, index, accessKind, overflowAccess, (:value store), state, effects)
                        )
                        (do
                            (PEReadEliminationClosure'processIdentity-2 state, location)
                            false
                        )
                    )
                )
                (do
                    (PEReadEliminationBlockState''killReadCache-1 state)
                    false
                )
            )
        )
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processArrayLength-4 [#_"PEReadEliminationClosure" this, #_"ArrayLengthNode" length, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (PEReadEliminationClosure''processLoad-8 this, length, (:array length), NamedLocationIdentity'ARRAY_LENGTH_LOCATION, -1, JavaKind/Int, state, effects)
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processStoreField-4 [#_"PEReadEliminationClosure" this, #_"StoreFieldNode" store, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (if (AccessFieldNode''isVolatile-1 store)
            (do
                (PEReadEliminationBlockState''killReadCache-1 state)
                false
            )
            (let [
                #_"JavaKind" kind (#_"ResolvedJavaField" .getJavaKind (AccessFieldNode''field-1 store))
            ]
                (PEReadEliminationClosure''processStore-10 this, store, (:object store), (FieldLocationIdentity'new-1 (AccessFieldNode''field-1 store)), -1, kind, false, (:value store), state, effects)
            )
        )
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processLoadField-4 [#_"PEReadEliminationClosure" this, #_"LoadFieldNode" load, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (if (AccessFieldNode''isVolatile-1 load)
            (do
                (PEReadEliminationBlockState''killReadCache-1 state)
                false
            )
            (PEReadEliminationClosure''processLoad-8 this, load, (:object load), (FieldLocationIdentity'new-1 (AccessFieldNode''field-1 load)), -1, (#_"ResolvedJavaField" .getJavaKind (AccessFieldNode''field-1 load)), state, effects)
        )
    )

    (§ defn- #_"JavaKind" PEReadEliminationClosure'getElementKindFromStamp-1 [#_"ValueNode" array]
        (let [
            #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp array))
        ]
            (when (and (some? type) (#_"ResolvedJavaType" .isArray type)) => JavaKind/Illegal
                (#_"ResolvedJavaType" .getJavaKind (#_"ResolvedJavaType" .getComponentType type))
            )
        )
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processStoreIndexed-4 [#_"PEReadEliminationClosure" this, #_"StoreIndexedNode" store, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (let [
            #_"int" index (if (instance? ConstantNode (AccessIndexedNode''index-1 store)) (#_"JavaConstant" .asInt (:value (AccessIndexedNode''index-1 store))) -1)
            ;; BASTORE (with elementKind being Byte) can be used to store values in boolean arrays.
            #_"JavaKind" elementKind (:elementKind store)
            elementKind
                (when (= elementKind JavaKind/Byte) => elementKind
                    (let [
                        elementKind (PEReadEliminationClosure'getElementKindFromStamp-1 (AccessArrayNode''array-1 store))
                    ]
                        (when (= elementKind JavaKind/Illegal) => elementKind
                            ;; Could not determine the actual access kind from stamp. Hence kill both.
                            (PEReadEliminationBlockState''killReadCache-3 state, (NamedLocationIdentity'getArrayLocation-1 JavaKind/Boolean), index)
                            (PEReadEliminationBlockState''killReadCache-3 state, (NamedLocationIdentity'getArrayLocation-1 JavaKind/Byte), index)
                            (§ return false)
                        )
                    )
                )
        ]
            (let [
                #_"LocationIdentity" arrayLocation (NamedLocationIdentity'getArrayLocation-1 elementKind)
            ]
                (when (= index -1) => (PEReadEliminationClosure''processStore-10 this, store, (AccessArrayNode''array-1 store), arrayLocation, index, elementKind, false, (:value store), state, effects)
                    (PEReadEliminationBlockState''killReadCache-3 state, arrayLocation, -1)
                    false
                )
            )
        )
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processLoadIndexed-4 [#_"PEReadEliminationClosure" this, #_"LoadIndexedNode" load, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (and (instance? ConstantNode (AccessIndexedNode''index-1 load))
            (let [
                #_"int" index (#_"JavaConstant" .asInt (:value (AccessIndexedNode''index-1 load)))
                ;; BALOAD (with elementKind being Byte) can be used to retrieve values from boolean arrays.
                #_"JavaKind" elementKind (:elementKind load)
                elementKind
                    (when (= elementKind JavaKind/Byte) => elementKind
                        (let [
                            elementKind (PEReadEliminationClosure'getElementKindFromStamp-1 (AccessArrayNode''array-1 load))
                        ]
                            (when (= elementKind JavaKind/Illegal) => elementKind
                                (§ return false)
                            )
                        )
                    )
            ]
                (let [
                    #_"LocationIdentity" arrayLocation (NamedLocationIdentity'getArrayLocation-1 elementKind)
                ]
                    (PEReadEliminationClosure''processLoad-8 this, load, (AccessArrayNode''array-1 load), arrayLocation, index, elementKind, state, effects)
                )
            )
        )
    )

    (§ method- #_"boolean" PEReadEliminationClosure''processUnbox-4 [#_"PEReadEliminationClosure" this, #_"UnboxNode" unbox, #_"PEReadEliminationBlockState" state, #_"GraphEffectList" effects]
        (PEReadEliminationClosure''processLoad-8 this, unbox, (UnboxNode''getValue-1 unbox), (get PEReadEliminationClosure'UNBOX_LOCATIONS (:boxingKind unbox)), -1, (:boxingKind unbox), state, effects)
    )

    (§ defn- #_"void" PEReadEliminationClosure'processIdentity-2 [#_"PEReadEliminationBlockState" state, #_"LocationIdentity" identity]
        (if (#_"LocationIdentity" .isAny identity)
            (PEReadEliminationBlockState''killReadCache-1 state)
            (PEReadEliminationBlockState''killReadCache-3 state, identity, -1)
        )
        nil
    )

    #_unused
    (§ override! #_"void" PEReadEliminationClosure''processInitialLoopState-3 [#_"PEReadEliminationClosure" this, #_"Loop" loop, #_"PEReadEliminationBlockState" initialState]
        (PartialEscapeClosure''processInitialLoopState-3 (§ super ), loop, initialState)

        (when (seq (:readCache initialState))
            (let [
                #_"EconomicMap<ValueNode, Pair<ValueNode, Object>>" firstValueSet
                    (loop-when [firstValueSet nil #_"ISeq" s (seq (AbstractMergeNode''phis-1 (:beginNode (:header loop))))] (some? s) => firstValueSet
                        (let [
                            #_"PhiNode" phi (first s)
                            #_"ValueNode" firstValue (PhiNode''valueAt-2 phi, 0)
                            firstValueSet
                                (when (and (some? firstValue) (#_"JavaKind" .isObject (ValueNode''getStackKind-1 phi))) => firstValueSet
                                    (let [
                                        #_"ValueNode" unproxified (GraphUtil'unproxify-1 firstValue)
                                        firstValueSet (or firstValueSet (EconomicMap/create Equivalence/IDENTITY_WITH_SYSTEM_HASHCODE))
                                    ]
                                        (#_"EconomicMap" .put firstValueSet, unproxified, (Pair/create unproxified, (get firstValueSet unproxified)))
                                        firstValueSet
                                    )
                                )
                        ]
                            (recur firstValueSet (next s))
                        )
                    )
            ]
                (when (some? firstValueSet)
                    (let [
                        #_"ReadCacheEntry[]" entries (make-array ReadCacheEntry (count (:readCache initialState)))
                        _
                            (loop-when-recur [#_"int" i 0 #_"ISeq" s (seq (keys (:readCache initialState)))] (some? s) [(inc i) (next s)]
                                (aset entries i (first s))
                            )
                    ]
                        (doseq [#_"ReadCacheEntry" entry entries]
                            (when (some? (:object entry))
                                (loop-when-recur [#_"Pair<ValueNode, Object>" pair (get firstValueSet (:object entry))] (some? pair) [(#_"Pair" .getRight pair)]
                                    (PEReadEliminationBlockState''addReadCache-8 initialState, (#_"Pair" .getLeft pair), (:identity entry), (:index entry), (:kind entry), (:overflowAccess entry), (get (:readCache initialState) entry), this)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"void" PEReadEliminationClosure''processLoopExit-5 [#_"PEReadEliminationClosure" this, #_"LoopExitNode" exitNode, #_"PEReadEliminationBlockState" initialState, #_"PEReadEliminationBlockState" exitState, #_"GraphEffectList" effects]
        (PartialEscapeClosure''processLoopExit-5 (§ super ), exitNode, initialState, exitState, effects)

        (when (:hasValueProxies (:graph exitNode))
            (let [
                #_"MapCursor<ReadCacheEntry, ValueNode>" entry (#_"EconomicMap" .getEntries (:readCache exitState))
            ]
                (while (#_"MapCursor" .advance entry)
                    (when-not (= (get (:readCache initialState) (#_"MapCursor" .getKey entry)) (#_"MapCursor" .getValue entry))
                        (let [
                            #_"ValueNode" value (PEReadEliminationBlockState''getReadCache-6 exitState, (:object (#_"MapCursor" .getKey entry)), (:identity (#_"MapCursor" .getKey entry)), (:index (#_"MapCursor" .getKey entry)), (:kind (#_"MapCursor" .getKey entry)), this)
                        ]
                            (when-not (and (instance? ProxyNode value) (= (:loopExit value) exitNode))
                                (let [
                                    #_"ProxyNode" proxy (ValueProxyNode'new-2 value, exitNode)
                                ]
                                    (GraphEffectList''addFloatingNode-3 effects, proxy, "readCacheProxy")
                                    (#_"EconomicMap" .put (:readCache exitState), (#_"MapCursor" .getKey entry), proxy)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"PEReadEliminationBlockState" PEReadEliminationClosure''cloneState-2 [#_"PEReadEliminationClosure" this, #_"PEReadEliminationBlockState" other]
        (PEReadEliminationBlockState'new-1 other)
    )

    #_unused
    (§ override! #_"PEMergeProcessor<PEReadEliminationBlockState>" PEReadEliminationClosure''createMergeProcessor-2 [#_"PEReadEliminationClosure" this, #_"Block" merge]
        (PEReadEliminationMergeProcessor'new-2 this, merge)
    )

    #_unused
    (§ override! #_"void" PEReadEliminationClosure''processKilledLoopLocations-4 [#_"PEReadEliminationClosure" this, #_"Loop" loop, #_"PEReadEliminationBlockState" initialState, #_"PEReadEliminationBlockState" mergedStates]
        (when (seq (:readCache initialState))
            (let [
                #_"LoopKillCache" loopKilledLocations (get (:loopLocationKillCache this) loop)
            ]
                ;; we have fully processed this loop the first time, remember to cache it the next time it is visited
                (if (nil? loopKilledLocations)
                    (do
                        (§ ass loopKilledLocations (LoopKillCache'new-1 1)) ;; 1.visit
                        (#_"EconomicMap" .put (:loopLocationKillCache this), loop, loopKilledLocations)
                    )
                    (do
                        (if (< GraalOptions'readEliminationMaxLoopVisits (:visits loopKilledLocations))
                            (do
                                ;; we have processed the loop too many times: kill all locations, so
                                ;; the inner loop will never be processed more than once again on visit
                                (§ ass! loopKilledLocations (LoopKillCache''setKillsAll-1 loopKilledLocations))
                            )
                            ;; we have fully processed this loop >1 times, update the killed locations
                            (let [
                                #_"EconomicSet<LocationIdentity>" forwardEndLiveLocations (EconomicSet/create Equivalence/DEFAULT)
                            ]
                                (doseq [#_"ReadCacheEntry" entry (keys (:readCache initialState))]
                                    (#_"EconomicSet" .add forwardEndLiveLocations, (:identity entry))
                                )
                                (doseq [#_"ReadCacheEntry" entry (keys (:readCache mergedStates))]
                                    (#_"EconomicSet" .remove forwardEndLiveLocations, (:identity entry))
                                )
                                ;; every location that is alive before the loop but not after is killed by the loop
                                (doseq [#_"LocationIdentity" location forwardEndLiveLocations]
                                    (§ ass! loopKilledLocations (LoopKillCache''rememberLoopKilledLocation-2 loopKilledLocations, location))
                                )
                            )
                        )
                        ;; remember the loop visit
                        (§ ass! loopKilledLocations (LoopKillCache''visited-1 loopKilledLocations))
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"PEReadEliminationBlockState" PEReadEliminationClosure''stripKilledLoopLocations-3 [#_"PEReadEliminationClosure" this, #_"Loop" loop, #_"PEReadEliminationBlockState" originalInitialState]
        (let [
            #_"PEReadEliminationBlockState" initialState (PartialEscapeClosure''stripKilledLoopLocations-3 (§ super ), loop, originalInitialState)
            #_"LoopKillCache" loopKilledLocations (get (:loopLocationKillCache this) loop)
        ]
            (when (and (some? loopKilledLocations) (LoopKillCache''loopKillsLocations-1 loopKilledLocations))
                (let [
                    #_"Iterator<ReadCacheEntry>" it (#_"Iterable" .iterator (keys (:readCache initialState)))
                ]
                    (while (#_"Iterator" .hasNext it)
                        (when (LoopKillCache''containsLocation-2 loopKilledLocations, (:identity (#_"Iterator" .next it)))
                            (#_"Iterator" .remove it)
                        )
                    )
                )
            )
            initialState
        )
    )
)

;;;
 ; @anno PEReadEliminationClosure.PEReadEliminationMergeProcessor
 ;;
(final-ns PEReadEliminationMergeProcessor (§ extends PEMergeProcessor #_"<PEReadEliminationBlockState>")
    (§ defn #_"PEReadEliminationMergeProcessor" PEReadEliminationMergeProcessor'new-2 [#_"PEReadEliminationClosure" reClosure, #_"Block" mergeBlock]
        (PEMergeProcessor'new-2 reClosure, mergeBlock)
    )

    #_unused
    (§ override! #_"void" PEReadEliminationMergeProcessor''merge-2 [#_"PEReadEliminationMergeProcessor" this, #_"List<PEReadEliminationBlockState>" states]
        (PEMergeProcessor''merge-2 (§ super ), states)

        (PEReadEliminationMergeProcessor''mergeReadCache-2 this, states)
        nil
    )

    (§ method- #_"void" PEReadEliminationMergeProcessor''mergeReadCache-2 [#_"PEReadEliminationMergeProcessor" this, #_"List<PEReadEliminationBlockState>" states]
        (let [
            #_"MapCursor<ReadCacheEntry, ValueNode>" cursor (#_"EconomicMap" .getEntries (:readCache (nth states 0)))
        ]
            (while (#_"MapCursor" .advance cursor)
                (let [
                    #_"ReadCacheEntry" key (#_"MapCursor" .getKey cursor)
                    [#_"ValueNode" value #_"boolean" phi]
                        (loop-when [value (#_"MapCursor" .getValue cursor) phi false #_"int" i 1] (< i (count states)) => [value phi]
                            (let [
                                #_"ValueNode" other (get (:readCache (nth states i)) key)
                            ]
                                ;; e.g. unsafe loads/stores with different access kinds have different stamps although location,
                                ;; object and offset are the same, in this case we cannot create a phi nor can we set a common value
                                (when (and (some? other) (Stamp''isCompatible-2 (:stamp value), (:stamp other))) => [nil false]
                                    (recur value (or phi (not (= other value))) (inc i))
                                )
                            )
                        )
                ]
                    (cond
                        phi
                            (let [
                                #_"PhiNode" phiNode (PEMergeProcessor''getPhi-3 this, key, (Stamp''unrestricted-1 (:stamp value)))
                            ]
                                (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phiNode, "mergeReadCache")
                                (dotimes [#_"int" i (count states)]
                                    (MergeProcessor''setPhiInput-4 this, phiNode, i, (PEReadEliminationBlockState''getReadCache-6 (nth states i), (:object key), (:identity key), (:index key), (:kind key), (:peClosure this)))
                                )
                                (#_"EconomicMap" .put (:readCache (:newState this)), key, phiNode)
                            )
                        (some? value)
                            (#_"EconomicMap" .put (:readCache (:newState this)), key, value)
                    )
                )
            )
            ;; For object phis, see if there are known reads on all predecessors, for which we could create new phis.
            (doseq [#_"PhiNode" phi (MergeProcessor''getPhis-1 this)]
                (when (= (ValueNode''getStackKind-1 phi) JavaKind/Object)
                    (doseq [#_"ReadCacheEntry" entry (keys (:readCache (nth states 0)))]
                        (when (= (:object entry) (MergeProcessor''getPhiValueAt-3 this, phi, 0))
                            (PEReadEliminationMergeProcessor''mergeReadCachePhi-7 this, phi, (:identity entry), (:index entry), (:kind entry), (:overflowAccess entry), states)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" PEReadEliminationMergeProcessor''mergeReadCachePhi-7 [#_"PEReadEliminationMergeProcessor" this, #_"PhiNode" phi, #_"LocationIdentity" identity, #_"int" index, #_"JavaKind" kind, #_"boolean" overflowAccess, #_"List<PEReadEliminationBlockState>" states]
        (let [
            #_"ValueNode[]" values (make-array ValueNode (count states))
        ]
            (aset values 0 (PEReadEliminationBlockState''getReadCache-6 (nth states 0), (MergeProcessor''getPhiValueAt-3 this, phi, 0), identity, index, kind, (:peClosure this)))
            (when (some? (nth values 0))
                (loop [#_"int" i 1]
                    (if (< i (count states))
                        (let [
                            #_"ValueNode" value (PEReadEliminationBlockState''getReadCache-6 (nth states i), (MergeProcessor''getPhiValueAt-3 this, phi, i), identity, index, kind, (:peClosure this))
                        ]
                            ;; e.g. unsafe loads/stores with same identity, but different access kinds, see mergeReadCache(states)
                            (when (and (some? value) (Stamp''isCompatible-2 (:stamp (nth values (dec i))), (:stamp value)))
                                (aset values i value)
                                (recur (inc i))
                            )
                        )
                        (let [
                            #_"PhiNode" phiNode (PEMergeProcessor''getPhi-3 this, (ReadCacheEntry'new-5 identity, phi, index, kind, overflowAccess), (Stamp''unrestricted-1 (:stamp (nth values 0))))
                        ]
                            (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phiNode, "mergeReadCachePhi")
                            (dotimes [#_"int" i (count values)]
                                (MergeProcessor''setPhiInput-4 this, phiNode, i, (nth values i))
                            )
                            (#_"EconomicMap" .put (:readCache (:newState this)), (ReadCacheEntry'new-5 identity, phi, index, kind, overflowAccess), phiNode)
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; This class maintains a set of known values, identified by base object, locations and offset.
 ;;
(final-ns ReadEliminationBlockState (§ extends EffectsBlockState #_"<ReadEliminationBlockState>")
    (§ final #_"EconomicMap<CacheEntry, ValueNode>" :readCache nil)

    (§ defn #_"ReadEliminationBlockState" ReadEliminationBlockState'new-0 []
        (let [
            #_"ReadEliminationBlockState" this (EffectsBlockState'new-0)
            this (assoc this :readCache (EconomicMap/create Equivalence/DEFAULT))
        ]
            this
        )
    )

    (§ defn #_"ReadEliminationBlockState" ReadEliminationBlockState'new-1 [#_"ReadEliminationBlockState" other]
        (let [
            #_"ReadEliminationBlockState" this (EffectsBlockState'new-0)
            this (assoc this :readCache (EconomicMap/create Equivalence/DEFAULT, (:readCache other)))
        ]
            this
        )
    )

    #_unused
    (§ override! #_"boolean" ReadEliminationBlockState''equivalentTo-2 [#_"ReadEliminationBlockState" this, #_"ReadEliminationBlockState" other]
        (EffectsBlockState'isSubMapOf-2 (:readCache this), (:readCache other))
    )

    (§ method! #_"void" ReadEliminationBlockState''addCacheEntry-3 [#_"ReadEliminationBlockState" this, #_"CacheEntry" identifier, #_"ValueNode" value]
        (#_"EconomicMap" .put (:readCache this), identifier, value)
        nil
    )

    (§ method! #_"ValueNode" ReadEliminationBlockState''getCacheEntry-2 [#_"ReadEliminationBlockState" this, #_"CacheEntry" identifier]
        (get (:readCache this) identifier)
    )

    (§ method! #_"void" ReadEliminationBlockState''killReadCache-1 [#_"ReadEliminationBlockState" this]
        (#_"EconomicMap" .clear (:readCache this))
        nil
    )

    (§ method! #_"void" ReadEliminationBlockState''killReadCache-2 [#_"ReadEliminationBlockState" this, #_"LocationIdentity" identity]
        (let [
            #_"Iterator<CacheEntry>" it (#_"Iterable" .iterator (keys (:readCache this)))
        ]
            (while (#_"Iterator" .hasNext it)
                (when (CacheEntry''conflicts-2 (#_"Iterator" .next it), identity)
                    (#_"Iterator" .remove it)
                )
            )
        )
        nil
    )
)

;;;
 ; @anno ReadEliminationBlockState.CacheEntry
 ;;
(class-ns CacheEntry #_"<T>"
    (§ final #_"ValueNode" :object nil)
    (§ final #_"T" :identity nil)

    (§ defn #_"CacheEntry" CacheEntry'new-2 [#_"ValueNode" object, #_"T" identity]
        (let [
            #_"CacheEntry" this (Object.)
            this (assoc this :object object)
            this (assoc this :identity identity)
        ]
            this
        )
    )

    (§ abstract #_"CacheEntry<T>" CacheEntry''duplicateWithObject-2 [#_"CacheEntry<T>" this, #_"ValueNode" newObject])

    (§ abstract #_"boolean" CacheEntry''conflicts-2 [#_"CacheEntry<T>" this, #_"LocationIdentity" other])

    (§ abstract #_"LocationIdentity" CacheEntry''getIdentity-1 [#_"CacheEntry<T>" this])
)

;;;
 ; @anno ReadEliminationBlockState.LoadCacheEntry
 ;;
(final-ns LoadCacheEntry (§ extends CacheEntry #_"<LocationIdentity>")
    (§ defn #_"LoadCacheEntry" LoadCacheEntry'new-2 [#_"ValueNode" object, #_"LocationIdentity" identity]
        (CacheEntry'new-2 object, identity)
    )

    #_unused
    (§ override! #_"CacheEntry<LocationIdentity>" LoadCacheEntry''duplicateWithObject-2 [#_"LoadCacheEntry" this, #_"ValueNode" newObject]
        (LoadCacheEntry'new-2 newObject, (:identity this))
    )

    #_unused
    (§ override! #_"boolean" LoadCacheEntry''conflicts-2 [#_"LoadCacheEntry" this, #_"LocationIdentity" other]
        (= (:identity this) other)
    )

    #_unused
    (§ override! #_"LocationIdentity" LoadCacheEntry''getIdentity-1 [#_"LoadCacheEntry" this]
        (:identity this)
    )
)

;;;
 ; CacheEntry describing an Unsafe memory reference. The memory location and the
 ; location identity are separate so both must be considered when looking for optimizable memory accesses.
 ;
 ; @anno ReadEliminationBlockState.UnsafeLoadCacheEntry
 ;;
(final-ns UnsafeLoadCacheEntry (§ extends CacheEntry #_"<ValueNode>")
    (§ final #_"LocationIdentity" :locationIdentity nil)

    (§ defn #_"UnsafeLoadCacheEntry" UnsafeLoadCacheEntry'new-3 [#_"ValueNode" object, #_"ValueNode" location, #_"LocationIdentity" locationIdentity]
        (let [
            #_"UnsafeLoadCacheEntry" this (CacheEntry'new-2 object, location)
            this (assoc this :locationIdentity locationIdentity)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"CacheEntry<ValueNode>" UnsafeLoadCacheEntry''duplicateWithObject-2 [#_"UnsafeLoadCacheEntry" this, #_"ValueNode" newObject]
        (UnsafeLoadCacheEntry'new-3 newObject, (:identity this), (:locationIdentity this))
    )

    #_unused
    (§ override! #_"boolean" UnsafeLoadCacheEntry''conflicts-2 [#_"UnsafeLoadCacheEntry" this, #_"LocationIdentity" other]
        (= (:locationIdentity this) other)
    )

    #_unused
    (§ override! #_"LocationIdentity" UnsafeLoadCacheEntry''getIdentity-1 [#_"UnsafeLoadCacheEntry" this]
        (:locationIdentity this)
    )
)

;;;
 ; This closure initially handled a set of nodes that is disjunct from PEReadEliminationClosure,
 ; but over time both have evolved so that there's a significant overlap.
 ;;
(final-ns ReadEliminationClosure (§ extends EffectsClosure #_"<ReadEliminationBlockState>")
    (§ final #_"boolean" :considerGuards false)

    (§ defn #_"ReadEliminationClosure" ReadEliminationClosure'new-2 [#_"ControlFlowGraph" cfg, #_"boolean" considerGuards]
        (let [
            #_"ReadEliminationClosure" this (EffectsClosure'new-2 nil, cfg)
            this (assoc this :considerGuards considerGuards)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"ReadEliminationBlockState" ReadEliminationClosure''getInitialState-1 [#_"ReadEliminationClosure" this]
        (ReadEliminationBlockState'new-0)
    )

    #_unused
    (§ override! #_"boolean" ReadEliminationClosure''processNode-5 [#_"ReadEliminationClosure" this, #_"Node" node, #_"ReadEliminationBlockState" state, #_"GraphEffectList" effects, #_"FixedWithNextNode" lastFixedNode]
        (condp instance? node
            AccessFieldNode
                (if (AccessFieldNode''isVolatile-1 node)
                    (do
                        (ReadEliminationClosure'processIdentity-2 state, (LocationIdentity/any))
                        false
                    )
                    (let [
                        #_"ValueNode" object (GraphUtil'unproxify-1 (:object node))
                        #_"LoadCacheEntry" identifier (LoadCacheEntry'new-2 object, (FieldLocationIdentity'new-1 (AccessFieldNode''field-1 node)))
                        #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                    ]
                        (if (instance? LoadFieldNode node)
                            (if (and (some? cachedValue) (Stamp''isCompatible-2 (:stamp node), (:stamp cachedValue)))
                                (do
                                    (GraphEffectList''replaceAtUsages-4 effects, node, cachedValue, node)
                                    (EffectsClosure''addScalarAlias-3 this, node, cachedValue)
                                    true
                                )
                                (do
                                    (ReadEliminationBlockState''addCacheEntry-3 state, identifier, node)
                                    false
                                )
                            )
                            (let [
                                #_"ValueNode" value (EffectsClosure''getScalarAlias-2 this, (:value node))
                                #_"boolean" del? (= (GraphUtil'unproxify-1 value) (GraphUtil'unproxify-1 cachedValue))
                            ]
                                (when del?
                                    (GraphEffectList''deleteNode-2 effects, node)
                                )
                                (ReadEliminationBlockState''killReadCache-2 state, (:identity identifier))
                                (ReadEliminationBlockState''addCacheEntry-3 state, identifier, value)
                                del?
                            )
                        )
                    )
                )
            ReadNode
                (and (#_"LocationIdentity" .isSingle (FixedAccessNode''getLocationIdentity-1 node))
                    (let [
                        #_"ValueNode" object (GraphUtil'unproxify-1 (FixedAccessNode''getAddress-1 node))
                        #_"LoadCacheEntry" identifier (LoadCacheEntry'new-2 object, (FixedAccessNode''getLocationIdentity-1 node))
                        #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                    ]
                        (if (and (some? cachedValue) (ReadEliminationClosure'areValuesReplaceable-3 node, cachedValue, (:considerGuards this)))
                            (do
                                (GraphEffectList''replaceAtUsages-4 effects, node, cachedValue, node)
                                (EffectsClosure''addScalarAlias-3 this, node, cachedValue)
                                true
                            )
                            (do
                                (ReadEliminationBlockState''addCacheEntry-3 state, identifier, node)
                                false
                            )
                        )
                    )
                )
            WriteNode
                (if (#_"LocationIdentity" .isSingle (FixedAccessNode''getLocationIdentity-1 node))
                    (let [
                        #_"ValueNode" object (GraphUtil'unproxify-1 (FixedAccessNode''getAddress-1 node))
                        #_"LoadCacheEntry" identifier (LoadCacheEntry'new-2 object, (FixedAccessNode''getLocationIdentity-1 node))
                        #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                        #_"ValueNode" value (EffectsClosure''getScalarAlias-2 this, (AbstractWriteNode''value-1 node))
                        #_"boolean" del? (= (GraphUtil'unproxify-1 value) (GraphUtil'unproxify-1 cachedValue))
                    ]
                        (when del?
                            (GraphEffectList''deleteNode-2 effects, node)
                        )
                        (ReadEliminationClosure'processIdentity-2 state, (FixedAccessNode''getLocationIdentity-1 node))
                        (ReadEliminationBlockState''addCacheEntry-3 state, identifier, value)
                        del?
                    )
                    (do
                        (ReadEliminationClosure'processIdentity-2 state, (FixedAccessNode''getLocationIdentity-1 node))
                        false
                    )
                )
            UnsafeAccessNode
                (let [
                    #_"ResolvedJavaType" type (StampTool'typeOrNull-1 (:stamp (:object node)))
                ]
                    (and (some? type) (not (#_"ResolvedJavaType" .isArray type))
                        (if (instance? RawLoadNode node)
                            (and (#_"LocationIdentity" .isSingle (:locationIdentity node))
                                (let [
                                    #_"ValueNode" object (GraphUtil'unproxify-1 (:object node))
                                    #_"UnsafeLoadCacheEntry" identifier (UnsafeLoadCacheEntry'new-3 object, (:offset node), (:locationIdentity node))
                                    #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                                ]
                                    (if (and (some? cachedValue) (ReadEliminationClosure'areValuesReplaceable-3 node, cachedValue, (:considerGuards this)))
                                        (do
                                            (GraphEffectList''replaceAtUsages-4 effects, node, cachedValue, node)
                                            (EffectsClosure''addScalarAlias-3 this, node, cachedValue)
                                            true
                                        )
                                        (do
                                            (ReadEliminationBlockState''addCacheEntry-3 state, identifier, node)
                                            false
                                        )
                                    )
                                )
                            )
                            (if (#_"LocationIdentity" .isSingle (:locationIdentity node))
                                (let [
                                    #_"ValueNode" object (GraphUtil'unproxify-1 (:object node))
                                    #_"UnsafeLoadCacheEntry" identifier (UnsafeLoadCacheEntry'new-3 object, (:offset node), (:locationIdentity node))
                                    #_"ValueNode" cachedValue (ReadEliminationBlockState''getCacheEntry-2 state, identifier)
                                    #_"ValueNode" value (EffectsClosure''getScalarAlias-2 this, (:value node))
                                    #_"boolean" del? (= (GraphUtil'unproxify-1 value) (GraphUtil'unproxify-1 cachedValue))
                                ]
                                    (when del?
                                        (GraphEffectList''deleteNode-2 effects, node)
                                    )
                                    (ReadEliminationClosure'processIdentity-2 state, (:locationIdentity node))
                                    (ReadEliminationBlockState''addCacheEntry-3 state, identifier, value)
                                    del?
                                )
                                (do
                                    (ReadEliminationClosure'processIdentity-2 state, (:locationIdentity node))
                                    false
                                )
                            )
                        )
                    )
                )
            Single
                (let [
                    #_"LocationIdentity" identity (Single''getLocationIdentity-1 node)
                ]
                    (ReadEliminationClosure'processIdentity-2 state, identity)
                    false
                )
            Multi
                (do
                    (doseq [#_"LocationIdentity" identity (Multi''getLocationIdentities-1 node)]
                        (ReadEliminationClosure'processIdentity-2 state, identity)
                    )
                    false
                )
            false
        )
    )

    (§ defn- #_"boolean" ReadEliminationClosure'areValuesReplaceable-3 [#_"ValueNode" originalValue, #_"ValueNode" replacementValue, #_"boolean" considerGuards]
        (and (Stamp''isCompatible-2 (:stamp originalValue), (:stamp replacementValue)) (or (not considerGuards) (nil? (ReadEliminationClosure'getGuard-1 originalValue)) (= (ReadEliminationClosure'getGuard-1 originalValue) (ReadEliminationClosure'getGuard-1 replacementValue))))
    )

    (§ defn- #_"GuardingNode" ReadEliminationClosure'getGuard-1 [#_"ValueNode" node]
        (when (instance? GuardedNode node)
            (GuardedNode''getGuard-1 node)
        )
    )

    (§ defn- #_"void" ReadEliminationClosure'processIdentity-2 [#_"ReadEliminationBlockState" state, #_"LocationIdentity" identity]
        (if (#_"LocationIdentity" .isAny identity)
            (ReadEliminationBlockState''killReadCache-1 state)
            (ReadEliminationBlockState''killReadCache-2 state, identity)
        )
        nil
    )

    #_unused
    (§ override! #_"void" ReadEliminationClosure''processLoopExit-5 [#_"ReadEliminationClosure" this, #_"LoopExitNode" exitNode, #_"ReadEliminationBlockState" initialState, #_"ReadEliminationBlockState" exitState, #_"GraphEffectList" effects]
        (when (:hasValueProxies (:graph exitNode))
            (let [
                #_"MapCursor<CacheEntry, ValueNode>" entry (#_"EconomicMap" .getEntries (:readCache exitState))
            ]
                (while (#_"MapCursor" .advance entry)
                    (when-not (= (get (:readCache initialState) (#_"MapCursor" .getKey entry)) (#_"MapCursor" .getValue entry))
                        (let [
                            #_"ProxyNode" proxy (ValueProxyNode'new-2 (ReadEliminationBlockState''getCacheEntry-2 exitState, (#_"MapCursor" .getKey entry)), exitNode)
                        ]
                            (GraphEffectList''addFloatingNode-3 effects, proxy, "readCacheProxy")
                            (#_"EconomicMap" .put (:readCache exitState), (#_"MapCursor" .getKey entry), proxy)
                        )
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"ReadEliminationBlockState" ReadEliminationClosure''cloneState-2 [#_"ReadEliminationClosure" this, #_"ReadEliminationBlockState" other]
        (ReadEliminationBlockState'new-1 other)
    )

    #_unused
    (§ override! #_"MergeProcessor<ReadEliminationBlockState>" ReadEliminationClosure''createMergeProcessor-2 [#_"ReadEliminationClosure" this, #_"Block" merge]
        (ReadEliminationMergeProcessor'new-1 merge)
    )

    #_unused
    (§ override! #_"void" ReadEliminationClosure''processKilledLoopLocations-4 [#_"ReadEliminationClosure" this, #_"Loop" loop, #_"ReadEliminationBlockState" initialState, #_"ReadEliminationBlockState" mergedStates]
        (when (seq (:readCache initialState))
            (let [
                #_"LoopKillCache" loopKilledLocations (get (:loopLocationKillCache this) loop)
            ]
                ;; we have fully processed this loop the first time, remember to cache it the next time it is visited
                (if (nil? loopKilledLocations)
                    (do
                        (§ ass loopKilledLocations (LoopKillCache'new-1 1)) ;; 1.visit
                        (#_"EconomicMap" .put (:loopLocationKillCache this), loop, loopKilledLocations)
                    )
                    (do
                        (if (< GraalOptions'readEliminationMaxLoopVisits (:visits loopKilledLocations))
                            (do
                                ;; we have processed the loop too many times: kill all locations, so
                                ;; the inner loop will never be processed more than once again on visit
                                (§ ass! loopKilledLocations (LoopKillCache''setKillsAll-1 loopKilledLocations))
                            )
                            ;; we have fully processed this loop >1 times, update the killed locations
                            (let [
                                #_"EconomicSet<LocationIdentity>" forwardEndLiveLocations (EconomicSet/create Equivalence/DEFAULT)
                            ]
                                (doseq [#_"CacheEntry" entry (keys (:readCache initialState))]
                                    (#_"EconomicSet" .add forwardEndLiveLocations, (CacheEntry''getIdentity-1 entry))
                                )
                                (doseq [#_"CacheEntry" entry (keys (:readCache mergedStates))]
                                    (#_"EconomicSet" .remove forwardEndLiveLocations, (CacheEntry''getIdentity-1 entry))
                                )
                                ;; every location that is alive before the loop but not after is killed by the loop
                                (doseq [#_"LocationIdentity" location forwardEndLiveLocations]
                                    (§ ass! loopKilledLocations (LoopKillCache''rememberLoopKilledLocation-2 loopKilledLocations, location))
                                )
                            )
                        )
                        ;; remember the loop visit
                        (§ ass! loopKilledLocations (LoopKillCache''visited-1 loopKilledLocations))
                    )
                )
            )
        )
        nil
    )

    #_unused
    (§ override! #_"ReadEliminationBlockState" ReadEliminationClosure''stripKilledLoopLocations-3 [#_"ReadEliminationClosure" this, #_"Loop" loop, #_"ReadEliminationBlockState" originalInitialState]
        (let [
            #_"ReadEliminationBlockState" initialState (EffectsClosure''stripKilledLoopLocations-3 (§ super ), loop, originalInitialState)
            #_"LoopKillCache" loopKilledLocations (get (:loopLocationKillCache this) loop)
        ]
            (when (and (some? loopKilledLocations) (LoopKillCache''loopKillsLocations-1 loopKilledLocations))
                (let [
                    #_"Iterator<CacheEntry>" it (#_"Iterable" .iterator (keys (:readCache initialState)))
                ]
                    (while (#_"Iterator" .hasNext it)
                        (when (LoopKillCache''containsLocation-2 loopKilledLocations, (CacheEntry''getIdentity-1 (#_"Iterator" .next it)))
                            (#_"Iterator" .remove it)
                        )
                    )
                )
            )
            initialState
        )
    )
)

;;;
 ; @anno ReadEliminationClosure.ReadEliminationMergeProcessor
 ;;
(final-ns ReadEliminationMergeProcessor (§ extends MergeProcessor #_"<ReadEliminationBlockState>")
    (§ final #_"EconomicMap<Object, ValuePhiNode>" :materializedPhis (EconomicMap/create Equivalence/DEFAULT))

    (§ defn #_"ReadEliminationMergeProcessor" ReadEliminationMergeProcessor'new-1 [#_"Block" mergeBlock]
        (MergeProcessor'new-1 mergeBlock)
    )

    (§ method! #_"ValuePhiNode" ReadEliminationMergeProcessor''getCachedPhi-3 [#_"ReadEliminationMergeProcessor" this, #_"CacheEntry" virtual, #_"Stamp" stamp]
        (or (get (:materializedPhis this) virtual)
            (let [
                #_"ValuePhiNode" result (MergeProcessor''createValuePhi-2 this, stamp)
            ]
                (#_"EconomicMap" .put (:materializedPhis this), virtual, result)
                result
            )
        )
    )

    #_unused
    (§ override! #_"void" ReadEliminationMergeProcessor''merge-2 [#_"ReadEliminationMergeProcessor" this, #_"List<ReadEliminationBlockState>" states]
        (let [
            #_"MapCursor<CacheEntry, ValueNode>" cursor (#_"EconomicMap" .getEntries (:readCache (nth states 0)))
        ]
            (while (#_"MapCursor" .advance cursor)
                (let [
                    #_"CacheEntry" key (#_"MapCursor" .getKey cursor)
                    [#_"ValueNode" value #_"boolean" phi]
                        (loop-when [value (#_"MapCursor" .getValue cursor) phi false #_"int" i 1] (< i (count states)) => [value phi]
                            (let [
                                #_"ValueNode" other (get (:readCache (nth states i)) key)
                            ]
                                ;; e.g. unsafe loads/stores with different access kinds have different stamps although location,
                                ;; object and offset are the same, in this case we cannot create a phi nor can we set a common value
                                (when (and (some? other) (Stamp''isCompatible-2 (:stamp value), (:stamp other))) => [nil false]
                                    (recur value (or phi (not (= other value))) (inc i))
                                )
                            )
                        )
                ]
                    (cond
                        phi
                            (let [
                                #_"PhiNode" phiNode (ReadEliminationMergeProcessor''getCachedPhi-3 this, key, (Stamp''unrestricted-1 (:stamp value)))
                            ]
                                (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phiNode, "mergeReadCache")
                                (dotimes [#_"int" i (count states)]
                                    (MergeProcessor''setPhiInput-4 this, phiNode, i, (ReadEliminationBlockState''getCacheEntry-2 (nth states i), key))
                                )
                                (ReadEliminationBlockState''addCacheEntry-3 (:newState this), key, phiNode)
                            )
                        (some? value)
                            ;; there is the same value on all branches
                            (ReadEliminationBlockState''addCacheEntry-3 (:newState this), key, value)
                    )
                )
            )
            ;; For object phis, see if there are known reads on all predecessors, for which we could create new phis.
            (doseq [#_"PhiNode" phi (MergeProcessor''getPhis-1 this)]
                (when (= (ValueNode''getStackKind-1 phi) JavaKind/Object)
                    (doseq [#_"CacheEntry" entry (keys (:readCache (nth states 0)))]
                        (when (= (:object entry) (MergeProcessor''getPhiValueAt-3 this, phi, 0))
                            (ReadEliminationMergeProcessor''mergeReadCachePhi-4 this, phi, entry, states)
                        )
                    )
                )
            )
        )
        nil
    )

    (§ method- #_"void" ReadEliminationMergeProcessor''mergeReadCachePhi-4 [#_"ReadEliminationMergeProcessor" this, #_"PhiNode" phi, #_"CacheEntry" identifier, #_"List<ReadEliminationBlockState>" states]
        (let [
            #_"ValueNode[]" values (make-array ValueNode (count states))
        ]
            (aset values 0 (ReadEliminationBlockState''getCacheEntry-2 (nth states 0), (CacheEntry''duplicateWithObject-2 identifier, (MergeProcessor''getPhiValueAt-3 this, phi, 0))))
            (when (some? (nth values 0))
                (loop [#_"int" i 1]
                    (if (< i (count states))
                        (let [
                            #_"ValueNode" value (ReadEliminationBlockState''getCacheEntry-2 (nth states i), (CacheEntry''duplicateWithObject-2 identifier, (MergeProcessor''getPhiValueAt-3 this, phi, i)))
                        ]
                            ;; e.g. unsafe loads/stores with same identity, but different access kinds, see mergeReadCache(states)
                            (when (and (some? value) (Stamp''isCompatible-2 (:stamp (nth values (dec i))), (:stamp value)))
                                (aset values i value)
                                (recur (inc i))
                            )
                        )
                        (let [
                            #_"CacheEntry" newIdentifier (CacheEntry''duplicateWithObject-2 identifier, phi)
                            #_"PhiNode" phiNode (ReadEliminationMergeProcessor''getCachedPhi-3 this, newIdentifier, (Stamp''unrestricted-1 (:stamp (nth values 0))))
                        ]
                            (GraphEffectList''addFloatingNode-3 (:mergeEffects this), phiNode, "mergeReadCachePhi")
                            (dotimes [#_"int" i (count values)]
                                (MergeProcessor''setPhiInput-4 this, phiNode, i, (nth values i))
                            )
                            (ReadEliminationBlockState''addCacheEntry-3 (:newState this), newIdentifier, phiNode)
                        )
                    )
                )
            )
        )
        nil
    )
)

;;;
 ; Forwards calls from VirtualizerTool to the actual PartialEscapeBlockState.
 ;;
(final-ns VirtualizerToolImpl (§ implements VirtualizerTool, CanonicalizerTool)
    (§ final #_"PartialEscapeClosure" :closure nil)
    (§ mutable #_"ConstantNode" :illegalConstant nil)

    (§ mutable #_"boolean" :deleted false)
    (§ mutable #_"PartialEscapeBlockState" :state nil)
    (§ mutable #_"ValueNode" :current nil)
    (§ mutable #_"FixedNode" :position nil)
    (§ mutable #_"GraphEffectList" :effects nil)

    (§ defn #_"VirtualizerToolImpl" VirtualizerToolImpl'new-1 [#_"PartialEscapeClosure" closure]
        (let [
            #_"VirtualizerToolImpl" this (Object.)
            this (assoc this :closure closure)
        ]
            this
        )
    )

    (§ method! #_"VirtualizerToolImpl" VirtualizerToolImpl''reset-5 [#_"VirtualizerToolImpl" this, #_"PartialEscapeBlockState" state, #_"ValueNode" current, #_"FixedNode" position, #_"GraphEffectList" effects]
        (let [
            this (assoc this :deleted false)
            this (assoc this :state state)
            this (assoc this :current current)
            this (assoc this :position position)
            this (assoc this :effects effects)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"ValueNode" VirtualizerToolImpl''getAlias-2 [#_"VirtualizerToolImpl" this, #_"ValueNode" value]
        (PartialEscapeClosure''getAliasAndResolve-3 (:closure this), (:state this), value)
    )

    (§ override! #_"ValueNode" VirtualizerToolImpl''getEntry-3 [#_"VirtualizerToolImpl" this, #_"VirtualObjectNode" virtualObject, #_"int" index]
        (ObjectState''getEntry-2 (PartialEscapeBlockState''getObjectState-2 (:state this), virtualObject), index)
    )

    #_unused
    (§ override! #_"boolean" VirtualizerToolImpl''setVirtualEntry-6 [#_"VirtualizerToolImpl" this, #_"VirtualObjectNode" virtual, #_"int" index, #_"ValueNode" value, #_"JavaKind" theAccessKind, #_"long" offset]
        (let [
            #_"ObjectState" obj (PartialEscapeBlockState''getObjectState-2 (:state this), virtual)
            #_"JavaKind" entryKind (VirtualObjectNode''entryKind-2 virtual, index)
            #_"JavaKind" accessKind (or theAccessKind entryKind)
            #_"ValueNode" newValue (when (some? value) (PartialEscapeClosure''getAliasAndResolve-3 (:closure this), (:state this), value))
            #_"ValueNode" oldValue (VirtualizerToolImpl''getEntry-3 this, virtual, index)
            #_"boolean" canVirtualize
                (or (= entryKind accessKind) (and (= entryKind (#_"JavaKind" .getStackKind accessKind)) (instance? VirtualInstanceNode virtual))
                    ;; Special case: If the entryKind is long, allow arbitrary kinds as long as a value of the
                    ;; same kind is already there. This can only happen if some other node initialized the entry with
                    ;; a value of a different kind. One example where this happens is the Truffle NewFrameNode.
                    (and (= entryKind JavaKind/Long) (= (ValueNode''getStackKind-1 oldValue) (ValueNode''getStackKind-1 newValue)) (#_"JavaKind" .isPrimitive (ValueNode''getStackKind-1 oldValue)))
                    ;; Special case: Allow storing a single long or double value into two consecutive int slots.
                    (and (= entryKind JavaKind/Int) (= accessKind JavaKind/Long) (zero? (% offset 8)) (not (= (VirtualObjectNode''entryIndexForOffset-3 virtual, (+ offset 4), JavaKind/Int) -1)))
                )
        ]
            (when canVirtualize => false ;; should only occur if there are mismatches between the entry and access kind
                (PartialEscapeBlockState''setEntry-4 (:state this), (VirtualObjectNode''getObjectId-1 virtual), index, newValue)
                (when (= entryKind JavaKind/Int)
                    (cond
                        (#_"JavaKind" .needsTwoSlots accessKind)
                            ;; storing double word value two int slots
                            (PartialEscapeBlockState''setEntry-4 (:state this), (VirtualObjectNode''getObjectId-1 virtual), (inc index), (VirtualizerToolImpl''getIllegalConstant-1 this))
                        (= (ValueNode''getStackKind-1 oldValue) JavaKind/Long)
                            ;; splitting double word constant by storing over it with an int
                            (let [
                                #_"ValueNode" secondHalf (UnpackEndianHalfNode'create-2 oldValue, false)
                            ]
                                (VirtualizerToolImpl''addNode-2 this, secondHalf)
                                (PartialEscapeBlockState''setEntry-4 (:state this), (VirtualObjectNode''getObjectId-1 virtual), (inc index), secondHalf)
                            )
                    )
                )
                (when (and (instance? ConstantNode oldValue) (= (:value oldValue) (JavaConstant/forIllegal)))
                    ;; storing into second half of double, so replace previous value
                    (let [
                        #_"ValueNode" previous (VirtualizerToolImpl''getEntry-3 this, virtual, (dec index))
                        #_"ValueNode" firstHalf (UnpackEndianHalfNode'create-2 previous, true)
                    ]
                        (VirtualizerToolImpl''addNode-2 this, firstHalf)
                        (PartialEscapeBlockState''setEntry-4 (:state this), (VirtualObjectNode''getObjectId-1 virtual), (dec index), firstHalf)
                    )
                )
                true
            )
        )
    )

    (§ method- #_"ValueNode" VirtualizerToolImpl''getIllegalConstant-1 [#_"VirtualizerToolImpl" this]
        (when (nil? (:illegalConstant this))
            (§ ass! this (assoc this :illegalConstant (ConstantNode'forConstant-1 (JavaConstant/forIllegal))))
            (VirtualizerToolImpl''addNode-2 this, (:illegalConstant this))
        )
        (:illegalConstant this)
    )

    #_unused
    (§ override! #_"void" VirtualizerToolImpl''setEnsureVirtualized-3 [#_"VirtualizerToolImpl" this, #_"VirtualObjectNode" object, #_"boolean" ensure?]
        (PartialEscapeBlockState''setEnsureVirtualized-3 (:state this), (VirtualObjectNode''getObjectId-1 object), ensure?)
        nil
    )

    #_unused
    (§ override! #_"boolean" VirtualizerToolImpl''getEnsureVirtualized-2 [#_"VirtualizerToolImpl" this, #_"VirtualObjectNode" object]
        (:ensureVirtualized (PartialEscapeBlockState''getObjectState-2 (:state this), object))
    )

    (§ override! #_"void" VirtualizerToolImpl''replaceWithVirtual-2 [#_"VirtualizerToolImpl" this, #_"VirtualObjectNode" object]
        (PartialEscapeClosure''addVirtualAlias-3 (:closure this), object, (:current this))
        (GraphEffectList''deleteNode-2 (:effects this), (:current this))
        (§ ass! this (assoc this :deleted true))
        nil
    )

    (§ override! #_"void" VirtualizerToolImpl''replaceWithValue-2 [#_"VirtualizerToolImpl" this, #_"ValueNode" replacement]
        (GraphEffectList''replaceAtUsages-4 (:effects this), (:current this), (EffectsClosure''getScalarAlias-2 (:closure this), replacement), (:position this))
        (EffectsClosure''addScalarAlias-3 (:closure this), (:current this), replacement)
        (§ ass! this (assoc this :deleted true))
        nil
    )

    #_unused
    (§ override! #_"void" VirtualizerToolImpl''delete-1 [#_"VirtualizerToolImpl" this]
        (GraphEffectList''deleteNode-2 (:effects this), (:current this))
        (§ ass! this (assoc this :deleted true))
        nil
    )

    #_unused
    (§ override! #_"void" VirtualizerToolImpl''replaceFirstInput-3 [#_"VirtualizerToolImpl" this, #_"Node" oldInput, #_"Node" replacement]
        (GraphEffectList''replaceFirstInput-4 (:effects this), (:current this), oldInput, replacement)
        nil
    )

    (§ override! #_"void" VirtualizerToolImpl''addNode-2 [#_"VirtualizerToolImpl" this, #_"ValueNode" node]
        (if (instance? FloatingNode node)
            (GraphEffectList''addFloatingNode-3 (:effects this), node, "VirtualizerTool")
            (GraphEffectList''addFixedNodeBefore-3 (:effects this), node, (:position this))
        )
        nil
    )

    #_unused
    (§ override! #_"void" VirtualizerToolImpl''createVirtualObject-5 [#_"VirtualizerToolImpl" this, #_"VirtualObjectNode" virtualObject, #_"ValueNode[]" entryState, #_"List<MonitorIdNode>" locks, #_"boolean" ensureVirtualized]
        (when-not (Node''isAlive-1 virtualObject)
            (GraphEffectList''addFloatingNode-3 (:effects this), virtualObject, "newVirtualObject")
        )
        (dotimes [#_"int" i (count entryState)]
            (let [
                #_"ValueNode" entry (nth entryState i)
            ]
                (aset entryState i (if (instance? VirtualObjectNode entry) entry (PartialEscapeClosure''getAliasAndResolve-3 (:closure this), (:state this), entry)))
            )
        )
        (let [
            #_"int" id (VirtualObjectNode''getObjectId-1 virtualObject)
            id
                (when (= id -1) => id
                    (let [
                        id (count (:virtualObjects (:closure this)))
                    ]
                        (#_"ArrayList" .add (:virtualObjects (:closure this)), virtualObject)
                        (§ ass! virtualObject (VirtualObjectNode''setObjectId-2 virtualObject, id))
                        id
                    )
                )
        ]
            (PartialEscapeBlockState''addObject-3 (:state this), id, (ObjectState'new-3 entryState, locks, ensureVirtualized))
            (PartialEscapeClosure''addVirtualAlias-3 (:closure this), virtualObject, virtualObject)
            (§ ass! (:effects this) (GraphEffectList''addVirtualizationDelta-2 (:effects this), 1))
        )
        nil
    )

    #_unused
    (§ override! #_"int" VirtualizerToolImpl''getMaximumEntryCount-1 [#_"VirtualizerToolImpl" this]
        GraalOptions'maximumEscapeAnalysisArrayLength
    )

    #_unused
    (§ override! #_"void" VirtualizerToolImpl''replaceWith-2 [#_"VirtualizerToolImpl" this, #_"ValueNode" node]
        (if (instance? VirtualObjectNode node)
            (VirtualizerToolImpl''replaceWithVirtual-2 this, node)
            (VirtualizerToolImpl''replaceWithValue-2 this, node)
        )
        nil
    )

    #_unused
    (§ override! #_"boolean" VirtualizerToolImpl''ensureMaterialized-2 [#_"VirtualizerToolImpl" this, #_"VirtualObjectNode" object]
        (PartialEscapeClosure''ensureMaterialized-5 (:closure this), (:state this), (VirtualObjectNode''getObjectId-1 object), (:position this), (:effects this))
    )

    #_unused
    (§ override! #_"void" VirtualizerToolImpl''addLock-3 [#_"VirtualizerToolImpl" this, #_"VirtualObjectNode" object, #_"MonitorIdNode" monitorId]
        (PartialEscapeBlockState''addLock-3 (:state this), (VirtualObjectNode''getObjectId-1 object), monitorId)
        nil
    )

    #_unused
    (§ override! #_"MonitorIdNode" VirtualizerToolImpl''removeLock-2 [#_"VirtualizerToolImpl" this, #_"VirtualObjectNode" object]
        (PartialEscapeBlockState''removeLock-2 (:state this), (VirtualObjectNode''getObjectId-1 object))
    )

    #_unused
    (§ override! #_"boolean" VirtualizerToolImpl''canonicalizeReads-1 [#_"VirtualizerToolImpl" this]
        false
    )

    #_unused
    (§ override! #_"boolean" VirtualizerToolImpl''allUsagesAvailable-1 [#_"VirtualizerToolImpl" this]
        true
    )

    #_unused
    (§ override! #_"Integer" VirtualizerToolImpl''smallestCompareWidth-1 [#_"VirtualizerToolImpl" this]
        (Lowerer'smallestCompareWidth-0)
    )
)

;;;
 ; Medium-level memory access for objects. Similarly to the readXxx and writeXxx methods defined for
 ; Pointer and ObjectAccess, these methods access the memory without any nil-checks.
 ; However, these methods use read- or write barriers. When the VM uses compressed pointers,
 ; then readObject and writeObject methods access compressed pointers.
 ;;
(value-ns BarrieredAccess
    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"byte" BarrieredAccess'readByte-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"char" BarrieredAccess'readChar-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"short" BarrieredAccess'readShort-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"int" BarrieredAccess'readInt-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"long" BarrieredAccess'readLong-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"<T extends WordBase> T" BarrieredAccess'readWord-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"Object" BarrieredAccess'readObject-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"byte" BarrieredAccess'readByte-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"char" BarrieredAccess'readChar-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"short" BarrieredAccess'readShort-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"int" BarrieredAccess'readInt-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"long" BarrieredAccess'readLong-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"<T extends WordBase> T" BarrieredAccess'readWord-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"Object" BarrieredAccess'readObject-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeByte-4 [#_"Object" object, #_"WordBase" offset, #_"byte" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeChar-4 [#_"Object" object, #_"WordBase" offset, #_"char" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeShort-4 [#_"Object" object, #_"WordBase" offset, #_"short" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeInt-4 [#_"Object" object, #_"WordBase" offset, #_"int" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeLong-4 [#_"Object" object, #_"WordBase" offset, #_"long" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeWord-4 [#_"Object" object, #_"WordBase" offset, #_"WordBase" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeObject-4 [#_"Object" object, #_"WordBase" offset, #_"Object" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeByte-4 [#_"Object" object, #_"int" offset, #_"byte" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeChar-4 [#_"Object" object, #_"int" offset, #_"char" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeShort-4 [#_"Object" object, #_"int" offset, #_"short" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeInt-4 [#_"Object" object, #_"int" offset, #_"int" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeLong-4 [#_"Object" object, #_"int" offset, #_"long" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeWord-4 [#_"Object" object, #_"int" offset, #_"WordBase" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeObject-4 [#_"Object" object, #_"int" offset, #_"Object" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"byte" BarrieredAccess'readByte-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"char" BarrieredAccess'readChar-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"short" BarrieredAccess'readShort-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"int" BarrieredAccess'readInt-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"long" BarrieredAccess'readLong-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"<T extends WordBase> T" BarrieredAccess'readWord-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"Object" BarrieredAccess'readObject-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"byte" BarrieredAccess'readByte-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"char" BarrieredAccess'readChar-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"short" BarrieredAccess'readShort-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"int" BarrieredAccess'readInt-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"long" BarrieredAccess'readLong-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"<T extends WordBase> T" BarrieredAccess'readWord-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_BARRIERED)
    #_unused
    (§ native #_"Object" BarrieredAccess'readObject-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeByte-3 [#_"Object" object, #_"WordBase" offset, #_"byte" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeChar-3 [#_"Object" object, #_"WordBase" offset, #_"char" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeShort-3 [#_"Object" object, #_"WordBase" offset, #_"short" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeInt-3 [#_"Object" object, #_"WordBase" offset, #_"int" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeLong-3 [#_"Object" object, #_"WordBase" offset, #_"long" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeWord-3 [#_"Object" object, #_"WordBase" offset, #_"WordBase" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeObject-3 [#_"Object" object, #_"WordBase" offset, #_"Object" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeByte-3 [#_"Object" object, #_"int" offset, #_"byte" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeChar-3 [#_"Object" object, #_"int" offset, #_"char" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeShort-3 [#_"Object" object, #_"int" offset, #_"short" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeInt-3 [#_"Object" object, #_"int" offset, #_"int" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeLong-3 [#_"Object" object, #_"int" offset, #_"long" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeWord-3 [#_"Object" object, #_"int" offset, #_"WordBase" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_BARRIERED)
    #_unused
    (§ native #_"void" BarrieredAccess'writeObject-3 [#_"Object" object, #_"int" offset, #_"Object" val])
)

;;;
 ; Low-level memory access for objects. Similarly to the readXxx and writeXxx methods defined for
 ; Pointer, these methods access the raw memory without any nil-checks, read- or write
 ; barriers. When the VM uses compressed pointers, then readObject and writeObject methods access
 ; compressed pointers.
 ;;
(value-ns ObjectAccess
    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"byte" ObjectAccess'readByte-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"char" ObjectAccess'readChar-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"short" ObjectAccess'readShort-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"int" ObjectAccess'readInt-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"long" ObjectAccess'readLong-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"<T extends WordBase> T" ObjectAccess'readWord-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"Object" ObjectAccess'readObject-3 [#_"Object" object, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"byte" ObjectAccess'readByte-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"char" ObjectAccess'readChar-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"short" ObjectAccess'readShort-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"int" ObjectAccess'readInt-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"long" ObjectAccess'readLong-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"<T extends WordBase> T" ObjectAccess'readWord-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"Object" ObjectAccess'readObject-3 [#_"Object" object, #_"int" offset, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeByte-4 [#_"Object" object, #_"WordBase" offset, #_"byte" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeChar-4 [#_"Object" object, #_"WordBase" offset, #_"char" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeShort-4 [#_"Object" object, #_"WordBase" offset, #_"short" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeInt-4 [#_"Object" object, #_"WordBase" offset, #_"int" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeLong-4 [#_"Object" object, #_"WordBase" offset, #_"long" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeWord-4 [#_"Object" object, #_"WordBase" offset, #_"WordBase" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeObject-4 [#_"Object" object, #_"WordBase" offset, #_"Object" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeByte-4 [#_"Object" object, #_"int" offset, #_"byte" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeChar-4 [#_"Object" object, #_"int" offset, #_"char" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeShort-4 [#_"Object" object, #_"int" offset, #_"short" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeInt-4 [#_"Object" object, #_"int" offset, #_"int" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeLong-4 [#_"Object" object, #_"int" offset, #_"long" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeWord-4 [#_"Object" object, #_"int" offset, #_"WordBase" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeObject-4 [#_"Object" object, #_"int" offset, #_"Object" val, #_"LocationIdentity" locationIdentity])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"byte" ObjectAccess'readByte-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"char" ObjectAccess'readChar-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"short" ObjectAccess'readShort-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"int" ObjectAccess'readInt-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"long" ObjectAccess'readLong-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"<T extends WordBase> T" ObjectAccess'readWord-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"Object" ObjectAccess'readObject-2 [#_"Object" object, #_"WordBase" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"byte" ObjectAccess'readByte-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"char" ObjectAccess'readChar-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"short" ObjectAccess'readShort-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"int" ObjectAccess'readInt-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"long" ObjectAccess'readLong-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"<T extends WordBase> T" ObjectAccess'readWord-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Reads the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'READ_OBJECT)
    #_unused
    (§ native #_"Object" ObjectAccess'readObject-2 [#_"Object" object, #_"int" offset])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeByte-3 [#_"Object" object, #_"WordBase" offset, #_"byte" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeChar-3 [#_"Object" object, #_"WordBase" offset, #_"char" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeShort-3 [#_"Object" object, #_"WordBase" offset, #_"short" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeInt-3 [#_"Object" object, #_"WordBase" offset, #_"int" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeLong-3 [#_"Object" object, #_"WordBase" offset, #_"long" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeWord-3 [#_"Object" object, #_"WordBase" offset, #_"WordBase" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeObject-3 [#_"Object" object, #_"WordBase" offset, #_"Object" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeByte-3 [#_"Object" object, #_"int" offset, #_"byte" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeChar-3 [#_"Object" object, #_"int" offset, #_"char" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeShort-3 [#_"Object" object, #_"int" offset, #_"short" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeInt-3 [#_"Object" object, #_"int" offset, #_"int" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeLong-3 [#_"Object" object, #_"int" offset, #_"long" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeWord-3 [#_"Object" object, #_"int" offset, #_"WordBase" val])

    ;;;
     ; Writes the memory at address {@code (object + offset)}. The offset is in bytes.
     ;;
    ; @Operation(opcode = WordOpcode'WRITE_OBJECT)
    #_unused
    (§ native #_"void" ObjectAccess'writeObject-3 [#_"Object" object, #_"int" offset, #_"Object" val])
)

(class-ns Word (§ implements SignedWord, UnsignedWord, Pointer)
    (§ defn #_"void" Word'ensureInitialized-0 []
        ;; Calling this method ensures that the static initializer has been executed.
        nil
    )

    (§ init
        (BoxFactoryImpl'initialize-0)
    )

    (§ defn #_"Word" Word'new-0 []
        (Object.)
    )

    ;; Outside users must use the different signed() and unsigned() methods to ensure proper
    ;; expansion of 32-bit values on 64-bit systems.
    (§ defn- #_"<T extends WordBase> T" Word'box-1 [#_"long" val]
        (§ cast #_"T" (HostedWord'boxLong-1 val))
    )

    (§ abstract #_"long" Word''unbox-1 [#_"Word" this])

    (§ defn- #_"Word" Word'intParam-1 [#_"int" val]
        (Word'box-1 val)
    )

    ; @Operation(opcode = WordOpcode'TO_RAW_VALUE)
    (§ override #_"long" Word''rawValue-1 [#_"Word" this]
        (Word''unbox-1 this)
    )

    ;;;
     ; Convert an Object to a Pointer, keeping the reference information. If the
     ; returned pointer or any value derived from it is alive across a safepoint, it will be
     ; tracked. Depending on the arithmetic on the pointer and the capabilities of the backend to
     ; deal with derived references, this may work correctly, or result in a compiler error.
     ;;
    ; @Operation(opcode = WordOpcode'OBJECT_TO_TRACKED)
    (§ native #_"Word" Word'objectToTrackedPointer-1 [#_"Object" val])

    ;;;
     ; Convert an Object to a Pointer, dropping the reference information. If the
     ; returned pointer or any value derived from it is alive across a safepoint, it will be treated
     ; as a simple integer and not tracked by the garbage collector.
     ;
     ; This is a dangerous operation, the GC could move the object without updating the pointer! Use
     ; only in combination with some mechanism to prevent the GC from moving or freeing the object
     ; as long as the pointer is in use.
     ;
     ; If the result value should not be alive across a safepoint, it's better to use
     ; #objectToTrackedPointer(Object) instead.
     ;;
    ; @Operation(opcode = WordOpcode'OBJECT_TO_UNTRACKED)
    #_unused
    (§ native #_"Word" Word'objectToUntrackedPointer-1 [#_"Object" val])

    ; @Operation(opcode = WordOpcode'FROM_ADDRESS)
    (§ native #_"Word" Word'fromAddress-1 [#_"Address" address])

    ; @Operation(opcode = WordOpcode'TO_OBJECT)
    #_native
    (§ abstract #_"Object" Word''toObject-1 [#_"Word" this])

    ; @Operation(opcode = WordOpcode'TO_OBJECT_NON_NULL)
    #_native
    (§ abstract #_"Object" Word''toObjectNonNull-1 [#_"Word" this])

    ; @Operation(node = AddNode.class)
    (§ override #_"Word" Word''add-2 [#_"Word" this, #_"SignedWord" val]
        (Word''add-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = AddNode.class)
    (§ override #_"Word" Word''add-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''add-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = AddNode.class)
    (§ override #_"Word" Word''add-2 [#_"Word" this, #_"int" val]
        (Word''add-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = AddNode.class)
    (§ method #_"Word" Word''add-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (+ (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = SubNode.class)
    (§ override #_"Word" Word''subtract-2 [#_"Word" this, #_"SignedWord" val]
        (Word''subtract-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = SubNode.class)
    (§ override #_"Word" Word''subtract-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''subtract-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = SubNode.class)
    (§ override #_"Word" Word''subtract-2 [#_"Word" this, #_"int" val]
        (Word''subtract-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = SubNode.class)
    (§ method #_"Word" Word''subtract-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (- (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = MulNode.class)
    (§ override #_"Word" Word''multiply-2 [#_"Word" this, #_"SignedWord" val]
        (Word''multiply-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = MulNode.class)
    (§ override #_"Word" Word''multiply-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''multiply-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = MulNode.class)
    (§ override #_"Word" Word''multiply-2 [#_"Word" this, #_"int" val]
        (Word''multiply-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = MulNode.class)
    (§ method! #_"Word" Word''multiply-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (* (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = SignedDivNode.class)
    (§ override #_"Word" Word''signedDivide-2 [#_"Word" this, #_"SignedWord" val]
        (Word''signedDivide-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = SignedDivNode.class)
    (§ override #_"Word" Word''signedDivide-2 [#_"Word" this, #_"int" val]
        (Word''signedDivide-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = SignedDivNode.class)
    (§ method! #_"Word" Word''signedDivide-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (quot (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = UnsignedDivNode.class)
    (§ override #_"Word" Word''unsignedDivide-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''unsignedDivide-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = UnsignedDivNode.class)
    (§ override #_"Word" Word''unsignedDivide-2 [#_"Word" this, #_"int" val]
        (Word''signedDivide-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = UnsignedDivNode.class)
    (§ method! #_"Word" Word''unsignedDivide-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (Long/divideUnsigned (Word''unbox-1 this), (Word''unbox-1 val)))
    )

    ; @Operation(node = SignedRemNode.class)
    (§ override #_"Word" Word''signedRemainder-2 [#_"Word" this, #_"SignedWord" val]
        (Word''signedRemainder-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = SignedRemNode.class)
    (§ override #_"Word" Word''signedRemainder-2 [#_"Word" this, #_"int" val]
        (Word''signedRemainder-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = SignedRemNode.class)
    (§ method! #_"Word" Word''signedRemainder-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (% (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = UnsignedRemNode.class)
    (§ override #_"Word" Word''unsignedRemainder-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''unsignedRemainder-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = UnsignedRemNode.class)
    (§ override #_"Word" Word''unsignedRemainder-2 [#_"Word" this, #_"int" val]
        (Word''signedRemainder-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = UnsignedRemNode.class)
    (§ method! #_"Word" Word''unsignedRemainder-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (Long/remainderUnsigned (Word''unbox-1 this), (Word''unbox-1 val)))
    )

    ; @Operation(node = LeftShiftNode.class, rightOperandIsInt = true)
    (§ override #_"Word" Word''shiftLeft-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''shiftLeft-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = LeftShiftNode.class, rightOperandIsInt = true)
    (§ override #_"Word" Word''shiftLeft-2 [#_"Word" this, #_"int" val]
        (Word''shiftLeft-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = LeftShiftNode.class, rightOperandIsInt = true)
    (§ method! #_"Word" Word''shiftLeft-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (<< (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = RightShiftNode.class, rightOperandIsInt = true)
    (§ override #_"Word" Word''signedShiftRight-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''signedShiftRight-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = RightShiftNode.class, rightOperandIsInt = true)
    (§ override #_"Word" Word''signedShiftRight-2 [#_"Word" this, #_"int" val]
        (Word''signedShiftRight-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = RightShiftNode.class, rightOperandIsInt = true)
    (§ method! #_"Word" Word''signedShiftRight-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (>> (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = UnsignedRightShiftNode.class, rightOperandIsInt = true)
    (§ override #_"Word" Word''unsignedShiftRight-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''unsignedShiftRight-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = UnsignedRightShiftNode.class, rightOperandIsInt = true)
    (§ override #_"Word" Word''unsignedShiftRight-2 [#_"Word" this, #_"int" val]
        (Word''unsignedShiftRight-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = UnsignedRightShiftNode.class, rightOperandIsInt = true)
    (§ method! #_"Word" Word''unsignedShiftRight-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (>>> (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = AndNode.class)
    (§ override #_"Word" Word''and-2 [#_"Word" this, #_"SignedWord" val]
        (Word''and-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = AndNode.class)
    (§ override #_"Word" Word''and-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''and-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = AndNode.class)
    (§ override #_"Word" Word''and-2 [#_"Word" this, #_"int" val]
        (Word''and-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = AndNode.class)
    (§ method #_"Word" Word''and-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (& (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = OrNode.class)
    (§ override #_"Word" Word''or-2 [#_"Word" this, #_"SignedWord" val]
        (Word''or-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = OrNode.class)
    (§ override #_"Word" Word''or-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''or-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = OrNode.class)
    (§ override #_"Word" Word''or-2 [#_"Word" this, #_"int" val]
        (Word''or-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = OrNode.class)
    (§ method #_"Word" Word''or-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (| (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(node = XorNode.class)
    (§ override #_"Word" Word''xor-2 [#_"Word" this, #_"SignedWord" val]
        (Word''xor-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = XorNode.class)
    (§ override #_"Word" Word''xor-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''xor-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(node = XorNode.class)
    (§ override #_"Word" Word''xor-2 [#_"Word" this, #_"int" val]
        (Word''xor-2 this, (Word'intParam-1 val))
    )

    ; @Operation(node = XorNode.class)
    (§ method! #_"Word" Word''xor-2 [#_"Word" this, #_"Word" val]
        (Word'box-1 (bit-xor (Word''unbox-1 this) (Word''unbox-1 val)))
    )

    ; @Operation(opcode = WordOpcode'NOT)
    #_unused
    (§ override #_"Word" Word''not-1 [#_"Word" this]
        (Word'box-1 (bit-not (Word''unbox-1 this)))
    )

    ; @Operation(opcode = WordOpcode'IS_NULL)
    #_unused
    (§ override #_"boolean" Word''isNull-1 [#_"Word" this]
        (Word''equal-2 this, (WordFactory/zero))
    )

    ; @Operation(opcode = WordOpcode'IS_NON_NULL)
    #_unused
    (§ override #_"boolean" Word''isNonNull-1 [#_"Word" this]
        (Word''notEqual-2 this, (WordFactory/zero))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'EQ)
    (§ override #_"boolean" Word''equal-2 [#_"Word" this, #_"ComparableWord" val]
        (Word''equal-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'EQ)
    (§ override #_"boolean" Word''equal-2 [#_"Word" this, #_"SignedWord" val]
        (Word''equal-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'EQ)
    (§ override #_"boolean" Word''equal-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''equal-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'EQ)
    (§ override #_"boolean" Word''equal-2 [#_"Word" this, #_"int" val]
        (Word''equal-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'EQ)
    (§ method #_"boolean" Word''equal-2 [#_"Word" this, #_"Word" val]
        (= (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'NE)
    (§ override #_"boolean" Word''notEqual-2 [#_"Word" this, #_"ComparableWord" val]
        (Word''notEqual-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'NE)
    (§ override #_"boolean" Word''notEqual-2 [#_"Word" this, #_"SignedWord" val]
        (Word''notEqual-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'NE)
    (§ override #_"boolean" Word''notEqual-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''notEqual-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'NE)
    (§ override #_"boolean" Word''notEqual-2 [#_"Word" this, #_"int" val]
        (Word''notEqual-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'NE)
    (§ method #_"boolean" Word''notEqual-2 [#_"Word" this, #_"Word" val]
        (not= (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'LT)
    (§ override #_"boolean" Word''lessThan-2 [#_"Word" this, #_"SignedWord" val]
        (Word''lessThan-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'LT)
    (§ override #_"boolean" Word''lessThan-2 [#_"Word" this, #_"int" val]
        (Word''lessThan-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'LT)
    (§ method #_"boolean" Word''lessThan-2 [#_"Word" this, #_"Word" val]
        (< (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'LE)
    (§ override #_"boolean" Word''lessOrEqual-2 [#_"Word" this, #_"SignedWord" val]
        (Word''lessOrEqual-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'LE)
    (§ override #_"boolean" Word''lessOrEqual-2 [#_"Word" this, #_"int" val]
        (Word''lessOrEqual-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'LE)
    (§ method! #_"boolean" Word''lessOrEqual-2 [#_"Word" this, #_"Word" val]
        (<= (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'GT)
    (§ override #_"boolean" Word''greaterThan-2 [#_"Word" this, #_"SignedWord" val]
        (Word''greaterThan-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'GT)
    (§ override #_"boolean" Word''greaterThan-2 [#_"Word" this, #_"int" val]
        (Word''greaterThan-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'GT)
    (§ method! #_"boolean" Word''greaterThan-2 [#_"Word" this, #_"Word" val]
        (> (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'GE)
    (§ override #_"boolean" Word''greaterOrEqual-2 [#_"Word" this, #_"SignedWord" val]
        (Word''greaterOrEqual-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'GE)
    (§ override #_"boolean" Word''greaterOrEqual-2 [#_"Word" this, #_"int" val]
        (Word''greaterOrEqual-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'GE)
    (§ method! #_"boolean" Word''greaterOrEqual-2 [#_"Word" this, #_"Word" val]
        (>= (Word''unbox-1 this) (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'BT)
    (§ override #_"boolean" Word''belowThan-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''belowThan-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'BT)
    (§ override #_"boolean" Word''belowThan-2 [#_"Word" this, #_"int" val]
        (Word''belowThan-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'BT)
    (§ method! #_"boolean" Word''belowThan-2 [#_"Word" this, #_"Word" val]
        (UnsignedMath'belowThan-2 (Word''unbox-1 this), (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'BE)
    (§ override #_"boolean" Word''belowOrEqual-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''belowOrEqual-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'BE)
    (§ override #_"boolean" Word''belowOrEqual-2 [#_"Word" this, #_"int" val]
        (Word''belowOrEqual-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'BE)
    (§ method! #_"boolean" Word''belowOrEqual-2 [#_"Word" this, #_"Word" val]
        (UnsignedMath'belowOrEqual-2 (Word''unbox-1 this), (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'AT)
    (§ override #_"boolean" Word''aboveThan-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''aboveThan-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'AT)
    (§ override #_"boolean" Word''aboveThan-2 [#_"Word" this, #_"int" val]
        (Word''aboveThan-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'AT)
    (§ method! #_"boolean" Word''aboveThan-2 [#_"Word" this, #_"Word" val]
        (UnsignedMath'aboveThan-2 (Word''unbox-1 this), (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'AE)
    (§ override #_"boolean" Word''aboveOrEqual-2 [#_"Word" this, #_"UnsignedWord" val]
        (Word''aboveOrEqual-2 this, (§ cast #_"Word" val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'AE)
    (§ override #_"boolean" Word''aboveOrEqual-2 [#_"Word" this, #_"int" val]
        (Word''aboveOrEqual-2 this, (Word'intParam-1 val))
    )

    ; @Operation(opcode = WordOpcode'COMPARISON, condition = Condition'AE)
    (§ method! #_"boolean" Word''aboveOrEqual-2 [#_"Word" this, #_"Word" val]
        (UnsignedMath'aboveOrEqual-2 (Word''unbox-1 this), (Word''unbox-1 val))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"byte" Word''readByte-3 [#_"Word" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity]
        (.getByte HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"char" Word''readChar-3 [#_"Word" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity]
        (.getChar HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"short" Word''readShort-3 [#_"Word" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity]
        (.getShort HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"int" Word''readInt-3 [#_"Word" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity]
        (.getInt HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"long" Word''readLong-3 [#_"Word" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity]
        (.getLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"<T extends WordBase> T" Word''readWord-3 [#_"Word" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity]
        (Word'box-1 (.getAddress HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset)))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_native
    (§ abstract #_"Object" Word''readObject-3 [#_"Word" this, #_"WordBase" offset, #_"LocationIdentity" locationIdentity])

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"byte" Word''readByte-3 [#_"Word" this, #_"int" offset, #_"LocationIdentity" locationIdentity]
        (Word''readByte-3 this, (WordFactory/signed offset), locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"char" Word''readChar-3 [#_"Word" this, #_"int" offset, #_"LocationIdentity" locationIdentity]
        (Word''readChar-3 this, (WordFactory/signed offset), locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"short" Word''readShort-3 [#_"Word" this, #_"int" offset, #_"LocationIdentity" locationIdentity]
        (Word''readShort-3 this, (WordFactory/signed offset), locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"int" Word''readInt-3 [#_"Word" this, #_"int" offset, #_"LocationIdentity" locationIdentity]
        (Word''readInt-3 this, (WordFactory/signed offset), locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"long" Word''readLong-3 [#_"Word" this, #_"int" offset, #_"LocationIdentity" locationIdentity]
        (Word''readLong-3 this, (WordFactory/signed offset), locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"<T extends WordBase> T" Word''readWord-3 [#_"Word" this, #_"int" offset, #_"LocationIdentity" locationIdentity]
        (Word''readWord-3 this, (WordFactory/signed offset), locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"Object" Word''readObject-3 [#_"Word" this, #_"int" offset, #_"LocationIdentity" locationIdentity]
        (Word''readObject-3 this, (WordFactory/signed offset), locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeByte-4 [#_"Word" this, #_"WordBase" offset, #_"byte" val, #_"LocationIdentity" locationIdentity]
        (.putByte HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeChar-4 [#_"Word" this, #_"WordBase" offset, #_"char" val, #_"LocationIdentity" locationIdentity]
        (.putChar HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeShort-4 [#_"Word" this, #_"WordBase" offset, #_"short" val, #_"LocationIdentity" locationIdentity]
        (.putShort HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeInt-4 [#_"Word" this, #_"WordBase" offset, #_"int" val, #_"LocationIdentity" locationIdentity]
        (.putInt HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeLong-4 [#_"Word" this, #_"WordBase" offset, #_"long" val, #_"LocationIdentity" locationIdentity]
        (.putLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeWord-4 [#_"Word" this, #_"WordBase" offset, #_"WordBase" val, #_"LocationIdentity" locationIdentity]
        (.putAddress HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), (Word''unbox-1 (§ cast #_"Word" val)))
        nil
    )

    ; @Operation(opcode = WordOpcode'INITIALIZE)
    (§ override #_"void" Word''initializeLong-4 [#_"Word" this, #_"WordBase" offset, #_"long" val, #_"LocationIdentity" locationIdentity]
        (.putLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_native
    (§ abstract #_"void" Word''writeObject-4 [#_"Word" this, #_"WordBase" offset, #_"Object" val, #_"LocationIdentity" locationIdentity])

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeByte-4 [#_"Word" this, #_"int" offset, #_"byte" val, #_"LocationIdentity" locationIdentity]
        (Word''writeByte-4 this, (WordFactory/signed offset), val, locationIdentity)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeChar-4 [#_"Word" this, #_"int" offset, #_"char" val, #_"LocationIdentity" locationIdentity]
        (Word''writeChar-4 this, (WordFactory/signed offset), val, locationIdentity)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeShort-4 [#_"Word" this, #_"int" offset, #_"short" val, #_"LocationIdentity" locationIdentity]
        (Word''writeShort-4 this, (WordFactory/signed offset), val, locationIdentity)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeInt-4 [#_"Word" this, #_"int" offset, #_"int" val, #_"LocationIdentity" locationIdentity]
        (Word''writeInt-4 this, (WordFactory/signed offset), val, locationIdentity)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeLong-4 [#_"Word" this, #_"int" offset, #_"long" val, #_"LocationIdentity" locationIdentity]
        (Word''writeLong-4 this, (WordFactory/signed offset), val, locationIdentity)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeWord-4 [#_"Word" this, #_"int" offset, #_"WordBase" val, #_"LocationIdentity" locationIdentity]
        (Word''writeWord-4 this, (WordFactory/signed offset), val, locationIdentity)
        nil
    )

    ; @Operation(opcode = WordOpcode'INITIALIZE)
    (§ override #_"void" Word''initializeLong-4 [#_"Word" this, #_"int" offset, #_"long" val, #_"LocationIdentity" locationIdentity]
        (Word''initializeLong-4 this, (WordFactory/signed offset), val, locationIdentity)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeObject-4 [#_"Word" this, #_"int" offset, #_"Object" val, #_"LocationIdentity" locationIdentity]
        (Word''writeObject-4 this, (WordFactory/signed offset), val, locationIdentity)
        nil
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"byte" Word''readByte-2 [#_"Word" this, #_"WordBase" offset]
        (.getByte HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"char" Word''readChar-2 [#_"Word" this, #_"WordBase" offset]
        (.getChar HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"short" Word''readShort-2 [#_"Word" this, #_"WordBase" offset]
        (.getShort HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"int" Word''readInt-2 [#_"Word" this, #_"WordBase" offset]
        (.getInt HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"long" Word''readLong-2 [#_"Word" this, #_"WordBase" offset]
        (.getLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"<T extends WordBase> T" Word''readWord-2 [#_"Word" this, #_"WordBase" offset]
        (Word'box-1 (.getAddress HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset)))))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    #_native
    (§ abstract #_"Object" Word''readObject-2 [#_"Word" this, #_"WordBase" offset])

    ; @Operation(opcode = WordOpcode'READ_HEAP)
    #_native
    (§ abstract #_"Object" Word''readObject-3 [#_"Word" this, #_"WordBase" offset, #_"BarrierType" barrierType])

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"byte" Word''readByte-2 [#_"Word" this, #_"int" offset]
        (Word''readByte-2 this, (WordFactory/signed offset))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"char" Word''readChar-2 [#_"Word" this, #_"int" offset]
        (Word''readChar-2 this, (WordFactory/signed offset))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"short" Word''readShort-2 [#_"Word" this, #_"int" offset]
        (Word''readShort-2 this, (WordFactory/signed offset))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"int" Word''readInt-2 [#_"Word" this, #_"int" offset]
        (Word''readInt-2 this, (WordFactory/signed offset))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"long" Word''readLong-2 [#_"Word" this, #_"int" offset]
        (Word''readLong-2 this, (WordFactory/signed offset))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"<T extends WordBase> T" Word''readWord-2 [#_"Word" this, #_"int" offset]
        (Word''readWord-2 this, (WordFactory/signed offset))
    )

    ; @Operation(opcode = WordOpcode'READ_POINTER)
    (§ override #_"Object" Word''readObject-2 [#_"Word" this, #_"int" offset]
        (Word''readObject-2 this, (WordFactory/signed offset))
    )

    ; @Operation(opcode = WordOpcode'READ_HEAP)
    (§ method #_"Object" Word''readObject-3 [#_"Word" this, #_"int" offset, #_"BarrierType" barrierType]
        (Word''readObject-3 this, (WordFactory/signed offset), barrierType)
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeByte-3 [#_"Word" this, #_"WordBase" offset, #_"byte" val]
        (.putByte HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeChar-3 [#_"Word" this, #_"WordBase" offset, #_"char" val]
        (.putChar HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeShort-3 [#_"Word" this, #_"WordBase" offset, #_"short" val]
        (.putShort HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeInt-3 [#_"Word" this, #_"WordBase" offset, #_"int" val]
        (.putInt HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeLong-3 [#_"Word" this, #_"WordBase" offset, #_"long" val]
        (.putLong HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    #_native
    (§ override #_"int" Word''compareAndSwapInt-5 [#_"Word" this, #_"WordBase" offset, #_"int" expectedValue, #_"int" newValue, #_"LocationIdentity" locationIdentity])

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    #_native
    (§ override #_"long" Word''compareAndSwapLong-5 [#_"Word" this, #_"WordBase" offset, #_"long" expectedValue, #_"long" newValue, #_"LocationIdentity" locationIdentity])

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    #_native
    (§ override #_"<T extends WordBase> T" Word''compareAndSwapWord-5 [#_"Word" this, #_"WordBase" offset, #_"T" expectedValue, #_"T" newValue, #_"LocationIdentity" locationIdentity])

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    #_native
    (§ override #_"Object" Word''compareAndSwapObject-5 [#_"Word" this, #_"WordBase" offset, #_"Object" expectedValue, #_"Object" newValue, #_"LocationIdentity" locationIdentity])

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"boolean" Word''logicCompareAndSwapInt-5 [#_"Word" this, #_"WordBase" offset, #_"int" expectedValue, #_"int" newValue, #_"LocationIdentity" locationIdentity]
        (.compareAndSwapInt HotSpot'unsafe, (Word''toObject-1 this), (Word''unbox-1 (§ cast #_"Word" offset)), expectedValue, newValue)
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"boolean" Word''logicCompareAndSwapLong-5 [#_"Word" this, #_"WordBase" offset, #_"long" expectedValue, #_"long" newValue, #_"LocationIdentity" locationIdentity]
        (.compareAndSwapLong HotSpot'unsafe, (Word''toObject-1 this), (Word''unbox-1 (§ cast #_"Word" offset)), expectedValue, newValue)
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    #_native
    (§ override #_"boolean" Word''logicCompareAndSwapWord-5 [#_"Word" this, #_"WordBase" offset, #_"WordBase" expectedValue, #_"WordBase" newValue, #_"LocationIdentity" locationIdentity])

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"boolean" Word''logicCompareAndSwapObject-5 [#_"Word" this, #_"WordBase" offset, #_"Object" expectedValue, #_"Object" newValue, #_"LocationIdentity" locationIdentity]
        (.compareAndSwapObject HotSpot'unsafe, (Word''toObject-1 this), (Word''unbox-1 (§ cast #_"Word" offset)), expectedValue, newValue)
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeWord-3 [#_"Word" this, #_"WordBase" offset, #_"WordBase" val]
        (.putAddress HotSpot'unsafe, (Word''unbox-1 (Word''add-2 this, (§ cast #_"Word" offset))), (Word''unbox-1 (§ cast #_"Word" val)))
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    #_native
    (§ abstract #_"void" Word''writeObject-3 [#_"Word" this, #_"WordBase" offset, #_"Object" val])

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeByte-3 [#_"Word" this, #_"int" offset, #_"byte" val]
        (Word''writeByte-3 this, (WordFactory/signed offset), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeChar-3 [#_"Word" this, #_"int" offset, #_"char" val]
        (Word''writeChar-3 this, (WordFactory/signed offset), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeShort-3 [#_"Word" this, #_"int" offset, #_"short" val]
        (Word''writeShort-3 this, (WordFactory/signed offset), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeInt-3 [#_"Word" this, #_"int" offset, #_"int" val]
        (Word''writeInt-3 this, (WordFactory/signed offset), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeLong-3 [#_"Word" this, #_"int" offset, #_"long" val]
        (Word''writeLong-3 this, (WordFactory/signed offset), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeWord-3 [#_"Word" this, #_"int" offset, #_"WordBase" val]
        (Word''writeWord-3 this, (WordFactory/signed offset), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'WRITE_POINTER)
    (§ override #_"void" Word''writeObject-3 [#_"Word" this, #_"int" offset, #_"Object" val]
        (Word''writeObject-3 this, (WordFactory/signed offset), val)
        nil
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"int" Word''compareAndSwapInt-5 [#_"Word" this, #_"int" offset, #_"int" expectedValue, #_"int" newValue, #_"LocationIdentity" locationIdentity]
        (Word''compareAndSwapInt-5 this, (WordFactory/signed offset), expectedValue, newValue, locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"long" Word''compareAndSwapLong-5 [#_"Word" this, #_"int" offset, #_"long" expectedValue, #_"long" newValue, #_"LocationIdentity" locationIdentity]
        (Word''compareAndSwapLong-5 this, (WordFactory/signed offset), expectedValue, newValue, locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"<T extends WordBase> T" Word''compareAndSwapWord-5 [#_"Word" this, #_"int" offset, #_"T" expectedValue, #_"T" newValue, #_"LocationIdentity" locationIdentity]
        (Word''compareAndSwapWord-5 this, (WordFactory/signed offset), expectedValue, newValue, locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"Object" Word''compareAndSwapObject-5 [#_"Word" this, #_"int" offset, #_"Object" expectedValue, #_"Object" newValue, #_"LocationIdentity" locationIdentity]
        (Word''compareAndSwapObject-5 this, (WordFactory/signed offset), expectedValue, newValue, locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"boolean" Word''logicCompareAndSwapInt-5 [#_"Word" this, #_"int" offset, #_"int" expectedValue, #_"int" newValue, #_"LocationIdentity" locationIdentity]
        (Word''logicCompareAndSwapInt-5 this, (WordFactory/signed offset), expectedValue, newValue, locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"boolean" Word''logicCompareAndSwapLong-5 [#_"Word" this, #_"int" offset, #_"long" expectedValue, #_"long" newValue, #_"LocationIdentity" locationIdentity]
        (Word''logicCompareAndSwapLong-5 this, (WordFactory/signed offset), expectedValue, newValue, locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"boolean" Word''logicCompareAndSwapWord-5 [#_"Word" this, #_"int" offset, #_"WordBase" expectedValue, #_"WordBase" newValue, #_"LocationIdentity" locationIdentity]
        (Word''logicCompareAndSwapWord-5 this, (WordFactory/signed offset), expectedValue, newValue, locationIdentity)
    )

    ; @Operation(opcode = WordOpcode'CAS_POINTER)
    (§ override #_"boolean" Word''logicCompareAndSwapObject-5 [#_"Word" this, #_"int" offset, #_"Object" expectedValue, #_"Object" newValue, #_"LocationIdentity" locationIdentity]
        (Word''logicCompareAndSwapObject-5 this, (WordFactory/signed offset), expectedValue, newValue, locationIdentity)
    )
)

;;;
 ; Links a method to a canonical operation represented by an WordOpcode val.
 ;
 ; @anno Word.Operation
 ; @target ElementType.METHOD
 ;;
(§ annotation Operation
    (§ value #_"Class<? extends ValueNode>" node ValueNode)

    (§ value #_"boolean" rightOperandIsInt false)

    (§ value #_"WordOpcode" opcode WordOpcode'NODE_CLASS)

    (§ value #_"Condition" condition Condition'EQ)
)

;;;
 ; The canonical Operation represented by a method in the Word class.
 ;
 ; @anno Word.WordOpcode
 ;;
(value-ns WordOpcode
    (§ enum WordOpcode'NODE_CLASS)
    (§ enum WordOpcode'COMPARISON)
    (§ enum WordOpcode'IS_NULL)
    (§ enum WordOpcode'IS_NON_NULL)
    (§ enum WordOpcode'NOT)
    (§ enum WordOpcode'READ_POINTER)
    (§ enum WordOpcode'READ_OBJECT)
    (§ enum WordOpcode'READ_BARRIERED)
    (§ enum WordOpcode'READ_HEAP)
    (§ enum WordOpcode'WRITE_POINTER)
    (§ enum WordOpcode'WRITE_OBJECT)
    (§ enum WordOpcode'WRITE_BARRIERED)
    (§ enum WordOpcode'CAS_POINTER)
    (§ enum WordOpcode'INITIALIZE)
    (§ enum WordOpcode'FROM_ADDRESS)
    (§ enum WordOpcode'OBJECT_TO_TRACKED)
    (§ enum WordOpcode'OBJECT_TO_UNTRACKED)
    (§ enum WordOpcode'TO_OBJECT)
    (§ enum WordOpcode'TO_OBJECT_NON_NULL)
    (§ enum WordOpcode'TO_RAW_VALUE)
)

;;;
 ; @anno Word.BoxFactoryImpl
 ;;
(final-ns BoxFactoryImpl (§ extends WordBoxFactory)
    (§ defn #_"BoxFactoryImpl" BoxFactoryImpl'new-0 []
        (WordBoxFactory.)
    )

    (§ defn #_"void" BoxFactoryImpl'initialize-0 []
        (§ ass WordBoxFactory/boxFactory (BoxFactoryImpl'new-0))
        nil
    )

    #_unused
    (§ override! #_"<T extends WordBase> T" BoxFactoryImpl''boxImpl-2 [#_"BoxFactoryImpl" this, #_"long" val]
        (§ cast #_"T" (HostedWord'boxLong-1 val))
    )
)

(final-ns HostedWord (§ extends Word)
    (def- #_"int" HostedWord'SMALL_FROM -1)
    (def- #_"int" HostedWord'SMALL_TO 100)

    (§ def- #_"HostedWord[]" HostedWord'smallCache (make-array HostedWord (inc (- HostedWord'SMALL_TO HostedWord'SMALL_FROM))))

    (§ init
        (loop-when-recur [#_"int" i HostedWord'SMALL_FROM] (<= i HostedWord'SMALL_TO) [(inc i)]
            (aset HostedWord'smallCache (- i HostedWord'SMALL_FROM) (HostedWord'new-1 i))
        )
    )

    (§ final #_"long" :rawValue 0)

    (§ defn- #_"HostedWord" HostedWord'new-1 [#_"long" rawValue]
        (let [
            #_"HostedWord" this (Word'new-0)
            this (assoc this :rawValue rawValue)
        ]
            this
        )
    )

    (§ defn #_"Word" HostedWord'boxLong-1 [#_"long" val]
        (if (<= HostedWord'SMALL_FROM val HostedWord'SMALL_TO) (nth HostedWord'smallCache (int (- val HostedWord'SMALL_FROM))) (HostedWord'new-1 val))
    )

    #_unused
    (§ override! #_"long" HostedWord''unbox-1 [#_"HostedWord" this]
        (:rawValue this)
    )
)

;;;
 ; Casts between Word and Object exposed by the Word#fromAddress,
 ; Word#objectToTrackedPointer, Word#objectToUntrackedPointer and
 ; Word#toObject() operations. It has an impact on the pointer maps for the GC,
 ; so it must not be scheduled or optimized away.
 ;;
(final-ns WordCastNode (§ extends FixedWithNextNode) (§ implements LIRLowerable, Canonicalizable)
    (§ def #_"NodeClass<WordCastNode>" WordCastNode'TYPE (NodeClass'create-1 WordCastNode))

    ; @Input
    (§ mutable #_"ValueNode" :input nil)
    (§ final #_"boolean" :trackedPointer false)

    (§ defn #_"WordCastNode" WordCastNode'wordToObject-2 [#_"ValueNode" input, #_"JavaKind" wordKind]
        (WordCastNode'new-2 StampFactory'objectStamp, input)
    )

    (§ defn #_"WordCastNode" WordCastNode'wordToObjectNonNull-2 [#_"ValueNode" input, #_"JavaKind" wordKind]
        (WordCastNode'new-2 StampFactory'objectNonNullStamp, input)
    )

    (§ defn #_"WordCastNode" WordCastNode'addressToWord-2 [#_"ValueNode" input, #_"JavaKind" wordKind]
        (WordCastNode'new-2 (StampFactory'forKind-1 wordKind), input)
    )

    (§ defn #_"WordCastNode" WordCastNode'objectToTrackedPointer-2 [#_"ValueNode" input, #_"JavaKind" wordKind]
        (WordCastNode'new-3 (StampFactory'forKind-1 wordKind), input, true)
    )

    (§ defn #_"WordCastNode" WordCastNode'objectToUntrackedPointer-2 [#_"ValueNode" input, #_"JavaKind" wordKind]
        (WordCastNode'new-3 (StampFactory'forKind-1 wordKind), input, false)
    )

    (§ defn #_"WordCastNode" WordCastNode'new-2 [#_"Stamp" stamp, #_"ValueNode" input]
        (WordCastNode'new-3 stamp, input, true)
    )

    (§ defn #_"WordCastNode" WordCastNode'new-3 [#_"Stamp" stamp, #_"ValueNode" input, #_"boolean" trackedPointer]
        (let [
            #_"WordCastNode" this (FixedWithNextNode'new-2 WordCastNode'TYPE, stamp)
            this (assoc this :input input)
            this (assoc this :trackedPointer trackedPointer)
        ]
            this
        )
    )

    #_unused
    (§ override! #_"Node" WordCastNode''canonical-2 [#_"WordCastNode" this, #_"CanonicalizerTool" tool]
        (cond
            (and (CanonicalizerTool''allUsagesAvailable-1 tool) (Node''hasNoUsages-1 this))
                ;; if the cast is unused, it can be eliminated
                (:input this)
            (instance? ConstantNode (:input this))
                ;; null pointers are uncritical for GC, so they can be constant folded
                (cond
                    (#_"JavaConstant" .isNull (ValueNode''asJavaConstant-1 (:input this)))
                        (ConstantNode'forIntegerStamp-2 (:stamp this), 0)
                    (and (-> (ValueNode''asJavaConstant-1 (:input this)) (#_"JavaConstant" .getJavaKind) (#_"JavaKind" .isNumericInteger))
                        (zero? (#_"JavaConstant" .asLong (ValueNode''asJavaConstant-1 (:input this))))
                    )
                        (ConstantNode'forConstant-2 (:stamp this), JavaConstant/NULL_POINTER)
                    :else
                        this
                )
            :else
                this
        )
    )

    #_unused
    (§ override! #_"void" WordCastNode''generate-2 [#_"WordCastNode" this, #_"LIRBuilder" builder]
        (let [
            #_"Value" value (LIRBuilder''operand-2 builder, (:input this))
            #_"ValueKind" kind (Stamp''getLIRKind-1 (:stamp this))
            kind
                (when (and (:trackedPointer this) (LIRKind'isValue-1 kind) (not (LIRKind'isValue-1 value))) => kind
                    ;; just change the PlatformKind, but don't drop reference information
                    (#_"ValueKind" .changeType (#_"Value" .getValueKind value), (#_"ValueKind" .getPlatformKind kind))
                )
        ]
            (if (and (= kind (#_"Value" .getValueKind value)) (not (instance? ConstantValue value)))
                (LIRBuilder''setResult-3 builder, this, value)
                (let [
                    #_"AllocatableValue" result (LIRGenerator''newVariable-2 (:gen builder), kind)
                ]
                    (LIRGenerator''emitMove-3 (:gen builder), result, value)
                    (LIRBuilder''setResult-3 builder, this, result)
                )
            )
        )
        nil
    )
)

;;;
 ; A plugin for calls to word operations, as well as all other nodes
 ; that need special handling for Word types.
 ;;
(class-ns WordOperationPlugin (§ implements NodePlugin, TypePlugin, InlineInvokePlugin)
    (§ defn #_"WordOperationPlugin" WordOperationPlugin'new-0 []
        (Object.)
    )

    ;;;
     ; Processes a call to a method if it is annotated as a word operation by adding nodes to the graph
     ; being built that implement the denoted operation.
     ;
     ; @return true iff {@code method} is annotated with Operation (and was thus processed by this method)
     ;;
    (§ override #_"boolean" WordOperationPlugin''handleInvoke-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"ValueNode[]" args]
        (and (WordTypes'isWordOperation-1 method)
            (do
                (WordOperationPlugin''processWordOperation-4 this, parser, args, (WordTypes'getWordOperation-2 method, (#_"ResolvedJavaMethod" .getDeclaringClass (BytecodeParser''getMethod-1 parser))))
                true
            )
        )
    )

    (§ override #_"StampPair" WordOperationPlugin''interceptType-4 [#_"WordOperationPlugin" this, #_"GraphBuilderTool" b, #_"JavaType" type, #_"boolean" never-nil?]
        (let [
            #_"Stamp" wordStamp
                (when (instance? ResolvedJavaType type)
                    (cond
                        (WordTypes'isWord-1 type)
                            (WordTypes'getWordStamp-1 type)
                        (and (#_"ResolvedJavaType" .isArray type) (WordTypes'isWord-1 (#_"ResolvedJavaType" .getElementalType type)))
                            (StampFactory'object-2 (TypeReference'createTrusted-1 type), never-nil?)
                    )
                )
        ]
            (when (some? wordStamp) (StampPair'new-2 wordStamp, nil))
        )
    )

    #_unused
    (§ override #_"void" WordOperationPlugin''notifyNotInlined-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaMethod" method, #_"InvokeNode" invoke]
        (when (WordTypes'isWord-1 invoke)
            (§ ass! invoke (ValueNode''setStamp-2 invoke, (WordTypes'getWordStamp-1 (StampTool'typeOrNull-1 (:stamp invoke)))))
        )
        nil
    )

    (§ override #_"boolean" WordOperationPlugin''handleLoadField-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" receiver, #_"ResolvedJavaField" field]
        (let [
            #_"StampPair" wordStamp (WordOperationPlugin''interceptType-4 this, parser, (#_"ResolvedJavaField" .getType field), false)
        ]
            (and (some? wordStamp)
                (do
                    (BytecodeParser''addPush-3 parser, (#_"ResolvedJavaField" .getJavaKind field), (LoadFieldNode'createOverrideStamp-3 wordStamp, receiver, field))
                    true
                )
            )
        )
    )

    (§ override #_"boolean" WordOperationPlugin''handleLoadStaticField-3 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" staticField]
        (WordOperationPlugin''handleLoadField-4 this, parser, nil, staticField)
    )

    (§ override #_"boolean" WordOperationPlugin''handleLoadIndexed-5 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind]
        (let [
            #_"ResolvedJavaType" arrayType (StampTool'typeOrNull-1 (:stamp array))
        ]
            ;; There are cases where the array does not have a known type yet, i.e. the type is nil.
            ;; In that case we assume it is not a word type.
            (and (some? arrayType) (WordTypes'isWord-1 (#_"ResolvedJavaType" .getComponentType arrayType))
                (do
                    (BytecodeParser''addPush-3 parser, elementKind, (WordOperationPlugin''createLoadIndexedNode-3 this, array, index))
                    true
                )
            )
        )
    )

    (§ method #_"LoadIndexedNode" WordOperationPlugin''createLoadIndexedNode-3 [#_"WordOperationPlugin" this, #_"ValueNode" array, #_"ValueNode" index]
        (LoadIndexedNode'new-3 array, index, WordTypes'wordKind)
    )

    (§ override #_"boolean" WordOperationPlugin''handleStoreField-5 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaField" field, #_"ValueNode" value]
        (and (= (#_"ResolvedJavaField" .getJavaKind field) JavaKind/Object)
            (let [
                #_"boolean" isWordField (WordTypes'isWord-1 (#_"ResolvedJavaField" .getType field))
                #_"boolean" isWordValue (= (ValueNode''getStackKind-1 value) WordTypes'wordKind)
            ]
                (cond
                    (and isWordField (not isWordValue))
                        (throw! (str "cannot store a non-word value into a word field: " (#_"ResolvedJavaField" .format field, "%H.\n")))
                    (and (not isWordField) isWordValue)
                        (throw! (str "cannot store a word value into a non-word field: " (#_"ResolvedJavaField" .format field, "%H.\n")))
                    :else
                        false ;; we never need to intercept the field store
                )
            )
        )
    )

    (§ override #_"boolean" WordOperationPlugin''handleStoreStaticField-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ResolvedJavaField" field, #_"ValueNode" value]
        (WordOperationPlugin''handleStoreField-5 this, parser, nil, field, value)
    )

    (§ override #_"boolean" WordOperationPlugin''handleStoreIndexed-6 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" array, #_"ValueNode" index, #_"JavaKind" elementKind, #_"ValueNode" value]
        (let [
            #_"ResolvedJavaType" arrayType (StampTool'typeOrNull-1 (:stamp array))
        ]
            (if (and (some? arrayType) (WordTypes'isWord-1 (#_"ResolvedJavaType" .getComponentType arrayType)))
                (do
                    (when-not (= (ValueNode''getStackKind-1 value) WordTypes'wordKind)
                        (throw! (str "cannot store a non-word value into a word array: " (#_"ResolvedJavaType" .toJavaName arrayType, true)))
                    )
                    (BytecodeParser''add-2 parser, (WordOperationPlugin''createStoreIndexedNode-4 this, array, index, value))
                    true
                )
                (do
                    (when (and (= elementKind JavaKind/Object) (= (ValueNode''getStackKind-1 value) WordTypes'wordKind))
                        (throw! (str "cannot store a word value into a non-word array: " (#_"ResolvedJavaType" .toJavaName arrayType, true)))
                    )
                    false
                )
            )
        )
    )

    (§ method! #_"StoreIndexedNode" WordOperationPlugin''createStoreIndexedNode-4 [#_"WordOperationPlugin" this, #_"ValueNode" array, #_"ValueNode" index, #_"ValueNode" value]
        (StoreIndexedNode'new-4 array, index, WordTypes'wordKind, value)
    )

    (§ override #_"boolean" WordOperationPlugin''handleCheckCast-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
        (if (WordTypes'isWord-1 type)
            (when (= (ValueNode''getStackKind-1 object) WordTypes'wordKind) => (throw! (str "cannot cast a non-word value to a word type: " (#_"ResolvedJavaType" .toJavaName type, true)))
                (BytecodeParser''push-3 parser, JavaKind/Object, object)
                true
            )
            (when (= (ValueNode''getStackKind-1 object) JavaKind/Object) => (throw! (str "cannot cast a word value to a non-word type: " (#_"ResolvedJavaType" .toJavaName type, true)))
                false
            )
        )
    )

    (§ override #_"boolean" WordOperationPlugin''handleInstanceOf-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" object, #_"ResolvedJavaType" type]
        (cond
            (WordTypes'isWord-1 type)
                (throw! (str "cannot use instanceof for word a type: " (#_"ResolvedJavaType" .toJavaName type, true)))
            (not= (ValueNode''getStackKind-1 object) JavaKind/Object)
                (throw! (str "cannot use instanceof on a word value: " (#_"ResolvedJavaType" .toJavaName type, true)))
            :else
                false
        )
    )

    (§ method! #_"void" WordOperationPlugin''processWordOperation-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode[]" args, #_"ResolvedJavaMethod" wordMethod]
        (let [
            #_"JavaKind" returnKind (#_"Signature" .getReturnKind (#_"ResolvedJavaMethod" .getSignature wordMethod))
            #_"WordFactoryOperation" factoryOperation (BridgeMethodUtils'getAnnotation-2 WordFactoryOperation, wordMethod)
        ]
            (or
                (when (some? factoryOperation)
                    (condp = (#_"WordFactoryOperation" .opcode factoryOperation)
                        WordFactoryOpcode'ZERO
                        (do
                            (BytecodeParser''addPush-3 parser, returnKind, (ConstantNode'forIntegerKind-2 WordTypes'wordKind, 0))
                            :done
                        )
                        WordFactoryOpcode'FROM_UNSIGNED
                        (do
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin''fromUnsigned-3 this, parser, (nth args 0)))
                            :done
                        )
                        WordFactoryOpcode'FROM_SIGNED
                        (do
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin''fromSigned-3 this, parser, (nth args 0)))
                            :done
                        )
                        nil
                    )
                )

                (let [
                    #_"Operation" operation (BridgeMethodUtils'getAnnotation-2 Operation, wordMethod)
                ]
                    (when (nil? operation)
                        (throw! (str "cannot call method on a word value: " (#_"ResolvedJavaMethod" .format wordMethod, "%H.\n(%p)")))
                    )
                    (condp =? (Operation''opcode-1 operation)
                        WordOpcode'NODE_CLASS
                            (let [
                                #_"ValueNode" left (nth args 0)
                                #_"ValueNode" right (if (Operation''rightOperandIsInt-1 operation) (WordOperationPlugin''toUnsigned-4 this, parser, (nth args 1), JavaKind/Int) (WordOperationPlugin''fromSigned-3 this, parser, (nth args 1)))
                            ]
                                (BytecodeParser''addPush-3 parser, returnKind, (WordOperationPlugin'createBinaryNodeInstance-3 (Operation''node-1 operation), left, right))
                            )
                        WordOpcode'COMPARISON
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin''comparisonOp-5 this, parser, (Operation''condition-1 operation), (nth args 0), (WordOperationPlugin''fromSigned-3 this, parser, (nth args 1))))
                        WordOpcode'IS_NULL
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin''comparisonOp-5 this, parser, Condition'EQ, (nth args 0), (ConstantNode'forIntegerKind-2 WordTypes'wordKind, 0)))
                        WordOpcode'IS_NON_NULL
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin''comparisonOp-5 this, parser, Condition'NE, (nth args 0), (ConstantNode'forIntegerKind-2 WordTypes'wordKind, 0)))
                        WordOpcode'NOT
                            (BytecodeParser''addPush-3 parser, returnKind, (XorNode'new-2 (nth args 0), (BytecodeParser''add-2 parser, (ConstantNode'forIntegerKind-2 WordTypes'wordKind, -1))))
                    [WordOpcode'READ_POINTER WordOpcode'READ_OBJECT WordOpcode'READ_BARRIERED]
                            (let [
                                #_"JavaKind" readKind (WordTypes'asKind-1 (#_"Signature" .getReturnType (#_"ResolvedJavaMethod" .getSignature wordMethod), (#_"ResolvedJavaMethod" .getDeclaringClass wordMethod)))
                                #_"AddressNode" address (WordOperationPlugin''makeAddress-4 this, parser, (nth args 0), (nth args 1))
                                #_"LocationIdentity" location
                                    (if (= (count args) 2)
                                        (LocationIdentity/any)
                                        (SnippetReflection'asObject-2 LocationIdentity, (ValueNode''asJavaConstant-1 (nth args 2)))
                                    )
                            ]
                                (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin''readOp-6 this, parser, readKind, address, location, (Operation''opcode-1 operation)))
                            )
                        WordOpcode'READ_HEAP
                            (let [
                                #_"JavaKind" readKind (WordTypes'asKind-1 (#_"Signature" .getReturnType (#_"ResolvedJavaMethod" .getSignature wordMethod), (#_"ResolvedJavaMethod" .getDeclaringClass wordMethod)))
                                #_"AddressNode" address (WordOperationPlugin''makeAddress-4 this, parser, (nth args 0), (nth args 1))
                                #_"BarrierType" barrierType (SnippetReflection'asObject-2 BarrierType, (ValueNode''asJavaConstant-1 (nth args 2)))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin'readOp-6 parser, readKind, address, (LocationIdentity/any), barrierType, true))
                            )
                    [WordOpcode'WRITE_POINTER WordOpcode'WRITE_OBJECT WordOpcode'WRITE_BARRIERED WordOpcode'INITIALIZE]
                            (let [
                                #_"JavaKind" writeKind (WordTypes'asKind-1 (#_"Signature" .getParameterType (#_"ResolvedJavaMethod" .getSignature wordMethod), (if (#_"ResolvedJavaMethod" .isStatic wordMethod) 2 1), (#_"ResolvedJavaMethod" .getDeclaringClass wordMethod)))
                                #_"AddressNode" address (WordOperationPlugin''makeAddress-4 this, parser, (nth args 0), (nth args 1))
                                #_"LocationIdentity" location
                                    (if (= (count args) 3)
                                        (LocationIdentity/any)
                                        (SnippetReflection'asObject-2 LocationIdentity, (ValueNode''asJavaConstant-1 (nth args 3)))
                                    )
                            ]
                                (WordOperationPlugin''writeOp-7 this, parser, writeKind, address, location, (nth args 2), (Operation''opcode-1 operation))
                            )
                        WordOpcode'TO_RAW_VALUE
                            (BytecodeParser''push-3 parser, returnKind, (WordOperationPlugin''toUnsigned-4 this, parser, (nth args 0), JavaKind/Long))
                        WordOpcode'OBJECT_TO_TRACKED
                            (let [
                                #_"WordCastNode" objectToTracked (BytecodeParser''add-2 parser, (WordCastNode'objectToTrackedPointer-2 (nth args 0), WordTypes'wordKind))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, objectToTracked)
                            )
                        WordOpcode'OBJECT_TO_UNTRACKED
                            (let [
                                #_"WordCastNode" objectToUntracked (BytecodeParser''add-2 parser, (WordCastNode'objectToUntrackedPointer-2 (nth args 0), WordTypes'wordKind))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, objectToUntracked)
                            )
                        WordOpcode'FROM_ADDRESS
                            (let [
                                #_"WordCastNode" addressToWord (BytecodeParser''add-2 parser, (WordCastNode'addressToWord-2 (nth args 0), WordTypes'wordKind))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, addressToWord)
                            )
                        WordOpcode'TO_OBJECT
                            (let [
                                #_"WordCastNode" wordToObject (BytecodeParser''add-2 parser, (WordCastNode'wordToObject-2 (nth args 0), WordTypes'wordKind))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, wordToObject)
                            )
                        WordOpcode'TO_OBJECT_NON_NULL
                            (let [
                                #_"WordCastNode" wordToObjectNonNull (BytecodeParser''add-2 parser, (WordCastNode'wordToObjectNonNull-2 (nth args 0), WordTypes'wordKind))
                            ]
                                (BytecodeParser''push-3 parser, returnKind, wordToObjectNonNull)
                            )
                        WordOpcode'CAS_POINTER
                            (let [
                                #_"AddressNode" address (WordOperationPlugin''makeAddress-4 this, parser, (nth args 0), (nth args 1))
                                #_"JavaKind" valueKind (WordTypes'asKind-1 (#_"Signature" .getParameterType (#_"ResolvedJavaMethod" .getSignature wordMethod), 1, (#_"ResolvedJavaMethod" .getDeclaringClass wordMethod)))
                                #_"LocationIdentity" location (SnippetReflection'asObject-2 LocationIdentity, (ValueNode''asJavaConstant-1 (nth args 4)))
                                #_"JavaType" returnType (#_"Signature" .getReturnType (#_"ResolvedJavaMethod" .getSignature wordMethod), (#_"ResolvedJavaMethod" .getDeclaringClass wordMethod))
                            ]
                                (BytecodeParser''addPush-3 parser, returnKind, (WordOperationPlugin''casOp-7 this, valueKind, (WordTypes'asKind-1 returnType), address, location, (nth args 2), (nth args 3)))
                            )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Create an instance of a binary node which is used to lower Word operations.
     ; This method is called for all Word operations which are annotated with
     ; @Operation(node = ...) and encapsulates the reflective allocation of the node.
     ;;
    (§ defn- #_"ValueNode" WordOperationPlugin'createBinaryNodeInstance-3 [#_"Class<? extends ValueNode>" nodeClass, #_"ValueNode" left, #_"ValueNode" right]
        (#_"Constructor" .newInstance (#_"Class" .getDeclaredConstructor nodeClass, ValueNode, ValueNode), left, right)
    )

    (§ method- #_"ValueNode" WordOperationPlugin''comparisonOp-5 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"Condition" condition, #_"ValueNode" left, #_"ValueNode" right]
        (let [
            #_"CanonicalizedCondition" canonical (Condition''canonicalize-1 condition)
            #_"ValueNode" a (if (:mirror? canonical) right left)
            #_"ValueNode" b (if (:mirror? canonical) left right)
            #_"CompareNode" comparison
                (condp = (:canonicalCondition canonical)
                    CanonicalCondition'EQ (IntegerEqualsNode'new-2 a, b)
                    CanonicalCondition'BT (IntegerBelowNode'new-2 a, b)
                                          (IntegerLessThanNode'new-2 a, b)
                )
            #_"ConstantNode" t (BytecodeParser''add-2 parser, (ConstantNode'forInt-1 1))
            #_"ConstantNode" f (BytecodeParser''add-2 parser, (ConstantNode'forInt-1 0))
            [t f] (if (:negate? canonical) [f t] [t f])
        ]
            (BytecodeParser''add-2 parser, (ConditionalNode'new-3 (BytecodeParser''add-2 parser, comparison), t, f))
        )
    )

    (§ method! #_"ValueNode" WordOperationPlugin''readOp-6 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"JavaKind" readKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"WordOpcode" op]
        (let [
            #_"BarrierType" barrier (if (= op WordOpcode'READ_BARRIERED) BarrierType'PRECISE BarrierType'NONE)
            #_"boolean" compressible? (any = op WordOpcode'READ_OBJECT WordOpcode'READ_BARRIERED)
        ]
            (WordOperationPlugin'readOp-6 parser, readKind, address, location, barrier, compressible?)
        )
    )

    (§ defn #_"ValueNode" WordOperationPlugin'readOp-6 [#_"BytecodeParser" parser, #_"JavaKind" readKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"BarrierType" barrierType, #_"boolean" compressible?]
        ;; A JavaReadNode lowered to a ReadNode that will not float. This means it cannot float above
        ;; an explicit zero check on its base address or any other test that ensures the read is safe.
        (BytecodeParser''add-2 parser, (JavaReadNode'new-5 readKind, address, location, barrierType, compressible?))
    )

    (§ method! #_"void" WordOperationPlugin''writeOp-7 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"JavaKind" writeKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" value, #_"WordOpcode" op]
        (let [
            #_"BarrierType" barrier (if (= op WordOpcode'WRITE_BARRIERED) BarrierType'PRECISE BarrierType'NONE)
            #_"boolean" compressible? (any = op WordOpcode'WRITE_OBJECT WordOpcode'WRITE_BARRIERED)
        ]
            (BytecodeParser''add-2 parser, (JavaWriteNode'new-6 writeKind, address, location, value, barrier, compressible?))
        )
        nil
    )

    (§ method! #_"AbstractCompareAndSwapNode" WordOperationPlugin''casOp-7 [#_"WordOperationPlugin" this, #_"JavaKind" writeKind, #_"JavaKind" returnKind, #_"AddressNode" address, #_"LocationIdentity" location, #_"ValueNode" expectedValue, #_"ValueNode" newValue]
        (if (= returnKind JavaKind/Boolean)
            (LogicCompareAndSwapNode'new-4 address, expectedValue, newValue, location)
            (ValueCompareAndSwapNode'new-4 address, expectedValue, newValue, location)
        )
    )

    (§ method #_"AddressNode" WordOperationPlugin''makeAddress-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" base, #_"ValueNode" offset]
        (BytecodeParser''add-2 parser, (OffsetAddressNode'new-2 base, (WordOperationPlugin''fromSigned-3 this, parser, offset)))
    )

    (§ method! #_"ValueNode" WordOperationPlugin''fromUnsigned-3 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" value]
        (WordOperationPlugin''convert-5 this, parser, value, WordTypes'wordKind, true)
    )

    (§ method! #_"ValueNode" WordOperationPlugin''fromSigned-3 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" value]
        (WordOperationPlugin''convert-5 this, parser, value, WordTypes'wordKind, false)
    )

    (§ method! #_"ValueNode" WordOperationPlugin''toUnsigned-4 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" value, #_"JavaKind" toKind]
        (WordOperationPlugin''convert-5 this, parser, value, toKind, true)
    )

    (§ method #_"ValueNode" WordOperationPlugin''convert-5 [#_"WordOperationPlugin" this, #_"BytecodeParser" parser, #_"ValueNode" value, #_"JavaKind" toKind, #_"boolean" unsigned?]
        (cond
            (= (ValueNode''getStackKind-1 value) toKind) value
            (= toKind JavaKind/Int)                      (BytecodeParser''add-2 parser, (NarrowNode'new-2 value, 32))
            unsigned?                                    (BytecodeParser''add-2 parser, (ZeroExtendNode'new-2 value, 64))
            :else                                        (BytecodeParser''add-2 parser, (SignExtendNode'new-2 value, 64))
        )
    )
)

(final-ns Suites
    (§ defn #_"PhaseSuite<HighTierContext>" Suites'createGraphBuilderSuite-0 []
        (let [
            #_"PhaseSuite<HighTierContext>" suite (PhaseSuite'new-0)
        ]
            (PhaseSuite''appendPhase-2 suite, (GraphBuilderPhase'new-0))
            suite
        )
    )

    (§ defn #_"Suites" Suites'createSuites-0 []
        (let [
            #_"Suites" suites (Suites'new-3 (HighTier'new-0), (MidTier'new-0), (LowTier'new-0))
            _ (PhaseSuite''appendPhase-2 (:midTier suites), (WriteBarrierAdditionPhase'new-0))
            #_"ListIterator<BasePhase<? super LowTierContext>>" findPhase
                (or (PhaseSuite''findPhase-2 (:lowTier suites), FixReadsPhase)
                    (PhaseSuite''findPhase-2 (:lowTier suites), ExpandLogicPhase)
                )
        ]
            (#_"ListIterator" .add findPhase, (AddressLoweringPhase'new-1 (AddressLowering'new-1 HotSpot'heapBaseRegister)))
            suites
        )
    )

    (§ defn #_"LIRSuites" Suites'createLIRSuites-0 []
        (let [
            #_"LIRSuites" lirSuites (LIRSuites'new-3 (PreAllocationOptimizationStage'new-0), (AllocationStage'new-0), (PostAllocationOptimizationStage'new-0))
        ]
            (when GraalOptions'lirOptStackMoveOptimizer
                ;; note: this phase must be inserted *after* RedundantMoveElimination
                (LIRPhaseSuite''appendPhase-2 (:postAllocStage lirSuites), (StackMoveOptimizationPhase'new-0))
            )
            lirSuites
        )
    )

    (§ final #_"PhaseSuite<HighTierContext>" :highTier nil)
    (§ final #_"PhaseSuite<MidTierContext>" :midTier nil)
    (§ final #_"PhaseSuite<LowTierContext>" :lowTier nil)

    (§ defn #_"Suites" Suites'new-3 [#_"PhaseSuite<HighTierContext>" highTier, #_"PhaseSuite<MidTierContext>" midTier, #_"PhaseSuite<LowTierContext>" lowTier]
        (let [
            #_"Suites" this (Object.)
            this (assoc this :highTier highTier)
            this (assoc this :midTier midTier)
            this (assoc this :lowTier lowTier)
        ]
            this
        )
    )
)

;;;
 ; Code for managing a method's native frame.
 ; Emits code at the verified entry point and return point(s) of a method.
 ;;
(final-ns FrameContext
    ;;;
     ; The size of the instruction used to patch the verified entry point of an nmethod when the
     ; nmethod is made non-entrant or a zombie (e.g. during deopt or class unloading). The first
     ; instruction emitted at an nmethod's verified entry point must be at least this length to
     ; ensure mt-safe patching.
     ;;
    (def #_"int" FrameContext'PATCHED_VERIFIED_ENTRY_POINT_INSTRUCTION_SIZE 5)

    (§ final #_"boolean" :isStub false)
    (§ final #_"boolean" :omitFrame false)

    (§ defn #_"FrameContext" FrameContext'new-2 [#_"boolean" isStub, #_"boolean" omitFrame]
        (let [
            #_"FrameContext" this (Object.)
            this (assoc this :isStub isStub)
            this (assoc this :omitFrame omitFrame)
        ]
            this
        )
    )

    ;;;
     ; Determines if a frame is set up and torn down by this object.
     ;;
    #_unused
    (§ method! #_"boolean" FrameContext''hasFrame-1 [#_"FrameContext" this]
        (not (:omitFrame this))
    )

    ;;;
     ; Emits code common to all entry points of a method. This may include:
     ;
     ; - setting up the stack frame
     ; - saving callee-saved registers
     ; - stack overflow checking
     ;;
    (§ method! #_"void" FrameContext''enter-2 [#_"FrameContext" this, #_"Assembler" asm]
        (if (:omitFrame this)
            (when-not (:isStub this)
                (Assembler''nop-2 asm, FrameContext'PATCHED_VERIFIED_ENTRY_POINT_INSTRUCTION_SIZE)
            )
            (let [
                #_"int" verifiedEntryPosition (Assembler''position-1 asm)
                #_"int" frameSize (FrameMap''frameSize-1 (:frameMap asm))
            ]
                (when-not (:isStub this)
                    (Compiler'emitStackOverflowCheck-1 asm)
                )
                (if (and (not (:isStub this)) (= (Assembler''position-1 asm) verifiedEntryPosition))
                    (Assembler''subqWide-3 asm, AMD64/rsp, frameSize)
                    (Assembler''decrementq-3 asm, AMD64/rsp, frameSize)
                )
                (when GraalOptions'zapStackOnMethodEntry
                    (let [
                        #_"int" intSize 4
                    ]
                        (dotimes [#_"int" i (quot frameSize intSize)]
                            (Assembler''movl-3 asm, (AMD64Address'new-2 AMD64/rsp, (* i intSize)), 0xc1c1c1c1)
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Emits code to be executed just prior to returning from a method. This may include:
     ;
     ; - restoring callee-saved registers
     ; - performing a safepoint
     ; - destroying the stack frame
     ;;
    (§ method! #_"void" FrameContext''leave-2 [#_"FrameContext" this, #_"Assembler" asm]
        (when-not (:omitFrame this)
            (Assembler''incrementq-3 asm, AMD64/rsp, (FrameMap''frameSize-1 (:frameMap asm)))
        )
        nil
    )
)

(value-ns Compiler
    (§ defn #_"void" Compiler'emitStackOverflowCheck-1 [#_"Assembler" asm]
        (when HotSpot'useStackBanging
            ;; Each code entry causes one stack bang n pages down the stack where n is configurable
            ;; by StackShadowPages. The setting depends on the maximum depth of VM call stack or native
            ;; before going back into java code, since only java code can raise a stack overflow exception
            ;; using the stack banging mechanism. The VM and native code does not detect stack overflow.
            ;; The code in JavaCalls::call() checks that there is at least n pages available, so all
            ;; entry code needs to do is bang once for the end of this shadow zone.
            ;; The entry code may need to bang additional pages if the framesize is greater than a page.
            (let [
                #_"int" end (NumUtil'roundUp-2 (* HotSpot'stackShadowPages 4 CodeUtil/K), HotSpot'vmPageSize)
                ;; This is how far the previous frame's stack banging extended.
                #_"int" frameSize (FrameMap''frameSize-1 (:frameMap asm))
                #_"int" end' (if (< HotSpot'vmPageSize frameSize) (+ end frameSize) end)
            ]
                (loop-when-recur [#_"int" i end] (<= i end') [(+ i HotSpot'vmPageSize)]
                    ;; Need at least one stack bang at end of shadow zone.
                    (Assembler''movl-3 asm, (AMD64Address'new-2 AMD64/rsp, (- i)), AMD64/rax)
                )
            )
        )
        nil
    )

    (§ defn #_"void" Compiler'emitFrontEnd-3 [#_"Graph" graph, #_"OptimisticOptimizations" optimisticOpts, #_"Suites" suites]
        (let [
            #_"HighTierContext" highTierContext (HighTierContext'new-1 optimisticOpts)
        ]
            (when (nil? (:next (:start graph)))
                (BasePhase''apply-3 HotSpot'graphBuilderSuite, graph, highTierContext)
                (Phase''apply-2 (DeadCodeEliminationPhase'new-1 Optionality'Optional), graph)
            )
            (BasePhase''apply-3 (:highTier suites), graph, highTierContext)
            (BasePhase''apply-3 (:midTier suites), graph, (MidTierContext'new-1 optimisticOpts))
            (BasePhase''apply-3 (:lowTier suites), graph, (LowTierContext'new-0))
        )
        nil
    )

    (§ defn #_"LIRGenerationResult" Compiler'emitLowLevel-3 [#_"LIRGenerationResult" res, #_"LIRGenerator" gen, #_"LIRSuites" suites]
        (LIRPhase''apply-3 (:preAllocOptStage suites), res, (PreAllocationOptimizationContext'new-1 gen))
        (LIRPhase''apply-3 (:allocStage suites), res, (AllocationContext'new-2 (:moveFactory gen), (AMD64HotSpotRegisterAllocationConfig'new-0)))
        (LIRPhase''apply-3 (:postAllocStage suites), res, (PostAllocationOptimizationContext'new-0))
        res
    )

    (§ defn- #_"CallingConvention" Compiler'makeCallingConvention-2 [#_"Graph" graph, #_"Stub" stub]
        (if (some? stub)
            (:incomingCallingConvention (:linkage stub))
            (CodeUtil/getCallingConvention HotSpot'codeCache, HotSpotCallingConventionType/JavaCallee, (:rootMethod graph), HotSpot'valueKindFactory)
        )
    )

    (§ defn #_"LIRGenerationResult" Compiler'emitLIR-3 [#_"Graph" graph, #_"Stub" stub, #_"LIRSuites" suites]
        (let [
            #_"ScheduleResult" schedule (:lastSchedule graph)
            #_"Block[]" blocks (:reversePostOrder (:cfg schedule))
            #_"Block" startBlock (ControlFlowGraph''getStartBlock-1 (:cfg schedule))
            #_"Block[]" codeEmittingOrder (ComputeBlockOrder'computeCodeEmittingOrder-2 (count blocks), startBlock)
            #_"Block[]" linearScanOrder (ComputeBlockOrder'computeLinearScanOrder-2 (count blocks), startBlock)
            #_"LIR" lir (LIR'new-3 (:cfg schedule), linearScanOrder, codeEmittingOrder)
            #_"LIRGenerationResult" res (LIRGenerationResult'new-4 lir, (AMD64FrameMapBuilder'new-1 (AMD64FrameMap'new-0)), (Compiler'makeCallingConvention-2 graph, stub), stub)
            #_"LIRGenerator" gen (LIRGenerator'new-1 res)
            #_"LIRBuilder" builder (LIRBuilder'new-2 graph, gen)
        ]
            (LIRPhase''apply-3 (LIRGenerationPhase'new-0), res, (LIRGenerationContext'new-4 gen, builder, graph, schedule))
            (Compiler'emitLowLevel-3 res, gen, suites)
        )
    )

    (§ defn #_"CompilationResult" Compiler'emitBackEnd-3 [#_"Graph" graph, #_"Stub" stub, #_"LIRSuites" lirSuites]
        (let [
            #_"Assembler" asm (Assembler'new-1 (Compiler'emitLIR-3 graph, stub, lirSuites))
        ]
            (§ ass! asm (Assembler''assemble-1 asm))
            (Assembler''finish-1 asm)
        )
    )

    (§ defn #_"CompilationResult" Compiler'compileGraph-1 [#_"Graph" graph]
        (Compiler'emitFrontEnd-3 graph, OptimisticOptimizations'ALL, (Suites'createSuites-0))
        (Compiler'emitBackEnd-3 graph, nil, (Suites'createLIRSuites-0))
    )

    #_unused
    (§ defn #_"CompilationResult" Compiler'compileMethod-1 [#_"ResolvedJavaMethod" method]
        (Compiler'compileGraph-1 (Graph'new-1 method))
    )

    (§ defn #_"CompilationResult" Compiler'compileStub-1 [#_"Stub" stub]
        (let [
            #_"Graph" graph (Stub''getStubGraph-1 stub)
        ]
            (when-not (instance? StubStartNode (:start graph))
                (let [
                    #_"StubStartNode" newStart (Graph''add-2 graph, (StubStartNode'new-1 stub))
                ]
                    (BeginStateSplitNode''setStateAfter-2 newStart, (BeginStateSplitNode''stateAfter-1 (:start graph)))
                    (§ ass! graph (Graph''replaceFixed-3 graph, (:start graph), newStart))
                )
            )

            (let [
                #_"Suites" suites (Suites'createSuites-0)
                suites (Suites'new-3 (PhaseSuite'new-0), (:midTier suites), (:lowTier suites))
            ]
                (Compiler'emitFrontEnd-3 graph, OptimisticOptimizations'ALL, suites)
                (Compiler'emitBackEnd-3 graph, stub, (Suites'createLIRSuites-0))
            )
        )
    )

    ;;;
     ; HotSpot expects sites to be presented in ascending order of PC (see {@code DebugInformationRecorder::add_new_pc_offset}).
     ;;
    (§ defn- #_"Site[]" Compiler'getSortedSites-1 [#_"CompilationResult" result]
        (let [
            #_"List<Site>" sites (ArrayList.)
        ]
            (#_"List" .addAll sites, (or (:dataPatches result) ()))
            (#_"List" .addAll sites, (or (:marks result) ()))

            (Collections/sort sites,
                (§ reify #_"Comparator<Site>" (Comparator.)
                    (§ override! #_"int" #_"Comparator" .compare [#_"Comparator<Site>" this, #_"Site" s1, #_"Site" s2]
                        (let [
                            #_"int" cmp (- (.pcOffset s1) (.pcOffset s2))
                        ]
                            (when (zero? cmp) => cmp
                                ;; Marks must come first since patching a call site
                                ;; may need to know the mark denoting the call type
                                ;; (see uses of CodeInstaller::_next_call_type).
                                (let [
                                    #_"boolean" m1 (instance? Mark s1)
                                    #_"boolean" m2 (instance? Mark s2)
                                ]
                                    (when-not (= m1 m2) => cmp
                                        (if m1 -1 1)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (#_"List" .toArray sites, (make-array Site (count sites)))
        )
    )

    ;;;
     ; Turns a CompilationResult into a CompiledCode that can be passed to the VM for installation.
     ;;
    (§ defn #_"HotSpotCompiledCode" Compiler'createCompiledCode-1 [#_"CompilationResult" result]
        (let [
            #_"byte[]" code (:targetCode result)
            #_"int" codeSize (:targetCodeSize result)
            #_"Site[]" sites (Compiler'getSortedSites-1 result)
            #_"DataSection" section (:dataSection result)
            #_"byte[]" data (byte-array (DataSection''getSectionSize-1 section))
            #_"ByteBuffer" buffer (#_"ByteBuffer" .order (ByteBuffer/wrap data), (ByteOrder/nativeOrder))
            #_"Stream$Builder<DataPatch>" builder (Stream/builder)
            _
                (DataSection''buildDataSection-3 section, buffer, (ß (position, vmConstant) ->
                    (§ fun
                        (#_"Stream$Builder" .accept builder, (DataPatch. position, (ConstantReference. vmConstant)))
                    ))
                )
            #_"int" alignment (DataSection''getSectionAlignment-1 section)
            #_"DataPatch[]" patches (#_"Stream" .toArray (#_"Stream$Builder" .build builder), (ß len -> (§ fun (make-array DataPatch len))))
            #_"int" frameSize (:totalFrameSize result)
        ]
            (HotSpotCompiledCode. nil, code, codeSize, sites, nil, nil, nil, data, alignment, patches, false, frameSize, nil)
        )
    )

    ;;;
     ; Installs code based on a given compilation result.
     ;
     ; @param method the method compiled to produce {@code compiledCode} or nil if the input
     ;            to {@code result} was not a ResolvedJavaMethod
     ; @param result the code to be installed
     ; @param predefinedInstalledCode a pre-allocated InstalledCode object to use as a reference
     ;            to the installed code. If nil, a new InstalledCode object will be created.
     ; @return a reference to the compiled and ready-to-run installed code
     ;;
    #_unused
    (§ defn #_"InstalledCode" Compiler'createInstalledCode-4 [#_"ResolvedJavaMethod" method, #_"CompilationResult" result, #_"InstalledCode" predefinedInstalledCode, #_"boolean" default?]
        (#_"CodeCacheProvider" .installCode HotSpot'codeCache, method, (Compiler'createCompiledCode-1 result), predefinedInstalledCode, nil, default?)
    )
)
